// Multi-Server Example — demonstrates named blocks running as separate processes
// Each named server block compiles to its own file and runs on its own port
// Features: ORM, SSE, auth, rate limiting, middleware, CORS, WebSocket, OpenAPI

shared {
  type User {
    id: Int
    name: String
    email: String
  }

  type Event {
    kind: String
    data: String
    timestamp: Int
  }
}

// API server — handles REST endpoints with ORM and auto-docs
server "api" {
  health "/health"

  db { path: "./data.db" }
  model User

  cors {
    origins: ["*"]
    methods: ["GET", "POST", "PUT", "DELETE"]
    headers: ["Content-Type", "Authorization"]
  }

  auth {
    type: "jwt"
    secret: "my-secret-key"
  }

  rate_limit {
    max: 100
    window: 60
  }

  middleware fn logger(req, next) {
    result = next(req)
    result
  }

  on_error fn(err, req) {
    respond(500, {error: "Internal server error"})
  }

  fn get_users() -> [User] {
    UserModel.all()
  }

  fn create_user(name: String, email: String) -> User {
    if name == "" {
      return respond(400, {error: "name is required"})
    }
    user = UserModel.create({name: name, email: email})
    events.push_event("user_created", name)
    respond(201, user)
  }

  fn get_user(id: String) -> User {
    user = UserModel.find(id)
    if user == nil {
      return respond(404, {error: "User not found"})
    }
    user
  }

  fn update_user(id: String, name: String, email: String) -> User {
    UserModel.update(id, {name: name, email: email})
  }

  fn delete_user(id: String) {
    UserModel.delete(id)
    respond(204, nil)
  }

  route GET "/api/users" => get_users
  route POST "/api/users" => create_user
  route GET "/api/users/:id" => get_user
  route PUT "/api/users/:id" with auth => update_user
  route DELETE "/api/users/:id" with auth, role("admin") => delete_user

  // SSE endpoint for real-time updates
  sse "/api/stream" fn(send, close) {
    send({kind: "connected"})
  }
}

// WebSocket / events server — handles real-time events with WebSocket support
server "events" {
  health "/health"

  var event_log = []

  ws {
    on_open fn(ws) {
      print("Client connected")
    }
    on_message fn(ws, msg) {
      print("Received: " + msg)
    }
    on_close fn(ws, code, reason) {
      print("Client disconnected")
    }
  }

  fn get_events() -> [Event] {
    event_log
  }

  fn push_event(kind: String, data: String) -> Event {
    event = Event(kind, data, 0)
    event_log = [...event_log, event]
    event
  }

  route GET "/events" => get_events
  route POST "/events" => push_event
}

// Client UI
client {
  state users: [User] = []
  state events: [Event] = []

  effect {
    users = server.get_users()
  }

  component App {
    <div class="app">
      <h1>"Multi-Server Demo"</h1>
      <section>
        <h2>"Users (from api server)"</h2>
        <ul>
          for user in users {
            <li>"{user.name} ({user.email})"</li>
          }
        </ul>
      </section>
      <section>
        <h2>"Events (from events server)"</h2>
        <ul>
          for event in events {
            <li>"[{event.kind}] {event.data}"</li>
          }
        </ul>
      </section>
    </div>
  }
}
