// Benchmark 7: N-Body Simulation (simplified)
// Tests: floating point math, object access, physics computation

PI = 3.141592653589793
SOLAR_MASS = 4.0 * PI * PI
DAYS_PER_YEAR = 365.24

// Create bodies at top level
var bodies = [
  { x: 0.0, y: 0.0, z: 0.0, vx: 0.0, vy: 0.0, vz: 0.0, mass: SOLAR_MASS },
  {
    x: 4.84143144246472090,
    y: -1.16032004402742839,
    z: -1.03622044471123109,
    vx: 0.00166007664274403694 * DAYS_PER_YEAR,
    vy: 0.00769901118419740425 * DAYS_PER_YEAR,
    vz: -0.00690460016972063023 * DAYS_PER_YEAR,
    mass: 0.000954791938424326609 * SOLAR_MASS
  },
  {
    x: 8.34336671824457987,
    y: 4.12479856412430479,
    z: -4.03523417114321381,
    vx: -0.00276742510726862411 * DAYS_PER_YEAR,
    vy: 0.00499852801234917238 * DAYS_PER_YEAR,
    vz: 0.00230417297573763929 * DAYS_PER_YEAR,
    mass: 0.000285885980666130812 * SOLAR_MASS
  }
]

// Offset momentum
var px = 0.0
var py = 0.0
var pz = 0.0
for b in bodies {
  px = px + b.vx * b.mass
  py = py + b.vy * b.mass
  pz = pz + b.vz * b.mass
}
bodies[0].vx = -px / SOLAR_MASS
bodies[0].vy = -py / SOLAR_MASS
bodies[0].vz = -pz / SOLAR_MASS

// Compute energy
fn compute_energy(bods) {
  nbodies = len(bods)
  var e = 0.0
  var i = 0
  while i < nbodies {
    bi = bods[i]
    e = e + 0.5 * bi.mass * (bi.vx * bi.vx + bi.vy * bi.vy + bi.vz * bi.vz)
    var j = i + 1
    while j < nbodies {
      bj = bods[j]
      dx = bi.x - bj.x
      dy = bi.y - bj.y
      dz = bi.z - bj.z
      dist = sqrt(dx * dx + dy * dy + dz * dz)
      e = e - (bi.mass * bj.mass) / dist
      j += 1
    }
    i += 1
  }
  e
}

e_before = compute_energy(bodies)

steps = 500000
nbodies = len(bodies)

start = performance.now()

for step in range(steps) {
  var i = 0
  while i < nbodies {
    bi = bodies[i]
    var j = i + 1
    while j < nbodies {
      bj = bodies[j]
      dx = bi.x - bj.x
      dy = bi.y - bj.y
      dz = bi.z - bj.z
      dist_sq = dx * dx + dy * dy + dz * dz
      dist = sqrt(dist_sq)
      mag = 0.01 / (dist_sq * dist)

      bi.vx = bi.vx - dx * bj.mass * mag
      bi.vy = bi.vy - dy * bj.mass * mag
      bi.vz = bi.vz - dz * bj.mass * mag

      bj.vx = bj.vx + dx * bi.mass * mag
      bj.vy = bj.vy + dy * bi.mass * mag
      bj.vz = bj.vz + dz * bi.mass * mag

      j += 1
    }
    i += 1
  }

  var k = 0
  while k < nbodies {
    b = bodies[k]
    b.x = b.x + 0.01 * b.vx
    b.y = b.y + 0.01 * b.vy
    b.z = b.z + 0.01 * b.vz
    k += 1
  }
}

elapsed = performance.now() - start

e_after = compute_energy(bodies)

print("BENCHMARK: nbody")
print("steps={steps}")
print("energy_before={e_before}")
print("energy_after={e_after}")
print("time={elapsed}ms")
