<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lux Playground</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
/* ─── Reset & Base ─────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #1e1e2e; --bg-surface: #181825; --bg-overlay: #11111b;
  --bg-hover: #1e1e2e;
  --text: #cdd6f4; --text-dim: #6c7086; --text-bright: #f5f5f5;
  --accent: #cba6f7; --accent-dim: #9370db; --accent-bg: rgba(203,166,247,0.1);
  --green: #a6e3a1; --red: #f38ba8; --yellow: #f9e2af; --blue: #89b4fa;
  --teal: #94e2d5; --peach: #fab387;
  --border: #313244; --border-active: #45475a;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --header-h: 48px; --status-h: 28px;
  --tab-h: 36px; --sidebar-w: 340px;
  --editor-font-size: 14px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: var(--font-sans); background: var(--bg); color: var(--text);
  display: flex; flex-direction: column;
}

/* ─── Header ───────────────────────────────────────── */
.header {
  height: var(--header-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.header .logo {
  font-weight: 700; font-size: 15px; color: var(--accent);
  display: flex; align-items: center; gap: 6px; white-space: nowrap;
}
.header .logo span { color: var(--text-dim); font-weight: 400; font-size: 12px; }
.header .sep { width: 1px; height: 24px; background: var(--border); }
.header .spacer { flex: 1; }

.btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; transition: all 0.15s; font-family: var(--font-sans);
  white-space: nowrap;
}
.btn:hover { border-color: var(--border-active); background: var(--bg-surface); }
.btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
.btn-primary { background: var(--accent); color: var(--bg-overlay); border-color: var(--accent); font-weight: 600; }
.btn-primary:hover { background: var(--accent-dim); border-color: var(--accent-dim); }
.btn-icon { padding: 5px 8px; font-size: 14px; }
.btn .kbd { font-size: 10px; opacity: 0.6; font-family: var(--font-mono); }

select.examples-select {
  padding: 5px 24px 5px 8px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; font-family: var(--font-sans); max-width: 200px;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236c7086' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 6px center;
}
select.examples-select:hover { border-color: var(--border-active); }
select.examples-select optgroup { background: var(--bg-surface); color: var(--accent); font-style: normal; }
select.examples-select option { background: var(--bg); color: var(--text); }

/* ─── Main Layout ──────────────────────────────────── */
.main {
  flex: 1; display: flex; overflow: hidden;
  height: calc(100% - var(--header-h) - var(--status-h));
}
.pane { display: flex; flex-direction: column; overflow: hidden; min-width: 200px; }
.pane-editor { flex: 1; position: relative; }
.pane-output { flex: 1; }

/* ─── Drag Handle ──────────────────────────────────── */
.drag-handle {
  width: 4px; cursor: col-resize; background: var(--border);
  transition: background 0.15s; flex-shrink: 0;
}
.drag-handle:hover, .drag-handle.active { background: var(--accent); }

/* ─── Output Tabs ──────────────────────────────────── */
.tabs {
  display: flex; height: var(--tab-h); background: var(--bg-surface);
  border-bottom: 1px solid var(--border); flex-shrink: 0; align-items: flex-end;
}
.tab {
  padding: 0 14px; height: 100%; font-size: 12px; cursor: pointer; display: flex; align-items: center;
  color: var(--text-dim); border-bottom: 2px solid transparent;
  transition: all 0.15s; user-select: none; gap: 6px;
}
.tab:hover { color: var(--text); background: rgba(255,255,255,0.02); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab .badge {
  font-size: 10px; padding: 1px 6px; border-radius: 8px;
  background: var(--red); color: var(--bg); font-weight: 600; min-width: 18px; text-align: center;
}

/* ─── Output Panels ────────────────────────────────── */
.output-content { flex: 1; overflow: auto; position: relative; }
.output-panel { display: none; height: 100%; overflow: auto; }
.output-panel.active { display: block; }
#panel-console.active { display: flex; flex-direction: column; }
#panel-js { position: relative; }

#js-output, #console-output, #ast-output {
  padding: 12px 16px; font-family: var(--font-mono); font-size: 13px;
  line-height: 1.6; white-space: pre-wrap; word-break: break-word;
}
#js-output { color: var(--text); }
#console-output .log-line { color: var(--text); padding: 1px 0; }
#console-output .log-error { color: var(--red); padding: 1px 0; }
#console-output .log-warn { color: var(--yellow); padding: 1px 0; }
#console-output .log-info { color: var(--blue); padding: 1px 0; }
#console-output .log-return { color: var(--text-dim); font-style: italic; padding: 1px 0; }

#preview-frame {
  width: 100%; height: 100%; border: none; background: #fff;
}

/* ─── AST Tree ─────────────────────────────────────── */
.ast-node { margin-left: 16px; font-family: var(--font-mono); font-size: 12px; line-height: 1.5; }
.ast-toggle { cursor: pointer; user-select: none; display: inline-flex; align-items: center; gap: 4px; }
.ast-toggle:hover { color: var(--accent); }
.ast-toggle::before { content: '\25B6'; font-size: 8px; display: inline-block; transition: transform 0.15s; }
.ast-toggle.open::before { transform: rotate(90deg); }
.ast-key { color: var(--blue); }
.ast-string { color: var(--green); }
.ast-number { color: var(--yellow); }
.ast-bool { color: var(--accent); }
.ast-null { color: var(--text-dim); }
.ast-type { color: var(--accent); font-weight: 600; }
.ast-children { display: none; }
.ast-children.open { display: block; }

/* ─── Status Bar ───────────────────────────────────── */
.status-bar {
  height: var(--status-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-top: 1px solid var(--border); font-size: 11px;
  color: var(--text-dim); gap: 16px; flex-shrink: 0;
}
.status-bar .success { color: var(--green); }
.status-bar .error { color: var(--red); }
.status-bar .spacer { flex: 1; }

/* ─── Error Display ────────────────────────────────── */
.error-banner {
  padding: 8px 16px; background: rgba(243,139,168,0.08);
  border-bottom: 1px solid rgba(243,139,168,0.3); color: var(--red);
  font-family: var(--font-mono); font-size: 12px; display: none;
  cursor: pointer; position: relative;
}
.error-banner:hover { background: rgba(243,139,168,0.12); }
.error-banner.visible { display: flex; align-items: center; gap: 8px; }
.error-banner .error-icon { font-weight: bold; flex-shrink: 0; }
.error-banner .error-text { flex: 1; }

/* ─── Sidebar / Reference Panel ───────────────────── */
.sidebar {
  width: 0; overflow: hidden; background: var(--bg-surface);
  border-left: 1px solid var(--border); transition: width 0.2s ease;
  flex-shrink: 0; display: flex; flex-direction: column;
}
.sidebar.open { width: var(--sidebar-w); }
.sidebar-header {
  display: flex; align-items: center; padding: 10px 14px;
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.sidebar-header h3 { font-size: 14px; font-weight: 600; color: var(--text-bright); flex: 1; }
.sidebar-close {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 18px; padding: 2px 6px; border-radius: 4px;
}
.sidebar-close:hover { color: var(--text); background: var(--bg); }
.sidebar-body { flex: 1; overflow-y: auto; padding: 8px 0; }

/* Reference styles */
.ref-section { margin-bottom: 4px; }
.ref-title {
  padding: 6px 14px; font-size: 12px; font-weight: 600;
  color: var(--accent); cursor: pointer; display: flex; align-items: center; gap: 6px;
  user-select: none;
}
.ref-title:hover { background: var(--bg); }
.ref-title::before { content: '\25B6'; font-size: 8px; transition: transform 0.15s; }
.ref-title.open::before { transform: rotate(90deg); }
.ref-items { display: none; padding: 0 14px 8px; }
.ref-items.open { display: block; }
.ref-item { margin: 3px 0; }
.ref-item code {
  font-family: var(--font-mono); font-size: 11px; color: var(--green);
  background: rgba(166,227,161,0.08); padding: 1px 4px; border-radius: 3px;
}
.ref-item .ref-desc { font-size: 11px; color: var(--text-dim); margin-left: 4px; }

/* Tutorial styles */
.tutorial-nav { display: flex; gap: 4px; padding: 8px 14px; flex-shrink: 0; border-top: 1px solid var(--border); }
.tutorial-nav .btn { flex: 1; justify-content: center; font-size: 12px; }
.tutorial-step { padding: 14px; }
.tutorial-step h4 { color: var(--accent); font-size: 14px; margin-bottom: 8px; }
.tutorial-step p { font-size: 13px; color: var(--text); line-height: 1.5; margin-bottom: 10px; }
.tutorial-step .try-btn {
  display: inline-flex; align-items: center; gap: 4px;
  padding: 6px 14px; border-radius: 6px; border: 1px solid var(--accent);
  background: var(--accent-bg); color: var(--accent); font-size: 12px;
  cursor: pointer; font-weight: 500;
}
.tutorial-step .try-btn:hover { background: rgba(203,166,247,0.2); }
.tutorial-progress {
  display: flex; gap: 4px; padding: 0 14px 8px; flex-shrink: 0;
}
.tutorial-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--border); cursor: pointer;
}
.tutorial-dot.active { background: var(--accent); }
.tutorial-dot.completed { background: var(--green); }

/* ─── Keyboard Shortcuts Modal ────────────────────── */
.modal-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: none; align-items: center; justify-content: center; z-index: 100;
}
.modal-backdrop.visible { display: flex; }
.modal {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 24px; max-width: 480px; width: 90%;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.modal h3 { color: var(--accent); margin-bottom: 16px; font-size: 16px; }
.modal-close {
  float: right; background: none; border: none; color: var(--text-dim);
  cursor: pointer; font-size: 20px; padding: 0 4px;
}
.modal-close:hover { color: var(--text); }
.shortcut-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 0; border-bottom: 1px solid rgba(49,50,68,0.5);
}
.shortcut-row:last-child { border-bottom: none; }
.shortcut-keys {
  display: flex; gap: 4px;
}
.shortcut-key {
  background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  padding: 2px 8px; font-family: var(--font-mono); font-size: 11px; color: var(--text-bright);
}
.shortcut-desc { font-size: 13px; color: var(--text-dim); }

/* ─── Settings Dropdown ──────────────────────────── */
.settings-dropdown {
  position: absolute; top: calc(var(--header-h) + 4px); right: 12px;
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 12px; min-width: 220px; z-index: 50;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
}
.settings-dropdown.visible { display: block; }
.settings-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 0; font-size: 13px;
}
.settings-row label { color: var(--text); }
.settings-row select, .settings-row input[type="range"] {
  background: var(--bg); border: 1px solid var(--border); color: var(--text);
  border-radius: 4px; padding: 3px 6px; font-size: 12px;
}
.toggle {
  width: 36px; height: 20px; border-radius: 10px; background: var(--border);
  position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle.on { background: var(--accent); }
.toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 16px; height: 16px; border-radius: 50%; background: white;
  transition: transform 0.2s;
}
.toggle.on::after { transform: translateX(16px); }

/* ─── Welcome Overlay ─────────────────────────────── */
.welcome-toast {
  position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 16px; font-size: 12px;
  color: var(--text-dim); z-index: 10; display: flex; align-items: center; gap: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3); white-space: nowrap;
  animation: fadeIn 0.3s ease;
}
.welcome-toast .kbd-hint {
  font-family: var(--font-mono); font-size: 10px;
  background: var(--bg); border: 1px solid var(--border); padding: 2px 6px;
  border-radius: 3px; color: var(--text);
}
.welcome-toast .close-toast {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 14px; padding: 0 2px;
}
@keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(8px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

/* ─── Console Enhancements ────────────────────────── */
.console-toolbar {
  display: flex; align-items: center; gap: 8px;
  padding: 4px 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); font-size: 11px; flex-shrink: 0;
}
.console-toolbar .spacer { flex: 1; }
.console-toolbar .console-timing { color: var(--text-dim); font-family: var(--font-mono); }
.log-icon { margin-right: 6px; opacity: 0.7; font-size: 11px; }
.log-content { white-space: pre-wrap; word-break: break-word; }
#console-output .log-line, #console-output .log-error,
#console-output .log-warn, #console-output .log-info {
  display: flex; align-items: flex-start; padding: 3px 16px; border-bottom: 1px solid rgba(49,50,68,0.3);
}
#console-output .log-line:hover, #console-output .log-error:hover,
#console-output .log-warn:hover, #console-output .log-info:hover {
  background: rgba(255,255,255,0.02);
}

/* ─── Error Banner Enhanced ───────────────────────── */
.error-banner .error-hint {
  color: var(--yellow); font-size: 11px; margin-left: 12px; opacity: 0.8;
}

/* ─── Command Palette ─────────────────────────────── */
.cmd-palette-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: flex-start; justify-content: center;
  padding-top: 20vh; z-index: 200;
}
.cmd-palette-backdrop.visible { display: flex; }
.cmd-palette {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; width: 520px; max-width: 90vw;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5); overflow: hidden;
}
.cmd-palette input {
  width: 100%; padding: 14px 16px; background: transparent;
  border: none; border-bottom: 1px solid var(--border);
  color: var(--text); font-size: 15px; font-family: var(--font-sans);
  outline: none;
}
.cmd-palette input::placeholder { color: var(--text-dim); }
.cmd-palette-results {
  max-height: 320px; overflow-y: auto; padding: 4px 0;
}
.cmd-palette-item {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 16px; cursor: pointer; font-size: 13px;
  color: var(--text); transition: background 0.1s;
}
.cmd-palette-item:hover, .cmd-palette-item.selected {
  background: var(--accent-bg); color: var(--accent);
}
.cmd-palette-item .cmd-icon { width: 20px; text-align: center; opacity: 0.6; font-size: 14px; }
.cmd-palette-item .cmd-label { flex: 1; }
.cmd-palette-item .cmd-category { font-size: 11px; color: var(--text-dim); }
.cmd-palette-item .cmd-shortcut {
  font-family: var(--font-mono); font-size: 10px; color: var(--text-dim);
  background: var(--bg); border: 1px solid var(--border); border-radius: 3px;
  padding: 1px 5px;
}
.cmd-palette-empty {
  padding: 24px 16px; text-align: center; color: var(--text-dim); font-size: 13px;
}

/* ─── Layout Toggle ───────────────────────────────── */
.main.vertical { flex-direction: column; }
.main.vertical .drag-handle { width: auto; height: 4px; cursor: row-resize; }
.main.vertical .pane { min-width: unset; min-height: 150px; }

/* ─── Light Theme ─────────────────────────────────── */
.light-theme {
  --bg: #f8f9fa; --bg-surface: #ffffff; --bg-overlay: #e9ecef;
  --bg-hover: #f1f3f5;
  --text: #212529; --text-dim: #868e96; --text-bright: #000000;
  --accent: #7c3aed; --accent-dim: #6d28d9; --accent-bg: rgba(124,58,237,0.08);
  --green: #2b8a3e; --red: #e03131; --yellow: #e67700; --blue: #1971c2;
  --teal: #0ca678; --peach: #e8590c;
  --border: #dee2e6; --border-active: #ced4da;
}
.light-theme .cm-editor .cm-gutters { background: #f1f3f5; }
.light-theme #preview-frame { background: #fff; }

/* ─── Embed Mode ──────────────────────────────────── */
.embed-mode .header { display: none; }
.embed-mode .status-bar { display: none; }
.embed-mode .sidebar { display: none; }

/* ─── JS Output Editor ────────────────────────────── */
#js-output-editor { height: 100%; }
#panel-js .cm-editor { height: 100%; }
#panel-js .cm-editor .cm-gutters { background: var(--bg-surface); }

/* ─── CodeMirror Overrides ─────────────────────────── */
.cm-editor { height: 100%; font-size: var(--editor-font-size); }
.cm-editor .cm-scroller { font-family: var(--font-mono) !important; }
.cm-editor .cm-content { padding: 8px 0; }
.cm-editor .cm-gutters {
  background: var(--bg-surface); border-right: 1px solid var(--border);
  color: var(--text-dim);
}
.cm-editor .cm-activeLineGutter { background: rgba(203,166,247,0.08); }
.cm-editor .cm-activeLine { background: rgba(203,166,247,0.04); }
.cm-editor .cm-selectionBackground { background: rgba(203,166,247,0.2) !important; }
.cm-editor.cm-focused .cm-selectionBackground { background: rgba(203,166,247,0.25) !important; }
.cm-editor .cm-cursor { border-left-color: var(--accent); }
.cm-error-line { background: rgba(243,139,168,0.1) !important; }
.cm-error-gutter .cm-gutterElement { padding: 0 2px; }

/* ─── Autocomplete Styling ────────────────────────── */
.cm-tooltip-autocomplete { background: var(--bg-surface) !important; border: 1px solid var(--border) !important; border-radius: 8px !important; }
.cm-tooltip-autocomplete ul li { padding: 4px 8px !important; }
.cm-tooltip-autocomplete ul li[aria-selected] { background: var(--accent-bg) !important; color: var(--accent) !important; }
.cm-completionLabel { font-family: var(--font-mono); }
.cm-completionDetail { font-size: 11px; opacity: 0.7; margin-left: 8px; }
.cm-completionInfo { padding: 8px; font-size: 12px; }

/* ─── Scrollbar ───────────────────────────────────── */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--border-active); }

/* ─── Responsive ───────────────────────────────────── */
@media (max-width: 768px) {
  .main { flex-direction: column; }
  .drag-handle { width: auto; height: 4px; cursor: row-resize; }
  .pane { min-width: unset; min-height: 150px; }
  .sidebar { position: fixed; right: 0; top: var(--header-h); bottom: var(--status-h); z-index: 50; }
  .header .hide-mobile { display: none; }
  .header .sep { display: none; }
}
</style>
</head>
<body>

<!-- ─── Header ────────────────────────────────────── -->
<div class="header">
  <div class="logo">&#9670; Lux <span>Playground</span></div>
  <div class="sep"></div>
  <select class="examples-select" id="examples-select">
    <option value="" disabled selected>Load Example...</option>
  </select>
  <div class="spacer"></div>
  <button class="btn hide-mobile" id="btn-tutorial" title="Interactive tutorial">Learn</button>
  <button class="btn hide-mobile" id="btn-reference" title="Language reference">Reference</button>
  <div class="sep hide-mobile"></div>
  <button class="btn btn-icon hide-mobile" id="btn-layout" title="Toggle layout (Cmd+J)">&#9707;</button>
  <button class="btn btn-icon hide-mobile" id="btn-shortcuts" title="Keyboard shortcuts">&#9000;</button>
  <button class="btn btn-icon hide-mobile" id="btn-settings" title="Settings">&#9881;</button>
  <button class="btn" id="btn-export" title="Export as standalone HTML">Export</button>
  <button class="btn" id="btn-download" title="Download .lux file">&#8615;</button>
  <button class="btn" id="btn-share" title="Copy shareable URL">Share</button>
  <button class="btn btn-primary" id="btn-run" title="Cmd/Ctrl+Enter">Run &#9654;</button>
</div>

<!-- ─── Settings Dropdown ─────────────────────────── -->
<div class="settings-dropdown" id="settings-dropdown">
  <div class="settings-row">
    <label>Font Size</label>
    <select id="setting-fontsize">
      <option value="12">12px</option>
      <option value="13">13px</option>
      <option value="14" selected>14px</option>
      <option value="15">15px</option>
      <option value="16">16px</option>
      <option value="18">18px</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Auto-Compile</label>
    <div class="toggle on" id="setting-autocompile"></div>
  </div>
  <div class="settings-row">
    <label>Auto-Run</label>
    <div class="toggle on" id="setting-autorun"></div>
  </div>
  <div class="settings-row">
    <label>Light Theme</label>
    <div class="toggle" id="setting-theme"></div>
  </div>
</div>

<!-- ─── Main ──────────────────────────────────────── -->
<div class="main">
  <div class="pane pane-editor">
    <div id="editor"></div>
  </div>
  <div class="drag-handle" id="drag-handle"></div>
  <div class="pane pane-output">
    <div class="tabs" id="output-tabs">
      <div class="tab active" data-tab="js">JS Output</div>
      <div class="tab" data-tab="console">Console <span class="badge" id="console-badge" style="display:none">0</span></div>
      <div class="tab" data-tab="preview">Preview</div>
      <div class="tab" data-tab="ast">AST</div>
    </div>
    <div class="error-banner" id="error-banner">
      <span class="error-icon">&#10006;</span>
      <span class="error-text" id="error-text"></span>
      <span class="error-hint" id="error-hint"></span>
    </div>
    <div class="output-content">
      <div class="output-panel active" id="panel-js"><div id="js-output-editor"></div><pre id="js-output" style="display:none"></pre></div>
      <div class="output-panel" id="panel-console">
        <div class="console-toolbar">
          <span class="console-timing" id="console-timing"></span>
          <div class="spacer"></div>
          <button class="btn" id="btn-copy-console" style="padding:2px 8px;font-size:11px;">Copy</button>
          <button class="btn" id="btn-clear-console" style="padding:2px 8px;font-size:11px;">Clear</button>
        </div>
        <div id="console-output" style="padding:12px 0;font-family:var(--font-mono);font-size:13px;line-height:1.6;overflow:auto;flex:1;"></div>
      </div>
      <div class="output-panel" id="panel-preview"><iframe id="preview-frame" sandbox="allow-scripts"></iframe></div>
      <div class="output-panel" id="panel-ast"><div id="ast-output"></div></div>
    </div>
  </div>

  <!-- ─── Sidebar ─────────────────────────────────── -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h3 id="sidebar-title">Reference</h3>
      <button class="sidebar-close" id="sidebar-close">&#10005;</button>
    </div>
    <div class="sidebar-body" id="sidebar-body"></div>
    <div class="tutorial-nav" id="tutorial-nav" style="display:none;">
      <button class="btn" id="tut-prev">&#8592; Prev</button>
      <button class="btn btn-primary" id="tut-next">Next &#8594;</button>
    </div>
  </div>
</div>

<!-- ─── Status Bar ────────────────────────────────── -->
<div class="status-bar">
  <span id="status-compile"></span>
  <span id="status-size" style="color:var(--text-dim)"></span>
  <div class="spacer"></div>
  <span id="status-cursor">Ln 1, Col 1</span>
</div>

<!-- ─── Keyboard Shortcuts Modal ──────────────────── -->
<div class="modal-backdrop" id="shortcuts-modal">
  <div class="modal">
    <button class="modal-close" id="shortcuts-close">&#10005;</button>
    <h3>Keyboard Shortcuts</h3>
    <div class="shortcut-row"><span class="shortcut-desc">Run code</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Enter</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Command palette</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">K</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Save to browser</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">S</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle reference</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">R</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle layout</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">J</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Show shortcuts</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">?</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Download .lux file</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">S</span></div></div>
    <p style="margin-top:12px;font-size:11px;color:var(--text-dim)">On Windows/Linux, use Ctrl instead of Cmd</p>
  </div>
</div>

<!-- ─── Command Palette ──────────────────────────── -->
<div class="cmd-palette-backdrop" id="cmd-palette">
  <div class="cmd-palette">
    <input type="text" id="cmd-input" placeholder="Search examples, actions, reference..." autocomplete="off" />
    <div class="cmd-palette-results" id="cmd-results"></div>
  </div>
</div>

<!-- ─── LZString for sharing ─────────────────────── -->
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

<!-- ─── Inlined Lux Compiler & Runtime ───────────── -->
<script>
var RUNTIME_CODE = "// Fine-grained reactivity system for Lux (signals-based)\n\nlet currentEffect = null;\nconst effectStack = [];\nfunction createSignal(initialValue) {\n  let value = initialValue;\n  const subscribers = new Set();\n\n  function getter() {\n    if (currentEffect) {\n      subscribers.add(currentEffect);\n    }\n    return value;\n  }\n\n  function setter(newValue) {\n    if (typeof newValue === 'function') {\n      newValue = newValue(value);\n    }\n    if (value !== newValue) {\n      value = newValue;\n      // Batch updates\n      const toRun = [...subscribers];\n      for (const effect of toRun) {\n        effect();\n      }\n    }\n  }\n\n  return [getter, setter];\n}\nfunction createEffect(fn) {\n  function effect() {\n    effectStack.push(effect);\n    currentEffect = effect;\n    try {\n      fn();\n    } finally {\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n    }\n  }\n  effect();\n  return effect;\n}\nfunction createComputed(fn) {\n  const [value, setValue] = createSignal(undefined);\n  createEffect(() => {\n    setValue(fn());\n  });\n  return value;\n}\n\n// ─── DOM Rendering ────────────────────────────────────────\nfunction lux_el(tag, props = {}, children = []) {\n  return { __lux: true, tag, props, children };\n}\nfunction lux_fragment(children) {\n  return { __lux: true, tag: '__fragment', props: {}, children };\n}\n\n// Flatten nested arrays and vnodes into a flat list of vnodes\nfunction flattenVNodes(children) {\n  const result = [];\n  for (const child of children) {\n    if (child === null || child === undefined) {\n      continue;\n    } else if (Array.isArray(child)) {\n      result.push(...flattenVNodes(child));\n    } else {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\n// Create a real DOM node from a vnode\nfunction render(vnode) {\n  if (vnode === null || vnode === undefined) {\n    return document.createTextNode('');\n  }\n\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    return document.createTextNode(String(vnode));\n  }\n\n  if (Array.isArray(vnode)) {\n    const fragment = document.createDocumentFragment();\n    for (const child of vnode) {\n      fragment.appendChild(render(child));\n    }\n    return fragment;\n  }\n\n  if (!vnode.__lux) {\n    return document.createTextNode(String(vnode));\n  }\n\n  // Fragment\n  if (vnode.tag === '__fragment') {\n    const fragment = document.createDocumentFragment();\n    for (const child of flattenVNodes(vnode.children)) {\n      fragment.appendChild(render(child));\n    }\n    return fragment;\n  }\n\n  // Element\n  const el = document.createElement(vnode.tag);\n  applyProps(el, vnode.props, {});\n\n  // Render children\n  for (const child of flattenVNodes(vnode.children)) {\n    el.appendChild(render(child));\n  }\n\n  // Store vnode reference for patching\n  el.__vnode = vnode;\n\n  return el;\n}\n\n// Apply/update props on a DOM element\nfunction applyProps(el, newProps, oldProps) {\n  // Remove old props that are no longer present\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in newProps)) {\n      if (key.startsWith('on')) {\n        // Can't easily remove anonymous listeners, skip\n      } else if (key === 'className') {\n        el.className = '';\n      } else if (key === 'style') {\n        el.removeAttribute('style');\n      } else {\n        el.removeAttribute(key);\n      }\n    }\n  }\n\n  // Apply new props\n  for (const [key, value] of Object.entries(newProps)) {\n    if (key === 'className') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.className !== val) el.className = val;\n    } else if (key.startsWith('on')) {\n      // Re-attach event listeners (store reference to remove old one)\n      const eventName = key.slice(2).toLowerCase();\n      const oldHandler = el.__handlers && el.__handlers[eventName];\n      if (oldHandler !== value) {\n        if (oldHandler) el.removeEventListener(eventName, oldHandler);\n        el.addEventListener(eventName, value);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value;\n      }\n    } else if (key === 'style' && typeof value === 'object') {\n      Object.assign(el.style, value);\n    } else if (key === 'key') {\n      // Skip\n    } else if (key === 'value') {\n      // For input elements, set .value property directly (not attribute)\n      // and skip if element is focused (user is typing)\n      const val = typeof value === 'function' ? value() : value;\n      if (el !== document.activeElement && el.value !== val) {\n        el.value = val;\n      }\n    } else if (key === 'checked') {\n      el.checked = !!value;\n    } else {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.getAttribute(key) !== String(val)) {\n        el.setAttribute(key, val);\n      }\n    }\n  }\n}\n\n// Patch existing DOM to match new vnode (in-place updates, preserves focus)\nfunction patch(parent, oldNode, newVNode, index = 0) {\n  const existing = parent.childNodes[index];\n\n  // No existing node — append new one\n  if (!existing) {\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  // New vnode is null/undefined — remove existing\n  if (newVNode === null || newVNode === undefined) {\n    parent.removeChild(existing);\n    return;\n  }\n\n  // Text node\n  if (typeof newVNode === 'string' || typeof newVNode === 'number' || typeof newVNode === 'boolean') {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      // Existing is text node — just update content\n      if (existing.textContent !== text) {\n        existing.textContent = text;\n      }\n    } else {\n      // Replace non-text with text\n      parent.replaceChild(document.createTextNode(text), existing);\n    }\n    return;\n  }\n\n  // Non-lux vnode — render as text\n  if (!newVNode.__lux) {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      parent.replaceChild(document.createTextNode(text), existing);\n    }\n    return;\n  }\n\n  // Fragment — patch children directly into parent starting at index\n  if (newVNode.tag === '__fragment') {\n    const children = flattenVNodes(newVNode.children);\n    for (let i = 0; i < children.length; i++) {\n      patch(parent, null, children[i], index + i);\n    }\n    return;\n  }\n\n  // Element — check if we can patch in-place\n  if (existing.nodeType === 1 && existing.tagName.toLowerCase() === newVNode.tag.toLowerCase()) {\n    // Same tag — patch props and children in place\n    const oldVNode = existing.__vnode || { props: {}, children: [] };\n    applyProps(existing, newVNode.props, oldVNode.props);\n\n    // Patch children\n    const newChildren = flattenVNodes(newVNode.children);\n    const oldChildCount = existing.childNodes.length;\n    const newChildCount = newChildren.length;\n\n    // Patch existing children\n    for (let i = 0; i < Math.min(oldChildCount, newChildCount); i++) {\n      patch(existing, existing.childNodes[i], newChildren[i], i);\n    }\n\n    // Add new children\n    for (let i = oldChildCount; i < newChildCount; i++) {\n      existing.appendChild(render(newChildren[i]));\n    }\n\n    // Remove extra old children\n    while (existing.childNodes.length > newChildCount) {\n      existing.removeChild(existing.lastChild);\n    }\n\n    existing.__vnode = newVNode;\n    return;\n  }\n\n  // Different tag or node type — full replace\n  parent.replaceChild(render(newVNode), existing);\n}\n\nfunction flattenChildren(children) {\n  return flattenVNodes(children);\n}\nfunction mount(component, container) {\n  if (!container) {\n    console.error('Lux: Mount target not found');\n    return;\n  }\n\n  let firstRender = true;\n\n  createEffect(() => {\n    const vnode = typeof component === 'function' ? component() : component;\n\n    if (firstRender) {\n      container.innerHTML = '';\n      container.appendChild(render(vnode));\n      firstRender = false;\n    } else {\n      // Patch existing DOM in-place (preserves focus, input state)\n      patch(container, container.firstChild, vnode, 0);\n    }\n  });\n}";
var STRING_PROTO_CODE = "// Lux string method extensions — bridges Lux method syntax to JavaScript\n// Allows: \"hello\".upper() instead of requiring upper(\"hello\")\n\nconst methods = {\n  upper()       { return this.toUpperCase(); },\n  lower()       { return this.toLowerCase(); },\n  contains(s)   { return this.includes(s); },\n  starts_with(s){ return this.startsWith(s); },\n  ends_with(s)  { return this.endsWith(s); },\n  chars()       { return [...this]; },\n  words()       { return this.split(/\\s+/).filter(Boolean); },\n  lines()       { return this.split('\\n'); },\n  capitalize()  { return this.length ? this.charAt(0).toUpperCase() + this.slice(1) : this; },\n  title_case()  { return this.replace(/\\b\\w/g, c => c.toUpperCase()); },\n  snake_case()  { return this.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },\n  camel_case()  { return this.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },\n};\n\nfor (const [name, fn] of Object.entries(methods)) {\n  if (!String.prototype[name]) {\n    Object.defineProperty(String.prototype, name, {\n      value: fn,\n      writable: true,\n      configurable: true,\n    });\n  }\n}";
var STDLIB_CODE = "function print(...args) { console.log(...args); }\nfunction len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }\nfunction range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }\nfunction enumerate(a) { return a.map((v, i) => [i, v]); }\nfunction sum(a) { return a.reduce((x, y) => x + y, 0); }\nfunction sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }\nfunction reversed(a) { return [...a].reverse(); }\nfunction zip(...as) { const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }\nfunction min(a) { return Math.min(...a); }\nfunction max(a) { return Math.max(...a); }\nfunction type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }\nfunction filter(arr, fn) { return arr.filter(fn); }\nfunction map(arr, fn) { return arr.map(fn); }\nfunction flat_map(arr, fn) { return arr.flatMap(fn); }\nfunction any(arr, fn) { return arr.some(fn); }\nfunction all(arr, fn) { return arr.every(fn); }";

// ─── Lux Compiler Bundle ────────────────────────────
(function() {

// ─── src/lexer/tokens.js ───────────────────────────────

// Token type definitions for the Lux language
const TokenType = {
  // Literals
  NUMBER: 'NUMBER',
  STRING: 'STRING',
  STRING_TEMPLATE: 'STRING_TEMPLATE',
  BOOLEAN: 'BOOLEAN',
  NIL: 'NIL',
  IDENTIFIER: 'IDENTIFIER',

  // Keywords
  VAR: 'VAR',
  LET: 'LET',
  FN: 'FN',
  RETURN: 'RETURN',
  IF: 'IF',
  ELIF: 'ELIF',
  ELSE: 'ELSE',
  FOR: 'FOR',
  WHILE: 'WHILE',
  MATCH: 'MATCH',
  TYPE: 'TYPE',
  IMPORT: 'IMPORT',
  FROM: 'FROM',
  EXPORT: 'EXPORT',
  AS: 'AS',

  // Boolean / logic keywords
  AND: 'AND',
  OR: 'OR',
  NOT: 'NOT',
  IN: 'IN',
  TRUE: 'TRUE',
  FALSE: 'FALSE',

  // Full-stack keywords
  SERVER: 'SERVER',
  CLIENT: 'CLIENT',
  SHARED: 'SHARED',
  ROUTE: 'ROUTE',
  STATE: 'STATE',
  COMPUTED: 'COMPUTED',
  EFFECT: 'EFFECT',
  COMPONENT: 'COMPONENT',

  // HTTP methods (used in route declarations)
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',

  // Operators
  PLUS: 'PLUS',               // +
  MINUS: 'MINUS',             // -
  STAR: 'STAR',               // *
  SLASH: 'SLASH',             // /
  PERCENT: 'PERCENT',         // %
  POWER: 'POWER',             // **
  ASSIGN: 'ASSIGN',           // =
  EQUAL: 'EQUAL',             // ==
  NOT_EQUAL: 'NOT_EQUAL',     // !=
  LESS: 'LESS',               // <
  LESS_EQUAL: 'LESS_EQUAL',   // <=
  GREATER: 'GREATER',         // >
  GREATER_EQUAL: 'GREATER_EQUAL', // >=
  AND_AND: 'AND_AND',         // &&
  OR_OR: 'OR_OR',             // ||
  BANG: 'BANG',                // !
  PIPE: 'PIPE',               // |>
  ARROW: 'ARROW',             // =>
  THIN_ARROW: 'THIN_ARROW',   // ->
  DOT: 'DOT',                 // .
  DOT_DOT: 'DOT_DOT',        // ..
  DOT_DOT_EQUAL: 'DOT_DOT_EQUAL', // ..=
  SPREAD: 'SPREAD',           // ...
  COLON: 'COLON',             // :
  DOUBLE_COLON: 'DOUBLE_COLON', // ::
  QUESTION: 'QUESTION',       // ?
  QUESTION_DOT: 'QUESTION_DOT', // ?.
  QUESTION_QUESTION: 'QUESTION_QUESTION', // ??
  PLUS_ASSIGN: 'PLUS_ASSIGN', // +=
  MINUS_ASSIGN: 'MINUS_ASSIGN', // -=
  STAR_ASSIGN: 'STAR_ASSIGN', // *=
  SLASH_ASSIGN: 'SLASH_ASSIGN', // /=

  // Delimiters
  LPAREN: 'LPAREN',           // (
  RPAREN: 'RPAREN',           // )
  LBRACE: 'LBRACE',           // {
  RBRACE: 'RBRACE',           // }
  LBRACKET: 'LBRACKET',       // [
  RBRACKET: 'RBRACKET',       // ]
  COMMA: 'COMMA',             // ,
  SEMICOLON: 'SEMICOLON',     // ;
  NEWLINE: 'NEWLINE',         // \n (significant in some contexts)

  // JSX
  JSX_OPEN: 'JSX_OPEN',       // <tag
  JSX_CLOSE: 'JSX_CLOSE',     // </tag>
  JSX_SELF_CLOSE: 'JSX_SELF_CLOSE', // />
  JSX_TEXT: 'JSX_TEXT',

  // Special
  EOF: 'EOF',
  DOCSTRING: 'DOCSTRING',     // /// comment
};

// Keywords map for quick lookup during lexing
const Keywords = {
  'var': TokenType.VAR,
  'let': TokenType.LET,
  'fn': TokenType.FN,
  'return': TokenType.RETURN,
  'if': TokenType.IF,
  'elif': TokenType.ELIF,
  'else': TokenType.ELSE,
  'for': TokenType.FOR,
  'while': TokenType.WHILE,
  'match': TokenType.MATCH,
  'type': TokenType.TYPE,
  'import': TokenType.IMPORT,
  'from': TokenType.FROM,
  'export': TokenType.EXPORT,
  'as': TokenType.AS,
  'and': TokenType.AND,
  'or': TokenType.OR,
  'not': TokenType.NOT,
  'in': TokenType.IN,
  'true': TokenType.TRUE,
  'false': TokenType.FALSE,
  'nil': TokenType.NIL,
  'server': TokenType.SERVER,
  'client': TokenType.CLIENT,
  'shared': TokenType.SHARED,
  'route': TokenType.ROUTE,
  'state': TokenType.STATE,
  'computed': TokenType.COMPUTED,
  'effect': TokenType.EFFECT,
  'component': TokenType.COMPONENT,
};

// Token class
class Token {
  constructor(type, value, line, column) {
    this.type = type;
    this.value = value;
    this.line = line;
    this.column = column;
  }

  toString() {
    return `Token(${this.type}, ${JSON.stringify(this.value)}, ${this.line}:${this.column})`;
  }
}

// ─── src/lexer/lexer.js ────────────────────────────────

class Lexer {
  constructor(source, filename = '<stdin>') {
    this.source = source;
    this.filename = filename;
    this.tokens = [];
    this.pos = 0;
    this.line = 1;
    this.column = 1;
    this.length = source.length;
  }

  error(message) {
    throw new Error(`${this.filename}:${this.line}:${this.column} — ${message}`);
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.length ? this.source[idx] : '\0';
  }

  advance() {
    const ch = this.source[this.pos];
    this.pos++;
    if (ch === '\n') {
      this.line++;
      this.column = 1;
    } else {
      this.column++;
    }
    return ch;
  }

  match(expected) {
    if (this.pos < this.length && this.source[this.pos] === expected) {
      this.advance();
      return true;
    }
    return false;
  }

  addToken(type, value) {
    this.tokens.push(new Token(type, value, this.line, this.column));
  }

  isDigit(ch) {
    return ch >= '0' && ch <= '9';
  }

  isAlpha(ch) {
    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_';
  }

  isAlphaNumeric(ch) {
    return this.isAlpha(ch) || this.isDigit(ch);
  }

  isWhitespace(ch) {
    return ch === ' ' || ch === '\t' || ch === '\r';
  }

  tokenize() {
    while (this.pos < this.length) {
      this.scanToken();
    }
    this.tokens.push(new Token(TokenType.EOF, null, this.line, this.column));
    return this.tokens;
  }

  scanToken() {
    const ch = this.peek();

    // Skip whitespace (not newlines)
    if (this.isWhitespace(ch)) {
      this.advance();
      return;
    }

    // Newlines
    if (ch === '\n') {
      this.tokens.push(new Token(TokenType.NEWLINE, '\n', this.line, this.column));
      this.advance();
      return;
    }

    // Comments
    if (ch === '/' && this.peek(1) === '/') {
      this.scanComment();
      return;
    }
    if (ch === '/' && this.peek(1) === '*') {
      this.scanBlockComment();
      return;
    }

    // Numbers
    if (this.isDigit(ch)) {
      this.scanNumber();
      return;
    }

    // Strings
    if (ch === '"') {
      this.scanString();
      return;
    }
    if (ch === "'") {
      this.scanSimpleString();
      return;
    }

    // Identifiers and keywords
    if (this.isAlpha(ch)) {
      this.scanIdentifier();
      return;
    }

    // Operators and delimiters
    this.scanOperator();
  }

  scanComment() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // /
    this.advance(); // /

    // Check for docstring ///
    const isDocstring = this.peek() === '/';
    if (isDocstring) this.advance();

    let value = '';
    while (this.pos < this.length && this.peek() !== '\n') {
      value += this.advance();
    }

    if (isDocstring) {
      this.tokens.push(new Token(TokenType.DOCSTRING, value.trim(), startLine, startCol));
    }
    // Regular comments are discarded
  }

  scanBlockComment() {
    this.advance(); // /
    this.advance(); // *
    let depth = 1;

    while (this.pos < this.length && depth > 0) {
      if (this.peek() === '/' && this.peek(1) === '*') {
        depth++;
        this.advance();
        this.advance();
      } else if (this.peek() === '*' && this.peek(1) === '/') {
        depth--;
        this.advance();
        this.advance();
      } else {
        this.advance();
      }
    }

    if (depth !== 0) {
      this.error('Unterminated block comment');
    }
  }

  scanNumber() {
    const startLine = this.line;
    const startCol = this.column;
    let value = '';

    // Handle hex, octal, binary
    if (this.peek() === '0') {
      const next = this.peek(1);
      if (next === 'x' || next === 'X') {
        this.advance(); // 0
        this.advance(); // x
        while (this.pos < this.length && /[0-9a-fA-F_]/.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 16), startLine, startCol));
        return;
      }
      if (next === 'b' || next === 'B') {
        this.advance(); // 0
        this.advance(); // b
        while (this.pos < this.length && /[01_]/.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 2), startLine, startCol));
        return;
      }
      if (next === 'o' || next === 'O') {
        this.advance(); // 0
        this.advance(); // o
        while (this.pos < this.length && /[0-7_]/.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 8), startLine, startCol));
        return;
      }
    }

    // Decimal
    while (this.pos < this.length && (this.isDigit(this.peek()) || this.peek() === '_')) {
      const ch = this.advance();
      if (ch !== '_') value += ch;
    }

    // Decimal point
    if (this.peek() === '.' && this.peek(1) !== '.') {
      value += this.advance(); // .
      while (this.pos < this.length && (this.isDigit(this.peek()) || this.peek() === '_')) {
        const ch = this.advance();
        if (ch !== '_') value += ch;
      }
    }

    // Exponent
    if (this.peek() === 'e' || this.peek() === 'E') {
      value += this.advance();
      if (this.peek() === '+' || this.peek() === '-') {
        value += this.advance();
      }
      while (this.pos < this.length && this.isDigit(this.peek())) {
        value += this.advance();
      }
    }

    this.tokens.push(new Token(TokenType.NUMBER, parseFloat(value), startLine, startCol));
  }

  scanString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening "

    const parts = [];
    let current = '';

    while (this.pos < this.length && this.peek() !== '"') {
      // Escape sequences
      if (this.peek() === '\\') {
        this.advance();
        const esc = this.advance();
        switch (esc) {
          case 'n': current += '\n'; break;
          case 't': current += '\t'; break;
          case 'r': current += '\r'; break;
          case '\\': current += '\\'; break;
          case '"': current += '"'; break;
          case '{': current += '{'; break;
          default: current += '\\' + esc;
        }
        continue;
      }

      // String interpolation: {expr}
      if (this.peek() === '{') {
        this.advance(); // {
        if (current.length > 0) {
          parts.push({ type: 'text', value: current });
          current = '';
        }

        // Lex the interpolation expression
        let depth = 1;
        let exprSource = '';
        while (this.pos < this.length && depth > 0) {
          if (this.peek() === '{') depth++;
          if (this.peek() === '}') {
            depth--;
            if (depth === 0) break;
          }
          exprSource += this.advance();
        }

        if (this.peek() !== '}') {
          this.error('Unterminated string interpolation');
        }
        this.advance(); // }

        // Sub-lex the expression
        const subLexer = new Lexer(exprSource, this.filename);
        const exprTokens = subLexer.tokenize();
        // Remove the EOF token
        exprTokens.pop();

        parts.push({ type: 'expr', tokens: exprTokens, source: exprSource });
        continue;
      }

      current += this.advance();
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing "

    // If there are no interpolation parts, emit a simple string
    if (parts.length === 0) {
      this.tokens.push(new Token(TokenType.STRING, current, startLine, startCol));
    } else {
      if (current.length > 0) {
        parts.push({ type: 'text', value: current });
      }
      this.tokens.push(new Token(TokenType.STRING_TEMPLATE, parts, startLine, startCol));
    }
  }

  scanSimpleString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening '

    let value = '';
    while (this.pos < this.length && this.peek() !== "'") {
      if (this.peek() === '\\') {
        this.advance();
        const esc = this.advance();
        switch (esc) {
          case 'n': value += '\n'; break;
          case 't': value += '\t'; break;
          case 'r': value += '\r'; break;
          case '\\': value += '\\'; break;
          case "'": value += "'"; break;
          default: value += '\\' + esc;
        }
      } else {
        value += this.advance();
      }
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing '

    this.tokens.push(new Token(TokenType.STRING, value, startLine, startCol));
  }

  scanIdentifier() {
    const startLine = this.line;
    const startCol = this.column;
    let value = '';

    while (this.pos < this.length && this.isAlphaNumeric(this.peek())) {
      value += this.advance();
    }

    // Check if it's a keyword
    const type = Keywords[value] || TokenType.IDENTIFIER;
    this.tokens.push(new Token(type, value, startLine, startCol));
  }

  scanOperator() {
    const startLine = this.line;
    const startCol = this.column;
    const ch = this.advance();

    switch (ch) {
      case '(':
        this.tokens.push(new Token(TokenType.LPAREN, '(', startLine, startCol));
        break;
      case ')':
        this.tokens.push(new Token(TokenType.RPAREN, ')', startLine, startCol));
        break;
      case '{':
        this.tokens.push(new Token(TokenType.LBRACE, '{', startLine, startCol));
        break;
      case '}':
        this.tokens.push(new Token(TokenType.RBRACE, '}', startLine, startCol));
        break;
      case '[':
        this.tokens.push(new Token(TokenType.LBRACKET, '[', startLine, startCol));
        break;
      case ']':
        this.tokens.push(new Token(TokenType.RBRACKET, ']', startLine, startCol));
        break;
      case ',':
        this.tokens.push(new Token(TokenType.COMMA, ',', startLine, startCol));
        break;
      case ';':
        this.tokens.push(new Token(TokenType.SEMICOLON, ';', startLine, startCol));
        break;

      case '+':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.PLUS_ASSIGN, '+=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.PLUS, '+', startLine, startCol));
        }
        break;

      case '-':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.THIN_ARROW, '->', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.MINUS_ASSIGN, '-=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.MINUS, '-', startLine, startCol));
        }
        break;

      case '*':
        if (this.match('*')) {
          this.tokens.push(new Token(TokenType.POWER, '**', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.STAR_ASSIGN, '*=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.STAR, '*', startLine, startCol));
        }
        break;

      case '/':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.SLASH_ASSIGN, '/=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.SLASH, '/', startLine, startCol));
        }
        break;

      case '%':
        this.tokens.push(new Token(TokenType.PERCENT, '%', startLine, startCol));
        break;

      case '=':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.EQUAL, '==', startLine, startCol));
        } else if (this.match('>')) {
          this.tokens.push(new Token(TokenType.ARROW, '=>', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.ASSIGN, '=', startLine, startCol));
        }
        break;

      case '!':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.NOT_EQUAL, '!=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.BANG, '!', startLine, startCol));
        }
        break;

      case '<':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.LESS_EQUAL, '<=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.LESS, '<', startLine, startCol));
        }
        break;

      case '>':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.GREATER_EQUAL, '>=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.GREATER, '>', startLine, startCol));
        }
        break;

      case '&':
        if (this.match('&')) {
          this.tokens.push(new Token(TokenType.AND_AND, '&&', startLine, startCol));
        } else {
          this.error(`Unexpected character: '&'. Did you mean '&&'?`);
        }
        break;

      case '|':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.PIPE, '|>', startLine, startCol));
        } else if (this.match('|')) {
          this.tokens.push(new Token(TokenType.OR_OR, '||', startLine, startCol));
        } else {
          this.error(`Unexpected character: '|'. Did you mean '|>' or '||'?`);
        }
        break;

      case '.':
        if (this.match('.')) {
          if (this.match('=')) {
            this.tokens.push(new Token(TokenType.DOT_DOT_EQUAL, '..=', startLine, startCol));
          } else if (this.match('.')) {
            this.tokens.push(new Token(TokenType.SPREAD, '...', startLine, startCol));
          } else {
            this.tokens.push(new Token(TokenType.DOT_DOT, '..', startLine, startCol));
          }
        } else {
          this.tokens.push(new Token(TokenType.DOT, '.', startLine, startCol));
        }
        break;

      case ':':
        if (this.match(':')) {
          this.tokens.push(new Token(TokenType.DOUBLE_COLON, '::', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.COLON, ':', startLine, startCol));
        }
        break;

      case '?':
        if (this.match('.')) {
          this.tokens.push(new Token(TokenType.QUESTION_DOT, '?.', startLine, startCol));
        } else if (this.match('?')) {
          this.tokens.push(new Token(TokenType.QUESTION_QUESTION, '??', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.QUESTION, '?', startLine, startCol));
        }
        break;

      default:
        this.error(`Unexpected character: '${ch}'`);
    }
  }
}

// ─── src/parser/ast.js ─────────────────────────────────

// AST Node definitions for the Lux language

// ============================================================
// Program (root node)
// ============================================================
class Program {
  constructor(body) {
    this.type = 'Program';
    this.body = body; // Array of top-level statements/blocks
  }
}

// ============================================================
// Full-stack blocks
// ============================================================
class ServerBlock {
  constructor(body, loc, name = null) {
    this.type = 'ServerBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class ClientBlock {
  constructor(body, loc, name = null) {
    this.type = 'ClientBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class SharedBlock {
  constructor(body, loc, name = null) {
    this.type = 'SharedBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}

// ============================================================
// Declarations
// ============================================================
class Assignment {
  constructor(targets, values, loc) {
    this.type = 'Assignment';
    this.targets = targets;   // Array of identifiers (supports multiple: a, b = 1, 2)
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class VarDeclaration {
  constructor(targets, values, loc) {
    this.type = 'VarDeclaration';
    this.targets = targets;   // Array of identifiers
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class LetDestructure {
  constructor(pattern, value, loc) {
    this.type = 'LetDestructure';
    this.pattern = pattern;   // ObjectPattern or ArrayPattern
    this.value = value;       // Expression
    this.loc = loc;
  }
}
class FunctionDeclaration {
  constructor(name, params, body, returnType, loc) {
    this.type = 'FunctionDeclaration';
    this.name = name;
    this.params = params;     // Array of Parameter nodes
    this.body = body;         // BlockStatement or Expression (implicit return)
    this.returnType = returnType; // optional type annotation
    this.loc = loc;
  }
}
class Parameter {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'Parameter';
    this.name = name;
    this.typeAnnotation = typeAnnotation; // optional
    this.defaultValue = defaultValue;     // optional
    this.loc = loc;
  }
}
class TypeDeclaration {
  constructor(name, typeParams, variants, loc) {
    this.type = 'TypeDeclaration';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (generics)
    this.variants = variants;     // Array of TypeVariant or TypeField
    this.loc = loc;
  }
}
class TypeVariant {
  constructor(name, fields, loc) {
    this.type = 'TypeVariant';
    this.name = name;
    this.fields = fields; // Array of { name, typeAnnotation }
    this.loc = loc;
  }
}
class TypeField {
  constructor(name, typeAnnotation, loc) {
    this.type = 'TypeField';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.loc = loc;
  }
}

// ============================================================
// Import / Export
// ============================================================
class ImportDeclaration {
  constructor(specifiers, source, loc) {
    this.type = 'ImportDeclaration';
    this.specifiers = specifiers; // Array of { imported, local }
    this.source = source;         // string literal
    this.loc = loc;
  }
}
class ImportSpecifier {
  constructor(imported, local, loc) {
    this.type = 'ImportSpecifier';
    this.imported = imported;
    this.local = local || imported;
    this.loc = loc;
  }
}
class ImportDefault {
  constructor(local, source, loc) {
    this.type = 'ImportDefault';
    this.local = local;
    this.source = source;
    this.loc = loc;
  }
}

// ============================================================
// Statements
// ============================================================
class BlockStatement {
  constructor(body, loc) {
    this.type = 'BlockStatement';
    this.body = body;
    this.loc = loc;
  }
}
class ReturnStatement {
  constructor(value, loc) {
    this.type = 'ReturnStatement';
    this.value = value;
    this.loc = loc;
  }
}
class IfStatement {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfStatement';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement or null
    this.loc = loc;
  }
}
class ForStatement {
  constructor(variable, iterable, body, elseBody, loc) {
    this.type = 'ForStatement';
    this.variable = variable;   // Identifier or destructure pattern
    this.iterable = iterable;   // Expression
    this.body = body;           // BlockStatement
    this.elseBody = elseBody;   // BlockStatement or null (for-else)
    this.loc = loc;
  }
}
class WhileStatement {
  constructor(condition, body, loc) {
    this.type = 'WhileStatement';
    this.condition = condition;
    this.body = body;
    this.loc = loc;
  }
}
class IfExpression {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfExpression';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement (required)
    this.loc = loc;
  }
}
class ExpressionStatement {
  constructor(expression, loc) {
    this.type = 'ExpressionStatement';
    this.expression = expression;
    this.loc = loc;
  }
}

// ============================================================
// Expressions
// ============================================================
class Identifier {
  constructor(name, loc) {
    this.type = 'Identifier';
    this.name = name;
    this.loc = loc;
  }
}
class NumberLiteral {
  constructor(value, loc) {
    this.type = 'NumberLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class StringLiteral {
  constructor(value, loc) {
    this.type = 'StringLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class TemplateLiteral {
  constructor(parts, loc) {
    this.type = 'TemplateLiteral';
    this.parts = parts; // Array of { type: 'text'|'expr', value }
    this.loc = loc;
  }
}
class BooleanLiteral {
  constructor(value, loc) {
    this.type = 'BooleanLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class NilLiteral {
  constructor(loc) {
    this.type = 'NilLiteral';
    this.loc = loc;
  }
}
class ArrayLiteral {
  constructor(elements, loc) {
    this.type = 'ArrayLiteral';
    this.elements = elements;
    this.loc = loc;
  }
}
class ObjectLiteral {
  constructor(properties, loc) {
    this.type = 'ObjectLiteral';
    this.properties = properties; // Array of { key, value, shorthand }
    this.loc = loc;
  }
}
class BinaryExpression {
  constructor(operator, left, right, loc) {
    this.type = 'BinaryExpression';
    this.operator = operator;
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class UnaryExpression {
  constructor(operator, operand, prefix, loc) {
    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
    this.prefix = prefix;
    this.loc = loc;
  }
}
class ChainedComparison {
  constructor(operands, operators, loc) {
    this.type = 'ChainedComparison';
    this.operands = operands;   // [a, b, c] for a < b < c
    this.operators = operators; // ['<', '<']
    this.loc = loc;
  }
}
class LogicalExpression {
  constructor(operator, left, right, loc) {
    this.type = 'LogicalExpression';
    this.operator = operator; // 'and', 'or', '&&', '||'
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class CallExpression {
  constructor(callee, args, loc) {
    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = args;
    this.loc = loc;
  }
}
class NamedArgument {
  constructor(name, value, loc) {
    this.type = 'NamedArgument';
    this.name = name;
    this.value = value;
    this.loc = loc;
  }
}
class MemberExpression {
  constructor(object, property, computed, loc) {
    this.type = 'MemberExpression';
    this.object = object;
    this.property = property;
    this.computed = computed; // true for obj[expr], false for obj.prop
    this.loc = loc;
  }
}
class OptionalChain {
  constructor(object, property, computed, loc) {
    this.type = 'OptionalChain';
    this.object = object;
    this.property = property;
    this.computed = computed;
    this.loc = loc;
  }
}
class PipeExpression {
  constructor(left, right, loc) {
    this.type = 'PipeExpression';
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class LambdaExpression {
  constructor(params, body, loc) {
    this.type = 'LambdaExpression';
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class MatchExpression {
  constructor(subject, arms, loc) {
    this.type = 'MatchExpression';
    this.subject = subject;
    this.arms = arms; // Array of MatchArm
    this.loc = loc;
  }
}
class MatchArm {
  constructor(pattern, guard, body, loc) {
    this.type = 'MatchArm';
    this.pattern = pattern;
    this.guard = guard;   // optional guard expression (if condition)
    this.body = body;
    this.loc = loc;
  }
}
class RangeExpression {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangeExpression';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive; // true for ..=, false for ..
    this.loc = loc;
  }
}
class SliceExpression {
  constructor(object, start, end, step, loc) {
    this.type = 'SliceExpression';
    this.object = object;
    this.start = start;
    this.end = end;
    this.step = step;
    this.loc = loc;
  }
}
class SpreadExpression {
  constructor(argument, loc) {
    this.type = 'SpreadExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class ListComprehension {
  constructor(expression, variable, iterable, condition, loc) {
    this.type = 'ListComprehension';
    this.expression = expression;
    this.variable = variable;
    this.iterable = iterable;
    this.condition = condition; // optional filter
    this.loc = loc;
  }
}
class DictComprehension {
  constructor(key, value, variables, iterable, condition, loc) {
    this.type = 'DictComprehension';
    this.key = key;
    this.value = value;
    this.variables = variables;
    this.iterable = iterable;
    this.condition = condition;
    this.loc = loc;
  }
}
class MembershipExpression {
  constructor(value, collection, negated, loc) {
    this.type = 'MembershipExpression';
    this.value = value;
    this.collection = collection;
    this.negated = negated; // true for "not in"
    this.loc = loc;
  }
}
class CompoundAssignment {
  constructor(target, operator, value, loc) {
    this.type = 'CompoundAssignment';
    this.target = target;
    this.operator = operator; // +=, -=, *=, /=
    this.value = value;
    this.loc = loc;
  }
}

// ============================================================
// Patterns (for destructuring and match)
// ============================================================
class ObjectPattern {
  constructor(properties, loc) {
    this.type = 'ObjectPattern';
    this.properties = properties; // Array of { key, value (alias), defaultValue }
    this.loc = loc;
  }
}
class ArrayPattern {
  constructor(elements, loc) {
    this.type = 'ArrayPattern';
    this.elements = elements;
    this.loc = loc;
  }
}
class WildcardPattern {
  constructor(loc) {
    this.type = 'WildcardPattern';
    this.loc = loc;
  }
}
class LiteralPattern {
  constructor(value, loc) {
    this.type = 'LiteralPattern';
    this.value = value;
    this.loc = loc;
  }
}
class VariantPattern {
  constructor(name, fields, loc) {
    this.type = 'VariantPattern';
    this.name = name;
    this.fields = fields;
    this.loc = loc;
  }
}
class BindingPattern {
  constructor(name, loc) {
    this.type = 'BindingPattern';
    this.name = name;
    this.loc = loc;
  }
}
class RangePattern {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangePattern';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive;
    this.loc = loc;
  }
}

// ============================================================
// Client-specific nodes
// ============================================================
class StateDeclaration {
  constructor(name, typeAnnotation, initialValue, loc) {
    this.type = 'StateDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.initialValue = initialValue;
    this.loc = loc;
  }
}
class ComputedDeclaration {
  constructor(name, expression, loc) {
    this.type = 'ComputedDeclaration';
    this.name = name;
    this.expression = expression;
    this.loc = loc;
  }
}
class EffectDeclaration {
  constructor(body, loc) {
    this.type = 'EffectDeclaration';
    this.body = body;
    this.loc = loc;
  }
}
class ComponentDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'ComponentDeclaration';
    this.name = name;
    this.params = params;
    this.body = body; // Array of JSX elements and statements
    this.loc = loc;
  }
}

// ============================================================
// JSX-like nodes
// ============================================================
class JSXElement {
  constructor(tag, attributes, children, selfClosing, loc) {
    this.type = 'JSXElement';
    this.tag = tag;
    this.attributes = attributes; // Array of JSXAttribute
    this.children = children;     // Array of JSXElement, JSXText, JSXExpression
    this.selfClosing = selfClosing;
    this.loc = loc;
  }
}
class JSXAttribute {
  constructor(name, value, loc) {
    this.type = 'JSXAttribute';
    this.name = name;   // string (e.g., "class", "on:click")
    this.value = value;  // Expression or string
    this.loc = loc;
  }
}
class JSXText {
  constructor(value, loc) {
    this.type = 'JSXText';
    this.value = value;
    this.loc = loc;
  }
}
class JSXExpression {
  constructor(expression, loc) {
    this.type = 'JSXExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXFor {
  constructor(variable, iterable, body, loc) {
    this.type = 'JSXFor';
    this.variable = variable;
    this.iterable = iterable;
    this.body = body;
    this.loc = loc;
  }
}
class JSXIf {
  constructor(condition, consequent, alternate, loc) {
    this.type = 'JSXIf';
    this.condition = condition;
    this.consequent = consequent;
    this.alternate = alternate;
    this.loc = loc;
  }
}

// ============================================================
// Server-specific nodes
// ============================================================
class RouteDeclaration {
  constructor(method, path, handler, loc) {
    this.type = 'RouteDeclaration';
    this.method = method;   // GET, POST, PUT, DELETE, PATCH
    this.path = path;       // string literal
    this.handler = handler; // Identifier or FunctionDeclaration
    this.loc = loc;
  }
}

// ============================================================
// Type annotations
// ============================================================
class TypeAnnotation {
  constructor(name, typeParams, loc) {
    this.type = 'TypeAnnotation';
    this.name = name;         // "Int", "String", "Bool", "Float", etc.
    this.typeParams = typeParams; // Array of TypeAnnotation (for generics)
    this.loc = loc;
  }
}
class ArrayTypeAnnotation {
  constructor(elementType, loc) {
    this.type = 'ArrayTypeAnnotation';
    this.elementType = elementType;
    this.loc = loc;
  }
}
class FunctionTypeAnnotation {
  constructor(paramTypes, returnType, loc) {
    this.type = 'FunctionTypeAnnotation';
    this.paramTypes = paramTypes;
    this.returnType = returnType;
    this.loc = loc;
  }
}

// AST namespace shim for parser.js compatibility

const AST = { Program, ServerBlock, ClientBlock, SharedBlock, Assignment, VarDeclaration, LetDestructure, FunctionDeclaration, Parameter, TypeDeclaration, TypeVariant, TypeField, ImportDeclaration, ImportSpecifier, ImportDefault, BlockStatement, ReturnStatement, IfStatement, ForStatement, WhileStatement, IfExpression, ExpressionStatement, Identifier, NumberLiteral, StringLiteral, TemplateLiteral, BooleanLiteral, NilLiteral, ArrayLiteral, ObjectLiteral, BinaryExpression, UnaryExpression, ChainedComparison, LogicalExpression, CallExpression, NamedArgument, MemberExpression, OptionalChain, PipeExpression, LambdaExpression, MatchExpression, MatchArm, RangeExpression, SliceExpression, SpreadExpression, ListComprehension, DictComprehension, MembershipExpression, CompoundAssignment, ObjectPattern, ArrayPattern, WildcardPattern, LiteralPattern, VariantPattern, BindingPattern, RangePattern, StateDeclaration, ComputedDeclaration, EffectDeclaration, ComponentDeclaration, JSXElement, JSXAttribute, JSXText, JSXExpression, JSXFor, JSXIf, RouteDeclaration, TypeAnnotation, ArrayTypeAnnotation, FunctionTypeAnnotation };

// ─── src/parser/parser.js ──────────────────────────────

class Parser {
  constructor(tokens, filename = '<stdin>') {
    this.tokens = tokens.filter(t => t.type !== TokenType.NEWLINE && t.type !== TokenType.DOCSTRING);
    this.rawTokens = tokens;
    this.filename = filename;
    this.pos = 0;
    this.docstrings = this.extractDocstrings(tokens);
  }

  extractDocstrings(tokens) {
    const docs = [];
    for (const t of tokens) {
      if (t.type === TokenType.DOCSTRING) {
        docs.push(t);
      }
    }
    return docs;
  }

  // ─── Helpers ───────────────────────────────────────────────

  error(message) {
    const tok = this.current();
    throw new Error(
      `${this.filename}:${tok.line}:${tok.column} — Parse error: ${message}\n  Got: ${tok.type} (${JSON.stringify(tok.value)})`
    );
  }

  current() {
    return this.tokens[this.pos] || this.tokens[this.tokens.length - 1];
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.tokens.length ? this.tokens[idx] : this.tokens[this.tokens.length - 1];
  }

  advance() {
    const tok = this.current();
    this.pos++;
    return tok;
  }

  check(type) {
    return this.current().type === type;
  }

  checkValue(type, value) {
    const tok = this.current();
    return tok.type === type && tok.value === value;
  }

  match(...types) {
    for (const type of types) {
      if (this.check(type)) {
        return this.advance();
      }
    }
    return null;
  }

  expect(type, message) {
    if (this.check(type)) {
      return this.advance();
    }
    this.error(message || `Expected ${type}, got ${this.current().type}`);
  }

  loc() {
    const tok = this.current();
    return { line: tok.line, column: tok.column, file: this.filename };
  }

  isAtEnd() {
    return this.check(TokenType.EOF);
  }

  // ─── Program ───────────────────────────────────────────────

  parse() {
    const body = [];
    while (!this.isAtEnd()) {
      const stmt = this.parseTopLevel();
      if (stmt) body.push(stmt);
    }
    return new AST.Program(body);
  }

  parseTopLevel() {
    if (this.check(TokenType.SERVER)) return this.parseServerBlock();
    if (this.check(TokenType.CLIENT)) return this.parseClientBlock();
    if (this.check(TokenType.SHARED)) return this.parseSharedBlock();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    return this.parseStatement();
  }

  // ─── Full-stack blocks ────────────────────────────────────

  parseServerBlock() {
    const l = this.loc();
    this.expect(TokenType.SERVER);
    // Optional block name: server "api" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'server'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      body.push(this.parseServerStatement());
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close server block");
    return new AST.ServerBlock(body, l, name);
  }

  parseClientBlock() {
    const l = this.loc();
    this.expect(TokenType.CLIENT);
    // Optional block name: client "admin" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'client'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      body.push(this.parseClientStatement());
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close client block");
    return new AST.ClientBlock(body, l, name);
  }

  parseSharedBlock() {
    const l = this.loc();
    this.expect(TokenType.SHARED);
    // Optional block name: shared "models" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'shared'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      body.push(this.parseStatement());
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close shared block");
    return new AST.SharedBlock(body, l, name);
  }

  // ─── Server-specific statements ───────────────────────────

  parseServerStatement() {
    if (this.check(TokenType.ROUTE)) return this.parseRoute();
    return this.parseStatement();
  }

  parseRoute() {
    const l = this.loc();
    this.expect(TokenType.ROUTE);

    // HTTP method: GET, POST, PUT, DELETE, PATCH (as identifiers)
    const methodTok = this.expect(TokenType.IDENTIFIER, "Expected HTTP method (GET, POST, PUT, DELETE, PATCH)");
    const method = methodTok.value.toUpperCase();
    if (!['GET', 'POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
      this.error(`Invalid HTTP method: ${method}`);
    }

    const path = this.expect(TokenType.STRING, "Expected route path string");
    this.expect(TokenType.ARROW, "Expected '=>' after route path");
    const handler = this.parseExpression();

    return new AST.RouteDeclaration(method, path.value, handler, l);
  }

  // ─── Client-specific statements ───────────────────────────

  parseClientStatement() {
    if (this.check(TokenType.STATE)) return this.parseState();
    if (this.check(TokenType.COMPUTED)) return this.parseComputed();
    if (this.check(TokenType.EFFECT)) return this.parseEffect();
    if (this.check(TokenType.COMPONENT)) return this.parseComponent();
    return this.parseStatement();
  }

  parseState() {
    const l = this.loc();
    this.expect(TokenType.STATE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected state variable name").value;

    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in state declaration");
    const value = this.parseExpression();

    return new AST.StateDeclaration(name, typeAnnotation, value, l);
  }

  parseComputed() {
    const l = this.loc();
    this.expect(TokenType.COMPUTED);
    const name = this.expect(TokenType.IDENTIFIER, "Expected computed variable name").value;
    this.expect(TokenType.ASSIGN, "Expected '=' in computed declaration");
    const expr = this.parseExpression();

    return new AST.ComputedDeclaration(name, expr, l);
  }

  parseEffect() {
    const l = this.loc();
    this.expect(TokenType.EFFECT);
    const body = this.parseBlock();
    return new AST.EffectDeclaration(body, l);
  }

  parseComponent() {
    const l = this.loc();
    this.expect(TokenType.COMPONENT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected component name").value;

    let params = [];
    if (this.match(TokenType.LPAREN)) {
      params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after component parameters");
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open component body");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElement());
      } else {
        body.push(this.parseStatement());
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close component body");

    return new AST.ComponentDeclaration(name, params, body, l);
  }

  // ─── JSX-like parsing ─────────────────────────────────────

  parseJSXElement() {
    const l = this.loc();
    this.expect(TokenType.LESS, "Expected '<'");

    const tag = this.expect(TokenType.IDENTIFIER, "Expected tag name").value;

    // Parse attributes
    const attributes = [];
    while (!this.check(TokenType.GREATER) && !this.check(TokenType.SLASH) && !this.isAtEnd()) {
      attributes.push(this.parseJSXAttribute());
    }

    // Self-closing tag: />
    if (this.match(TokenType.SLASH)) {
      this.expect(TokenType.GREATER, "Expected '>' in self-closing tag");
      return new AST.JSXElement(tag, attributes, [], true, l);
    }

    this.expect(TokenType.GREATER, "Expected '>'");

    // Parse children
    const children = this.parseJSXChildren(tag);

    return new AST.JSXElement(tag, attributes, children, false, l);
  }

  parseJSXAttribute() {
    const l = this.loc();
    // Accept keywords as attribute names (type, class, for, etc. are valid HTML attributes)
    let name;
    if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.TYPE) || this.check(TokenType.FOR) ||
        this.check(TokenType.IN) || this.check(TokenType.AS) || this.check(TokenType.EXPORT) ||
        this.check(TokenType.STATE) || this.check(TokenType.COMPUTED) || this.check(TokenType.ROUTE)) {
      name = this.advance().value;
    } else {
      this.error("Expected attribute name");
    }

    // Handle event attributes like on:click
    if (this.match(TokenType.COLON)) {
      let suffix;
      if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.IN)) {
        suffix = this.advance().value;
      } else {
        suffix = this.expect(TokenType.IDENTIFIER, "Expected event name after ':'").value;
      }
      name = `on:${suffix}`;
    }

    if (!this.match(TokenType.ASSIGN)) {
      // Boolean attribute: <input disabled />
      return new AST.JSXAttribute(name, new AST.BooleanLiteral(true, l), l);
    }

    // Value can be {expression} or "string"
    if (this.match(TokenType.LBRACE)) {
      const expr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after attribute expression");
      return new AST.JSXAttribute(name, expr, l);
    }

    if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
      const val = this.parseStringLiteral();
      return new AST.JSXAttribute(name, val, l);
    }

    this.error("Expected attribute value");
  }

  parseJSXChildren(parentTag) {
    const children = [];

    while (!this.isAtEnd()) {
      // Closing tag: </tag>
      if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.SLASH) {
        this.advance(); // <
        this.advance(); // /
        const closeTag = this.expect(TokenType.IDENTIFIER, "Expected closing tag name").value;
        if (closeTag !== parentTag) {
          this.error(`Mismatched closing tag: expected </${parentTag}>, got </${closeTag}>`);
        }
        this.expect(TokenType.GREATER, "Expected '>' in closing tag");
        break;
      }

      // Nested element
      if (this.check(TokenType.LESS)) {
        children.push(this.parseJSXElement());
        continue;
      }

      // String literal as text
      if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        const str = this.parseStringLiteral();
        children.push(new AST.JSXText(str, this.loc()));
        continue;
      }

      // Expression in braces: {expr}
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after JSX expression");
        children.push(new AST.JSXExpression(expr, this.loc()));
        continue;
      }

      // for loop inside JSX
      if (this.check(TokenType.FOR)) {
        children.push(this.parseJSXFor());
        continue;
      }

      // if inside JSX
      if (this.check(TokenType.IF)) {
        children.push(this.parseJSXIf());
        continue;
      }

      break;
    }

    return children;
  }

  parseJSXFor() {
    const l = this.loc();
    this.expect(TokenType.FOR);
    const variable = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
    this.expect(TokenType.IN, "Expected 'in' in for loop");
    const iterable = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' in JSX for body");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElement());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else {
        break;
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX for body");

    return new AST.JSXFor(variable, iterable, body, l);
  }

  parseJSXIf() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' in JSX if body");

    const consequent = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        consequent.push(this.parseJSXElement());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        consequent.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else {
        break;
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX if body");

    let alternate = null;
    if (this.check(TokenType.ELSE)) {
      this.advance();
      this.expect(TokenType.LBRACE);
      alternate = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        if (this.check(TokenType.LESS)) {
          alternate.push(this.parseJSXElement());
        } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
          alternate.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
        } else {
          break;
        }
      }
      this.expect(TokenType.RBRACE);
    }

    return new AST.JSXIf(condition, consequent, alternate, l);
  }

  // ─── Statements ───────────────────────────────────────────

  parseStatement() {
    if (this.check(TokenType.FN) && this.peek(1).type === TokenType.IDENTIFIER) return this.parseFunctionDeclaration();
    if (this.check(TokenType.TYPE)) return this.parseTypeDeclaration();
    if (this.check(TokenType.VAR)) return this.parseVarDeclaration();
    if (this.check(TokenType.LET)) return this.parseLetDestructure();
    if (this.check(TokenType.IF)) return this.parseIfStatement();
    if (this.check(TokenType.FOR)) return this.parseForStatement();
    if (this.check(TokenType.WHILE)) return this.parseWhileStatement();
    if (this.check(TokenType.RETURN)) return this.parseReturnStatement();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    if (this.check(TokenType.MATCH)) return this.parseMatchAsStatement();

    return this.parseExpressionOrAssignment();
  }

  parseFunctionDeclaration() {
    const l = this.loc();
    this.expect(TokenType.FN);
    const name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l);
  }

  parseParameterList() {
    const params = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      const l = this.loc();
      const name = this.expect(TokenType.IDENTIFIER, "Expected parameter name").value;

      let typeAnnotation = null;
      if (this.match(TokenType.COLON)) {
        typeAnnotation = this.parseTypeAnnotation();
      }

      let defaultValue = null;
      if (this.match(TokenType.ASSIGN)) {
        defaultValue = this.parseExpression();
      }

      params.push(new AST.Parameter(name, typeAnnotation, defaultValue, l));

      if (!this.match(TokenType.COMMA)) break;
    }
    return params;
  }

  parseTypeAnnotation() {
    const l = this.loc();

    // [Type] — array type shorthand
    if (this.match(TokenType.LBRACKET)) {
      const elementType = this.parseTypeAnnotation();
      this.expect(TokenType.RBRACKET, "Expected ']' in array type");
      return new AST.ArrayTypeAnnotation(elementType, l);
    }

    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    // Generics: Type<A, B>
    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.parseTypeAnnotation());
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    return new AST.TypeAnnotation(name, typeParams, l);
  }

  parseTypeDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TYPE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    // Optional type parameters: Type<T, E>
    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open type body");

    const variants = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const vl = this.loc();
      const vname = this.expect(TokenType.IDENTIFIER, "Expected variant or field name").value;

      if (this.match(TokenType.LPAREN)) {
        // Variant with fields: Circle(radius: Float)
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          const fl = this.loc();
          const fname = this.expect(TokenType.IDENTIFIER, "Expected field name").value;
          let ftype = null;
          if (this.match(TokenType.COLON)) {
            ftype = this.parseTypeAnnotation();
          }
          fields.push(new AST.TypeField(fname, ftype, fl));
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN, "Expected ')' after variant fields");
        variants.push(new AST.TypeVariant(vname, fields, vl));
      } else if (this.match(TokenType.COLON)) {
        // Simple field: name: String
        const ftype = this.parseTypeAnnotation();
        variants.push(new AST.TypeField(vname, ftype, vl));
      } else {
        // Bare variant: None
        variants.push(new AST.TypeVariant(vname, [], vl));
      }

      this.match(TokenType.COMMA);
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close type body");
    return new AST.TypeDeclaration(name, typeParams, variants, l);
  }

  parseVarDeclaration() {
    const l = this.loc();
    this.expect(TokenType.VAR);

    const targets = [];
    do {
      targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
    } while (this.match(TokenType.COMMA));

    this.expect(TokenType.ASSIGN, "Expected '=' in var declaration");

    const values = [this.parseExpression()];
    while (this.match(TokenType.COMMA)) {
      values.push(this.parseExpression());
    }

    return new AST.VarDeclaration(targets, values, l);
  }

  parseLetDestructure() {
    const l = this.loc();
    this.expect(TokenType.LET);

    let pattern;
    if (this.check(TokenType.LBRACE)) {
      pattern = this.parseObjectPattern();
    } else if (this.check(TokenType.LBRACKET)) {
      pattern = this.parseArrayPattern();
    } else {
      this.error("Expected '{' or '[' after 'let' for destructuring");
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in destructuring");
    const value = this.parseExpression();

    return new AST.LetDestructure(pattern, value, l);
  }

  parseObjectPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);
    const properties = [];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
      let valueName = key;
      let defaultValue = null;

      if (this.match(TokenType.COLON)) {
        valueName = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
      }
      if (this.match(TokenType.ASSIGN)) {
        defaultValue = this.parseExpression();
      }

      properties.push({ key, value: valueName, defaultValue });
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACE, "Expected '}' in object pattern");
    return new AST.ObjectPattern(properties, l);
  }

  parseArrayPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);
    const elements = [];

    while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
      if (this.check(TokenType.IDENTIFIER) && this.current().value === '_') {
        elements.push(null); // skip placeholder
        this.advance();
      } else {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACKET, "Expected ']' in array pattern");
    return new AST.ArrayPattern(elements, l);
  }

  parseIfStatement() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance();
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.IfStatement(condition, consequent, alternates, elseBody, l);
  }

  parseForStatement() {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // For variable(s)
    let variable;
    const firstName = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
    if (this.match(TokenType.COMMA)) {
      const secondName = this.expect(TokenType.IDENTIFIER, "Expected second loop variable").value;
      variable = [firstName, secondName];
    } else {
      variable = firstName;
    }

    this.expect(TokenType.IN, "Expected 'in' after for variable");
    const iterable = this.parseExpression();
    const body = this.parseBlock();

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.ForStatement(variable, iterable, body, elseBody, l);
  }

  parseWhileStatement() {
    const l = this.loc();
    this.expect(TokenType.WHILE);
    const condition = this.parseExpression();
    const body = this.parseBlock();
    return new AST.WhileStatement(condition, body, l);
  }

  parseReturnStatement() {
    const l = this.loc();
    this.expect(TokenType.RETURN);

    let value = null;
    if (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      value = this.parseExpression();
    }

    return new AST.ReturnStatement(value, l);
  }

  parseImport() {
    const l = this.loc();
    this.expect(TokenType.IMPORT);

    // import { a, b } from "module"
    if (this.match(TokenType.LBRACE)) {
      const specifiers = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const imported = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
        let local = imported;
        if (this.match(TokenType.AS)) {
          local = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
        }
        specifiers.push(new AST.ImportSpecifier(imported, local, this.loc()));
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in import");
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportDeclaration(specifiers, source, l);
    }

    // import Name from "module"
    const name = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
    this.expect(TokenType.FROM, "Expected 'from' in import");
    const source = this.expect(TokenType.STRING, "Expected module path").value;
    return new AST.ImportDefault(name, source, l);
  }

  parseBlock() {
    const l = this.loc();
    this.expect(TokenType.LBRACE, "Expected '{'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      body.push(this.parseStatement());
    }
    this.expect(TokenType.RBRACE, "Expected '}'");
    return new AST.BlockStatement(body, l);
  }

  // ─── Expression or Assignment ─────────────────────────────

  parseExpressionOrAssignment() {
    const l = this.loc();
    const expr = this.parseExpression();

    // Multiple assignment: a, b = 1, 2
    if (this.check(TokenType.COMMA) && expr.type === 'Identifier') {
      const targets = [expr.name];
      while (this.match(TokenType.COMMA)) {
        targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
      }
      this.expect(TokenType.ASSIGN, "Expected '=' in multiple assignment");
      const values = [this.parseExpression()];
      while (this.match(TokenType.COMMA)) {
        values.push(this.parseExpression());
      }
      return new AST.Assignment(targets, values, l);
    }

    // Simple assignment: x = expr (creates immutable binding)
    if (this.match(TokenType.ASSIGN)) {
      if (expr.type === 'Identifier') {
        const value = this.parseExpression();
        return new AST.Assignment([expr.name], [value], l);
      }
      this.error("Invalid assignment target");
    }

    // Compound assignment: x += expr
    const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
    if (compoundOp) {
      if (expr.type !== 'Identifier' && expr.type !== 'MemberExpression') {
        this.error("Invalid compound assignment target");
      }
      const value = this.parseExpression();
      return new AST.CompoundAssignment(expr, compoundOp.value, value, l);
    }

    return new AST.ExpressionStatement(expr, l);
  }

  parseMatchAsStatement() {
    const expr = this.parseMatchExpression();
    return new AST.ExpressionStatement(expr, this.loc());
  }

  parseIfExpression() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance();
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    if (!this.check(TokenType.ELSE)) {
      this.error("if expression requires an else branch");
    }
    this.advance();
    const elseBody = this.parseBlock();

    return new AST.IfExpression(condition, consequent, alternates, elseBody, l);
  }

  // ─── Expressions (precedence climbing) ────────────────────

  parseExpression() {
    return this.parsePipe();
  }

  parsePipe() {
    let left = this.parseNullCoalesce();
    while (this.match(TokenType.PIPE)) {
      const l = this.loc();
      const right = this.parseNullCoalesce();
      left = new AST.PipeExpression(left, right, l);
    }
    return left;
  }

  parseNullCoalesce() {
    let left = this.parseOr();
    while (this.match(TokenType.QUESTION_QUESTION)) {
      const l = this.loc();
      const right = this.parseOr();
      left = new AST.BinaryExpression('??', left, right, l);
    }
    return left;
  }

  parseOr() {
    let left = this.parseAnd();
    while (this.match(TokenType.OR_OR) || this.match(TokenType.OR)) {
      const l = this.loc();
      const right = this.parseAnd();
      left = new AST.LogicalExpression('or', left, right, l);
    }
    return left;
  }

  parseAnd() {
    let left = this.parseNot();
    while (this.match(TokenType.AND_AND) || this.match(TokenType.AND)) {
      const l = this.loc();
      const right = this.parseNot();
      left = new AST.LogicalExpression('and', left, right, l);
    }
    return left;
  }

  parseNot() {
    if (this.match(TokenType.NOT) || this.match(TokenType.BANG)) {
      const l = this.loc();
      const operand = this.parseNot();
      return new AST.UnaryExpression('not', operand, true, l);
    }
    return this.parseComparison();
  }

  parseComparison() {
    let left = this.parseMembership();

    // Check for chained comparisons: a < b < c
    const compOps = [TokenType.LESS, TokenType.LESS_EQUAL, TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.EQUAL, TokenType.NOT_EQUAL];

    if (compOps.some(op => this.check(op))) {
      const operands = [left];
      const operators = [];

      while (true) {
        const op = this.match(...compOps);
        if (!op) break;
        operators.push(op.value);
        operands.push(this.parseMembership());
      }

      if (operators.length === 1) {
        return new AST.BinaryExpression(operators[0], operands[0], operands[1], this.loc());
      }
      return new AST.ChainedComparison(operands, operators, this.loc());
    }

    return left;
  }

  parseMembership() {
    let left = this.parseRange();

    // "in" / "not in"
    if (this.check(TokenType.NOT) && this.peek(1).type === TokenType.IN) {
      const l = this.loc();
      this.advance(); // not
      this.advance(); // in
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, true, l);
    }

    if (this.check(TokenType.IN)) {
      const l = this.loc();
      this.advance();
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, false, l);
    }

    return left;
  }

  parseRange() {
    let left = this.parseAddition();

    if (this.match(TokenType.DOT_DOT_EQUAL)) {
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, true, this.loc());
    }
    if (this.match(TokenType.DOT_DOT)) {
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, false, this.loc());
    }

    return left;
  }

  parseAddition() {
    let left = this.parseMultiplication();
    while (true) {
      const op = this.match(TokenType.PLUS, TokenType.MINUS);
      if (!op) break;
      const right = this.parseMultiplication();
      left = new AST.BinaryExpression(op.value, left, right, this.loc());
    }
    return left;
  }

  parseMultiplication() {
    let left = this.parsePower();
    while (true) {
      const op = this.match(TokenType.STAR, TokenType.SLASH, TokenType.PERCENT);
      if (!op) break;
      const right = this.parsePower();
      left = new AST.BinaryExpression(op.value, left, right, this.loc());
    }
    return left;
  }

  parsePower() {
    let base = this.parseUnary();
    if (this.match(TokenType.POWER)) {
      const exp = this.parsePower(); // Right-associative
      return new AST.BinaryExpression('**', base, exp, this.loc());
    }
    return base;
  }

  parseUnary() {
    if (this.check(TokenType.MINUS)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.UnaryExpression('-', operand, true, l);
    }
    if (this.check(TokenType.SPREAD)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.SpreadExpression(operand, l);
    }
    return this.parsePostfix();
  }

  parsePostfix() {
    let expr = this.parsePrimary();

    while (true) {
      if (this.match(TokenType.DOT)) {
        const prop = this.expect(TokenType.IDENTIFIER, "Expected property name after '.'").value;
        expr = new AST.MemberExpression(expr, prop, false, this.loc());
        continue;
      }

      if (this.match(TokenType.QUESTION_DOT)) {
        const prop = this.expect(TokenType.IDENTIFIER, "Expected property name after '?.'").value;
        expr = new AST.OptionalChain(expr, prop, false, this.loc());
        continue;
      }

      if (this.check(TokenType.LBRACKET)) {
        expr = this.parseSubscript(expr);
        continue;
      }

      if (this.check(TokenType.LPAREN)) {
        expr = this.parseCallExpression(expr);
        continue;
      }

      break;
    }

    return expr;
  }

  parseSubscript(object) {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    // Handle [::step] — DOUBLE_COLON is lexed as one token
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, null, step, l);
    }

    // Check for slice: obj[start:end:step]
    if (this.check(TokenType.COLON)) {
      // [:end] or [:end:step]
      this.advance();
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, end, step, l);
    }

    const start = this.parseExpression();

    // Handle [start::step] — DOUBLE_COLON after start expression
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, null, step, l);
    }

    if (this.match(TokenType.COLON)) {
      // [start:end] or [start:end:step]
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, end, step, l);
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.MemberExpression(object, start, true, l);
  }

  parseCallExpression(callee) {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const args = [];

    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      // Check for named argument: name: value
      if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
        const name = this.advance().value;
        this.advance(); // :
        const value = this.parseExpression();
        args.push(new AST.NamedArgument(name, value, this.loc()));
      } else {
        args.push(this.parseExpression());
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RPAREN, "Expected ')' after arguments");
    return new AST.CallExpression(callee, args, l);
  }

  // ─── Primary expressions ──────────────────────────────────

  parsePrimary() {
    const l = this.loc();

    // Number
    if (this.check(TokenType.NUMBER)) {
      return new AST.NumberLiteral(this.advance().value, l);
    }

    // String
    if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
      return this.parseStringLiteral();
    }

    // Boolean
    if (this.check(TokenType.TRUE)) {
      this.advance();
      return new AST.BooleanLiteral(true, l);
    }
    if (this.check(TokenType.FALSE)) {
      this.advance();
      return new AST.BooleanLiteral(false, l);
    }

    // Nil
    if (this.check(TokenType.NIL)) {
      this.advance();
      return new AST.NilLiteral(l);
    }

    // Match expression
    if (this.check(TokenType.MATCH)) {
      return this.parseMatchExpression();
    }

    // If expression (in expression position): if cond { a } else { b }
    if (this.check(TokenType.IF)) {
      return this.parseIfExpression();
    }

    // Lambda: fn(params) body  or  params => body
    if (this.check(TokenType.FN) && this.peek(1).type === TokenType.LPAREN) {
      return this.parseLambda();
    }

    // Arrow lambda: x => expr  or  (x, y) => expr
    // We'll handle this in the identifier/paren case

    // Array literal or list comprehension
    if (this.check(TokenType.LBRACKET)) {
      return this.parseArrayOrComprehension();
    }

    // Object literal or dict comprehension
    if (this.check(TokenType.LBRACE)) {
      return this.parseObjectOrDictComprehension();
    }

    // Parenthesized expression or arrow lambda
    if (this.check(TokenType.LPAREN)) {
      return this.parseParenOrArrowLambda();
    }

    // server/client/shared as identifiers in expression position (for RPC: server.get_users())
    if (this.check(TokenType.SERVER) || this.check(TokenType.CLIENT) || this.check(TokenType.SHARED)) {
      const name = this.advance().value;
      return new AST.Identifier(name, l);
    }

    // Identifier (or arrow lambda: x => expr)
    if (this.check(TokenType.IDENTIFIER)) {
      const name = this.advance().value;
      // Check for arrow lambda: x => expr
      if (this.check(TokenType.ARROW)) {
        this.advance();
        const body = this.parseExpression();
        return new AST.LambdaExpression(
          [new AST.Parameter(name, null, null, l)],
          body,
          l
        );
      }
      return new AST.Identifier(name, l);
    }

    this.error(`Unexpected token: ${this.current().type}`);
  }

  parseStringLiteral() {
    const l = this.loc();
    const tok = this.advance();

    if (tok.type === TokenType.STRING) {
      return new AST.StringLiteral(tok.value, l);
    }

    // String template with interpolation
    const parts = tok.value.map(part => {
      if (part.type === 'text') {
        return { type: 'text', value: part.value };
      }
      // Re-parse the expression tokens
      const subParser = new Parser(
        [...part.tokens, { type: TokenType.EOF, value: null, line: 0, column: 0 }],
        this.filename
      );
      const expr = subParser.parseExpression();
      return { type: 'expr', value: expr };
    });

    return new AST.TemplateLiteral(parts, l);
  }

  parseLambda() {
    const l = this.loc();
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      // Parse expression, then check for compound/simple assignment
      const expr = this.parseExpression();
      const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
      if (compoundOp) {
        const value = this.parseExpression();
        body = new AST.CompoundAssignment(expr, compoundOp.value, value, l);
      } else if (this.match(TokenType.ASSIGN)) {
        if (expr.type === 'Identifier') {
          const value = this.parseExpression();
          body = new AST.Assignment([expr.name], [value], l);
        } else {
          body = expr;
        }
      } else {
        body = expr;
      }
    }

    return new AST.LambdaExpression(params, body, l);
  }

  parseMatchExpression() {
    const l = this.loc();
    this.expect(TokenType.MATCH);
    const subject = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' to open match body");

    const arms = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      arms.push(this.parseMatchArm());
      this.match(TokenType.COMMA); // Optional comma between arms
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close match body");
    return new AST.MatchExpression(subject, arms, l);
  }

  parseMatchArm() {
    const l = this.loc();
    const pattern = this.parsePattern();

    let guard = null;
    if (this.match(TokenType.IF)) {
      guard = this.parseExpression();
    }

    this.expect(TokenType.ARROW, "Expected '=>' in match arm");

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.MatchArm(pattern, guard, body, l);
  }

  parsePattern() {
    const l = this.loc();

    // Wildcard _
    if (this.checkValue(TokenType.IDENTIFIER, '_')) {
      this.advance();
      return new AST.WildcardPattern(l);
    }

    // Number literal pattern
    if (this.check(TokenType.NUMBER)) {
      const val = this.advance().value;
      // Check for range pattern: 1..10
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // String literal pattern
    if (this.check(TokenType.STRING)) {
      return new AST.LiteralPattern(this.advance().value, l);
    }

    // Boolean literal pattern
    if (this.check(TokenType.TRUE)) {
      this.advance();
      return new AST.LiteralPattern(true, l);
    }
    if (this.check(TokenType.FALSE)) {
      this.advance();
      return new AST.LiteralPattern(false, l);
    }

    // Nil pattern
    if (this.check(TokenType.NIL)) {
      this.advance();
      return new AST.LiteralPattern(null, l);
    }

    // Identifier: could be variant pattern or binding pattern
    if (this.check(TokenType.IDENTIFIER)) {
      const name = this.advance().value;

      // Variant pattern: Circle(r)
      if (this.match(TokenType.LPAREN)) {
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          fields.push(this.expect(TokenType.IDENTIFIER, "Expected field name").value);
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN);
        return new AST.VariantPattern(name, fields, l);
      }

      // Binding pattern (lowercase = binding, uppercase = variant without args)
      if (name[0] === name[0].toUpperCase() && name[0] !== '_') {
        return new AST.VariantPattern(name, [], l);
      }
      return new AST.BindingPattern(name, l);
    }

    this.error("Expected pattern");
  }

  parseArrayOrComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    if (this.check(TokenType.RBRACKET)) {
      this.advance();
      return new AST.ArrayLiteral([], l);
    }

    // Parse first expression
    const first = this.parseExpression();

    // Check if this is a list comprehension: [expr for x in items]
    if (this.check(TokenType.FOR)) {
      this.advance();
      const variable = this.expect(TokenType.IDENTIFIER, "Expected variable in comprehension").value;
      this.expect(TokenType.IN, "Expected 'in' in comprehension");
      const iterable = this.parseExpression();

      let condition = null;
      if (this.match(TokenType.IF)) {
        condition = this.parseExpression();
      }

      this.expect(TokenType.RBRACKET, "Expected ']' to close comprehension");
      return new AST.ListComprehension(first, variable, iterable, condition, l);
    }

    // Regular array literal
    const elements = [first];
    while (this.match(TokenType.COMMA)) {
      if (this.check(TokenType.RBRACKET)) break; // trailing comma
      elements.push(this.parseExpression());
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.ArrayLiteral(elements, l);
  }

  parseObjectOrDictComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);

    if (this.check(TokenType.RBRACE)) {
      this.advance();
      return new AST.ObjectLiteral([], l);
    }

    // Try to parse first key: value pair
    const firstKey = this.parseExpression();

    if (this.match(TokenType.COLON)) {
      const firstValue = this.parseExpression();

      // Dict comprehension: {k: v for k, v in pairs}
      if (this.check(TokenType.FOR)) {
        this.advance();
        const vars = [];
        vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        if (this.match(TokenType.COMMA)) {
          vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        }
        this.expect(TokenType.IN, "Expected 'in' in comprehension");
        const iterable = this.parseExpression();
        let condition = null;
        if (this.match(TokenType.IF)) {
          condition = this.parseExpression();
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close dict comprehension");
        return new AST.DictComprehension(firstKey, firstValue, vars, iterable, condition, l);
      }

      // Regular object literal
      const properties = [{ key: firstKey, value: firstValue, shorthand: false }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        const key = this.parseExpression();
        this.expect(TokenType.COLON, "Expected ':' in object literal");
        const value = this.parseExpression();
        properties.push({ key, value, shorthand: false });
      }

      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    // Shorthand object: { x, y } — but this might conflict with blocks
    // For now, treat as shorthand object if firstKey is an identifier
    if (firstKey.type === 'Identifier') {
      const properties = [{ key: firstKey, value: firstKey, shorthand: true }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        const key = this.parseExpression();
        properties.push({ key, value: key, shorthand: true });
      }
      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    this.error("Invalid object literal");
  }

  parseParenOrArrowLambda() {
    const l = this.loc();

    // Save position to backtrack if needed
    const savedPos = this.pos;

    this.expect(TokenType.LPAREN);

    // Empty parens: () => expr
    if (this.check(TokenType.RPAREN)) {
      this.advance();
      if (this.check(TokenType.ARROW)) {
        this.advance();
        const body = this.parseExpression();
        return new AST.LambdaExpression([], body, l);
      }
      // Empty parens but not arrow — error or unit value
      this.error("Unexpected '()'");
    }

    // Try to parse as arrow lambda params
    // Look ahead: if we see ) => then it's a lambda
    const params = [];
    let isLambda = true;

    try {
      const innerSaved = this.pos;
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        if (!this.check(TokenType.IDENTIFIER)) {
          isLambda = false;
          break;
        }
        const pname = this.advance().value;
        let ptype = null;
        let pdefault = null;
        if (this.match(TokenType.COLON)) {
          // Could be a type annotation or named argument
          if (this.check(TokenType.IDENTIFIER)) {
            ptype = this.parseTypeAnnotation();
          } else {
            isLambda = false;
            break;
          }
        }
        if (this.match(TokenType.ASSIGN)) {
          pdefault = this.parseExpression();
        }
        params.push(new AST.Parameter(pname, ptype, pdefault, l));
        if (!this.match(TokenType.COMMA)) break;
      }

      if (isLambda && this.check(TokenType.RPAREN)) {
        this.advance(); // )
        if (this.check(TokenType.ARROW)) {
          this.advance(); // =>
          const body = this.check(TokenType.LBRACE) ? this.parseBlock() : this.parseExpression();
          return new AST.LambdaExpression(params, body, l);
        }
      }
    } catch (e) {
      // Not a lambda, backtrack
    }

    // Backtrack and parse as parenthesized expression
    this.pos = savedPos;
    this.expect(TokenType.LPAREN);
    const expr = this.parseExpression();
    this.expect(TokenType.RPAREN, "Expected ')'");
    return expr;
  }
}

// ─── src/analyzer/scope.js ─────────────────────────────

// Scope and symbol management for the Lux analyzer
class Symbol {
  constructor(name, kind, type, mutable, loc) {
    this.name = name;
    this.kind = kind;       // 'variable', 'function', 'type', 'parameter', 'state', 'computed', 'component'
    this.type = type;       // type annotation (optional)
    this.mutable = mutable; // true for 'var' declarations
    this.loc = loc;
    this.used = false;
  }
}
class Scope {
  constructor(parent = null, context = 'module') {
    this.parent = parent;
    this.context = context; // 'module', 'server', 'client', 'shared', 'function', 'block'
    this.symbols = new Map();
  }

  define(name, symbol) {
    if (this.symbols.has(name)) {
      throw new Error(
        `${symbol.loc.file}:${symbol.loc.line}:${symbol.loc.column} — '${name}' is already defined in this scope`
      );
    }
    this.symbols.set(name, symbol);
  }

  lookup(name) {
    if (this.symbols.has(name)) {
      return this.symbols.get(name);
    }
    if (this.parent) {
      return this.parent.lookup(name);
    }
    return null;
  }

  lookupLocal(name) {
    return this.symbols.get(name) || null;
  }

  getContext() {
    if (this.context === 'server' || this.context === 'client' || this.context === 'shared') {
      return this.context;
    }
    if (this.parent) {
      return this.parent.getContext();
    }
    return 'module';
  }

  child(context) {
    return new Scope(this, context || this.context);
  }
}

// ─── src/analyzer/analyzer.js ──────────────────────────

class Analyzer {
  constructor(ast, filename = '<stdin>') {
    this.ast = ast;
    this.filename = filename;
    this.errors = [];
    this.warnings = [];
    this.globalScope = new Scope(null, 'module');
    this.currentScope = this.globalScope;

    // Register built-in types
    this.registerBuiltins();
  }

  registerBuiltins() {
    const builtins = [
      'Int', 'Float', 'String', 'Bool', 'Nil', 'Any',
      'print', 'range', 'len', 'type_of', 'enumerate', 'zip',
      'map', 'filter', 'reduce', 'sum', 'sorted', 'reversed',
      'fetch', 'db',
    ];
    for (const name of builtins) {
      this.globalScope.define(name, new Symbol(name, 'builtin', null, false, { line: 0, column: 0, file: '<builtin>' }));
    }
  }

  error(message, loc) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    this.errors.push({
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    });
  }

  warn(message, loc) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    this.warnings.push({
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    });
  }

  analyze() {
    this.visitProgram(this.ast);

    if (this.errors.length > 0) {
      const msgs = this.errors.map(e => `  ${e.file}:${e.line}:${e.column} — ${e.message}`);
      throw new Error(`Analysis errors:\n${msgs.join('\n')}`);
    }

    return { warnings: this.warnings, scope: this.globalScope };
  }

  // ─── Visitors ─────────────────────────────────────────────

  visitProgram(node) {
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
  }

  visitNode(node) {
    if (!node) return;

    switch (node.type) {
      case 'ServerBlock': return this.visitServerBlock(node);
      case 'ClientBlock': return this.visitClientBlock(node);
      case 'SharedBlock': return this.visitSharedBlock(node);
      case 'Assignment': return this.visitAssignment(node);
      case 'VarDeclaration': return this.visitVarDeclaration(node);
      case 'LetDestructure': return this.visitLetDestructure(node);
      case 'FunctionDeclaration': return this.visitFunctionDeclaration(node);
      case 'TypeDeclaration': return this.visitTypeDeclaration(node);
      case 'ImportDeclaration': return this.visitImportDeclaration(node);
      case 'ImportDefault': return this.visitImportDefault(node);
      case 'IfStatement': return this.visitIfStatement(node);
      case 'ForStatement': return this.visitForStatement(node);
      case 'WhileStatement': return this.visitWhileStatement(node);
      case 'ReturnStatement': return this.visitReturnStatement(node);
      case 'ExpressionStatement': return this.visitExpression(node.expression);
      case 'BlockStatement': return this.visitBlock(node);
      case 'CompoundAssignment': return this.visitCompoundAssignment(node);
      case 'StateDeclaration': return this.visitStateDeclaration(node);
      case 'ComputedDeclaration': return this.visitComputedDeclaration(node);
      case 'EffectDeclaration': return this.visitEffectDeclaration(node);
      case 'ComponentDeclaration': return this.visitComponentDeclaration(node);
      case 'RouteDeclaration': return this.visitRouteDeclaration(node);
      default:
        // Expression nodes
        this.visitExpression(node);
    }
  }

  visitExpression(node) {
    if (!node) return;

    switch (node.type) {
      case 'Identifier':
        return this.visitIdentifier(node);
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return;
      case 'TemplateLiteral':
        for (const part of node.parts) {
          if (part.type === 'expr') this.visitExpression(part.value);
        }
        return;
      case 'BinaryExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'UnaryExpression':
        this.visitExpression(node.operand);
        return;
      case 'LogicalExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'ChainedComparison':
        for (const op of node.operands) this.visitExpression(op);
        return;
      case 'MembershipExpression':
        this.visitExpression(node.value);
        this.visitExpression(node.collection);
        return;
      case 'CallExpression':
        this.visitExpression(node.callee);
        for (const arg of node.arguments) {
          if (arg.type === 'NamedArgument') {
            this.visitExpression(arg.value);
          } else {
            this.visitExpression(arg);
          }
        }
        return;
      case 'MemberExpression':
      case 'OptionalChain':
        this.visitExpression(node.object);
        if (node.computed) this.visitExpression(node.property);
        return;
      case 'PipeExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'LambdaExpression':
        return this.visitLambda(node);
      case 'MatchExpression':
        return this.visitMatchExpression(node);
      case 'ArrayLiteral':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'ObjectLiteral':
        for (const prop of node.properties) {
          this.visitExpression(prop.key);
          this.visitExpression(prop.value);
        }
        return;
      case 'ListComprehension':
        return this.visitListComprehension(node);
      case 'DictComprehension':
        return this.visitDictComprehension(node);
      case 'RangeExpression':
        this.visitExpression(node.start);
        this.visitExpression(node.end);
        return;
      case 'SliceExpression':
        this.visitExpression(node.object);
        if (node.start) this.visitExpression(node.start);
        if (node.end) this.visitExpression(node.end);
        if (node.step) this.visitExpression(node.step);
        return;
      case 'SpreadExpression':
        this.visitExpression(node.argument);
        return;
      case 'IfExpression':
        this.visitExpression(node.condition);
        this.visitNode(node.consequent);
        for (const alt of node.alternates) {
          this.visitExpression(alt.condition);
          this.visitNode(alt.body);
        }
        this.visitNode(node.elseBody);
        return;
      case 'JSXElement':
        return this.visitJSXElement(node);
    }
  }

  // ─── Block visitors ───────────────────────────────────────

  visitServerBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('server');
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
    this.currentScope = prevScope;
  }

  visitClientBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('client');
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
    this.currentScope = prevScope;
  }

  visitSharedBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('shared');
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
    this.currentScope = prevScope;
  }

  // ─── Declaration visitors ─────────────────────────────────

  visitAssignment(node) {
    // Check if any target is already defined (immutable reassignment check)
    for (const target of node.targets) {
      const existing = this.currentScope.lookupLocal(target);
      if (existing) {
        if (!existing.mutable) {
          this.error(`Cannot reassign immutable variable '${target}'. Use 'var' for mutable variables.`, node.loc);
        }
      } else {
        // New binding — define in current scope
        try {
          this.currentScope.define(target,
            new Symbol(target, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    }

    for (const val of node.values) {
      this.visitExpression(val);
    }
  }

  visitVarDeclaration(node) {
    for (const target of node.targets) {
      try {
        this.currentScope.define(target,
          new Symbol(target, 'variable', null, true, node.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    for (const val of node.values) {
      this.visitExpression(val);
    }
  }

  visitLetDestructure(node) {
    this.visitExpression(node.value);

    if (node.pattern.type === 'ObjectPattern') {
      for (const prop of node.pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (node.pattern.type === 'ArrayPattern') {
      for (const el of node.pattern.elements) {
        if (el) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'variable', null, false, node.loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitFunctionDeclaration(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', node.returnType, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');

    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
      if (param.defaultValue) {
        this.visitExpression(param.defaultValue);
      }
    }

    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitTypeDeclaration(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'type', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    // Define variant constructors as functions
    for (const variant of node.variants) {
      if (variant.type === 'TypeVariant') {
        try {
          this.currentScope.define(variant.name,
            new Symbol(variant.name, 'function', null, false, variant.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    }
  }

  visitImportDeclaration(node) {
    for (const spec of node.specifiers) {
      try {
        this.currentScope.define(spec.local,
          new Symbol(spec.local, 'variable', null, false, spec.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  visitImportDefault(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  // ─── Statement visitors ───────────────────────────────────

  visitBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
    this.currentScope = prevScope;
  }

  visitIfStatement(node) {
    this.visitExpression(node.condition);
    this.visitNode(node.consequent);
    for (const alt of node.alternates) {
      this.visitExpression(alt.condition);
      this.visitNode(alt.body);
    }
    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
  }

  visitForStatement(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    this.visitExpression(node.iterable);

    // Define loop variable(s)
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    for (const v of vars) {
      try {
        this.currentScope.define(v,
          new Symbol(v, 'variable', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
    }

    this.visitNode(node.body);
    this.currentScope = prevScope;

    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
  }

  visitWhileStatement(node) {
    this.visitExpression(node.condition);
    this.visitNode(node.body);
  }

  visitReturnStatement(node) {
    if (node.value) {
      this.visitExpression(node.value);
    }
  }

  visitCompoundAssignment(node) {
    // Target must be mutable
    if (node.target.type === 'Identifier') {
      const sym = this.currentScope.lookup(node.target.name);
      if (sym && !sym.mutable && sym.kind !== 'builtin') {
        this.error(`Cannot use '${node.operator}' on immutable variable '${node.target.name}'`, node.loc);
      }
    }
    this.visitExpression(node.target);
    this.visitExpression(node.value);
  }

  // ─── Client-specific visitors ─────────────────────────────

  visitStateDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'state' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'state', node.typeAnnotation, true, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.initialValue);
  }

  visitComputedDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'computed' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'computed', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.expression);
  }

  visitEffectDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'effect' can only be used inside a client block`, node.loc);
    }
    this.visitNode(node.body);
  }

  visitComponentDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'component' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'component', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    for (const child of node.body) {
      this.visitNode(child);
    }
    this.currentScope = prevScope;
  }

  visitRouteDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'route' can only be used inside a server block`, node.loc);
    }
    this.visitExpression(node.handler);
  }

  // ─── Expression visitors ──────────────────────────────────

  visitIdentifier(node) {
    if (node.name === '_') return; // wildcard is always valid

    const sym = this.currentScope.lookup(node.name);
    if (!sym) {
      // Allow server.xxx in client context (RPC calls)
      // Don't error on unknown identifiers — could be globals
      // We'll just warn for now, strict mode can enforce later
    } else {
      sym.used = true;
    }
  }

  visitLambda(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    if (node.body.type === 'BlockStatement') {
      this.visitNode(node.body);
    } else {
      this.visitExpression(node.body);
    }
    this.currentScope = prevScope;
  }

  visitMatchExpression(node) {
    this.visitExpression(node.subject);
    for (const arm of node.arms) {
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('block');

      this.visitPattern(arm.pattern);
      if (arm.guard) this.visitExpression(arm.guard);

      if (arm.body.type === 'BlockStatement') {
        this.visitNode(arm.body);
      } else {
        this.visitExpression(arm.body);
      }
      this.currentScope = prevScope;
    }
  }

  visitPattern(pattern) {
    if (!pattern) return;

    switch (pattern.type) {
      case 'WildcardPattern':
      case 'LiteralPattern':
      case 'RangePattern':
        break;
      case 'BindingPattern':
        try {
          this.currentScope.define(pattern.name,
            new Symbol(pattern.name, 'variable', null, false, pattern.loc));
        } catch (e) {
          this.error(e.message);
        }
        break;
      case 'VariantPattern':
        for (const field of pattern.fields) {
          try {
            this.currentScope.define(field,
              new Symbol(field, 'variable', null, false, pattern.loc));
          } catch (e) {
            this.error(e.message);
          }
        }
        break;
    }
  }

  visitListComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    this.visitExpression(node.iterable);
    try {
      this.currentScope.define(node.variable,
        new Symbol(node.variable, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    if (node.condition) this.visitExpression(node.condition);
    this.visitExpression(node.expression);

    this.currentScope = prevScope;
  }

  visitDictComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    this.visitExpression(node.iterable);
    for (const v of node.variables) {
      try {
        this.currentScope.define(v,
          new Symbol(v, 'variable', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    if (node.condition) this.visitExpression(node.condition);
    this.visitExpression(node.key);
    this.visitExpression(node.value);

    this.currentScope = prevScope;
  }

  visitJSXElement(node) {
    for (const attr of node.attributes) {
      this.visitExpression(attr.value);
    }
    for (const child of node.children) {
      if (child.type === 'JSXElement') {
        this.visitJSXElement(child);
      } else if (child.type === 'JSXExpression') {
        this.visitExpression(child.expression);
      } else if (child.type === 'JSXFor') {
        this.visitJSXFor(child);
      } else if (child.type === 'JSXIf') {
        this.visitJSXIf(child);
      }
    }
  }

  visitJSXFor(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.visitExpression(node.iterable);
    try {
      this.currentScope.define(node.variable,
        new Symbol(node.variable, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    for (const child of node.body) {
      this.visitNode(child);
    }
    this.currentScope = prevScope;
  }

  visitJSXIf(node) {
    this.visitExpression(node.condition);
    for (const child of node.consequent) {
      this.visitNode(child);
    }
    if (node.alternate) {
      for (const child of node.alternate) {
        this.visitNode(child);
      }
    }
  }
}

// ─── src/codegen/base-codegen.js ───────────────────────

// Base code generation utilities shared across all codegen targets
class BaseCodegen {
  constructor() {
    this.indent = 0;
    this._counter = 0;
    this._scopes = [new Set()]; // scope stack for tracking declared variables
    this._needsContainsHelper = false; // track if __contains helper is needed
  }

  _uid() {
    return this._counter++;
  }

  // ─── Scope tracking ─────────────────────────────────────────

  pushScope() {
    this._scopes.push(new Set());
  }

  popScope() {
    this._scopes.pop();
  }

  declareVar(name) {
    this._scopes[this._scopes.length - 1].add(name);
  }

  isDeclared(name) {
    for (let i = this._scopes.length - 1; i >= 0; i--) {
      if (this._scopes[i].has(name)) return true;
    }
    return false;
  }

  // ─── Helpers ────────────────────────────────────────────────

  i() {
    return '  '.repeat(this.indent);
  }

  getContainsHelper() {
    return 'function __contains(col, val) {\n' +
      '  if (Array.isArray(col) || typeof col === \'string\') return col.includes(val);\n' +
      '  if (col instanceof Set || col instanceof Map) return col.has(val);\n' +
      '  if (typeof col === \'object\' && col !== null) return val in col;\n' +
      '  return false;\n' +
      '}';
  }

  getStringProtoHelper() {
    return '// Lux string methods\n' +
      '(function() {\n' +
      '  const m = {\n' +
      '    upper() { return this.toUpperCase(); },\n' +
      '    lower() { return this.toLowerCase(); },\n' +
      '    contains(s) { return this.includes(s); },\n' +
      '    starts_with(s) { return this.startsWith(s); },\n' +
      '    ends_with(s) { return this.endsWith(s); },\n' +
      '    chars() { return [...this]; },\n' +
      '    words() { return this.split(/\\s+/).filter(Boolean); },\n' +
      '    lines() { return this.split(\'\\n\'); },\n' +
      '    capitalize() { return this.length ? this.charAt(0).toUpperCase() + this.slice(1) : this; },\n' +
      '    title_case() { return this.replace(/\\b\\w/g, c => c.toUpperCase()); },\n' +
      '    snake_case() { return this.replace(/[-\\s]+/g, \'_\').replace(/([a-z0-9])([A-Z])/g, \'$1_$2\').toLowerCase().replace(/^_/, \'\'); },\n' +
      '    camel_case() { return this.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : \'\').replace(/^[A-Z]/, c => c.toLowerCase()); },\n' +
      '  };\n' +
      '  for (const [n, fn] of Object.entries(m)) {\n' +
      '    if (!String.prototype[n]) Object.defineProperty(String.prototype, n, { value: fn, writable: true, configurable: true });\n' +
      '  }\n' +
      '})();';
  }

  generateStatement(node) {
    if (!node) return '';

    switch (node.type) {
      case 'Assignment': return this.genAssignment(node);
      case 'VarDeclaration': return this.genVarDeclaration(node);
      case 'LetDestructure': return this.genLetDestructure(node);
      case 'FunctionDeclaration': return this.genFunctionDeclaration(node);
      case 'TypeDeclaration': return this.genTypeDeclaration(node);
      case 'ImportDeclaration': return this.genImport(node);
      case 'ImportDefault': return this.genImportDefault(node);
      case 'IfStatement': return this.genIfStatement(node);
      case 'ForStatement': return this.genForStatement(node);
      case 'WhileStatement': return this.genWhileStatement(node);
      case 'ReturnStatement': return this.genReturnStatement(node);
      case 'ExpressionStatement': return `${this.i()}${this.genExpression(node.expression)};`;
      case 'BlockStatement': return this.genBlock(node);
      case 'CompoundAssignment': return this.genCompoundAssignment(node);
      default:
        return `${this.i()}${this.genExpression(node)};`;
    }
  }

  genExpression(node) {
    if (!node) return 'undefined';

    switch (node.type) {
      case 'Identifier': return node.name === '_' ? '_' : node.name;
      case 'NumberLiteral': return String(node.value);
      case 'StringLiteral': return JSON.stringify(node.value);
      case 'BooleanLiteral': return String(node.value);
      case 'NilLiteral': return 'null';
      case 'TemplateLiteral': return this.genTemplateLiteral(node);
      case 'BinaryExpression': return this.genBinaryExpression(node);
      case 'UnaryExpression': return this.genUnaryExpression(node);
      case 'LogicalExpression': return this.genLogicalExpression(node);
      case 'ChainedComparison': return this.genChainedComparison(node);
      case 'MembershipExpression': return this.genMembershipExpression(node);
      case 'CallExpression': return this.genCallExpression(node);
      case 'MemberExpression': return this.genMemberExpression(node);
      case 'OptionalChain': return this.genOptionalChain(node);
      case 'PipeExpression': return this.genPipeExpression(node);
      case 'LambdaExpression': return this.genLambdaExpression(node);
      case 'MatchExpression': return this.genMatchExpression(node);
      case 'IfExpression': return this.genIfExpression(node);
      case 'ArrayLiteral': return this.genArrayLiteral(node);
      case 'ObjectLiteral': return this.genObjectLiteral(node);
      case 'ListComprehension': return this.genListComprehension(node);
      case 'DictComprehension': return this.genDictComprehension(node);
      case 'RangeExpression': return this.genRangeExpression(node);
      case 'SliceExpression': return this.genSliceExpression(node);
      case 'SpreadExpression': return `...${this.genExpression(node.argument)}`;
      case 'NamedArgument': return this.genExpression(node.value);
      default:
        return `/* unknown: ${node.type} */`;
    }
  }

  // ─── Statements ───────────────────────────────────────────

  genAssignment(node) {
    if (node.targets.length === 1 && node.values.length === 1) {
      const target = node.targets[0];
      if (target === '_') {
        return `${this.i()}${this.genExpression(node.values[0])};`;
      }
      if (this.isDeclared(target)) {
        // Reassignment to an already-declared variable (must be mutable)
        return `${this.i()}${target} = ${this.genExpression(node.values[0])};`;
      }
      this.declareVar(target);
      return `${this.i()}const ${target} = ${this.genExpression(node.values[0])};`;
    }

    // Multiple assignment: a, b = 1, 2 (uses destructuring for atomicity)
    const vals = node.values.map(v => this.genExpression(v));
    const allDeclared = node.targets.every(t => this.isDeclared(t));

    if (allDeclared) {
      // Reassignment (e.g., swap): [a, b] = [v1, v2]
      return `${this.i()}[${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    // New declarations: const [a, b] = [v1, v2]
    for (const t of node.targets) this.declareVar(t);
    return `${this.i()}const [${node.targets.join(', ')}] = [${vals.join(', ')}];`;
  }

  genVarDeclaration(node) {
    if (node.targets.length === 1 && node.values.length === 1) {
      this.declareVar(node.targets[0]);
      return `${this.i()}let ${node.targets[0]} = ${this.genExpression(node.values[0])};`;
    }
    const lines = [];
    for (let idx = 0; idx < node.targets.length; idx++) {
      this.declareVar(node.targets[idx]);
      const val = idx < node.values.length ? node.values[idx] : node.values[node.values.length - 1];
      lines.push(`${this.i()}let ${node.targets[idx]} = ${this.genExpression(val)};`);
    }
    return lines.join('\n');
  }

  genLetDestructure(node) {
    if (node.pattern.type === 'ObjectPattern') {
      for (const p of node.pattern.properties) this.declareVar(p.value);
      const props = node.pattern.properties.map(p => {
        let str = p.key;
        if (p.value !== p.key) str += `: ${p.value}`;
        if (p.defaultValue) str += ` = ${this.genExpression(p.defaultValue)}`;
        return str;
      }).join(', ');
      return `${this.i()}const { ${props} } = ${this.genExpression(node.value)};`;
    }
    if (node.pattern.type === 'ArrayPattern') {
      for (const e of node.pattern.elements) if (e) this.declareVar(e);
      const els = node.pattern.elements.map(e => e || '').join(', ');
      return `${this.i()}const [${els}] = ${this.genExpression(node.value)};`;
    }
    return '';
  }

  genFunctionDeclaration(node) {
    const params = this.genParams(node.params);
    this.pushScope();
    for (const p of node.params) this.declareVar(p.name);
    const body = this.genBlockBody(node.body);
    this.popScope();
    return `${this.i()}function ${node.name}(${params}) {\n${body}\n${this.i()}}`;
  }

  genParams(params) {
    return params.map(p => {
      if (p.defaultValue) {
        return `${p.name} = ${this.genExpression(p.defaultValue)}`;
      }
      return p.name;
    }).join(', ');
  }

  genTypeDeclaration(node) {
    const lines = [];

    // Check if it's a struct-like type (all TypeField) or an enum (TypeVariant)
    const hasVariants = node.variants.some(v => v.type === 'TypeVariant');

    if (hasVariants) {
      // Generate as tagged union factory functions
      for (const variant of node.variants) {
        if (variant.type === 'TypeVariant') {
          this.declareVar(variant.name);
          if (variant.fields.length === 0) {
            lines.push(`${this.i()}const ${variant.name} = Object.freeze({ __tag: "${variant.name}" });`);
          } else {
            const fieldNames = variant.fields.map(f => f.name);
            const params = fieldNames.join(', ');
            const obj = fieldNames.map(f => `${f}`).join(', ');
            lines.push(`${this.i()}function ${variant.name}(${params}) { return Object.freeze({ __tag: "${variant.name}", ${obj} }); }`);
          }
        }
      }
    } else {
      // Struct-like: generate a constructor function
      this.declareVar(node.name);
      const fieldNames = node.variants.map(f => f.name);
      const params = fieldNames.join(', ');
      const obj = fieldNames.map(f => `${f}`).join(', ');
      lines.push(`${this.i()}function ${node.name}(${params}) { return { ${obj} }; }`);
    }

    return lines.join('\n');
  }

  genImport(node) {
    for (const s of node.specifiers) this.declareVar(s.local);
    const specs = node.specifiers.map(s => {
      if (s.imported !== s.local) return `${s.imported} as ${s.local}`;
      return s.imported;
    }).join(', ');
    return `${this.i()}import { ${specs} } from ${JSON.stringify(node.source)};`;
  }

  genImportDefault(node) {
    this.declareVar(node.local);
    return `${this.i()}import ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genIfStatement(node) {
    let code = `${this.i()}if (${this.genExpression(node.condition)}) {\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node.consequent);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;

    for (const alt of node.alternates) {
      code += ` else if (${this.genExpression(alt.condition)}) {\n`;
      this.indent++;
      this.pushScope();
      code += this.genBlockStatements(alt.body);
      this.popScope();
      this.indent--;
      code += `\n${this.i()}}`;
    }

    if (node.elseBody) {
      code += ` else {\n`;
      this.indent++;
      this.pushScope();
      code += this.genBlockStatements(node.elseBody);
      this.popScope();
      this.indent--;
      code += `\n${this.i()}}`;
    }

    return code;
  }

  genForStatement(node) {
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    const iterExpr = this.genExpression(node.iterable);

    if (node.elseBody) {
      // for-else: run else if iterable was empty
      const tempVar = `__iter_${this._uid()}`;
      let code = `${this.i()}{\n`;
      this.indent++;
      code += `${this.i()}const ${tempVar} = ${iterExpr};\n`;
      code += `${this.i()}let __entered = false;\n`;
      this.pushScope();
      for (const v of vars) this.declareVar(v);
      if (vars.length === 2) {
        code += `${this.i()}for (const [${vars[0]}, ${vars[1]}] of ${tempVar}) {\n`;
      } else {
        code += `${this.i()}for (const ${vars[0]} of ${tempVar}) {\n`;
      }
      this.indent++;
      code += `${this.i()}__entered = true;\n`;
      code += this.genBlockStatements(node.body);
      this.indent--;
      code += `\n${this.i()}}\n`;
      this.popScope();
      this.pushScope();
      code += `${this.i()}if (!__entered) {\n`;
      this.indent++;
      code += this.genBlockStatements(node.elseBody);
      this.indent--;
      code += `\n${this.i()}}\n`;
      this.popScope();
      this.indent--;
      code += `${this.i()}}`;
      return code;
    }

    this.pushScope();
    for (const v of vars) this.declareVar(v);
    let code;
    if (vars.length === 2) {
      code = `${this.i()}for (const [${vars[0]}, ${vars[1]}] of ${iterExpr}) {\n`;
    } else {
      code = `${this.i()}for (const ${vars[0]} of ${iterExpr}) {\n`;
    }
    this.indent++;
    code += this.genBlockStatements(node.body);
    this.indent--;
    code += `\n${this.i()}}`;
    this.popScope();

    return code;
  }

  genWhileStatement(node) {
    let code = `${this.i()}while (${this.genExpression(node.condition)}) {\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node.body);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;
    return code;
  }

  genReturnStatement(node) {
    if (node.value) {
      return `${this.i()}return ${this.genExpression(node.value)};`;
    }
    return `${this.i()}return;`;
  }

  genCompoundAssignment(node) {
    return `${this.i()}${this.genExpression(node.target)} ${node.operator} ${this.genExpression(node.value)};`;
  }

  genBlock(node) {
    let code = `{\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;
    return code;
  }

  genBlockBody(block) {
    if (block.type !== 'BlockStatement') {
      this.indent++;
      const code = `${this.i()}return ${this.genExpression(block)};`;
      this.indent--;
      return code;
    }

    this.indent++;
    const stmts = block.body;
    const lines = [];
    for (let idx = 0; idx < stmts.length; idx++) {
      const stmt = stmts[idx];
      // Implicit return: last expression in function body
      if (idx === stmts.length - 1 && stmt.type === 'ExpressionStatement') {
        lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }
    this.indent--;
    return lines.join('\n');
  }

  genBlockStatements(block) {
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    return stmts.map(s => this.generateStatement(s)).join('\n');
  }

  // ─── Expressions ──────────────────────────────────────────

  genTemplateLiteral(node) {
    const parts = node.parts.map(p => {
      if (p.type === 'text') {
        return p.value.replace(/`/g, '\\`').replace(/\$/g, '\\$');
      }
      return `\${${this.genExpression(p.value)}}`;
    }).join('');
    return `\`${parts}\``;
  }

  genBinaryExpression(node) {
    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);
    const op = node.operator;

    // String multiply: "ha" * 3 => "ha".repeat(3)
    if (op === '*' &&
      (node.left.type === 'StringLiteral' || node.left.type === 'TemplateLiteral')) {
      return `${left}.repeat(${right})`;
    }

    return `(${left} ${op} ${right})`;
  }

  genUnaryExpression(node) {
    const operand = this.genExpression(node.operand);
    if (node.operator === 'not') return `(!${operand})`;
    return `(${node.operator}${operand})`;
  }

  genLogicalExpression(node) {
    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);
    const op = node.operator === 'and' ? '&&' : node.operator === 'or' ? '||' : node.operator;
    return `(${left} ${op} ${right})`;
  }

  genChainedComparison(node) {
    // a < b < c => (a < b) && (b < c)
    const parts = [];
    for (let idx = 0; idx < node.operators.length; idx++) {
      const left = this.genExpression(node.operands[idx]);
      const right = this.genExpression(node.operands[idx + 1]);
      parts.push(`(${left} ${node.operators[idx]} ${right})`);
    }
    return `(${parts.join(' && ')})`;
  }

  genMembershipExpression(node) {
    const val = this.genExpression(node.value);
    const col = this.genExpression(node.collection);
    this._needsContainsHelper = true;
    if (node.negated) {
      return `(!__contains(${col}, ${val}))`;
    }
    return `__contains(${col}, ${val})`;
  }

  genCallExpression(node) {
    const callee = this.genExpression(node.callee);
    const hasNamedArgs = node.arguments.some(a => a.type === 'NamedArgument');

    if (hasNamedArgs) {
      const allNamed = node.arguments.every(a => a.type === 'NamedArgument');
      if (allNamed) {
        // All named args → single object argument
        const parts = node.arguments.map(a => `${a.name}: ${this.genExpression(a.value)}`);
        return `${callee}({ ${parts.join(', ')} })`;
      }
      // Mixed: positional first, then named as trailing object
      const positional = [];
      const named = [];
      for (const a of node.arguments) {
        if (a.type === 'NamedArgument') {
          named.push(`${a.name}: ${this.genExpression(a.value)}`);
        } else {
          positional.push(this.genExpression(a));
        }
      }
      return `${callee}(${[...positional, `{ ${named.join(', ')} }`].join(', ')})`;
    }

    const args = node.arguments.map(a => this.genExpression(a)).join(', ');
    return `${callee}(${args})`;
  }

  genMemberExpression(node) {
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}[${this.genExpression(node.property)}]`;
    }
    return `${obj}.${node.property}`;
  }

  genOptionalChain(node) {
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}?.[${this.genExpression(node.property)}]`;
    }
    return `${obj}?.${node.property}`;
  }

  genPipeExpression(node) {
    const left = this.genExpression(node.left);
    const right = node.right;

    // If right is a call expression, insert left as the first argument
    if (right.type === 'CallExpression') {
      const callee = this.genExpression(right.callee);
      const args = [left, ...right.arguments.map(a => this.genExpression(a))].join(', ');
      return `${callee}(${args})`;
    }
    // If right is an identifier, call it with left as argument
    if (right.type === 'Identifier') {
      return `${right.name}(${left})`;
    }
    // Fallback
    return `(${this.genExpression(right)})(${left})`;
  }

  genLambdaExpression(node) {
    const params = this.genParams(node.params);

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) this.declareVar(p.name);
      const body = this.genBlockBody(node.body);
      this.popScope();
      return `(${params}) => {\n${body}\n${this.i()}}`;
    }

    // Statement bodies (compound assignment, assignment in lambda)
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) this.declareVar(p.name);
      this.indent++;
      const stmt = this.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `(${params}) => { ${stmt.trim()} }`;
    }

    return `(${params}) => ${this.genExpression(node.body)}`;
  }

  genMatchExpression(node) {
    // Generate as IIFE with if-else chain
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';

    let code = `((${tempVar}) => {\n`;
    this.indent++;

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case
          if (arm.pattern.type === 'BindingPattern') {
            code += `${this.i()}const ${arm.pattern.name} = ${tempVar};\n`;
          }
          if (arm.body.type === 'BlockStatement') {
            code += this.genBlockStatements(arm.body) + '\n';
          } else {
            code += `${this.i()}return ${this.genExpression(arm.body)};\n`;
          }
          break;
        }
      }

      const keyword = idx === 0 ? 'if' : 'else if';
      code += `${this.i()}${keyword} (${condition}) {\n`;
      this.indent++;

      // Bind variables from pattern
      code += this.genPatternBindings(arm.pattern, tempVar);

      if (arm.body.type === 'BlockStatement') {
        code += this.genBlockStatements(arm.body) + '\n';
      } else {
        code += `${this.i()}return ${this.genExpression(arm.body)};\n`;
      }
      this.indent--;
      code += `${this.i()}}\n`;
    }

    this.indent--;
    code += `${this.i()}})(${subject})`;
    return code;
  }

  genIfExpression(node) {
    // Optimization: if all branches are single expressions, use ternary
    const isSingleExpr = (block) =>
      block.type === 'BlockStatement' && block.body.length === 1 && block.body[0].type === 'ExpressionStatement';

    if (node.alternates.length === 0 && isSingleExpr(node.consequent) && isSingleExpr(node.elseBody)) {
      const cond = this.genExpression(node.condition);
      const thenExpr = this.genExpression(node.consequent.body[0].expression);
      const elseExpr = this.genExpression(node.elseBody.body[0].expression);
      return `((${cond}) ? (${thenExpr}) : (${elseExpr}))`;
    }

    // Full IIFE for multi-statement branches
    let code = `(() => {\n`;
    this.indent++;

    code += `${this.i()}if (${this.genExpression(node.condition)}) {\n`;
    code += this.genBlockBody(node.consequent);
    code += `\n${this.i()}}`;

    for (const alt of node.alternates) {
      code += ` else if (${this.genExpression(alt.condition)}) {\n`;
      code += this.genBlockBody(alt.body);
      code += `\n${this.i()}}`;
    }

    code += ` else {\n`;
    code += this.genBlockBody(node.elseBody);
    code += `\n${this.i()}}`;

    this.indent--;
    code += `\n${this.i()}})()`;
    return code;
  }

  genPatternCondition(pattern, subject, guard) {
    let cond;

    switch (pattern.type) {
      case 'LiteralPattern':
        cond = `${subject} === ${JSON.stringify(pattern.value)}`;
        break;
      case 'RangePattern':
        if (pattern.inclusive) {
          cond = `${subject} >= ${pattern.start} && ${subject} <= ${pattern.end}`;
        } else {
          cond = `${subject} >= ${pattern.start} && ${subject} < ${pattern.end}`;
        }
        break;
      case 'VariantPattern':
        cond = `${subject}?.__tag === "${pattern.name}"`;
        break;
      case 'WildcardPattern':
        cond = 'true';
        break;
      case 'BindingPattern':
        cond = 'true';
        break;
      default:
        cond = 'true';
    }

    if (guard) {
      // For binding patterns, we need to bind first for the guard
      if (pattern.type === 'BindingPattern') {
        cond = `((${pattern.name}) => ${this.genExpression(guard)})(${subject})`;
      } else {
        cond = `(${cond}) && (${this.genExpression(guard)})`;
      }
    }

    return cond;
  }

  genPatternBindings(pattern, subject) {
    switch (pattern.type) {
      case 'BindingPattern':
        return `${this.i()}const ${pattern.name} = ${subject};\n`;
      case 'VariantPattern':
        return pattern.fields.map(f =>
          `${this.i()}const ${f} = ${subject}.${f};\n`
        ).join('');
      default:
        return '';
    }
  }

  genArrayLiteral(node) {
    const elements = node.elements.map(e => this.genExpression(e)).join(', ');
    return `[${elements}]`;
  }

  genObjectLiteral(node) {
    const props = node.properties.map(p => {
      if (p.shorthand) {
        return this.genExpression(p.key);
      }
      return `${this.genExpression(p.key)}: ${this.genExpression(p.value)}`;
    }).join(', ');
    return `{ ${props} }`;
  }

  genListComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const varName = node.variable;
    const expr = this.genExpression(node.expression);

    if (node.condition) {
      const cond = this.genExpression(node.condition);
      return `${iter}.filter((${varName}) => ${cond}).map((${varName}) => ${expr})`;
    }
    return `${iter}.map((${varName}) => ${expr})`;
  }

  genDictComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const vars = node.variables;
    const key = this.genExpression(node.key);
    const value = this.genExpression(node.value);

    const destructure = vars.length === 2 ? `[${vars[0]}, ${vars[1]}]` : vars[0];

    let code = `Object.fromEntries(${iter}`;
    if (node.condition) {
      code += `.filter((${destructure}) => ${this.genExpression(node.condition)})`;
    }
    code += `.map((${destructure}) => [${key}, ${value}]))`;
    return code;
  }

  genRangeExpression(node) {
    const start = this.genExpression(node.start);
    const end = this.genExpression(node.end);
    if (node.inclusive) {
      return `Array.from({length: ${end} - ${start} + 1}, (_, i) => ${start} + i)`;
    }
    return `Array.from({length: ${end} - ${start}}, (_, i) => ${start} + i)`;
  }

  genSliceExpression(node) {
    const obj = this.genExpression(node.object);
    const start = node.start ? this.genExpression(node.start) : '';
    const end = node.end ? this.genExpression(node.end) : '';

    if (node.step) {
      const step = this.genExpression(node.step);
      const s = node.start ? this.genExpression(node.start) : 'null';
      const e = node.end ? this.genExpression(node.end) : 'null';
      // Handles both positive and negative step directions
      return `((a, s, e, st) => { const r = []; if (st > 0) { for (let i = s !== null ? s : 0; i < (e !== null ? e : a.length); i += st) r.push(a[i]); } else { for (let i = s !== null ? s : a.length - 1; i > (e !== null ? e : -1); i += st) r.push(a[i]); } return r; })(${obj}, ${s}, ${e}, ${step})`;
    }

    if (!start && !end) return `${obj}.slice()`;
    if (!start) return `${obj}.slice(0, ${end})`;
    if (!end) return `${obj}.slice(${start})`;
    return `${obj}.slice(${start}, ${end})`;
  }
}

// ─── src/codegen/shared-codegen.js ─────────────────────

class SharedCodegen extends BaseCodegen {
  generate(block) {
    const code = block.body.map(stmt => this.generateStatement(stmt)).join('\n');
    return code;
  }

  // Generate any needed helpers (called after all code is generated)
  generateHelpers() {
    const helpers = [];
    helpers.push(this.getStringProtoHelper());
    if (this._needsContainsHelper) {
      helpers.push(this.getContainsHelper());
    }
    return helpers.join('\n');
  }
}

// ─── src/codegen/server-codegen.js ─────────────────────

class ServerCodegen extends BaseCodegen {
  generate(serverBlocks, sharedCode, blockName = null) {
    const lines = [];

    // Shared code
    if (sharedCode.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedCode);
      lines.push('');
    }

    // Lightweight router
    lines.push('// ── Router ──');
    lines.push('const __routes = [];');
    lines.push('function __addRoute(method, path, handler) {');
    lines.push('  const pattern = path.replace(/:([^/]+)/g, "(?<$1>[^/]+)");');
    lines.push('  __routes.push({ method, regex: new RegExp(`^${pattern}$`), handler });');
    lines.push('}');
    lines.push('');

    // CORS helper
    lines.push('const __corsHeaders = {');
    lines.push('  "Access-Control-Allow-Origin": "*",');
    lines.push('  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",');
    lines.push('  "Access-Control-Allow-Headers": "Content-Type, Authorization",');
    lines.push('};');
    lines.push('');

    // Collect functions and routes from blocks
    const routes = [];
    const functions = [];

    for (const block of serverBlocks) {
      for (const stmt of block.body) {
        if (stmt.type === 'RouteDeclaration') {
          routes.push(stmt);
        } else if (stmt.type === 'FunctionDeclaration') {
          functions.push(stmt);
        } else {
          lines.push(this.generateStatement(stmt));
        }
      }
    }

    // Generate functions
    if (functions.length > 0) {
      lines.push('// ── Server Functions ──');
      for (const fn of functions) {
        lines.push(this.generateStatement(fn));
        lines.push('');
      }
    }

    // Generate RPC endpoints for each server function (auto-wired)
    if (functions.length > 0) {
      lines.push('// ── RPC Endpoints ──');
      for (const fn of functions) {
        const name = fn.name;
        const paramNames = fn.params.map(p => p.name);
        lines.push(`__addRoute("POST", "/rpc/${name}", async (req) => {`);
        lines.push(`  const body = await req.json();`);
        if (paramNames.length > 0) {
          // Support both positional ({__args: [...]}) and named ({key: val}) arg formats
          for (let pi = 0; pi < paramNames.length; pi++) {
            lines.push(`  const ${paramNames[pi]} = body.__args ? body.__args[${pi}] : body.${paramNames[pi]};`);
          }
          lines.push(`  const result = await ${name}(${paramNames.join(', ')});`);
        } else {
          lines.push(`  const result = await ${name}();`);
        }
        lines.push(`  return Response.json({ result });`);
        lines.push(`});`);
        lines.push('');
      }
    }

    // Generate explicit routes
    if (routes.length > 0) {
      lines.push('// ── Routes ──');
      for (const route of routes) {
        const method = route.method.toUpperCase();
        const path = route.path;
        const handler = this.genExpression(route.handler);

        lines.push(`__addRoute(${JSON.stringify(method)}, ${JSON.stringify(path)}, async (req, params) => {`);
        lines.push(`  const result = await ${handler}(req, params);`);
        lines.push(`  return Response.json(result);`);
        lines.push(`});`);
        lines.push('');
      }
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push('// ── Runtime Helpers ──');
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // Bun.serve() request handler
    lines.push('// ── Request Handler ──');
    lines.push('async function __handleRequest(req) {');
    lines.push('  const url = new URL(req.url);');
    lines.push('  if (req.method === "OPTIONS") {');
    lines.push('    return new Response(null, { status: 204, headers: __corsHeaders });');
    lines.push('  }');
    lines.push('  for (const route of __routes) {');
    lines.push('    if (req.method === route.method) {');
    lines.push('      const match = url.pathname.match(route.regex);');
    lines.push('      if (match) {');
    lines.push('        try {');
    lines.push('          const res = await route.handler(req, match.groups || {});');
    lines.push('          // Attach CORS headers to response');
    lines.push('          const headers = new Headers(res.headers);');
    lines.push('          for (const [k, v] of Object.entries(__corsHeaders)) headers.set(k, v);');
    lines.push('          return new Response(res.body, { status: res.status, headers });');
    lines.push('        } catch (err) {');
    lines.push('          return Response.json({ error: err.message }, { status: 500, headers: __corsHeaders });');
    lines.push('        }');
    lines.push('      }');
    lines.push('    }');
    lines.push('  }');
    // Serve client HTML at root if available
    lines.push('  // Serve client HTML at root');
    lines.push('  if (url.pathname === "/" && typeof __clientHTML !== "undefined") {');
    lines.push('    return new Response(__clientHTML, { status: 200, headers: { "Content-Type": "text/html", ...(__corsHeaders) } });');
    lines.push('  }');
    lines.push('  return Response.json({ error: "Not Found" }, { status: 404, headers: __corsHeaders });');
    lines.push('}');
    lines.push('');

    // Start server with Bun.serve()
    const label = blockName ? ` [${blockName}]` : '';
    const portVar = blockName ? `PORT_${blockName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}` : 'PORT';
    lines.push('// ── Start Server ──');
    lines.push(`const __port = process.env.${portVar} || process.env.PORT || 3000;`);
    lines.push(`const __server = Bun.serve({`);
    lines.push(`  port: __port,`);
    lines.push(`  fetch: __handleRequest,`);
    lines.push(`});`);
    lines.push(`console.log(\`Lux server${label} running on \${__server.url}\`);`);

    return lines.join('\n');
  }
}

// ─── src/codegen/client-codegen.js ─────────────────────

class ClientCodegen extends BaseCodegen {
  constructor() {
    super();
    this.stateNames = new Set(); // Track state variable names for setter transforms
    this.computedNames = new Set(); // Track computed variable names for getter transforms
    this.componentNames = new Set(); // Track component names for JSX
  }

  // Override to add () for signal/computed reads
  genExpression(node) {
    if (node && node.type === 'Identifier' &&
        (this.stateNames.has(node.name) || this.computedNames.has(node.name))) {
      return `${node.name}()`;
    }
    return super.genExpression(node);
  }

  // Override to transform state assignments to setter calls
  generateStatement(node) {
    if (!node) return '';

    // Intercept compound assignments to state variables: count += 1 → setCount(prev => prev + 1)
    if (node.type === 'CompoundAssignment' && node.target.type === 'Identifier' && this.stateNames.has(node.target.name)) {
      const name = node.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.operator[0]; // += → +, -= → -, etc.
      const val = this.genExpression(node.value);
      return `${this.i()}${setter}(__prev => __prev ${op} ${val});`;
    }

    // Intercept assignments to state variables: count = 0 → setCount(0)
    if (node.type === 'Assignment' && node.targets.length === 1 && this.stateNames.has(node.targets[0])) {
      const name = node.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.values[0]);
      return `${this.i()}${setter}(${val});`;
    }

    return super.generateStatement(node);
  }

  // Override lambda expression to handle state mutations in lambda bodies
  genLambdaExpression(node) {
    const params = this.genParams(node.params);

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) this.declareVar(p.name);
      const body = this.genBlockBody(node.body);
      this.popScope();
      return `(${params}) => {\n${body}\n${this.i()}}`;
    }

    // Compound assignment in lambda body: fn() count += 1
    if (node.body.type === 'CompoundAssignment' && node.body.target.type === 'Identifier' && this.stateNames.has(node.body.target.name)) {
      const name = node.body.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.body.operator[0];
      const val = this.genExpression(node.body.value);
      return `(${params}) => { ${setter}(__prev => __prev ${op} ${val}); }`;
    }

    // Assignment in lambda body: fn() count = 0
    if (node.body.type === 'Assignment' && node.body.targets.length === 1 && this.stateNames.has(node.body.targets[0])) {
      const name = node.body.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.body.values[0]);
      return `(${params}) => { ${setter}(${val}); }`;
    }

    // Non-state statement bodies
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.indent++;
      const stmt = super.generateStatement(node.body);
      this.indent--;
      return `(${params}) => { ${stmt.trim()} }`;
    }

    return `(${params}) => ${this.genExpression(node.body)}`;
  }

  generate(clientBlocks, sharedCode) {
    const lines = [];

    // Runtime imports
    lines.push(`import { createSignal, createEffect, createComputed, mount, lux_el, lux_fragment } from './runtime/reactivity.js';`);
    lines.push(`import { rpc } from './runtime/rpc.js';`);
    lines.push('');

    // Shared code
    if (sharedCode.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedCode);
      lines.push('');
    }

    // Stdlib core functions (available in all Lux code)
    lines.push('// ── Stdlib ──');
    lines.push(this.getStdlibCore());
    lines.push('');

    // Server RPC proxy
    lines.push('// ── Server RPC Proxy ──');
    lines.push('const server = new Proxy({}, {');
    lines.push('  get(_, name) {');
    lines.push('    return (...args) => rpc(name, args);');
    lines.push('  }');
    lines.push('});');
    lines.push('');

    const states = [];
    const computeds = [];
    const effects = [];
    const components = [];
    const other = [];

    for (const block of clientBlocks) {
      for (const stmt of block.body) {
        switch (stmt.type) {
          case 'StateDeclaration': states.push(stmt); break;
          case 'ComputedDeclaration': computeds.push(stmt); break;
          case 'EffectDeclaration': effects.push(stmt); break;
          case 'ComponentDeclaration': components.push(stmt); break;
          default: other.push(stmt); break;
        }
      }
    }

    // Register state names for setter transforms
    for (const s of states) {
      this.stateNames.add(s.name);
    }

    // Register computed names for getter transforms
    for (const c of computeds) {
      this.computedNames.add(c.name);
    }

    // Register component names
    for (const comp of components) {
      this.componentNames.add(comp.name);
    }

    // Generate state signals
    if (states.length > 0) {
      lines.push('// ── Reactive State ──');
      for (const s of states) {
        const init = this.genExpression(s.initialValue);
        lines.push(`const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});`);
      }
      lines.push('');
    }

    // Generate computed values
    if (computeds.length > 0) {
      lines.push('// ── Computed Values ──');
      for (const c of computeds) {
        const expr = this.genExpression(c.expression);
        lines.push(`const ${c.name} = createComputed(() => ${expr});`);
      }
      lines.push('');
    }

    // Generate other statements
    for (const stmt of other) {
      lines.push(this.generateStatement(stmt));
    }

    // Generate components
    if (components.length > 0) {
      lines.push('// ── Components ──');
      for (const comp of components) {
        lines.push(this.generateComponent(comp));
        lines.push('');
      }
    }

    // Generate effects
    if (effects.length > 0) {
      lines.push('// ── Effects ──');
      for (const e of effects) {
        // Check if effect body contains server.* calls (async RPC)
        const bodyCode = (() => {
          this.indent++;
          const code = this.genBlockStatements(e.body);
          this.indent--;
          return code;
        })();
        const hasRPC = bodyCode.includes('server.') || bodyCode.includes('rpc(');
        if (hasRPC) {
          lines.push(`createEffect(() => {`);
          lines.push(`  (async () => {`);
          // Re-generate with await on server calls
          this.indent += 2;
          const asyncBody = this.genBlockStatements(e.body).replace(/\b(server\.\w+\([^)]*\))/g, 'await $1');
          this.indent -= 2;
          lines.push(asyncBody);
          lines.push(`  })();`);
          lines.push(`});`);
        } else {
          lines.push(`createEffect(() => {`);
          this.indent++;
          lines.push(this.genBlockStatements(e.body));
          this.indent--;
          lines.push(`});`);
        }
        lines.push('');
      }
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push('// ── Runtime Helpers ──');
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // Auto-mount the App component if it exists
    const hasApp = components.some(c => c.name === 'App');
    if (hasApp) {
      lines.push('// ── Mount ──');
      lines.push('document.addEventListener("DOMContentLoaded", () => {');
      lines.push('  mount(App, document.getElementById("app") || document.body);');
      lines.push('});');
    }

    return lines.join('\n');
  }

  generateComponent(comp) {
    const params = comp.params.length > 0
      ? `{ ${comp.params.map(p => p.name).join(', ')} }`
      : '';

    let code = `function ${comp.name}(${params}) {\n`;
    this.indent++;

    // Process body — find JSX elements and statements
    const jsxElements = [];
    const statements = [];

    for (const node of comp.body) {
      if (node.type === 'JSXElement' || node.type === 'JSXFor' || node.type === 'JSXIf') {
        jsxElements.push(node);
      } else {
        statements.push(node);
      }
    }

    // Generate statements first
    for (const stmt of statements) {
      code += this.generateStatement(stmt) + '\n';
    }

    // Generate JSX return
    if (jsxElements.length === 1) {
      code += `${this.i()}return ${this.genJSX(jsxElements[0])};\n`;
    } else if (jsxElements.length > 1) {
      const children = jsxElements.map(el => this.genJSX(el)).join(', ');
      code += `${this.i()}return lux_fragment([${children}]);\n`;
    }

    this.indent--;
    code += `}`;
    return code;
  }

  genJSX(node) {
    if (!node) return 'null';

    switch (node.type) {
      case 'JSXElement': return this.genJSXElement(node);
      case 'JSXText': return this.genJSXText(node);
      case 'JSXExpression': return this.genExpression(node.expression);
      case 'JSXFor': return this.genJSXFor(node);
      case 'JSXIf': return this.genJSXIf(node);
      default: return this.genExpression(node);
    }
  }

  genJSXElement(node) {
    const isComponent = node.tag[0] === node.tag[0].toUpperCase() && /^[A-Z]/.test(node.tag);

    // Attributes
    const attrs = {};
    const events = {};

    for (const attr of node.attributes) {
      if (attr.name.startsWith('on:')) {
        const eventName = attr.name.slice(3);
        events[eventName] = this.genExpression(attr.value);
      } else {
        const attrName = attr.name === 'class' ? 'className' : attr.name;
        attrs[attrName] = this.genExpression(attr.value);
      }
    }

    let propsStr = '{';
    const propParts = [];
    for (const [key, val] of Object.entries(attrs)) {
      propParts.push(`${key}: ${val}`);
    }
    for (const [event, handler] of Object.entries(events)) {
      propParts.push(`on${capitalize(event)}: ${handler}`);
    }
    propsStr += propParts.join(', ');
    propsStr += '}';

    // Components: call as function, passing props
    if (isComponent) {
      return `${node.tag}(${propsStr})`;
    }

    const tag = JSON.stringify(node.tag);

    if (node.selfClosing || node.children.length === 0) {
      return `lux_el(${tag}, ${propsStr})`;
    }

    const children = node.children.map(c => this.genJSX(c)).join(', ');
    return `lux_el(${tag}, ${propsStr}, [${children}])`;
  }

  genJSXText(node) {
    if (node.value.type === 'StringLiteral') {
      return JSON.stringify(node.value.value);
    }
    if (node.value.type === 'TemplateLiteral') {
      return this.genTemplateLiteral(node.value);
    }
    return this.genExpression(node.value);
  }

  genJSXFor(node) {
    const varName = node.variable;
    const iterable = this.genExpression(node.iterable);
    const children = node.body.map(c => this.genJSX(c));

    if (children.length === 1) {
      return `...${iterable}.map((${varName}) => ${children[0]})`;
    }
    return `...${iterable}.map((${varName}) => lux_fragment([${children.join(', ')}]))`;
  }

  genJSXIf(node) {
    const cond = this.genExpression(node.condition);
    const consequent = node.consequent.map(c => this.genJSX(c));
    const thenPart = consequent.length === 1 ? consequent[0] : `lux_fragment([${consequent.join(', ')}])`;

    if (node.alternate) {
      const alt = node.alternate.map(c => this.genJSX(c));
      const elsePart = alt.length === 1 ? alt[0] : `lux_fragment([${alt.join(', ')}])`;
      return `(${cond}) ? ${thenPart} : ${elsePart}`;
    }

    return `(${cond}) ? ${thenPart} : null`;
  }

  // Override function declaration to make async if it contains server.* calls
  genFunctionDeclaration(node) {
    const params = this.genParams(node.params);
    this.pushScope();
    for (const p of node.params) this.declareVar(p.name);
    const body = this.genBlockBody(node.body);
    this.popScope();
    const hasRPC = body.includes('server.') || body.includes('rpc(');
    const asyncPrefix = hasRPC ? 'async ' : '';
    let finalBody = body;
    if (hasRPC) {
      finalBody = body.replace(/\b(server\.\w+\([^)]*\))/g, 'await $1');
    }
    return `${this.i()}${asyncPrefix}function ${node.name}(${params}) {\n${finalBody}\n${this.i()}}`;
  }

  getStdlibCore() {
    return `function print(...args) { console.log(...args); }
function len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }
function range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }
function enumerate(a) { return a.map((v, i) => [i, v]); }
function sum(a) { return a.reduce((x, y) => x + y, 0); }
function sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }
function reversed(a) { return [...a].reverse(); }
function zip(...as) { const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }
function min(a) { return Math.min(...a); }
function max(a) { return Math.max(...a); }`;
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ─── src/codegen/codegen.js ────────────────────────────

// Main code generator — orchestrates shared/server/client codegen
// Supports named multi-blocks: server "api" { }, server "ws" { }
// Blocks with the same name are merged; different names produce separate output files.
class CodeGenerator {
  constructor(ast, filename = '<stdin>') {
    this.ast = ast;
    this.filename = filename;
  }

  // Group blocks by name (null name = "default")
  _groupByName(blocks) {
    const groups = new Map();
    for (const block of blocks) {
      const key = block.name || null;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key).push(block);
    }
    return groups;
  }

  generate() {
    const sharedBlocks = [];
    const serverBlocks = [];
    const clientBlocks = [];
    const topLevel = [];

    for (const node of this.ast.body) {
      switch (node.type) {
        case 'SharedBlock': sharedBlocks.push(node); break;
        case 'ServerBlock': serverBlocks.push(node); break;
        case 'ClientBlock': clientBlocks.push(node); break;
        default: topLevel.push(node); break;
      }
    }

    const sharedGen = new SharedCodegen();

    // All shared blocks (regardless of name) are merged into one shared output
    const sharedCode = sharedBlocks.map(b => sharedGen.generate(b)).join('\n');
    const topLevelCode = topLevel.map(s => sharedGen.generateStatement(s)).join('\n');
    const helpers = sharedGen.generateHelpers();
    const combinedShared = [helpers, sharedCode, topLevelCode].filter(s => s.trim()).join('\n').trim();

    // Group server and client blocks by name
    const serverGroups = this._groupByName(serverBlocks);
    const clientGroups = this._groupByName(clientBlocks);

    // Generate server outputs (one per named group)
    const servers = {};
    for (const [name, blocks] of serverGroups) {
      const gen = new ServerCodegen();
      const key = name || 'default';
      servers[key] = gen.generate(blocks, combinedShared, name);
    }

    // Generate client outputs (one per named group)
    const clients = {};
    for (const [name, blocks] of clientGroups) {
      const gen = new ClientCodegen();
      const key = name || 'default';
      clients[key] = gen.generate(blocks, combinedShared);
    }

    // Backward-compatible: if only unnamed blocks, return flat structure
    const hasNamedBlocks = [...serverGroups.keys(), ...clientGroups.keys()].some(k => k !== null);

    if (!hasNamedBlocks) {
      return {
        shared: combinedShared,
        server: servers['default'] || '',
        client: clients['default'] || '',
      };
    }

    // Multi-block output: separate files per named block
    return {
      shared: combinedShared,
      server: servers['default'] || '',
      client: clients['default'] || '',
      servers,   // { "api": code, "ws": code, ... }
      clients,   // { "admin": code, "dashboard": code, ... }
      multiBlock: true,
    };
  }
}

window.Lexer = Lexer;

window.Parser = Parser;

window.Analyzer = Analyzer;

window.CodeGenerator = CodeGenerator;

})();
</script>

<!-- ─── CodeMirror shared dependency map ──────────── -->
<script type="importmap">
{
  "imports": {
    "@codemirror/state": "https://esm.sh/@codemirror/state@6.4.1",
    "@codemirror/view": "https://esm.sh/@codemirror/view@6.26.0",
    "@codemirror/language": "https://esm.sh/@codemirror/language@6.10.1",
    "@codemirror/commands": "https://esm.sh/@codemirror/commands@6.3.3",
    "@codemirror/search": "https://esm.sh/@codemirror/search@6.5.5",
    "@codemirror/autocomplete": "https://esm.sh/@codemirror/autocomplete@6.12.0",
    "@codemirror/lint": "https://esm.sh/@codemirror/lint@6.5.0",
    "@lezer/common": "https://esm.sh/@lezer/common@1.2.1",
    "@lezer/highlight": "https://esm.sh/@lezer/highlight@1.2.0",
    "@lezer/lr": "https://esm.sh/@lezer/lr@1.4.0",
    "crelt": "https://esm.sh/crelt@1.0.6",
    "style-mod": "https://esm.sh/style-mod@4.1.2",
    "w3c-keyname": "https://esm.sh/w3c-keyname@2.2.8"
  }
}
</script>

<!-- ─── CodeMirror & App ─────────────────────────── -->
<script type="module">
import {EditorView, basicSetup} from 'https://esm.sh/*@codemirror/basic-setup@0.20.0';
import {EditorState, StateField, StateEffect} from 'https://esm.sh/*@codemirror/state@6.4.1';
import {keymap, Decoration} from 'https://esm.sh/*@codemirror/view@6.26.0';
import {StreamLanguage} from 'https://esm.sh/*@codemirror/language@6.10.1';
import {oneDark} from 'https://esm.sh/*@codemirror/theme-one-dark@6.1.2';
import {autocompletion} from 'https://esm.sh/*@codemirror/autocomplete@6.12.0';

// ─── Lux Syntax Highlighting ────────────────────────
const luxLanguage = StreamLanguage.define({
  startState() { return { inComment: false, commentDepth: 0 }; },
  token(stream, state) {
    // Block comment (nestable)
    if (state.inComment) {
      if (stream.match('/*')) { state.commentDepth++; return 'blockComment'; }
      if (stream.match('*/')) { state.commentDepth--; if (state.commentDepth <= 0) { state.inComment = false; state.commentDepth = 0; } return 'blockComment'; }
      stream.next(); return 'blockComment';
    }
    // Docstring
    if (stream.match('///')) { stream.skipToEnd(); return 'docString'; }
    // Line comment
    if (stream.match('//')) { stream.skipToEnd(); return 'lineComment'; }
    // Block comment start
    if (stream.match('/*')) { state.inComment = true; state.commentDepth = 1; return 'blockComment'; }
    // Strings with interpolation
    if (stream.match('"')) {
      while (!stream.eol()) {
        const ch = stream.next();
        if (ch === '\\') { stream.next(); continue; }
        if (ch === '{') { return 'string'; }
        if (ch === '"') return 'string';
      }
      return 'string';
    }
    // Simple strings
    if (stream.match("'")) {
      while (!stream.eol()) { const ch = stream.next(); if (ch === '\\') { stream.next(); continue; } if (ch === "'") return 'string'; }
      return 'string';
    }
    // Braces (interpolation)
    if (stream.match('{')) return 'brace';
    if (stream.match('}')) return 'brace';
    // Numbers
    if (stream.match(/^0[xX][0-9a-fA-F]+/)) return 'number';
    if (stream.match(/^0[bB][01]+/)) return 'number';
    if (stream.match(/^\d+\.\d+([eE][+-]?\d+)?/)) return 'number';
    if (stream.match(/^\d+([eE][+-]?\d+)?/)) return 'number';
    // Multi-char operators
    if (stream.match('|>')) return 'operator';
    if (stream.match('=>')) return 'operator';
    if (stream.match('->')) return 'operator';
    if (stream.match('..=')) return 'operator';
    if (stream.match('...')) return 'operator';
    if (stream.match('..')) return 'operator';
    if (stream.match('?.')) return 'operator';
    if (stream.match('??')) return 'operator';
    if (stream.match('::')) return 'operator';
    if (stream.match('**')) return 'operator';
    if (stream.match(/^[+\-*\/%]=?/)) return 'operator';
    if (stream.match(/^[<>!=]=?/)) return 'operator';
    if (stream.match(/^&&|\|\|/)) return 'operator';
    if (stream.match('=')) return 'operator';
    // JSX close tag
    if (stream.match(/^<\/[A-Za-z][A-Za-z0-9]*/)) { stream.match('>'); return 'tagName'; }
    // Identifiers and keywords
    if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
      const w = stream.current();
      if (['fn','let','var','if','elif','else','for','while','in','not','and','or','match',
           'return','type','import','from','export','as','true','false','nil',
           'server','client','shared','state','computed','effect','component',
           'route','GET','POST','PUT','DELETE','PATCH'].includes(w)) return 'keyword';
      if (/^[A-Z]/.test(w)) return 'typeName';
      return 'variableName';
    }
    // JSX
    if (stream.match('/>')) return 'angleBracket';
    if (stream.peek() === '<' && /[A-Za-z]/.test(stream.string.charAt(stream.pos + 1) || '')) {
      stream.next(); return 'angleBracket';
    }
    stream.next();
    return null;
  }
});

// ─── Autocompletion ─────────────────────────────────
const luxKeywords = [
  'fn', 'let', 'var', 'if', 'elif', 'else', 'for', 'while', 'match',
  'type', 'state', 'computed', 'effect', 'component', 'server', 'client',
  'shared', 'route', 'return', 'import', 'from', 'in', 'and', 'or', 'not',
  'true', 'false', 'nil', 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'as', 'export'
];

const luxStdlib = [
  { label: 'print', detail: '(...args)', info: 'Print values to console' },
  { label: 'len', detail: '(v)', info: 'Length of string, array, or object' },
  { label: 'range', detail: '(start?, end, step?)', info: 'Generate number array' },
  { label: 'sum', detail: '(arr)', info: 'Sum of array elements' },
  { label: 'min', detail: '(arr)', info: 'Minimum value in array' },
  { label: 'max', detail: '(arr)', info: 'Maximum value in array' },
  { label: 'sorted', detail: '(arr, key?)', info: 'Sort array (with optional key fn)' },
  { label: 'reversed', detail: '(arr)', info: 'Reverse array' },
  { label: 'enumerate', detail: '(arr)', info: 'Index-value pairs' },
  { label: 'zip', detail: '(...arrs)', info: 'Combine arrays element-wise' },
  { label: 'type_of', detail: '(v)', info: 'Runtime type name as string' },
  { label: 'filter', detail: '(arr, fn)', info: 'Filter array by predicate' },
  { label: 'map', detail: '(arr, fn)', info: 'Transform each element' },
  { label: 'flat_map', detail: '(arr, fn)', info: 'Map then flatten one level' },
  { label: 'any', detail: '(arr, fn)', info: 'True if any element matches' },
  { label: 'all', detail: '(arr, fn)', info: 'True if all elements match' },
];

const luxSnippets = [
  { label: 'fn', detail: 'function', apply: 'fn name() {\n  \n}', boost: -1 },
  { label: 'for', detail: 'for-in loop', apply: 'for item in items {\n  \n}', boost: -1 },
  { label: 'match', detail: 'match expression', apply: 'match value {\n  _ => \n}', boost: -1 },
  { label: 'type', detail: 'type definition', apply: 'type Name {\n  \n}', boost: -1 },
  { label: 'client', detail: 'client block', apply: 'client {\n  state count = 0\n\n  component App {\n    <div>\n      \n    </div>\n  }\n}', boost: -1 },
  { label: 'component', detail: 'component', apply: 'component App {\n  <div>\n    \n  </div>\n}', boost: -1 },
  { label: 'server', detail: 'server block', apply: 'server {\n  \n}', boost: -1 },
  { label: 'effect', detail: 'side effect', apply: 'effect {\n  \n}', boost: -1 },
  { label: 'if', detail: 'conditional', apply: 'if condition {\n  \n}', boost: -1 },
  { label: 'while', detail: 'while loop', apply: 'while condition {\n  \n}', boost: -1 },
  { label: 'route', detail: 'HTTP route', apply: 'route GET "/path" => fn(req) {\n  \n}', boost: -1 },
];

function luxCompletions(context) {
  const word = context.matchBefore(/[a-zA-Z_]\w*/);
  if (!word && !context.explicit) return null;
  const from = word ? word.from : context.pos;
  const text = word ? word.text : '';

  const options = [];

  // Keywords
  for (const kw of luxKeywords) {
    if (!text || kw.startsWith(text)) {
      // Check if there's a matching snippet
      const snippet = luxSnippets.find(s => s.label === kw);
      if (snippet) {
        options.push({ label: kw, type: 'keyword', detail: snippet.detail, apply: snippet.apply, boost: 1 });
      } else {
        options.push({ label: kw, type: 'keyword', boost: 0 });
      }
    }
  }

  // Stdlib functions
  for (const fn of luxStdlib) {
    if (!text || fn.label.startsWith(text)) {
      options.push({ label: fn.label, type: 'function', detail: fn.detail, info: fn.info, boost: 2 });
    }
  }

  return { from, options, filter: true };
}

// ─── Error Decorations ──────────────────────────────
const setErrorEffect = StateEffect.define();
const clearErrorEffect = StateEffect.define();

const errorLineDeco = Decoration.line({ class: 'cm-error-line' });

const errorField = StateField.define({
  create() { return Decoration.none; },
  update(decos, tr) {
    for (const e of tr.effects) {
      if (e.is(clearErrorEffect)) return Decoration.none;
      if (e.is(setErrorEffect)) {
        const lines = e.value;
        const ranges = [];
        for (const lineNum of lines) {
          try {
            const line = tr.state.doc.line(lineNum);
            ranges.push(errorLineDeco.range(line.from));
          } catch(ex) {}
        }
        return ranges.length ? Decoration.set(ranges) : Decoration.none;
      }
    }
    return decos;
  },
  provide: f => EditorView.decorations.from(f)
});

// ─── Data ───────────────────────────────────────────
const EXAMPLES = [
  {
    "category": "Getting Started",
    "name": "Hello World",
    "code": "// Welcome to Lux! A modern language that transpiles to JavaScript.\n// Click \"Run\" or press Cmd/Ctrl+Enter to execute.\n\nname = \"World\"\ngreeting = \"Hello, {name}!\"\nprint(greeting)\n\n// Lux uses string interpolation with {expressions}\nx = 42\npi = 3.14159\nprint(\"x is {x} and pi is {pi}\")\n\n// Variables: immutable by default, use 'var' for mutable\nlanguage = \"Lux\"         // immutable\nvar version = 1          // mutable\nversion += 1\nprint(\"{language} v{version}\")\n"
  },
  {
    "category": "Getting Started",
    "name": "Variables & Types",
    "code": "// Immutable bindings (default)\nname = \"Alice\"\nage = 30\npi = 3.14159\nis_active = true\nnothing = nil\n\n// Mutable bindings\nvar count = 0\ncount += 1\ncount += 1\nprint(\"count = {count}\")\n\n// Multiple assignment\na, b, c = 1, 2, 3\nprint(\"a={a}, b={b}, c={c}\")\n\n// Swap\nvar x = 10\nvar y = 20\nx, y = y, x\nprint(\"After swap: x={x}, y={y}\")\n\n// Type checking\nprint(type_of(42))\nprint(type_of(\"hello\"))\nprint(type_of(true))\nprint(type_of([1, 2, 3]))\nprint(type_of(nil))\n"
  },
  {
    "category": "Getting Started",
    "name": "String Operations",
    "code": "// String interpolation with expressions\nname = \"hello world\"\nprint(\"Upper: {name.upper()}\")\nprint(\"Capitalized: {name.capitalize()}\")\nprint(\"Title: {name.title_case()}\")\n\n// String methods\nsentence = \"the quick brown fox jumps\"\nprint(\"Words: {sentence.words()}\")\nprint(\"Starts with 'the': {sentence.starts_with(\"the\")}\")\nprint(\"Contains 'brown': {sentence.contains(\"brown\")}\")\n\n// Useful conversions\nprint(\"snake_case: {\"helloWorld\".snake_case()}\")\nprint(\"camelCase: {\"hello_world\".camel_case()}\")\n\n// String multiply (repeat)\nborder = \"-\" * 30\nprint(border)\nprint(\"  Lux Language\")\nprint(border)\n\n// Characters and lines\ntext = \"Lux\"\nprint(\"Chars: {text.chars()}\")\n"
  },
  {
    "category": "Functions",
    "name": "Functions & Lambdas",
    "code": "// Functions return the last expression (implicit return)\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"friend\") {\n  \"Hey, {name}!\"\n}\n\nprint(add(1, 2))\nprint(greet())\nprint(greet(\"Alice\"))\n\n// Lambda / anonymous functions\ndouble = fn(x) x * 2\nsquare = fn(x) x * x\nprint(\"double(7) = {double(7)}\")\nprint(\"square(5) = {square(5)}\")\n\n// Arrow syntax\nadd3 = fn(a, b, c) a + b + c\nprint(\"add3(1,2,3) = {add3(1, 2, 3)}\")\n\n// Functions are first-class\nfn apply(f, x) { f(x) }\nprint(\"apply(double, 21) = {apply(double, 21)}\")\n\n// Explicit return\nfn first_positive(items) {\n  for item in items {\n    if item > 0 { return item }\n  }\n  nil\n}\nprint(\"First positive: {first_positive([-3, -1, 0, 4, 7])}\")\n"
  },
  {
    "category": "Functions",
    "name": "Higher-Order Functions",
    "code": "// Map, filter, and reduce with lambdas\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndoubled = map(numbers, fn(x) x * 2)\nprint(\"Doubled: {doubled}\")\n\nevens = filter(numbers, fn(x) x % 2 == 0)\nprint(\"Evens: {evens}\")\n\ntotal = sum(numbers)\nprint(\"Sum: {total}\")\n\n// Composition\nfn compose(f, g) {\n  fn(x) f(g(x))\n}\n\ndouble = fn(x) x * 2\nadd_one = fn(x) x + 1\ndouble_then_add = compose(add_one, double)\nprint(\"double_then_add(5) = {double_then_add(5)}\")\n\n// Sorting with key function\nwords = [\"banana\", \"apple\", \"cherry\", \"date\"]\nby_length = sorted(words, fn(w) len(w))\nprint(\"By length: {by_length}\")\n\n// Checking conditions\nhas_negative = any([-1, 2, 3], fn(x) x < 0)\nall_positive = all([1, 2, 3], fn(x) x > 0)\nprint(\"Has negative: {has_negative}\")\nprint(\"All positive: {all_positive}\")\n"
  },
  {
    "category": "Functions",
    "name": "Pipe Operator",
    "code": "// The pipe operator |> chains function calls beautifully\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Another example\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\", \"Eve\"]\nresult2 = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\n  |> reversed()\nprint(\"Long names (Z-A): {result2}\")\n\n// Simple pipeline\n42 |> fn(x) x * 2 |> fn(x) \"The answer is {x}\" |> print()\n"
  },
  {
    "category": "Data Structures",
    "name": "Lists & Comprehensions",
    "code": "// List literals\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"Fruits: {fruits}\")\nprint(\"Length: {len(fruits)}\")\n\n// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// With filter\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Nested comprehension\npairs = [[x, y] for x in range(1, 4) for y in range(1, 4) if x != y]\nprint(\"Pairs: {pairs}\")\n\n// Dict comprehension\nsquare_map = {x: x * x for x in range(1, 6)}\nprint(\"Square map: {square_map}\")\n\n// Slice operations\nnums = [10, 20, 30, 40, 50, 60, 70]\nprint(\"nums[1:4] = {nums[1:4]}\")\nprint(\"nums[:3]  = {nums[:3]}\")\nprint(\"nums[4:]  = {nums[4:]}\")\nprint(\"nums[::-1] = {nums[::-1]}\")\n"
  },
  {
    "category": "Data Structures",
    "name": "Spread & Destructuring",
    "code": "// Array spread\nfirst = [1, 2, 3]\nsecond = [4, 5, 6]\ncombined = [...first, ...second]\nprint(\"Combined: {combined}\")\n\n// Object literals\nconfig = {\n  color: \"blue\",\n  size: \"medium\",\n  bold: false,\n  count: 42\n}\nprint(\"Config: {config}\")\n\n// Destructuring objects\nlet {color, size, bold} = config\nprint(\"Color: {color}\")\nprint(\"Size: {size}\")\n\n// Destructuring arrays\nlet [a, b, c] = [10, 20, 30]\nprint(\"a={a}, b={b}, c={c}\")\n\n// Membership testing\nfruits = [\"apple\", \"banana\", \"cherry\"]\nif \"banana\" in fruits {\n  print(\"We have bananas!\")\n}\nif \"grape\" not in fruits {\n  print(\"No grapes available\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "If / Elif / Else",
    "code": "// If expressions (they return values!)\nfn grade(score) {\n  if score >= 90 {\n    \"A\"\n  } elif score >= 80 {\n    \"B\"\n  } elif score >= 70 {\n    \"C\"\n  } elif score >= 60 {\n    \"D\"\n  } else {\n    \"F\"\n  }\n}\n\nfor s in [95, 85, 72, 65, 45] {\n  print(\"Score {s} = Grade {grade(s)}\")\n}\n\n// Chained comparisons (Python-style!)\ny = 5\nif 1 < y < 10 {\n  print(\"{y} is between 1 and 10\")\n}\n\nage = 25\nif 18 <= age < 65 {\n  print(\"Working age\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Loops",
    "code": "// For loops with range\nprint(\"Counting:\")\nfor i in range(1, 6) {\n  print(\"  {i}\")\n}\n\n// For-in with arrays\ncolors = [\"red\", \"green\", \"blue\"]\nfor color in colors {\n  print(\"Color: {color}\")\n}\n\n// Enumerate (get index + value)\nfor pair in enumerate(colors) {\n  print(\"  {pair[0]}: {pair[1]}\")\n}\n\n// While loops\nvar n = 1\nwhile n < 100 {\n  n = n * 2\n}\nprint(\"First power of 2 >= 100: {n}\")\n\n// FizzBuzz\nfn fizzbuzz(n) {\n  if n % 15 == 0 { \"FizzBuzz\" }\n  elif n % 3 == 0 { \"Fizz\" }\n  elif n % 5 == 0 { \"Buzz\" }\n  else { \"{n}\" }\n}\n\nfor i in range(1, 21) {\n  print(fizzbuzz(i))\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Pattern Matching",
    "code": "// Pattern matching — Lux's most powerful feature!\n\n// Simple value matching\nfn describe(value) {\n  match value {\n    0 => \"zero\"\n    1..10 => \"small (1-9)\"\n    n if n > 100 => \"big: {n}\"\n    _ => \"other: {value}\"\n  }\n}\n\nprint(describe(0))\nprint(describe(5))\nprint(describe(200))\nprint(describe(50))\n\n// Pattern matching on algebraic types\ntype Shape {\n  Circle(radius: Float),\n  Rect(w: Float, h: Float),\n  Triangle(base: Float, height: Float),\n  Point\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n    Triangle(b, h) => 0.5 * b * h\n    Point => 0.0\n  }\n}\n\nfn describe_shape(s) {\n  match s {\n    Circle(r) => \"Circle with radius {r}\"\n    Rect(w, h) => \"Rectangle {w}x{h}\"\n    Triangle(b, h) => \"Triangle base={b} height={h}\"\n    Point => \"Just a point\"\n  }\n}\n\nshapes = [Circle(5.0), Rect(3.0, 4.0), Triangle(6.0, 3.0), Point]\nfor shape in shapes {\n  print(\"{describe_shape(shape)} => area = {area(shape)}\")\n}\n"
  },
  {
    "category": "Types",
    "name": "Algebraic Data Types",
    "code": "// Algebraic Data Types (tagged unions / sum types)\ntype Color {\n  Red,\n  Green,\n  Blue,\n  Custom(r: Int, g: Int, b: Int)\n}\n\nfn to_hex(c) {\n  match c {\n    Red => \"#FF0000\"\n    Green => \"#00FF00\"\n    Blue => \"#0000FF\"\n    Custom(r, g, b) => \"rgb({r},{g},{b})\"\n  }\n}\n\nprint(to_hex(Red))\nprint(to_hex(Custom(255, 128, 0)))\n\n// Option type pattern\ntype Option {\n  Some(value: Any),\n  None\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { None }\n  else { Some(a / b) }\n}\n\nfn unwrap(opt, default_val) {\n  match opt {\n    Some(v) => v\n    None => default_val\n  }\n}\n\nprint(unwrap(safe_divide(10, 3), 0))\nprint(unwrap(safe_divide(10, 0), 0))\n\n// Result type\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_age(input) {\n  if input > 0 and input < 150 {\n    Ok(input)\n  } else {\n    Err(\"Invalid age: {input}\")\n  }\n}\n\nprint(parse_age(25))\nprint(parse_age(-5))\n"
  },
  {
    "category": "Types",
    "name": "Struct Types",
    "code": "// Struct-like types with named fields\ntype Point {\n  x: Float\n  y: Float\n}\n\ntype User {\n  name: String\n  age: Int\n}\n\n// Creating instances\np1 = Point(3.0, 4.0)\np2 = Point(1.0, 2.0)\nprint(\"p1 = ({p1.x}, {p1.y})\")\nprint(\"p2 = ({p2.x}, {p2.y})\")\n\n// Distance function\nfn distance(a, b) {\n  dx = a.x - b.x\n  dy = a.y - b.y\n  (dx ** 2 + dy ** 2) ** 0.5\n}\nprint(\"Distance: {distance(p1, p2)}\")\n\n// User records\nusers = [\n  User(\"Alice\", 30),\n  User(\"Bob\", 25),\n  User(\"Charlie\", 35)\n]\n\n// Sort by age\nby_age = sorted(users, fn(u) u.age)\nfor u in by_age {\n  print(\"{u.name}: {u.age}\")\n}\n"
  },
  {
    "category": "Standard Library",
    "name": "Built-in Functions",
    "code": "// Lux comes with useful built-in functions\n\n// range(start?, end, step?)\nprint(\"range(5): {range(5)}\")\nprint(\"range(2,8): {range(2, 8)}\")\nprint(\"range(0,20,3): {range(0, 20, 3)}\")\n\n// len — works on strings, arrays, objects\nprint(\"len('hello'): {len(\"hello\")}\")\nprint(\"len([1,2,3]): {len([1, 2, 3])}\")\n\n// sum, min, max\nnums = [4, 2, 7, 1, 9, 3]\nprint(\"sum: {sum(nums)}\")\nprint(\"min: {min(nums)}\")\nprint(\"max: {max(nums)}\")\n\n// sorted, reversed\nprint(\"sorted: {sorted(nums)}\")\nprint(\"reversed: {reversed(nums)}\")\n\n// enumerate — get index,value pairs\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor pair in enumerate(fruits) {\n  print(\"  [{pair[0]}] {pair[1]}\")\n}\n\n// zip — combine arrays\nkeys = [\"name\", \"age\", \"city\"]\nvals = [\"Alice\", 30, \"NYC\"]\nprint(\"zipped: {zip(keys, vals)}\")\n\n// type_of — runtime type checking\nprint(\"type_of(42): {type_of(42)}\")\nprint(\"type_of(3.14): {type_of(3.14)}\")\nprint(\"type_of('hi'): {type_of(\"hi\")}\")\nprint(\"type_of(true): {type_of(true)}\")\nprint(\"type_of(nil): {type_of(nil)}\")\nprint(\"type_of([1]): {type_of([1, 2])}\")\n"
  },
  {
    "category": "Reactive UI",
    "name": "Counter App",
    "code": "// Counter App in Lux — demonstrates reactive UI\n\nclient {\n  state count = 0\n\n  computed doubled = count * 2\n  computed message = match count {\n    0 => \"Click the button!\"\n    1..5 => \"Keep going...\"\n    n if n >= 10 => \"You're on fire! 🔥\"\n    _ => \"Nice!\"\n  }\n\n  component App {\n    <div class=\"counter-app\">\n      <h1>\"Lux Counter\"</h1>\n      <p class=\"count\">\"{count}\"</p>\n      <p class=\"doubled\">\"Doubled: {doubled}\"</p>\n      <p class=\"message\">\"{message}\"</p>\n      <div class=\"buttons\">\n        <button on:click={fn() count -= 1}>\"-\"</button>\n        <button on:click={fn() count += 1}>\"+\"</button>\n        <button on:click={fn() count = 0}>\"Reset\"</button>\n      </div>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Todo App (Full-Stack)",
    "code": "// Full-Stack Todo App in Lux — demonstrates server/client/shared blocks\n\nshared {\n  type Todo {\n    id: Int\n    title: String\n    completed: Bool\n  }\n}\n\nserver {\n  // In-memory store for demo (use db.query for real apps)\n  var todos = []\n  var next_id = 1\n\n  fn get_todos() -> [Todo] {\n    todos\n  }\n\n  fn add_todo(title: String) -> Todo {\n    todo = Todo(next_id, title, false)\n    next_id += 1\n    todos = [...todos, todo]\n    todo\n  }\n\n  fn toggle_todo(id: Int) -> Todo {\n    for t in todos {\n      if t.id == id {\n        return Todo(t.id, t.title, not t.completed)\n      }\n    }\n    nil\n  }\n\n  fn delete_todo(id: Int) {\n    todos = [t for t in todos if t.id != id]\n  }\n\n  route GET \"/api/todos\" => get_todos\n}\n\nclient {\n  state todos: [Todo] = []\n  state new_title = \"\"\n\n  computed remaining = len([t for t in todos if not t.completed])\n  computed total = len(todos)\n\n  effect {\n    todos = server.get_todos()\n  }\n\n  fn handle_add() {\n    if new_title != \"\" {\n      server.add_todo(new_title)\n      new_title = \"\"\n      todos = server.get_todos()\n    }\n  }\n\n  fn handle_toggle(id) {\n    server.toggle_todo(id)\n    todos = server.get_todos()\n  }\n\n  fn handle_delete(id) {\n    server.delete_todo(id)\n    todos = server.get_todos()\n  }\n\n  component TodoItem(todo) {\n    <li class=\"todo-item\">\n      <input type=\"checkbox\" checked={todo.completed} on:change={fn() handle_toggle(todo.id)} />\n      <span class=\"todo-text\">\"{todo.title}\"</span>\n      <button on:click={fn() handle_delete(todo.id)}>\"×\"</button>\n    </li>\n  }\n\n  component App {\n    <div class=\"todo-app\">\n      <h1>\"Lux Todo\"</h1>\n      <div class=\"input-row\">\n        <input\n          type=\"text\"\n          placeholder=\"What needs to be done?\"\n          value={new_title}\n          on:input={fn(e) new_title = e.target.value}\n        />\n        <button on:click={handle_add}>\"Add\"</button>\n      </div>\n      <ul class=\"todo-list\">\n        for todo in todos {\n          <TodoItem todo={todo} />\n        }\n      </ul>\n      <p class=\"status\">\"{remaining} of {total} remaining\"</p>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Temperature Converter",
    "code": "// Temperature converter — reactive two-way conversion\nclient {\n  state celsius = 20\n  computed fahrenheit = celsius * 9 / 5 + 32\n  computed kelvin = celsius + 273.15\n\n  computed description = match celsius {\n    c if c <= 0 => \"Freezing!\"\n    c if c <= 15 => \"Cold\"\n    c if c <= 25 => \"Comfortable\"\n    c if c <= 35 => \"Warm\"\n    _ => \"Hot!\"\n  }\n\n  component App {\n    <div class=\"converter\">\n      <h1>\"Temperature Converter\"</h1>\n      <div class=\"input-group\">\n        <label>\"Celsius\"</label>\n        <input type=\"range\" min=\"-40\" max=\"60\" value={celsius}\n               on:input={fn(e) celsius = e.target.value * 1} />\n        <span class=\"value\">\"{celsius}C\"</span>\n      </div>\n      <div class=\"results\">\n        <p>\"{celsius}C = {fahrenheit}F = {kelvin}K\"</p>\n        <p class=\"desc\">\"{description}\"</p>\n      </div>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Reactive UI",
    "name": "Stopwatch",
    "code": "// Stopwatch with reactive state\nclient {\n  state elapsed = 0\n  state running = false\n  state timer_id = nil\n\n  fn start_timer() {\n    if not running {\n      running = true\n    }\n  }\n\n  fn stop_timer() {\n    running = false\n  }\n\n  fn reset_timer() {\n    running = false\n    elapsed = 0\n  }\n\n  computed display = match elapsed {\n    t if t < 60 => \"{t}s\"\n    t if t < 3600 => \"{t / 60}m {t % 60}s\"\n    _ => \"{elapsed / 3600}h {(elapsed % 3600) / 60}m\"\n  }\n\n  component App {\n    <div class=\"stopwatch\">\n      <h1>\"Stopwatch\"</h1>\n      <p class=\"time\">\"{display}\"</p>\n      <div class=\"controls\">\n        <button on:click={fn() elapsed += 1}>\"+1s\"</button>\n        <button on:click={fn() elapsed += 10}>\"+10s\"</button>\n        <button on:click={fn() elapsed += 60}>\"+1m\"</button>\n        <button on:click={reset_timer}>\"Reset\"</button>\n      </div>\n      <p class=\"hint\">\"(Click buttons to simulate time passing)\"</p>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Algorithms",
    "name": "Fibonacci",
    "code": "// Fibonacci sequence — multiple approaches\n\n// Recursive (simple but slow)\nfn fib_recursive(n) {\n  if n <= 1 { n }\n  else { fib_recursive(n - 1) + fib_recursive(n - 2) }\n}\n\n// Iterative (fast)\nfn fib(n) {\n  if n <= 1 { return n }\n  var a = 0\n  var b = 1\n  for i in range(2, n + 1) {\n    var temp = b\n    b = a + b\n    a = temp\n  }\n  b\n}\n\n// Print first 15 Fibonacci numbers\nprint(\"Fibonacci sequence:\")\nfor i in range(15) {\n  print(\"  fib({i}) = {fib(i)}\")\n}\n\n// Using list comprehension\nfibs = [fib(i) for i in range(20)]\nprint(\"\\nFirst 20: {fibs}\")\nprint(\"Sum: {sum(fibs)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Binary Search",
    "code": "// Binary search on sorted array\nfn binary_search(arr, target) {\n  var lo = 0\n  var hi = len(arr) - 1\n  while lo <= hi {\n    mid = (lo + hi) / 2\n    if arr[mid] == target {\n      return mid\n    } elif arr[mid] < target {\n      lo = mid + 1\n    } else {\n      hi = mid - 1\n    }\n  }\n  -1\n}\n\n// Test it\nnums = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\nprint(\"Array: {nums}\")\n\nfor target in [23, 72, 15, 2, 91] {\n  idx = binary_search(nums, target)\n  if idx >= 0 {\n    print(\"Found {target} at index {idx}\")\n  } else {\n    print(\"{target} not found\")\n  }\n}\n\n// Sorting + searching\nwords = [\"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\", \"fig\"]\nsorted_words = sorted(words)\nprint(\"\\nSorted: {sorted_words}\")\nprint(\"Index of 'cherry': {binary_search(sorted_words, \"cherry\")}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Linked List with ADTs",
    "code": "// Linked List using algebraic data types\ntype List {\n  Cons(head: Any, tail: Any),\n  Empty\n}\n\n// Constructor helper\nfn list_of(arr) {\n  var result = Empty\n  for i in range(len(arr) - 1, -1, -1) {\n    result = Cons(arr[i], result)\n  }\n  result\n}\n\n// Operations\nfn list_len(lst) {\n  match lst {\n    Empty => 0\n    Cons(_, tail) => 1 + list_len(tail)\n  }\n}\n\nfn list_map(lst, f) {\n  match lst {\n    Empty => Empty\n    Cons(h, t) => Cons(f(h), list_map(t, f))\n  }\n}\n\nfn list_to_array(lst) {\n  var result = []\n  var current = lst\n  while true {\n    match current {\n      Empty => return result\n      Cons(h, t) => {\n        result = [...result, h]\n        current = t\n      }\n    }\n  }\n  result\n}\n\n// Test it\nmy_list = list_of([1, 2, 3, 4, 5])\nprint(\"Length: {list_len(my_list)}\")\n\ndoubled = list_map(my_list, fn(x) x * 2)\nprint(\"Doubled: {list_to_array(doubled)}\")\n\nsquared = list_map(my_list, fn(x) x * x)\nprint(\"Squared: {list_to_array(squared)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Game of Life",
    "code": "// Conway's Game of Life — one generation step\n\nfn make_grid(rows, cols) {\n  [[0 for c in range(cols)] for r in range(rows)]\n}\n\nfn count_neighbors(grid, r, c) {\n  rows = len(grid)\n  cols = len(grid[0])\n  var count = 0\n  for dr in [-1, 0, 1] {\n    for dc in [-1, 0, 1] {\n      if dr == 0 and dc == 0 { }\n      else {\n        nr = (r + dr + rows) % rows\n        nc = (c + dc + cols) % cols\n        count = count + grid[nr][nc]\n      }\n    }\n  }\n  count\n}\n\nfn step(grid) {\n  rows = len(grid)\n  cols = len(grid[0])\n  [\n    [\n      match [grid[r][c], count_neighbors(grid, r, c)] {\n        [1, n] if n < 2 => 0\n        [1, n] if n > 3 => 0\n        [1, _] => 1\n        [0, 3] => 3\n        _ => grid[r][c]\n      }\n    for c in range(cols)]\n  for r in range(rows)]\n}\n\nfn display(grid) {\n  for row in grid {\n    line = [match cell { 0 => \".\" _ => \"#\" } for cell in row]\n    print(line)\n  }\n}\n\n// Glider pattern\ngrid = make_grid(8, 8)\ngrid[1][2] = 1\ngrid[2][3] = 1\ngrid[3][1] = 1\ngrid[3][2] = 1\ngrid[3][3] = 1\n\nprint(\"Generation 0:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 1:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 2:\")\ndisplay(grid)\n"
  }
];
const REFERENCE = [
  {
    "title": "Variables",
    "items": [
      {
        "syntax": "name = \"Alice\"",
        "desc": "Immutable binding"
      },
      {
        "syntax": "var count = 0",
        "desc": "Mutable binding"
      },
      {
        "syntax": "a, b = 1, 2",
        "desc": "Multiple assignment"
      },
      {
        "syntax": "x, y = y, x",
        "desc": "Swap values"
      }
    ]
  },
  {
    "title": "Types",
    "items": [
      {
        "syntax": "Int, Float, String, Bool, Nil",
        "desc": "Primitive types"
      },
      {
        "syntax": "type Point { x: Float, y: Float }",
        "desc": "Struct type"
      },
      {
        "syntax": "type Color { Red, Blue, Custom(r: Int) }",
        "desc": "Algebraic type (ADT)"
      }
    ]
  },
  {
    "title": "Functions",
    "items": [
      {
        "syntax": "fn add(a, b) { a + b }",
        "desc": "Function (implicit return)"
      },
      {
        "syntax": "fn greet(name = \"world\") { ... }",
        "desc": "Default parameters"
      },
      {
        "syntax": "double = fn(x) x * 2",
        "desc": "Lambda expression"
      },
      {
        "syntax": "return value",
        "desc": "Early return"
      }
    ]
  },
  {
    "title": "Control Flow",
    "items": [
      {
        "syntax": "if cond { } elif { } else { }",
        "desc": "Conditionals"
      },
      {
        "syntax": "for item in items { }",
        "desc": "For-in loop"
      },
      {
        "syntax": "for i in range(10) { }",
        "desc": "Range loop"
      },
      {
        "syntax": "while cond { }",
        "desc": "While loop"
      }
    ]
  },
  {
    "title": "Pattern Matching",
    "items": [
      {
        "syntax": "match value { 0 => \"zero\", _ => \"other\" }",
        "desc": "Value matching"
      },
      {
        "syntax": "1..10 => \"small\"",
        "desc": "Range pattern"
      },
      {
        "syntax": "n if n > 100 => \"big\"",
        "desc": "Guard clause"
      },
      {
        "syntax": "Circle(r) => 3.14 * r ** 2",
        "desc": "Destructure ADT"
      }
    ]
  },
  {
    "title": "Strings",
    "items": [
      {
        "syntax": "\"Hello, {name}!\"",
        "desc": "Interpolation"
      },
      {
        "syntax": ".upper() .lower() .trim()",
        "desc": "Case methods"
      },
      {
        "syntax": ".contains(s) .starts_with(s)",
        "desc": "Search methods"
      },
      {
        "syntax": ".words() .chars() .lines()",
        "desc": "Split methods"
      },
      {
        "syntax": ".capitalize() .title_case()",
        "desc": "Format methods"
      },
      {
        "syntax": "\"-\" * 20",
        "desc": "String repeat"
      }
    ]
  },
  {
    "title": "Collections",
    "items": [
      {
        "syntax": "[1, 2, 3]",
        "desc": "Array literal"
      },
      {
        "syntax": "{key: value}",
        "desc": "Object literal"
      },
      {
        "syntax": "[x*2 for x in items if x > 0]",
        "desc": "List comprehension"
      },
      {
        "syntax": "{k: v for k in keys}",
        "desc": "Dict comprehension"
      },
      {
        "syntax": "arr[1:3]  arr[::-1]",
        "desc": "Slice syntax"
      },
      {
        "syntax": "[...a, ...b]",
        "desc": "Spread operator"
      }
    ]
  },
  {
    "title": "Operators",
    "items": [
      {
        "syntax": "+ - * / % **",
        "desc": "Arithmetic (** is power)"
      },
      {
        "syntax": "== != < <= > >=",
        "desc": "Comparison"
      },
      {
        "syntax": "and  or  not",
        "desc": "Logical"
      },
      {
        "syntax": "|>",
        "desc": "Pipe operator"
      },
      {
        "syntax": "x in list / x not in list",
        "desc": "Membership"
      },
      {
        "syntax": "1 < x < 10",
        "desc": "Chained comparison"
      },
      {
        "syntax": "a?.b",
        "desc": "Optional chaining"
      }
    ]
  },
  {
    "title": "Stdlib Functions",
    "items": [
      {
        "syntax": "print(...args)",
        "desc": "Print to console"
      },
      {
        "syntax": "len(v)",
        "desc": "Length of string/array/object"
      },
      {
        "syntax": "range(start?, end, step?)",
        "desc": "Generate number array"
      },
      {
        "syntax": "sum(arr) min(arr) max(arr)",
        "desc": "Aggregation"
      },
      {
        "syntax": "sorted(arr, key?) reversed(arr)",
        "desc": "Ordering"
      },
      {
        "syntax": "enumerate(arr)",
        "desc": "Index-value pairs"
      },
      {
        "syntax": "zip(a, b, ...)",
        "desc": "Combine arrays"
      },
      {
        "syntax": "map(arr, fn) filter(arr, fn)",
        "desc": "Transform/filter"
      },
      {
        "syntax": "type_of(value)",
        "desc": "Runtime type name"
      }
    ]
  },
  {
    "title": "Reactive (client)",
    "items": [
      {
        "syntax": "state count = 0",
        "desc": "Reactive variable (signal)"
      },
      {
        "syntax": "computed doubled = count * 2",
        "desc": "Derived value"
      },
      {
        "syntax": "effect { ... }",
        "desc": "Side effect (auto-tracks deps)"
      },
      {
        "syntax": "component App { <div>...</div> }",
        "desc": "UI component"
      },
      {
        "syntax": "on:click={fn() ...}",
        "desc": "Event handler"
      },
      {
        "syntax": "server.method()",
        "desc": "RPC call to server"
      }
    ]
  },
  {
    "title": "Full-Stack Blocks",
    "items": [
      {
        "syntax": "server { ... }",
        "desc": "Server-side code (Bun)"
      },
      {
        "syntax": "client { ... }",
        "desc": "Client-side code (browser)"
      },
      {
        "syntax": "shared { ... }",
        "desc": "Shared code (both)"
      },
      {
        "syntax": "route GET \"/path\" => handler",
        "desc": "HTTP route"
      }
    ]
  }
];
const TUTORIAL = [
  {
    "title": "Welcome to Lux",
    "description": "Lux is a modern language that compiles to JavaScript. It combines Python's readability with ML-style pattern matching and built-in reactivity.",
    "code": "// Try running this! Press Cmd/Ctrl+Enter or click Run.\nprint(\"Welcome to Lux!\")\n\n// Variables are immutable by default\nname = \"Developer\"\nprint(\"Hello, {name}!\")\n\n// Use 'var' for mutable variables\nvar count = 0\ncount += 1\nprint(\"Count: {count}\")"
  },
  {
    "title": "Functions",
    "description": "Functions use the fn keyword and return their last expression. No \"return\" needed!",
    "code": "// Implicit return — the last expression is returned\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"World\") {\n  \"Hello, {name}!\"\n}\n\nprint(add(3, 4))\nprint(greet())\nprint(greet(\"Lux\"))\n\n// Lambdas for short functions\ndouble = fn(x) x * 2\nprint(double(21))"
  },
  {
    "title": "Collections",
    "description": "Lux has powerful collection features: list comprehensions, slicing, and the pipe operator.",
    "code": "// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// Filter with comprehension\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Pipe operator for readable chains\nresult = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Slicing\narr = [10, 20, 30, 40, 50]\nprint(\"First 3: {arr[:3]}\")\nprint(\"Last 2: {arr[3:]}\")"
  },
  {
    "title": "Pattern Matching",
    "description": "Match expressions are like switch on steroids. They support values, ranges, guards, and destructuring.",
    "code": "// Match on values and ranges\nfn classify(n) {\n  match n {\n    0 => \"zero\"\n    1..10 => \"small\"\n    n if n > 100 => \"huge: {n}\"\n    _ => \"medium: {n}\"\n  }\n}\n\nfor n in [0, 3, 50, 200] {\n  print(\"{n} -> {classify(n)}\")\n}\n\n// Match on algebraic types\ntype Shape {\n  Circle(r: Float),\n  Rect(w: Float, h: Float)\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n  }\n}\n\nprint(\"Circle area: {area(Circle(5.0))}\")\nprint(\"Rect area: {area(Rect(3.0, 4.0))}\")"
  },
  {
    "title": "Types & ADTs",
    "description": "Define struct-like types and algebraic data types (tagged unions) for type-safe data modeling.",
    "code": "// Struct type\ntype User {\n  name: String\n  age: Int\n}\n\n// Algebraic type (sum type)\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn validate_age(age) {\n  if age >= 0 and age <= 150 {\n    Ok(User(\"Valid\", age))\n  } else {\n    Err(\"Age must be 0-150, got {age}\")\n  }\n}\n\nfor age in [25, -5, 200, 42] {\n  result = validate_age(age)\n  match result {\n    Ok(user) => print(\"Valid: age {user.age}\")\n    Err(msg) => print(\"Error: {msg}\")\n  }\n}"
  },
  {
    "title": "Reactive UI",
    "description": "Lux has built-in reactivity for building UIs. State changes automatically update the DOM!",
    "code": "// Switch to the \"Preview\" tab to see this in action!\nclient {\n  state count = 0\n  computed doubled = count * 2\n  computed emoji = match count {\n    0 => \"Start clicking!\"\n    c if c < 5 => \"Getting started...\"\n    c if c < 10 => \"Nice!\"\n    _ => \"On fire!\"\n  }\n\n  component App {\n    <div style=\"text-align: center; padding: 20px;\">\n      <h1>\"Lux Reactive Demo\"</h1>\n      <p style=\"font-size: 48px;\">\"{count}\"</p>\n      <p>\"Doubled: {doubled}\"</p>\n      <p>\"{emoji}\"</p>\n      <button on:click={fn() count += 1}>\"+ Add\"</button>\n      <button on:click={fn() count -= 1}>\"- Sub\"</button>\n      <button on:click={fn() count = 0}>\"Reset\"</button>\n    </div>\n  }\n}"
  },
  {
    "title": "Strings & Interpolation",
    "description": "Lux strings support interpolation with {expressions}, plus Python-style methods like .upper(), .contains(), and even string repetition.",
    "code": "// String interpolation with any expression\nname = \"World\"\nprint(\"Hello, {name}!\")\n\n// Expressions inside interpolation\nx = 7\nprint(\"{x} squared is {x * x}\")\n\n// String methods\ngreeting = \"hello world\"\nprint(greeting.upper())\nprint(greeting.capitalize())\nprint(greeting.title_case())\n\n// Useful checks\nprint(\"contains 'world': {greeting.contains(\"world\")}\")\nprint(\"starts with 'hello': {greeting.starts_with(\"hello\")}\")\n\n// String repetition\nborder = \"=\" * 30\nprint(border)\nprint(\"  Lux is great!\")\nprint(border)"
  },
  {
    "title": "Pipe Operator",
    "description": "The pipe operator |> chains function calls, making data transformations read top-to-bottom instead of inside-out.",
    "code": "// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\n\nprint(\"Sum of squares of evens: {result}\")\n\n// Name pipeline\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\"]\nsorted_long = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\nprint(\"Long names sorted: {sorted_long}\")\n\n// Simple value pipeline\n42 |> fn(x) x * 2 |> fn(x) \"Answer: {x}\" |> print()"
  },
  {
    "title": "Full-Stack App",
    "description": "Lux has built-in full-stack blocks: server, client, and shared. In the playground, server features are simulated.",
    "code": "// A full-stack app has server + client blocks.\n// In playground mode, server calls are stubbed.\n\nclient {\n  state name = \"World\"\n  computed greeting = \"Hello, {name}!\"\n\n  component App {\n    <div style=\"padding: 20px;\">\n      <h1>\"Full-Stack Demo\"</h1>\n      <div class=\"input-group\">\n        <label>\"Your name:\"</label>\n        <input type=\"text\" value={name}\n               on:input={fn(e) name = e.target.value} />\n      </div>\n      <p style=\"font-size: 24px; margin-top: 16px;\">\"{greeting}\"</p>\n      <p class=\"hint\">\"(Type to see reactive updates!)\"</p>\n    </div>\n  }\n}"
  },
  {
    "title": "Advanced Patterns",
    "description": "Combine pattern matching with algebraic types, guards, and destructuring for expressive code.",
    "code": "// Result type with pattern matching\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_number(s) {\n  n = s * 1  // coerce to number\n  if n != n { Err(\"Not a number: {s}\") }\n  else { Ok(n) }\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { Err(\"Division by zero\") }\n  else { Ok(a / b) }\n}\n\n// Chain operations with match\ninputs = [[\"10\", \"2\"], [\"42\", \"0\"], [\"abc\", \"5\"], [\"100\", \"4\"]]\nfor pair in inputs {\n  result = match parse_number(pair[0]) {\n    Err(msg) => Err(msg)\n    Ok(a) => match parse_number(pair[1]) {\n      Err(msg) => Err(msg)\n      Ok(b) => safe_divide(a, b)\n    }\n  }\n  match result {\n    Ok(v) => print(\"{pair[0]} / {pair[1]} = {v}\")\n    Err(msg) => print(\"{pair[0]} / {pair[1]} -> Error: {msg}\")\n  }\n}"
  }
];

// ─── State ──────────────────────────────────────────
let autoCompile = true;
let autoRun = true;
let sidebarMode = null; // 'reference' | 'tutorial' | null
let tutorialStep = 0;
let compileTimer = null;

// ─── Restore settings from localStorage ─────────────
try {
  const saved = JSON.parse(localStorage.getItem('lux-playground-settings') || '{}');
  if (saved.fontSize) document.documentElement.style.setProperty('--editor-font-size', saved.fontSize + 'px');
  if (saved.fontSize) document.getElementById('setting-fontsize').value = saved.fontSize;
  if (saved.autoCompile === false) { autoCompile = false; document.getElementById('setting-autocompile').classList.remove('on'); }
  if (saved.autoRun === false) { autoRun = false; document.getElementById('setting-autorun').classList.remove('on'); }
} catch(e) {}

function saveSettings() {
  try {
    localStorage.setItem('lux-playground-settings', JSON.stringify({
      fontSize: parseInt(document.getElementById('setting-fontsize').value),
      autoCompile,
      autoRun
    }));
  } catch(e) {}
}

// ─── Editor Setup ───────────────────────────────────
const statusCursor = document.getElementById('status-cursor');

// Restore last code or use first example
let initialCode = EXAMPLES[0].code;
try {
  const lastCode = localStorage.getItem('lux-playground-code');
  if (lastCode && lastCode.trim()) initialCode = lastCode;
} catch(e) {}

const editor = new EditorView({
  state: EditorState.create({
    doc: initialCode,
    extensions: [
      basicSetup,
      oneDark,
      luxLanguage,
      errorField,
      autocompletion({
        override: [luxCompletions],
        icons: true,
        activateOnTyping: true,
      }),
      EditorView.updateListener.of(update => {
        if (update.docChanged) {
          try { localStorage.setItem('lux-playground-code', update.state.doc.toString()); } catch(e) {}
          if (autoCompile) scheduleCompile();
        }
        if (update.selectionSet) {
          const pos = update.state.selection.main.head;
          const line = update.state.doc.lineAt(pos);
          const lines = update.state.doc.lines;
          const chars = update.state.doc.length;
          statusCursor.textContent = 'Ln ' + line.number + ', Col ' + (pos - line.from + 1) + '  |  ' + lines + ' lines, ' + chars + ' chars';
        }
      }),
      keymap.of([
        { key: 'Mod-Enter', run: () => { compile(); return true; } },
        { key: 'Mod-k', run: () => { toggleCommandPalette(); return true; } },
        { key: 'Mod-s', run: () => {
          try { localStorage.setItem('lux-playground-code', editor.state.doc.toString()); } catch(e) {}
          const s = document.getElementById('status-compile');
          s.className = 'success'; s.textContent = 'Saved to browser';
          setTimeout(() => compile(), 1000);
          return true;
        }},
        { key: 'Mod-Shift-r', run: () => { toggleSidebar('reference'); return true; } },
        { key: 'Mod-Shift-s', run: () => { downloadCode(); return true; } },
        { key: 'Mod-/', run: () => { toggleModal('shortcuts-modal'); return true; } },
        { key: 'Mod-j', run: () => { toggleLayout(); return true; } },
      ]),
    ],
  }),
  parent: document.getElementById('editor'),
});

// ─── Populate Examples (with optgroups) ─────────────
const exSelect = document.getElementById('examples-select');
let optgroup = null;
let currentCat = null;
EXAMPLES.forEach((ex, i) => {
  if (ex.category !== currentCat) {
    currentCat = ex.category;
    optgroup = document.createElement('optgroup');
    optgroup.label = currentCat;
    exSelect.appendChild(optgroup);
  }
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = ex.name;
  optgroup.appendChild(opt);
});
exSelect.addEventListener('change', () => {
  const code = EXAMPLES[+exSelect.value].code;
  setEditorCode(code);
  exSelect.value = '';
});

function setEditorCode(code) {
  editor.dispatch({ changes: { from: 0, to: editor.state.doc.length, insert: code } });
  compile();
}

// ─── Output Tabs ────────────────────────────────────
function switchTab(tabName) {
  document.querySelectorAll('#output-tabs .tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.output-panel').forEach(p => p.classList.remove('active'));
  const tab = document.querySelector('#output-tabs .tab[data-tab="' + tabName + '"]');
  if (tab) tab.classList.add('active');
  const panel = document.getElementById('panel-' + tabName);
  if (panel) panel.classList.add('active');
}

document.querySelectorAll('#output-tabs .tab').forEach(tab => {
  tab.addEventListener('click', () => switchTab(tab.dataset.tab));
});

// ─── Drag Handle ────────────────────────────────────
const dragHandle = document.getElementById('drag-handle');
const mainEl = document.querySelector('.main');
const editorPane = document.querySelector('.pane-editor');
const outputPane = document.querySelector('.pane-output');

let dragging = false;
dragHandle.addEventListener('mousedown', e => { dragging = true; dragHandle.classList.add('active'); e.preventDefault(); });
document.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = mainEl.getBoundingClientRect();
  const sidebarW = sidebarMode ? parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w')) : 0;
  const availW = rect.width - sidebarW;
  const pct = ((e.clientX - rect.left) / availW) * 100;
  const clamped = Math.max(20, Math.min(80, pct));
  editorPane.style.flex = 'none';
  editorPane.style.width = clamped + '%';
  outputPane.style.flex = '1';
});
document.addEventListener('mouseup', () => { dragging = false; dragHandle.classList.remove('active'); });

// ─── Share ──────────────────────────────────────────
document.getElementById('btn-share').addEventListener('click', () => {
  const code = editor.state.doc.toString();
  const compressed = LZString.compressToEncodedURIComponent(code);
  const url = location.origin + location.pathname + '#code=' + compressed;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('btn-share');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Share'; }, 2000);
  });
});

// ─── Download ───────────────────────────────────────
function downloadCode() {
  const code = editor.state.doc.toString();
  const blob = new Blob([code], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'playground.lux';
  a.click();
  URL.revokeObjectURL(a.href);
}
document.getElementById('btn-download').addEventListener('click', downloadCode);

// ─── Load from URL hash ─────────────────────────────
function loadFromHash() {
  const hash = location.hash.slice(1);
  if (hash.startsWith('code=')) {
    try {
      const code = LZString.decompressFromEncodedURIComponent(hash.slice(5));
      if (code) { setEditorCode(code); return true; }
    } catch (e) {}
  }
  return false;
}
loadFromHash();

// ─── Run Button ─────────────────────────────────────
document.getElementById('btn-run').addEventListener('click', compile);

// ─── Debounced Compile ──────────────────────────────
function scheduleCompile() {
  clearTimeout(compileTimer);
  compileTimer = setTimeout(compile, 350);
}

// ─── Compiler ───────────────────────────────────────
let lastJsText = '';

function compile() {
  const source = editor.state.doc.toString();
  const statusEl = document.getElementById('status-compile');
  const statusSize = document.getElementById('status-size');
  const errorBanner = document.getElementById('error-banner');
  const errorText = document.getElementById('error-text');
  const errorHint = document.getElementById('error-hint');
  const consoleOutput = document.getElementById('console-output');
  const consoleBadge = document.getElementById('console-badge');
  const consoleTimingEl = document.getElementById('console-timing');
  const astOutput = document.getElementById('ast-output');
  const previewFrame = document.getElementById('preview-frame');

  errorBanner.classList.remove('visible');
  errorText.textContent = '';
  if (errorHint) errorHint.textContent = '';
  consoleOutput.innerHTML = '';
  consoleBadge.style.display = 'none';

  // Clear error decorations
  editor.dispatch({ effects: clearErrorEffect.of(null) });

  const start = performance.now();

  try {
    const lexer = new Lexer(source, 'playground.lux');
    const tokens = lexer.tokenize();

    const parser = new Parser(tokens, 'playground.lux');
    const ast = parser.parse();

    const analyzer = new Analyzer(ast, 'playground.lux');
    const { warnings } = analyzer.analyze();

    const codegen = new CodeGenerator(ast, 'playground.lux');
    const result = codegen.generate();

    const elapsed = (performance.now() - start).toFixed(1);

    // JS Output
    let jsText = '';
    if (result.shared) jsText += '// ── Shared ──\n' + result.shared + '\n\n';
    if (result.server) jsText += '// ── Server ──\n' + result.server + '\n\n';
    if (result.client) jsText += '// ── Client ──\n' + result.client + '\n\n';
    if (!result.shared && !result.server && !result.client && result.code) {
      jsText = result.code;
    }
    lastJsText = jsText || '// No output';

    // Update JS output (use CodeMirror read-only editor if available, else pre tag)
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: lastJsText } });
    } else {
      document.getElementById('js-output').textContent = lastJsText;
    }

    // Status bar output size
    if (statusSize) statusSize.textContent = (lastJsText.length / 1024).toFixed(1) + ' KB output';

    // AST
    astOutput.innerHTML = '';
    astOutput.appendChild(renderAST(ast));

    // Console + Preview
    if (autoRun) {
      executeCode(result, consoleOutput, previewFrame, consoleBadge, consoleTimingEl);
    }

    // Warnings
    const warnCount = warnings ? warnings.length : 0;
    if (warnCount) {
      for (const w of warnings) {
        const div = document.createElement('div');
        div.className = 'log-warn';
        div.innerHTML = '<span class="log-icon">\u26A0</span> Warning: ' + escapeHtml(w.message || String(w));
        consoleOutput.appendChild(div);
      }
    }

    statusEl.className = 'success';
    statusEl.textContent = '\u2713 Compiled in ' + elapsed + 'ms' + (warnCount ? ' (' + warnCount + ' warning' + (warnCount > 1 ? 's' : '') + ')' : '');

  } catch (err) {
    const elapsed = (performance.now() - start).toFixed(1);
    statusEl.className = 'error';
    statusEl.textContent = '\u2717 Error (' + elapsed + 'ms)';
    errorText.textContent = err.message;

    // Error hints for common mistakes
    const hints = getErrorHint(err.message);
    if (errorHint && hints) errorHint.textContent = hints;

    errorBanner.classList.add('visible');
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: '// Compilation error\n// ' + err.message } });
    } else {
      document.getElementById('js-output').textContent = '// Compilation error\n// ' + err.message;
    }
    previewFrame.srcdoc = '';

    // Highlight error line in editor with decorations
    const lineMatch = err.message.match(/:(\d+):/);
    if (lineMatch) {
      const lineNum = parseInt(lineMatch[1]);
      editor.dispatch({ effects: setErrorEffect.of([lineNum]) });
      // Scroll to error line
      try {
        const lineInfo = editor.state.doc.line(lineNum);
        editor.dispatch({ selection: { anchor: lineInfo.from } });
      } catch(e) {}
    }
  }
}

function getErrorHint(msg) {
  if (msg.includes('Unexpected token')) return 'Tip: Check for missing closing brackets or semicolons';
  if (msg.includes('not defined')) return 'Tip: Make sure the variable is declared before use';
  if (msg.includes('Expected')) return 'Tip: The compiler expected a different token here';
  return null;
}

// ─── Execute Code ───────────────────────────────────
function executeCode(result, consoleEl, previewFrame, consoleBadge, consoleTimingEl) {
  const logs = [];
  const fakeConsole = {
    log: (...args) => logs.push({ type: 'log', args }),
    warn: (...args) => logs.push({ type: 'warn', args }),
    error: (...args) => logs.push({ type: 'error', args }),
    info: (...args) => logs.push({ type: 'info', args }),
  };

  const execStart = performance.now();
  const codeToRun = result.code || result.shared || '';
  if (codeToRun.trim()) {
    try {
      const fn = new Function('console', STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n' + codeToRun);
      fn(fakeConsole);
    } catch (e) {
      logs.push({ type: 'error', args: ['Runtime Error: ' + e.message] });
    }
  }
  const execTime = (performance.now() - execStart).toFixed(2);

  if (consoleTimingEl) consoleTimingEl.textContent = 'Executed in ' + execTime + 'ms';

  // Render logs with icons and better formatting
  const icons = { log: '\u203A', warn: '\u26A0', error: '\u2717', info: '\u2139' };
  let errorCount = 0;
  for (const log of logs) {
    const div = document.createElement('div');
    div.className = 'log-' + log.type;
    const icon = document.createElement('span');
    icon.className = 'log-icon';
    icon.textContent = icons[log.type] || '';
    div.appendChild(icon);
    const content = document.createElement('span');
    content.className = 'log-content';
    const textParts = log.args.map(a => {
      if (a === null) return 'null';
      if (a === undefined) return 'undefined';
      if (typeof a === 'object') {
        try { return JSON.stringify(a, null, 2); } catch(e) { return String(a); }
      }
      return String(a);
    });
    content.textContent = textParts.join(' ');
    div.appendChild(content);
    consoleEl.appendChild(div);
    if (log.type === 'error') errorCount++;
  }

  // Badge for errors
  if (errorCount > 0) {
    consoleBadge.textContent = errorCount;
    consoleBadge.style.display = 'inline';
    switchTab('console');
  }

  // Auto-switch to console if there are logs and no client code
  if (logs.length > 0 && !result.client) {
    switchTab('console');
  }

  // Live Preview for client code
  if (result.client) {
    const clientCode = result.client
      .replace(/import\s+.*from\s+['"].*['"];?/g, '')
      .replace(/import\s+['"].*['"];?/g, '');

    const previewHTML = `<!DOCTYPE html>
<html><head><meta charset="UTF-8">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 20px; color: #333; }
  button { cursor: pointer; padding: 8px 16px; margin: 4px; border-radius: 6px; border: 1px solid #ddd; background: #f5f5f5; font-size: 14px; transition: all 0.15s; }
  button:hover { background: #e8e8e8; border-color: #ccc; }
  button:active { transform: scale(0.97); }
  input[type="text"], input[type="number"] { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; margin: 4px; font-size: 14px; outline: none; }
  input[type="text"]:focus, input[type="number"]:focus { border-color: #7c3aed; box-shadow: 0 0 0 3px rgba(124,58,237,0.1); }
  input[type="range"] { width: 200px; margin: 8px 0; }
  input[type="checkbox"] { margin: 4px 8px 4px 0; }
  ul { list-style: none; } li { padding: 6px 0; }
  h1 { margin-bottom: 16px; font-size: 24px; } h2 { margin-bottom: 12px; font-size: 20px; }
  p { margin: 6px 0; line-height: 1.5; }
  .status { color: #666; font-size: 14px; margin-top: 12px; }
  .counter-app, .todo-app, .converter, .stopwatch { max-width: 400px; }
  .count { font-size: 48px; font-weight: 700; color: #7c3aed; }
  .buttons { display: flex; gap: 4px; margin-top: 8px; }
  .input-row { display: flex; gap: 4px; margin-bottom: 12px; }
  .input-row input { flex: 1; }
  .todo-item { display: flex; align-items: center; gap: 8px; }
  .todo-text { flex: 1; }
  .input-group { margin: 12px 0; }
  .input-group label { display: block; font-weight: 600; margin-bottom: 4px; }
  .value { font-size: 18px; font-weight: 600; color: #7c3aed; margin-left: 8px; }
  .desc { font-style: italic; color: #666; }
  .time { font-size: 48px; font-weight: 700; color: #7c3aed; margin: 16px 0; }
  .controls { display: flex; gap: 4px; flex-wrap: wrap; }
  .hint { color: #999; font-size: 12px; margin-top: 12px; }
</style>
</head><body>
<div id="app"></div>
<script>
${RUNTIME_CODE}
${STDLIB_CODE}
${STRING_PROTO_CODE}

const server = new Proxy({}, {
  get(_, method) {
    return async (...args) => {
      console.warn('[Playground] RPC server.' + method + '() is not available in playground mode');
      return null;
    };
  }
});

${(result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '')}
${clientCode}

if (typeof App === 'function') {
  document.addEventListener('DOMContentLoaded', () => {
    mount(App, document.getElementById('app'));
  });
  if (document.readyState !== 'loading') {
    mount(App, document.getElementById('app'));
  }
}
<\/script>
</body></html>`;
    previewFrame.srcdoc = previewHTML;
    // Auto-switch to preview when there's a client block
    switchTab('preview');
  } else {
    previewFrame.srcdoc = '<html><body style="font-family:sans-serif;padding:20px;color:#aaa"><p>Write a <code>client { }</code> block with a <code>component App</code> to see a live preview here.</p></body></html>';
  }
}

// ─── AST Renderer ───────────────────────────────────
function renderAST(node, depth = 0) {
  if (node === null || node === undefined) {
    const span = document.createElement('span');
    span.className = 'ast-null'; span.textContent = 'null'; return span;
  }
  if (typeof node !== 'object') {
    const span = document.createElement('span');
    if (typeof node === 'string') { span.className = 'ast-string'; span.textContent = '"' + node + '"'; }
    else if (typeof node === 'number') { span.className = 'ast-number'; span.textContent = String(node); }
    else if (typeof node === 'boolean') { span.className = 'ast-bool'; span.textContent = String(node); }
    else { span.textContent = String(node); }
    return span;
  }
  if (Array.isArray(node)) {
    if (node.length === 0) { const s = document.createElement('span'); s.className = 'ast-null'; s.textContent = '[]'; return s; }
    const c = document.createElement('div'); c.className = 'ast-node';
    const t = document.createElement('span'); t.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
    t.textContent = 'Array[' + node.length + ']';
    const ch = document.createElement('div'); ch.className = 'ast-children' + (depth < 2 ? ' open' : '');
    t.addEventListener('click', () => { t.classList.toggle('open'); ch.classList.toggle('open'); });
    for (let i = 0; i < node.length; i++) {
      const r = document.createElement('div'); r.className = 'ast-node';
      const k = document.createElement('span'); k.className = 'ast-key'; k.textContent = i + ': ';
      r.appendChild(k); r.appendChild(renderAST(node[i], depth + 1)); ch.appendChild(r);
    }
    c.appendChild(t); c.appendChild(ch); return c;
  }
  const container = document.createElement('div'); container.className = 'ast-node';
  const typeName = node.constructor?.name || 'Object';
  const keys = Object.keys(node).filter(k => k !== 'line' && k !== 'column');
  if (keys.length === 0) { const s = document.createElement('span'); s.className = 'ast-type'; s.textContent = typeName; container.appendChild(s); return container; }
  const toggle = document.createElement('span'); toggle.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
  const typeSpan = document.createElement('span'); typeSpan.className = 'ast-type'; typeSpan.textContent = typeName;
  toggle.appendChild(typeSpan);
  const children = document.createElement('div'); children.className = 'ast-children' + (depth < 2 ? ' open' : '');
  toggle.addEventListener('click', () => { toggle.classList.toggle('open'); children.classList.toggle('open'); });
  for (const key of keys) {
    const row = document.createElement('div'); row.className = 'ast-node';
    const keySpan = document.createElement('span'); keySpan.className = 'ast-key'; keySpan.textContent = key + ': ';
    row.appendChild(keySpan); row.appendChild(renderAST(node[key], depth + 1)); children.appendChild(row);
  }
  container.appendChild(toggle); container.appendChild(children);
  return container;
}

// ─── Sidebar (Reference / Tutorial) ─────────────────
const sidebar = document.getElementById('sidebar');
const sidebarBody = document.getElementById('sidebar-body');
const sidebarTitle = document.getElementById('sidebar-title');
const tutorialNav = document.getElementById('tutorial-nav');

function toggleSidebar(mode) {
  if (sidebarMode === mode) {
    sidebar.classList.remove('open');
    sidebarMode = null;
    document.getElementById('btn-reference').classList.remove('active');
    document.getElementById('btn-tutorial').classList.remove('active');
    return;
  }
  sidebarMode = mode;
  sidebar.classList.add('open');

  document.getElementById('btn-reference').classList.toggle('active', mode === 'reference');
  document.getElementById('btn-tutorial').classList.toggle('active', mode === 'tutorial');

  if (mode === 'reference') {
    sidebarTitle.textContent = 'Lux Reference';
    tutorialNav.style.display = 'none';
    renderReference();
  } else if (mode === 'tutorial') {
    sidebarTitle.textContent = 'Learn Lux';
    tutorialNav.style.display = 'flex';
    renderTutorialStep();
  }
}

function renderTutorialStep() {
  sidebarBody.innerHTML = '';
  const step = TUTORIAL[tutorialStep];
  if (!step) return;

  // Progress dots
  const progress = document.createElement('div');
  progress.className = 'tutorial-progress';
  for (let i = 0; i < TUTORIAL.length; i++) {
    const dot = document.createElement('div');
    dot.className = 'tutorial-dot' + (i === tutorialStep ? ' active' : '') + (i < tutorialStep ? ' completed' : '');
    dot.addEventListener('click', () => { tutorialStep = i; renderTutorialStep(); });
    progress.appendChild(dot);
  }
  sidebarBody.appendChild(progress);

  const div = document.createElement('div');
  div.className = 'tutorial-step';
  div.innerHTML = '<h4>' + (tutorialStep + 1) + '. ' + escapeHtml(step.title) + '</h4>'
    + '<p>' + escapeHtml(step.description) + '</p>';
  const tryBtn = document.createElement('button');
  tryBtn.className = 'try-btn';
  tryBtn.textContent = '\u25B6 Try this code';
  tryBtn.addEventListener('click', () => { setEditorCode(step.code); });
  div.appendChild(tryBtn);
  sidebarBody.appendChild(div);

  // Update nav buttons
  document.getElementById('tut-prev').disabled = tutorialStep === 0;
  document.getElementById('tut-next').textContent = tutorialStep === TUTORIAL.length - 1 ? 'Finish \u2713' : 'Next \u2192';
}

document.getElementById('btn-reference').addEventListener('click', () => toggleSidebar('reference'));
document.getElementById('btn-tutorial').addEventListener('click', () => toggleSidebar('tutorial'));
document.getElementById('sidebar-close').addEventListener('click', () => toggleSidebar(sidebarMode));

document.getElementById('tut-prev').addEventListener('click', () => {
  if (tutorialStep > 0) { tutorialStep--; renderTutorialStep(); }
});
document.getElementById('tut-next').addEventListener('click', () => {
  if (tutorialStep < TUTORIAL.length - 1) { tutorialStep++; renderTutorialStep(); }
  else { toggleSidebar('tutorial'); }
});

// ─── Settings ───────────────────────────────────────
document.getElementById('btn-settings').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('settings-dropdown').classList.toggle('visible');
});
document.addEventListener('click', (e) => {
  if (!e.target.closest('#settings-dropdown') && !e.target.closest('#btn-settings')) {
    document.getElementById('settings-dropdown').classList.remove('visible');
  }
});
document.getElementById('setting-fontsize').addEventListener('change', (e) => {
  document.documentElement.style.setProperty('--editor-font-size', e.target.value + 'px');
  saveSettings();
});
document.getElementById('setting-autocompile').addEventListener('click', function() {
  autoCompile = !autoCompile;
  this.classList.toggle('on', autoCompile);
  saveSettings();
});
document.getElementById('setting-autorun').addEventListener('click', function() {
  autoRun = !autoRun;
  this.classList.toggle('on', autoRun);
  saveSettings();
});

// ─── Keyboard Shortcuts Modal ───────────────────────
function toggleModal(id) {
  document.getElementById(id).classList.toggle('visible');
}
document.getElementById('btn-shortcuts').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-close').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) toggleModal('shortcuts-modal');
});

// ─── Error banner click → jump to error line ────────
document.getElementById('error-banner').addEventListener('click', () => {
  const text = document.getElementById('error-text').textContent;
  const lineMatch = text.match(/:(\d+):/);
  if (lineMatch) {
    const line = parseInt(lineMatch[1]);
    try {
      const lineInfo = editor.state.doc.line(line);
      editor.dispatch({ selection: { anchor: lineInfo.from } });
      editor.focus();
    } catch(e) {}
  }
});

// ─── JS Output Editor (read-only CodeMirror) ────────
try {
  const jsEditorParent = document.getElementById('js-output-editor');
  if (jsEditorParent) {
    window.jsEditor = new EditorView({
      state: EditorState.create({
        doc: '// Compiled JS output will appear here',
        extensions: [
          basicSetup,
          oneDark,
          EditorState.readOnly.of(true),
          EditorView.editable.of(false),
        ],
      }),
      parent: jsEditorParent,
    });
  }
} catch(e) { console.warn('JS output editor init failed:', e); }

// ─── Console Buttons ────────────────────────────────
document.getElementById('btn-clear-console').addEventListener('click', () => {
  document.getElementById('console-output').innerHTML = '';
  document.getElementById('console-timing').textContent = '';
  const badge = document.getElementById('console-badge');
  badge.style.display = 'none';
});

document.getElementById('btn-copy-console').addEventListener('click', () => {
  const text = document.getElementById('console-output').innerText;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btn-copy-console');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
});

// ─── Command Palette ────────────────────────────────
let cmdPaletteOpen = false;
let cmdSelectedIndex = 0;

function getCommandItems(query) {
  const q = query.toLowerCase();
  const items = [];

  // Actions
  const actions = [
    { icon: '\u25B6', label: 'Run Code', category: 'Action', shortcut: '\u2318Enter', action: () => compile() },
    { icon: '\u2197', label: 'Share URL', category: 'Action', action: () => document.getElementById('btn-share').click() },
    { icon: '\u2913', label: 'Download .lux', category: 'Action', shortcut: '\u2318\u21E7S', action: () => downloadCode() },
    { icon: '\uD83D\uDCE4', label: 'Export as HTML', category: 'Action', action: () => exportAsHTML() },
    { icon: '\uD83D\uDCD6', label: 'Toggle Reference', category: 'Action', shortcut: '\u2318\u21E7R', action: () => toggleSidebar('reference') },
    { icon: '\uD83C\uDF93', label: 'Start Tutorial', category: 'Action', action: () => toggleSidebar('tutorial') },
    { icon: '\u2699', label: 'Toggle Light Theme', category: 'Action', action: () => document.getElementById('setting-theme').click() },
    { icon: '\u2B12', label: 'Toggle Layout', category: 'Action', shortcut: '\u2318J', action: () => toggleLayout() },
  ];

  for (const a of actions) {
    if (!q || a.label.toLowerCase().includes(q)) items.push(a);
  }

  // Examples
  for (let i = 0; i < EXAMPLES.length; i++) {
    const ex = EXAMPLES[i];
    if (!q || ex.name.toLowerCase().includes(q) || ex.category.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDCC4',
        label: ex.name,
        category: ex.category,
        action: () => { setEditorCode(ex.code); }
      });
    }
  }

  // Reference sections
  for (const section of REFERENCE) {
    if (!q || section.title.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDD0D',
        label: section.title,
        category: 'Reference',
        action: () => { toggleSidebar('reference'); }
      });
    }
  }

  return items;
}

function renderCommandPalette(query) {
  const results = document.getElementById('cmd-results');
  const items = getCommandItems(query || '');
  results.innerHTML = '';
  cmdSelectedIndex = 0;

  if (items.length === 0) {
    results.innerHTML = '<div class="cmd-palette-empty">No results found</div>';
    return;
  }

  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'cmd-palette-item' + (i === 0 ? ' selected' : '');
    div.innerHTML = '<span class="cmd-icon">' + item.icon + '</span>'
      + '<span class="cmd-label">' + escapeHtml(item.label) + '</span>'
      + '<span class="cmd-category">' + escapeHtml(item.category) + '</span>'
      + (item.shortcut ? '<span class="cmd-shortcut">' + item.shortcut + '</span>' : '');
    div.addEventListener('click', () => { item.action(); closeCommandPalette(); });
    div.addEventListener('mouseenter', () => {
      results.querySelectorAll('.cmd-palette-item').forEach(el => el.classList.remove('selected'));
      div.classList.add('selected');
      cmdSelectedIndex = i;
    });
    results.appendChild(div);
  });

  window._cmdItems = items;
}

function toggleCommandPalette() {
  if (cmdPaletteOpen) { closeCommandPalette(); return; }
  cmdPaletteOpen = true;
  document.getElementById('cmd-palette').classList.add('visible');
  const input = document.getElementById('cmd-input');
  input.value = '';
  renderCommandPalette('');
  input.focus();
}

function closeCommandPalette() {
  cmdPaletteOpen = false;
  document.getElementById('cmd-palette').classList.remove('visible');
  editor.focus();
}

document.getElementById('cmd-input').addEventListener('input', (e) => {
  renderCommandPalette(e.target.value);
});

document.getElementById('cmd-input').addEventListener('keydown', (e) => {
  const results = document.getElementById('cmd-results');
  const items = results.querySelectorAll('.cmd-palette-item');
  if (e.key === 'Escape') { closeCommandPalette(); e.preventDefault(); return; }
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    cmdSelectedIndex = Math.min(cmdSelectedIndex + 1, items.length - 1);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    cmdSelectedIndex = Math.max(cmdSelectedIndex - 1, 0);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'Enter') {
    e.preventDefault();
    if (window._cmdItems && window._cmdItems[cmdSelectedIndex]) {
      window._cmdItems[cmdSelectedIndex].action();
      closeCommandPalette();
    }
  }
});

document.getElementById('cmd-palette').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) closeCommandPalette();
});

// Global Cmd+K for command palette
document.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
    e.preventDefault();
    toggleCommandPalette();
  }
  if (e.key === 'Escape' && cmdPaletteOpen) {
    closeCommandPalette();
  }
});

// ─── Layout Toggle ──────────────────────────────────
let layoutVertical = false;
try {
  layoutVertical = localStorage.getItem('lux-playground-layout') === 'vertical';
} catch(e) {}

function toggleLayout() {
  layoutVertical = !layoutVertical;
  document.querySelector('.main').classList.toggle('vertical', layoutVertical);
  try { localStorage.setItem('lux-playground-layout', layoutVertical ? 'vertical' : 'horizontal'); } catch(e) {}
}

// Apply saved layout
if (layoutVertical) document.querySelector('.main').classList.add('vertical');

document.getElementById('btn-layout').addEventListener('click', toggleLayout);

// ─── Theme Toggle ───────────────────────────────────
let lightTheme = false;
try { lightTheme = localStorage.getItem('lux-playground-theme') === 'light'; } catch(e) {}

function applyTheme() {
  document.body.classList.toggle('light-theme', lightTheme);
  document.getElementById('setting-theme').classList.toggle('on', lightTheme);
}

document.getElementById('setting-theme').addEventListener('click', function() {
  lightTheme = !lightTheme;
  applyTheme();
  try { localStorage.setItem('lux-playground-theme', lightTheme ? 'light' : 'dark'); } catch(e) {}
  saveSettings();
});

applyTheme();

// ─── Export as HTML ─────────────────────────────────
function exportAsHTML() {
  if (!lastJsText || lastJsText.startsWith('// No output') || lastJsText.startsWith('// Compilation')) {
    alert('Nothing to export — compile your code first.');
    return;
  }
  const source = editor.state.doc.toString();
  const hasClient = source.includes('client {') || source.includes('client{');

  let exportHTML;
  if (hasClient) {
    // Export client app as standalone HTML
    try {
      const lexer = new Lexer(source, 'export.lux');
      const tokens = lexer.tokenize();
      const parser = new Parser(tokens, 'export.lux');
      const ast = parser.parse();
      const analyzer = new Analyzer(ast, 'export.lux');
      analyzer.analyze();
      const codegen = new CodeGenerator(ast, 'export.lux');
      const result = codegen.generate();
      const clientCode = (result.client || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');
      exportHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8"><title>Lux App</title>\n'
        + '<style>*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}'
        + 'body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;padding:20px;color:#333}'
        + 'button{cursor:pointer;padding:8px 16px;margin:4px;border-radius:6px;border:1px solid #ddd;background:#f5f5f5;font-size:14px}'
        + 'input[type="text"],input[type="number"]{padding:8px 12px;border:1px solid #ddd;border-radius:6px;margin:4px;font-size:14px}'
        + '</style></head><body><div id="app"></div>\n<script>\n'
        + RUNTIME_CODE + '\n' + STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n'
        + (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '') + '\n'
        + clientCode + '\n'
        + 'if(typeof App==="function"){mount(App,document.getElementById("app"));}\n'
        + '<\/script></body></html>';
    } catch(e) {
      exportHTML = '<!-- Export failed: ' + e.message + ' -->';
    }
  } else {
    // Export as Node/Bun script
    exportHTML = '// Generated by Lux Playground\n' + STDLIB_CODE + '\n' + lastJsText;
  }

  const blob = new Blob([exportHTML], { type: hasClient ? 'text/html' : 'text/javascript' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = hasClient ? 'lux-app.html' : 'lux-output.js';
  a.click();
  URL.revokeObjectURL(a.href);
}

document.getElementById('btn-export').addEventListener('click', exportAsHTML);

// ─── Embed Mode ─────────────────────────────────────
if (new URLSearchParams(location.search).get('embed') === 'true') {
  document.body.classList.add('embed-mode');
}

// ─── Reference Search & Runnable Snippets ───────────
function renderReference() {
  sidebarBody.innerHTML = '';

  // Search box
  const searchBox = document.createElement('input');
  searchBox.type = 'text';
  searchBox.placeholder = 'Search reference...';
  searchBox.style.cssText = 'width:calc(100% - 28px);margin:8px 14px;padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;outline:none;font-family:var(--font-sans);';
  searchBox.addEventListener('input', () => renderRefSections(searchBox.value));
  sidebarBody.appendChild(searchBox);

  const container = document.createElement('div');
  container.id = 'ref-container';
  sidebarBody.appendChild(container);

  renderRefSections('');
}

function renderRefSections(query) {
  const container = document.getElementById('ref-container');
  if (!container) return;
  container.innerHTML = '';
  const q = query.toLowerCase();

  for (const section of REFERENCE) {
    const matchingItems = section.items.filter(item =>
      !q || section.title.toLowerCase().includes(q) || item.syntax.toLowerCase().includes(q) || item.desc.toLowerCase().includes(q)
    );
    if (matchingItems.length === 0) continue;

    const div = document.createElement('div');
    div.className = 'ref-section';
    const title = document.createElement('div');
    title.className = 'ref-title' + (q ? ' open' : '');
    title.textContent = section.title;
    const items = document.createElement('div');
    items.className = 'ref-items' + (q ? ' open' : '');
    for (const item of matchingItems) {
      const row = document.createElement('div');
      row.className = 'ref-item';
      row.style.cursor = 'pointer';
      row.innerHTML = '<code>' + escapeHtml(item.syntax) + '</code><span class="ref-desc"> \u2014 ' + escapeHtml(item.desc) + '</span>';
      row.title = 'Click to insert into editor';
      row.addEventListener('click', () => {
        // Insert the syntax at cursor position
        const pos = editor.state.selection.main.head;
        editor.dispatch({ changes: { from: pos, insert: item.syntax } });
        editor.focus();
      });
      items.appendChild(row);
    }
    title.addEventListener('click', () => { title.classList.toggle('open'); items.classList.toggle('open'); });
    div.appendChild(title);
    div.appendChild(items);
    container.appendChild(div);
  }

  // Open first two sections by default when no search
  if (!q) {
    const titles = container.querySelectorAll('.ref-title');
    const itemSections = container.querySelectorAll('.ref-items');
    if (titles[0]) { titles[0].classList.add('open'); itemSections[0].classList.add('open'); }
    if (titles[1]) { titles[1].classList.add('open'); itemSections[1].classList.add('open'); }
  }
}

// ─── Welcome Toast ──────────────────────────────────
if (!localStorage.getItem('lux-playground-welcomed')) {
  const toast = document.createElement('div');
  toast.className = 'welcome-toast';
  toast.innerHTML = 'Welcome! Try the <strong style="color:var(--accent);margin:0 2px">Learn</strong> button, or press <span class="kbd-hint">Cmd+Enter</span> to run code. <button class="close-toast" aria-label="Close">\u2715</button>';
  document.querySelector('.pane-editor').appendChild(toast);
  toast.querySelector('.close-toast').addEventListener('click', () => { toast.remove(); localStorage.setItem('lux-playground-welcomed', '1'); });
  setTimeout(() => { if (toast.parentNode) toast.remove(); }, 15000);
  localStorage.setItem('lux-playground-welcomed', '1');
}

// ─── Utility ────────────────────────────────────────
function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ─── Initial Compile ────────────────────────────────
compile();
</script>
</body>
</html>