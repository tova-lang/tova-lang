<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tova Playground</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
/* ─── Reset & Base ─────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #1e1e2e; --bg-surface: #181825; --bg-overlay: #11111b;
  --bg-hover: #1e1e2e;
  --text: #cdd6f4; --text-dim: #6c7086; --text-bright: #f5f5f5;
  --accent: #cba6f7; --accent-dim: #9370db; --accent-bg: rgba(203,166,247,0.1);
  --green: #a6e3a1; --red: #f38ba8; --yellow: #f9e2af; --blue: #89b4fa;
  --teal: #94e2d5; --peach: #fab387;
  --border: #313244; --border-active: #45475a;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --header-h: 48px; --status-h: 28px;
  --tab-h: 36px; --sidebar-w: 340px;
  --editor-font-size: 14px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: var(--font-sans); background: var(--bg); color: var(--text);
  display: flex; flex-direction: column;
}

/* ─── Header ───────────────────────────────────────── */
.header {
  height: var(--header-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.header .logo {
  font-weight: 700; font-size: 15px; color: var(--accent);
  display: flex; align-items: center; gap: 6px; white-space: nowrap;
}
.header .logo span { color: var(--text-dim); font-weight: 400; font-size: 12px; }
.header .sep { width: 1px; height: 24px; background: var(--border); }
.header .spacer { flex: 1; }

.btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; transition: all 0.15s; font-family: var(--font-sans);
  white-space: nowrap;
}
.btn:hover { border-color: var(--border-active); background: var(--bg-surface); }
.btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
.btn-primary { background: var(--accent); color: var(--bg-overlay); border-color: var(--accent); font-weight: 600; }
.btn-primary:hover { background: var(--accent-dim); border-color: var(--accent-dim); }
.btn-icon { padding: 5px 8px; font-size: 14px; }
.btn .kbd { font-size: 10px; opacity: 0.6; font-family: var(--font-mono); }

select.examples-select {
  padding: 5px 24px 5px 8px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; font-family: var(--font-sans); max-width: 200px;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236c7086' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 6px center;
}
select.examples-select:hover { border-color: var(--border-active); }
select.examples-select optgroup { background: var(--bg-surface); color: var(--accent); font-style: normal; }
select.examples-select option { background: var(--bg); color: var(--text); }

/* ─── Main Layout ──────────────────────────────────── */
.main {
  flex: 1; display: flex; overflow: hidden;
  height: calc(100% - var(--header-h) - var(--status-h));
}
.pane { display: flex; flex-direction: column; overflow: hidden; min-width: 200px; }
.pane-editor { flex: 1; position: relative; }
.pane-output { flex: 1; }

/* ─── Drag Handle ──────────────────────────────────── */
.drag-handle {
  width: 4px; cursor: col-resize; background: var(--border);
  transition: background 0.15s; flex-shrink: 0;
}
.drag-handle:hover, .drag-handle.active { background: var(--accent); }

/* ─── Output Tabs ──────────────────────────────────── */
.tabs {
  display: flex; height: var(--tab-h); background: var(--bg-surface);
  border-bottom: 1px solid var(--border); flex-shrink: 0; align-items: flex-end;
}
.tab {
  padding: 0 14px; height: 100%; font-size: 12px; cursor: pointer; display: flex; align-items: center;
  color: var(--text-dim); border-bottom: 2px solid transparent;
  transition: all 0.15s; user-select: none; gap: 6px;
}
.tab:hover { color: var(--text); background: rgba(255,255,255,0.02); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab .badge {
  font-size: 10px; padding: 1px 6px; border-radius: 8px;
  background: var(--red); color: var(--bg); font-weight: 600; min-width: 18px; text-align: center;
}

/* ─── Output Panels ────────────────────────────────── */
.output-content { flex: 1; overflow: auto; position: relative; }
.output-panel { display: none; height: 100%; overflow: auto; }
.output-panel.active { display: block; }
#panel-console.active { display: flex; flex-direction: column; }
#panel-js { position: relative; }

#js-output, #console-output, #ast-output {
  padding: 12px 16px; font-family: var(--font-mono); font-size: 13px;
  line-height: 1.6; white-space: pre-wrap; word-break: break-word;
}
#js-output { color: var(--text); }
#console-output .log-line { color: var(--text); padding: 1px 0; }
#console-output .log-error { color: var(--red); padding: 1px 0; }
#console-output .log-warn { color: var(--yellow); padding: 1px 0; }
#console-output .log-info { color: var(--blue); padding: 1px 0; }
#console-output .log-return { color: var(--text-dim); font-style: italic; padding: 1px 0; }

#preview-frame {
  width: 100%; height: 100%; border: none; background: #fff;
}

/* ─── AST Tree ─────────────────────────────────────── */
.ast-node { margin-left: 16px; font-family: var(--font-mono); font-size: 12px; line-height: 1.5; }
.ast-toggle { cursor: pointer; user-select: none; display: inline-flex; align-items: center; gap: 4px; }
.ast-toggle:hover { color: var(--accent); }
.ast-toggle::before { content: '\25B6'; font-size: 8px; display: inline-block; transition: transform 0.15s; }
.ast-toggle.open::before { transform: rotate(90deg); }
.ast-key { color: var(--blue); }
.ast-string { color: var(--green); }
.ast-number { color: var(--yellow); }
.ast-bool { color: var(--accent); }
.ast-null { color: var(--text-dim); }
.ast-type { color: var(--accent); font-weight: 600; }
.ast-children { display: none; }
.ast-children.open { display: block; }

/* ─── Status Bar ───────────────────────────────────── */
.status-bar {
  height: var(--status-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-top: 1px solid var(--border); font-size: 11px;
  color: var(--text-dim); gap: 16px; flex-shrink: 0;
}
.status-bar .success { color: var(--green); }
.status-bar .error { color: var(--red); }
.status-bar .spacer { flex: 1; }

/* ─── Error Display ────────────────────────────────── */
.error-banner {
  padding: 8px 16px; background: rgba(243,139,168,0.08);
  border-bottom: 1px solid rgba(243,139,168,0.3); color: var(--red);
  font-family: var(--font-mono); font-size: 12px; display: none;
  cursor: pointer; position: relative;
}
.error-banner:hover { background: rgba(243,139,168,0.12); }
.error-banner.visible { display: flex; align-items: center; gap: 8px; }
.error-banner .error-icon { font-weight: bold; flex-shrink: 0; }
.error-banner .error-text { flex: 1; }

/* ─── Sidebar / Reference Panel ───────────────────── */
.sidebar {
  width: 0; overflow: hidden; background: var(--bg-surface);
  border-left: 1px solid var(--border); transition: width 0.2s ease;
  flex-shrink: 0; display: flex; flex-direction: column;
}
.sidebar.open { width: var(--sidebar-w); }
.sidebar-header {
  display: flex; align-items: center; padding: 10px 14px;
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.sidebar-header h3 { font-size: 14px; font-weight: 600; color: var(--text-bright); flex: 1; }
.sidebar-close {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 18px; padding: 2px 6px; border-radius: 4px;
}
.sidebar-close:hover { color: var(--text); background: var(--bg); }
.sidebar-body { flex: 1; overflow-y: auto; padding: 8px 0; }

/* Reference styles */
.ref-section { margin-bottom: 4px; }
.ref-title {
  padding: 6px 14px; font-size: 12px; font-weight: 600;
  color: var(--accent); cursor: pointer; display: flex; align-items: center; gap: 6px;
  user-select: none;
}
.ref-title:hover { background: var(--bg); }
.ref-title::before { content: '\25B6'; font-size: 8px; transition: transform 0.15s; }
.ref-title.open::before { transform: rotate(90deg); }
.ref-items { display: none; padding: 0 14px 8px; }
.ref-items.open { display: block; }
.ref-item { margin: 3px 0; }
.ref-item code {
  font-family: var(--font-mono); font-size: 11px; color: var(--green);
  background: rgba(166,227,161,0.08); padding: 1px 4px; border-radius: 3px;
}
.ref-item .ref-desc { font-size: 11px; color: var(--text-dim); margin-left: 4px; }

/* Tutorial styles */
.tutorial-nav { display: flex; gap: 4px; padding: 8px 14px; flex-shrink: 0; border-top: 1px solid var(--border); }
.tutorial-nav .btn { flex: 1; justify-content: center; font-size: 12px; }
.tutorial-step { padding: 14px; }
.tutorial-step h4 { color: var(--accent); font-size: 14px; margin-bottom: 8px; }
.tutorial-step p { font-size: 13px; color: var(--text); line-height: 1.5; margin-bottom: 10px; }
.tutorial-step .try-btn {
  display: inline-flex; align-items: center; gap: 4px;
  padding: 6px 14px; border-radius: 6px; border: 1px solid var(--accent);
  background: var(--accent-bg); color: var(--accent); font-size: 12px;
  cursor: pointer; font-weight: 500;
}
.tutorial-step .try-btn:hover { background: rgba(203,166,247,0.2); }
.tutorial-progress {
  display: flex; gap: 4px; padding: 0 14px 8px; flex-shrink: 0;
}
.tutorial-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--border); cursor: pointer;
}
.tutorial-dot.active { background: var(--accent); }
.tutorial-dot.completed { background: var(--green); }

/* ─── Keyboard Shortcuts Modal ────────────────────── */
.modal-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: none; align-items: center; justify-content: center; z-index: 100;
}
.modal-backdrop.visible { display: flex; }
.modal {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 24px; max-width: 480px; width: 90%;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.modal h3 { color: var(--accent); margin-bottom: 16px; font-size: 16px; }
.modal-close {
  float: right; background: none; border: none; color: var(--text-dim);
  cursor: pointer; font-size: 20px; padding: 0 4px;
}
.modal-close:hover { color: var(--text); }
.shortcut-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 0; border-bottom: 1px solid rgba(49,50,68,0.5);
}
.shortcut-row:last-child { border-bottom: none; }
.shortcut-keys {
  display: flex; gap: 4px;
}
.shortcut-key {
  background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  padding: 2px 8px; font-family: var(--font-mono); font-size: 11px; color: var(--text-bright);
}
.shortcut-desc { font-size: 13px; color: var(--text-dim); }

/* ─── Settings Dropdown ──────────────────────────── */
.settings-dropdown {
  position: absolute; top: calc(var(--header-h) + 4px); right: 12px;
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 12px; min-width: 220px; z-index: 50;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
}
.settings-dropdown.visible { display: block; }
.settings-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 0; font-size: 13px;
}
.settings-row label { color: var(--text); }
.settings-row select, .settings-row input[type="range"] {
  background: var(--bg); border: 1px solid var(--border); color: var(--text);
  border-radius: 4px; padding: 3px 6px; font-size: 12px;
}
.toggle {
  width: 36px; height: 20px; border-radius: 10px; background: var(--border);
  position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle.on { background: var(--accent); }
.toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 16px; height: 16px; border-radius: 50%; background: white;
  transition: transform 0.2s;
}
.toggle.on::after { transform: translateX(16px); }

/* ─── Welcome Overlay ─────────────────────────────── */
.welcome-toast {
  position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 16px; font-size: 12px;
  color: var(--text-dim); z-index: 10; display: flex; align-items: center; gap: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3); white-space: nowrap;
  animation: fadeIn 0.3s ease;
}
.welcome-toast .kbd-hint {
  font-family: var(--font-mono); font-size: 10px;
  background: var(--bg); border: 1px solid var(--border); padding: 2px 6px;
  border-radius: 3px; color: var(--text);
}
.welcome-toast .close-toast {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 14px; padding: 0 2px;
}
@keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(8px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

/* ─── Console Enhancements ────────────────────────── */
.console-toolbar {
  display: flex; align-items: center; gap: 8px;
  padding: 4px 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); font-size: 11px; flex-shrink: 0;
}
.console-toolbar .spacer { flex: 1; }
.console-toolbar .console-timing { color: var(--text-dim); font-family: var(--font-mono); }
.log-icon { margin-right: 6px; opacity: 0.7; font-size: 11px; }
.log-content { white-space: pre-wrap; word-break: break-word; }
#console-output .log-line, #console-output .log-error,
#console-output .log-warn, #console-output .log-info {
  display: flex; align-items: flex-start; padding: 3px 16px; border-bottom: 1px solid rgba(49,50,68,0.3);
}
#console-output .log-line:hover, #console-output .log-error:hover,
#console-output .log-warn:hover, #console-output .log-info:hover {
  background: rgba(255,255,255,0.02);
}

/* ─── Error Banner Enhanced ───────────────────────── */
.error-banner .error-hint {
  color: var(--yellow); font-size: 11px; margin-left: 12px; opacity: 0.8;
}

/* ─── Command Palette ─────────────────────────────── */
.cmd-palette-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: flex-start; justify-content: center;
  padding-top: 20vh; z-index: 200;
}
.cmd-palette-backdrop.visible { display: flex; }
.cmd-palette {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; width: 520px; max-width: 90vw;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5); overflow: hidden;
}
.cmd-palette input {
  width: 100%; padding: 14px 16px; background: transparent;
  border: none; border-bottom: 1px solid var(--border);
  color: var(--text); font-size: 15px; font-family: var(--font-sans);
  outline: none;
}
.cmd-palette input::placeholder { color: var(--text-dim); }
.cmd-palette-results {
  max-height: 320px; overflow-y: auto; padding: 4px 0;
}
.cmd-palette-item {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 16px; cursor: pointer; font-size: 13px;
  color: var(--text); transition: background 0.1s;
}
.cmd-palette-item:hover, .cmd-palette-item.selected {
  background: var(--accent-bg); color: var(--accent);
}
.cmd-palette-item .cmd-icon { width: 20px; text-align: center; opacity: 0.6; font-size: 14px; }
.cmd-palette-item .cmd-label { flex: 1; }
.cmd-palette-item .cmd-category { font-size: 11px; color: var(--text-dim); }
.cmd-palette-item .cmd-shortcut {
  font-family: var(--font-mono); font-size: 10px; color: var(--text-dim);
  background: var(--bg); border: 1px solid var(--border); border-radius: 3px;
  padding: 1px 5px;
}
.cmd-palette-empty {
  padding: 24px 16px; text-align: center; color: var(--text-dim); font-size: 13px;
}

/* ─── Layout Toggle ───────────────────────────────── */
.main.vertical { flex-direction: column; }
.main.vertical .drag-handle { width: auto; height: 4px; cursor: row-resize; }
.main.vertical .pane { min-width: unset; min-height: 150px; }

/* ─── Light Theme ─────────────────────────────────── */
.light-theme {
  --bg: #f8f9fa; --bg-surface: #ffffff; --bg-overlay: #e9ecef;
  --bg-hover: #f1f3f5;
  --text: #212529; --text-dim: #868e96; --text-bright: #000000;
  --accent: #7c3aed; --accent-dim: #6d28d9; --accent-bg: rgba(124,58,237,0.08);
  --green: #2b8a3e; --red: #e03131; --yellow: #e67700; --blue: #1971c2;
  --teal: #0ca678; --peach: #e8590c;
  --border: #dee2e6; --border-active: #ced4da;
}
.light-theme .cm-editor .cm-gutters { background: #f1f3f5; }
.light-theme #preview-frame { background: #fff; }

/* ─── Embed Mode ──────────────────────────────────── */
.embed-mode .header { display: none; }
.embed-mode .status-bar { display: none; }
.embed-mode .sidebar { display: none; }

/* ─── JS Output Editor ────────────────────────────── */
#js-output-editor { height: 100%; }
#panel-js .cm-editor { height: 100%; }
#panel-js .cm-editor .cm-gutters { background: var(--bg-surface); }

/* ─── CodeMirror Overrides ─────────────────────────── */
.cm-editor { height: 100%; font-size: var(--editor-font-size); }
.cm-editor .cm-scroller { font-family: var(--font-mono) !important; }
.cm-editor .cm-content { padding: 8px 0; }
.cm-editor .cm-gutters {
  background: var(--bg-surface); border-right: 1px solid var(--border);
  color: var(--text-dim);
}
.cm-editor .cm-activeLineGutter { background: rgba(203,166,247,0.08); }
.cm-editor .cm-activeLine { background: rgba(203,166,247,0.04); }
.cm-editor .cm-selectionBackground { background: rgba(203,166,247,0.2) !important; }
.cm-editor.cm-focused .cm-selectionBackground { background: rgba(203,166,247,0.25) !important; }
.cm-editor .cm-cursor { border-left-color: var(--accent); }
.cm-error-line { background: rgba(243,139,168,0.1) !important; }
.cm-error-gutter .cm-gutterElement { padding: 0 2px; }

/* ─── Autocomplete Styling ────────────────────────── */
.cm-tooltip-autocomplete { background: var(--bg-surface) !important; border: 1px solid var(--border) !important; border-radius: 8px !important; }
.cm-tooltip-autocomplete ul li { padding: 4px 8px !important; }
.cm-tooltip-autocomplete ul li[aria-selected] { background: var(--accent-bg) !important; color: var(--accent) !important; }
.cm-completionLabel { font-family: var(--font-mono); }
.cm-completionDetail { font-size: 11px; opacity: 0.7; margin-left: 8px; }
.cm-completionInfo { padding: 8px; font-size: 12px; }

/* ─── Scrollbar ───────────────────────────────────── */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--border-active); }

/* ─── Responsive ───────────────────────────────────── */
@media (max-width: 768px) {
  .main { flex-direction: column; }
  .drag-handle { width: auto; height: 4px; cursor: row-resize; }
  .pane { min-width: unset; min-height: 150px; }
  .sidebar { position: fixed; right: 0; top: var(--header-h); bottom: var(--status-h); z-index: 50; }
  .header .hide-mobile { display: none; }
  .header .sep { display: none; }
}
</style>
</head>
<body>

<!-- ─── Header ────────────────────────────────────── -->
<div class="header">
  <div class="logo">&#9670; Tova <span>Playground</span></div>
  <div class="sep"></div>
  <select class="examples-select" id="examples-select">
    <option value="" disabled selected>Load Example...</option>
  </select>
  <div class="spacer"></div>
  <button class="btn hide-mobile" id="btn-tutorial" title="Interactive tutorial">Learn</button>
  <button class="btn hide-mobile" id="btn-reference" title="Language reference">Reference</button>
  <div class="sep hide-mobile"></div>
  <button class="btn btn-icon hide-mobile" id="btn-layout" title="Toggle layout (Cmd+J)">&#9707;</button>
  <button class="btn btn-icon hide-mobile" id="btn-shortcuts" title="Keyboard shortcuts">&#9000;</button>
  <button class="btn btn-icon hide-mobile" id="btn-settings" title="Settings">&#9881;</button>
  <button class="btn" id="btn-export" title="Export as standalone HTML">Export</button>
  <button class="btn" id="btn-download" title="Download .tova file">&#8615;</button>
  <button class="btn" id="btn-share" title="Copy shareable URL">Share</button>
  <button class="btn btn-primary" id="btn-run" title="Cmd/Ctrl+Enter">Run &#9654;</button>
</div>

<!-- ─── Settings Dropdown ─────────────────────────── -->
<div class="settings-dropdown" id="settings-dropdown">
  <div class="settings-row">
    <label>Font Size</label>
    <select id="setting-fontsize">
      <option value="12">12px</option>
      <option value="13">13px</option>
      <option value="14" selected>14px</option>
      <option value="15">15px</option>
      <option value="16">16px</option>
      <option value="18">18px</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Auto-Compile</label>
    <div class="toggle on" id="setting-autocompile"></div>
  </div>
  <div class="settings-row">
    <label>Auto-Run</label>
    <div class="toggle on" id="setting-autorun"></div>
  </div>
  <div class="settings-row">
    <label>Light Theme</label>
    <div class="toggle" id="setting-theme"></div>
  </div>
</div>

<!-- ─── Main ──────────────────────────────────────── -->
<div class="main">
  <div class="pane pane-editor">
    <div id="editor"></div>
  </div>
  <div class="drag-handle" id="drag-handle"></div>
  <div class="pane pane-output">
    <div class="tabs" id="output-tabs">
      <div class="tab active" data-tab="js">JS Output</div>
      <div class="tab" data-tab="console">Console <span class="badge" id="console-badge" style="display:none">0</span></div>
      <div class="tab" data-tab="preview">Preview</div>
      <div class="tab" data-tab="ast">AST</div>
    </div>
    <div class="error-banner" id="error-banner">
      <span class="error-icon">&#10006;</span>
      <span class="error-text" id="error-text"></span>
      <span class="error-hint" id="error-hint"></span>
    </div>
    <div class="output-content">
      <div class="output-panel active" id="panel-js"><div id="js-output-editor"></div><pre id="js-output" style="display:none"></pre></div>
      <div class="output-panel" id="panel-console">
        <div class="console-toolbar">
          <span class="console-timing" id="console-timing"></span>
          <div class="spacer"></div>
          <button class="btn" id="btn-copy-console" style="padding:2px 8px;font-size:11px;">Copy</button>
          <button class="btn" id="btn-clear-console" style="padding:2px 8px;font-size:11px;">Clear</button>
        </div>
        <div id="console-output" style="padding:12px 0;font-family:var(--font-mono);font-size:13px;line-height:1.6;overflow:auto;flex:1;"></div>
      </div>
      <div class="output-panel" id="panel-preview"><iframe id="preview-frame" sandbox="allow-scripts"></iframe></div>
      <div class="output-panel" id="panel-ast"><div id="ast-output"></div></div>
    </div>
  </div>

  <!-- ─── Sidebar ─────────────────────────────────── -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h3 id="sidebar-title">Reference</h3>
      <button class="sidebar-close" id="sidebar-close">&#10005;</button>
    </div>
    <div class="sidebar-body" id="sidebar-body"></div>
    <div class="tutorial-nav" id="tutorial-nav" style="display:none;">
      <button class="btn" id="tut-prev">&#8592; Prev</button>
      <button class="btn btn-primary" id="tut-next">Next &#8594;</button>
    </div>
  </div>
</div>

<!-- ─── Status Bar ────────────────────────────────── -->
<div class="status-bar">
  <span id="status-compile"></span>
  <span id="status-size" style="color:var(--text-dim)"></span>
  <div class="spacer"></div>
  <span id="status-cursor">Ln 1, Col 1</span>
</div>

<!-- ─── Keyboard Shortcuts Modal ──────────────────── -->
<div class="modal-backdrop" id="shortcuts-modal">
  <div class="modal">
    <button class="modal-close" id="shortcuts-close">&#10005;</button>
    <h3>Keyboard Shortcuts</h3>
    <div class="shortcut-row"><span class="shortcut-desc">Run code</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Enter</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Command palette</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">K</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Save to browser</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">S</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle reference</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">R</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle layout</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">J</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Show shortcuts</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">?</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Download .tova file</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">S</span></div></div>
    <p style="margin-top:12px;font-size:11px;color:var(--text-dim)">On Windows/Linux, use Ctrl instead of Cmd</p>
  </div>
</div>

<!-- ─── Command Palette ──────────────────────────── -->
<div class="cmd-palette-backdrop" id="cmd-palette">
  <div class="cmd-palette">
    <input type="text" id="cmd-input" placeholder="Search examples, actions, reference..." autocomplete="off" />
    <div class="cmd-palette-results" id="cmd-results"></div>
  </div>
</div>

<!-- ─── LZString for sharing ─────────────────────── -->
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

<!-- ─── Inlined Tova Compiler & Runtime ───────────── -->
<script>
var RUNTIME_CODE = "// Fine-grained reactivity system for Tova (signals-based)\n\nconst __DEV__ = typeof process !== 'undefined' && process.env?.NODE_ENV !== 'production';\n\n// ─── DevTools hooks (zero-cost when disabled) ────────────\nlet __devtools_hooks = null;\nfunction __enableDevTools(hooks) {\n  __devtools_hooks = hooks;\n}\n\nlet currentEffect = null;\nconst effectStack = [];\n\n// ─── Ownership System ─────────────────────────────────────\nlet currentOwner = null;\nconst ownerStack = [];\n\n// ─── Batching ────────────────────────────────────────────\n// Default: synchronous flush after each setter (backward compatible).\n// Inside batch(): effects are deferred and flushed once when batch ends.\n// This means setA(1); setB(2) causes 2 runs by default, but\n// batch(() => { setA(1); setB(2); }) causes only 1 run.\n\nlet pendingEffects = new Set();\nlet batchDepth = 0;\nlet flushing = false;\n\nfunction flush() {\n  if (flushing) return; // prevent re-entrant flush\n  flushing = true;\n  let iterations = 0;\n  try {\n    while (pendingEffects.size > 0) {\n      if (++iterations > 100) {\n        console.error('Tova: Possible infinite loop in reactive updates (>100 flush iterations). Aborting.');\n        pendingEffects.clear();\n        break;\n      }\n\n      // Invoke onBeforeUpdate callbacks for owners that have pending effects\n      const ownersNotified = new Set();\n      for (const effect of pendingEffects) {\n        const owner = effect._owner;\n        if (owner && owner._beforeUpdate && !ownersNotified.has(owner)) {\n          ownersNotified.add(owner);\n          for (const cb of owner._beforeUpdate) {\n            try { cb(); } catch (e) { console.error('Tova: onBeforeUpdate error:', e); }\n          }\n        }\n      }\n\n      const toRun = pendingEffects;\n      pendingEffects = new Set();\n      // Sort by depth (parents first) to avoid redundant child re-runs\n      if (toRun.size > 1) {\n        const sorted = Array.from(toRun);\n        sorted.sort((a, b) => (a._depth || 0) - (b._depth || 0));\n        for (const effect of sorted) {\n          if (!effect._disposed) {\n            effect();\n          }\n        }\n      } else {\n        for (const effect of toRun) {\n          if (!effect._disposed) {\n            effect();\n          }\n        }\n      }\n    }\n  } finally {\n    flushing = false;\n  }\n}\nfunction batch(fn) {\n  batchDepth++;\n  try {\n    fn();\n  } finally {\n    batchDepth--;\n    if (batchDepth === 0) {\n      flush();\n    }\n  }\n}\n\n// ─── Ownership Root ──────────────────────────────────────\nfunction createRoot(fn) {\n  const root = {\n    _children: [],\n    _disposed: false,\n    _cleanups: [],\n    _contexts: null,\n    _owner: currentOwner,\n    dispose() {\n      if (root._disposed) return;\n      root._disposed = true;\n      // Dispose children in reverse order (skip already-disposed)\n      for (let i = root._children.length - 1; i >= 0; i--) {\n        const child = root._children[i];\n        if (!child._disposed && typeof child.dispose === 'function') child.dispose();\n      }\n      root._children.length = 0;\n      // Run cleanups in reverse order\n      for (let i = root._cleanups.length - 1; i >= 0; i--) {\n        try { root._cleanups[i](); } catch (e) { console.error('Tova: root cleanup error:', e); }\n      }\n      root._cleanups.length = 0;\n    }\n  };\n  ownerStack.push(currentOwner);\n  currentOwner = root;\n  try {\n    return fn(root.dispose.bind(root));\n  } finally {\n    currentOwner = ownerStack.pop();\n  }\n}\n\n// ─── Dependency Cleanup ──────────────────────────────────\n\nfunction cleanupDeps(subscriber) {\n  if (subscriber._deps) {\n    for (const depSet of subscriber._deps) {\n      depSet.delete(subscriber);\n    }\n    subscriber._deps.clear();\n  }\n}\n\nfunction trackDep(subscriber, subscriberSet) {\n  subscriberSet.add(subscriber);\n  if (!subscriber._deps) subscriber._deps = new Set();\n  subscriber._deps.add(subscriberSet);\n}\n\n// ─── Signals ─────────────────────────────────────────────\nfunction createSignal(initialValue, name) {\n  let value = initialValue;\n  const subscribers = new Set();\n  let signalId = null;\n\n  if (__devtools_hooks) {\n    signalId = __devtools_hooks.onSignalCreate(\n      () => value,\n      (v) => setter(v),\n      name,\n    );\n  }\n\n  function getter() {\n    if (currentEffect) {\n      trackDep(currentEffect, subscribers);\n    }\n    return value;\n  }\n\n  function setter(newValue) {\n    if (typeof newValue === 'function') {\n      newValue = newValue(value);\n    }\n    if (value !== newValue) {\n      const oldValue = value;\n      value = newValue;\n      if (__devtools_hooks && signalId != null) {\n        __devtools_hooks.onSignalUpdate(signalId, oldValue, newValue);\n      }\n      for (const sub of subscribers) {\n        if (sub._isComputed) {\n          sub(); // propagate dirty flags synchronously through computed graph\n        } else {\n          pendingEffects.add(sub);\n        }\n      }\n      if (batchDepth === 0) {\n        flush();\n      }\n    }\n  }\n\n  return [getter, setter];\n}\n\n// ─── Effects ─────────────────────────────────────────────\n\nfunction runCleanups(effect) {\n  if (effect._cleanup) {\n    try { effect._cleanup(); } catch (e) { console.error('Tova: cleanup error:', e); }\n    effect._cleanup = null;\n  }\n  if (effect._cleanups && effect._cleanups.length > 0) {\n    for (const cb of effect._cleanups) {\n      try { cb(); } catch (e) { console.error('Tova: cleanup error:', e); }\n    }\n    effect._cleanups = [];\n  }\n}\nfunction createEffect(fn) {\n  function effect() {\n    if (effect._running) return;\n    if (effect._disposed) return;\n    effect._running = true;\n\n    // Run cleanups from previous execution\n    runCleanups(effect);\n\n    // Remove from all previous dependency subscriber sets\n    cleanupDeps(effect);\n\n    effectStack.push(effect);\n    currentEffect = effect;\n    const startTime = __devtools_hooks && typeof performance !== 'undefined' ? performance.now() : 0;\n    try {\n      const result = fn();\n      // If effect returns a function, use as cleanup\n      if (typeof result === 'function') {\n        effect._cleanup = result;\n      }\n    } catch (e) {\n      console.error('Tova: Error in effect:', e);\n      if (currentErrorHandler) {\n        currentErrorHandler(e);\n      }\n    } finally {\n      if (__devtools_hooks) {\n        const duration = typeof performance !== 'undefined' ? performance.now() - startTime : 0;\n        __devtools_hooks.onEffectRun(effect, duration);\n      }\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n      effect._running = false;\n    }\n  }\n\n  effect._deps = new Set();\n  effect._running = false;\n  effect._disposed = false;\n  effect._cleanup = null;\n  effect._cleanups = [];\n  effect._owner = currentOwner;\n  // Compute depth for priority scheduling (parents flush before children)\n  effect._depth = currentOwner ? (currentOwner._depth || 0) + 1 : 0;\n\n  if (__devtools_hooks) {\n    __devtools_hooks.onEffectCreate(effect);\n  }\n\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._children.push(effect);\n  }\n\n  effect.dispose = function () {\n    effect._disposed = true;\n    runCleanups(effect);\n    cleanupDeps(effect);\n    pendingEffects.delete(effect);\n  };\n\n  // Run immediately (synchronous first run)\n  effect();\n  return effect;\n}\n\n// ─── Computed (lazy/pull-based for glitch-free reads) ────\nfunction createComputed(fn) {\n  let value;\n  let dirty = true;\n  const subscribers = new Set();\n\n  // notify is called synchronously when a source signal changes.\n  // It marks the computed dirty and propagates to downstream subscribers.\n  function notify() {\n    if (!dirty) {\n      dirty = true;\n      notify._dirty = true;\n      for (const sub of subscribers) {\n        if (sub._isComputed) {\n          if (!sub._dirty) sub(); // skip already-dirty computeds\n        } else {\n          pendingEffects.add(sub);\n        }\n      }\n    }\n  }\n\n  notify._deps = new Set();\n  notify._disposed = false;\n  notify._isComputed = true;\n  notify._owner = currentOwner;\n\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._children.push(notify);\n  }\n\n  notify.dispose = function () {\n    notify._disposed = true;\n    cleanupDeps(notify);\n  };\n\n  function recompute() {\n    cleanupDeps(notify);\n\n    effectStack.push(notify);\n    currentEffect = notify;\n    try {\n      value = fn();\n      dirty = false;\n      notify._dirty = false;\n    } finally {\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n    }\n  }\n\n  // Initial computation\n  recompute();\n\n  function getter() {\n    if (currentEffect) {\n      trackDep(currentEffect, subscribers);\n    }\n    if (dirty) {\n      recompute();\n    }\n    return value;\n  }\n\n  return getter;\n}\n\n// ─── Lifecycle Hooks ─────────────────────────────────────\nfunction onMount(fn) {\n  const owner = currentOwner;\n  queueMicrotask(() => {\n    const result = fn();\n    if (typeof result === 'function' && owner && !owner._disposed) {\n      owner._cleanups.push(result);\n    }\n  });\n}\nfunction onUnmount(fn) {\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._cleanups.push(fn);\n  }\n}\nfunction onCleanup(fn) {\n  if (currentEffect) {\n    if (!currentEffect._cleanups) currentEffect._cleanups = [];\n    currentEffect._cleanups.push(fn);\n  }\n}\nfunction onBeforeUpdate(fn) {\n  if (currentOwner && !currentOwner._disposed) {\n    if (!currentOwner._beforeUpdate) currentOwner._beforeUpdate = [];\n    currentOwner._beforeUpdate.push(fn);\n  }\n}\n\n// ─── Untrack ─────────────────────────────────────────────\n// Run a function without tracking any signal reads (opt out of reactivity)\nfunction untrack(fn) {\n  const prev = currentEffect;\n  currentEffect = null;\n  try {\n    return fn();\n  } finally {\n    currentEffect = prev;\n  }\n}\n\n// ─── Watch ───────────────────────────────────────────────\n// Watch a reactive expression, calling callback with (newValue, oldValue)\n// Returns a dispose function to stop watching.\nfunction watch(getter, callback, options = {}) {\n  let oldValue = undefined;\n  let initialized = false;\n\n  const effect = createEffect(() => {\n    const newValue = getter();\n    if (initialized) {\n      untrack(() => callback(newValue, oldValue));\n    } else if (options.immediate) {\n      untrack(() => callback(newValue, undefined));\n    }\n    oldValue = newValue;\n    initialized = true;\n  });\n\n  return effect.dispose ? effect.dispose.bind(effect) : () => {\n    effect._disposed = true;\n    runCleanups(effect);\n    cleanupDeps(effect);\n    pendingEffects.delete(effect);\n  };\n}\n\n// ─── Refs ────────────────────────────────────────────────\nfunction createRef(initialValue) {\n  return { current: initialValue !== undefined ? initialValue : null };\n}\n\n// ─── Error Boundaries ────────────────────────────────────\n\n// Stack-based error handler for correct nested boundary propagation\nconst errorHandlerStack = [];\nlet currentErrorHandler = null;\n\nfunction pushErrorHandler(handler) {\n  errorHandlerStack.push(currentErrorHandler);\n  currentErrorHandler = handler;\n}\n\nfunction popErrorHandler() {\n  currentErrorHandler = errorHandlerStack.pop() || null;\n}\n\n// Component name tracking for stack traces\nconst componentNameStack = [];\nfunction pushComponentName(name) {\n  componentNameStack.push(name);\n}\nfunction popComponentName() {\n  componentNameStack.pop();\n}\n\nfunction buildComponentStack() {\n  return [...componentNameStack].reverse();\n}\nfunction createErrorBoundary(options = {}) {\n  const { onError, onReset } = options;\n  const [error, setError] = createSignal(null);\n\n  function run(fn) {\n    pushErrorHandler((e) => {\n      const stack = buildComponentStack();\n      if (e && typeof e === 'object') e.__tovaComponentStack = stack;\n      setError(e);\n      if (onError) onError({ error: e, componentStack: stack });\n    });\n    try {\n      return fn();\n    } catch (e) {\n      const stack = buildComponentStack();\n      if (e && typeof e === 'object') e.__tovaComponentStack = stack;\n      setError(e);\n      if (onError) onError({ error: e, componentStack: stack });\n      return null;\n    } finally {\n      popErrorHandler();\n    }\n  }\n\n  function reset() {\n    setError(null);\n    if (onReset) onReset();\n  }\n\n  return { error, run, reset };\n}\n\nlet __errorBoundaryIdCounter = 0;\nfunction ErrorBoundary({ fallback, children, onError, onReset, onErrorCleared, retry = 0 }) {\n  const [error, setError] = createSignal(null);\n  const [retryCount, setRetryCount] = createSignal(0);\n  const boundaryId = ++__errorBoundaryIdCounter;\n  let lastErrorId = 0;\n\n  function handleError(e) {\n    const stack = buildComponentStack();\n    const errorId = `EB${boundaryId}-${++lastErrorId}`;\n\n    if (e && typeof e === 'object') {\n      e.__tovaComponentStack = stack;\n      e.__tovaErrorId = errorId;\n    }\n\n    if (retryCount() < retry) {\n      setRetryCount(c => c + 1);\n      setError(null); // clear to re-trigger render\n      return;\n    }\n    setError(e);\n    if (onError) onError({ error: e, componentStack: stack, errorId, retryCount: retryCount() });\n  }\n\n  function resetBoundary() {\n    setRetryCount(0);\n    setError(null);\n    if (onReset) onReset();\n  }\n\n  // Return a reactive wrapper that switches between children and fallback\n  const childContent = children && children.length === 1 ? children[0] : tova_fragment(children || []);\n\n  const vnode = {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    _fallback: fallback,\n    _componentName: 'ErrorBoundary',\n    _errorHandler: handleError, // Active during __dynamic effect render cycle\n    compute: () => {\n      const err = error();\n      if (err) {\n        // Render fallback — if fallback itself throws, propagate to parent boundary\n        try {\n          const errorId = err && typeof err === 'object' ? err.__tovaErrorId : null;\n          return typeof fallback === 'function'\n            ? fallback({\n                error: err,\n                errorId,\n                retryCount: retryCount(),\n                componentStack: err && typeof err === 'object' ? err.__tovaComponentStack : [],\n                reset: resetBoundary,\n              })\n            : fallback;\n        } catch (fallbackError) {\n          // Fallback threw — propagate to parent error boundary\n          if (currentErrorHandler) {\n            currentErrorHandler(fallbackError);\n          }\n          return null;\n        }\n      }\n      // Children rendered successfully — fire onErrorCleared if we recovered from an error\n      if (onErrorCleared && lastErrorId > 0 && retryCount() === 0) {\n        queueMicrotask(() => onErrorCleared());\n      }\n      return childContent;\n    },\n  };\n\n  return vnode;\n}\n\n// Built-in ErrorInfo component — renders a formatted error display\n// Usage: <ErrorBoundary fallback={fn(props) ErrorInfo(props)} />\nfunction ErrorInfo({ error, errorId, componentStack, reset, retryCount }) {\n  const message = error instanceof Error ? error.message : String(error);\n  const stackTrace = error instanceof Error && error.stack ? error.stack : '';\n  const compStack = (componentStack || []).join(' > ');\n\n  const children = [\n    tova_el('h3', { style: { margin: '0 0 8px 0', color: '#e53e3e' } }, ['Something went wrong']),\n    tova_el('p', { style: { margin: '4px 0', fontFamily: 'monospace', fontSize: '14px' } }, [message]),\n  ];\n\n  if (compStack) {\n    children.push(\n      tova_el('p', { style: { margin: '4px 0', fontSize: '12px', color: '#718096' } }, [\n        'Component: ', compStack\n      ])\n    );\n  }\n\n  if (errorId) {\n    children.push(\n      tova_el('p', { style: { margin: '4px 0', fontSize: '11px', color: '#a0aec0' } }, [\n        'Error ID: ', errorId\n      ])\n    );\n  }\n\n  if (stackTrace) {\n    children.push(\n      tova_el('details', { style: { marginTop: '8px', fontSize: '12px' } }, [\n        tova_el('summary', { style: { cursor: 'pointer', color: '#4a5568' } }, ['Stack trace']),\n        tova_el('pre', { style: { margin: '4px 0', padding: '8px', background: '#1a202c', color: '#e2e8f0', borderRadius: '4px', overflow: 'auto', fontSize: '11px', maxHeight: '200px' } }, [stackTrace]),\n      ])\n    );\n  }\n\n  if (reset) {\n    children.push(\n      tova_el('button', {\n        style: { marginTop: '8px', padding: '6px 16px', background: '#3182ce', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '13px' },\n        onClick: reset,\n      }, [retryCount > 0 ? 'Retry again' : 'Try again'])\n    );\n  }\n\n  return tova_el('div', {\n    style: { padding: '16px', border: '1px solid #fed7d7', borderRadius: '8px', background: '#fff5f5', color: '#2d3748', fontFamily: 'system-ui, -apple-system, sans-serif' },\n    role: 'alert',\n  }, children);\n}\n\n// ─── Dynamic Component ──────────────────────────────────\n// Renders a component dynamically based on a reactive signal.\n// Usage: Dynamic({ component: mySignal, ...props })\nfunction Dynamic({ component, ...rest }) {\n  return {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    compute: () => {\n      const comp = typeof component === 'function' && !component.__tova ? component() : component;\n      if (!comp) return null;\n      if (typeof comp === 'function') {\n        return comp(rest);\n      }\n      return comp;\n    },\n  };\n}\n\n// ─── Portal ─────────────────────────────────────────────\n// Renders children into a different DOM target.\n// Usage: Portal({ target: \"#modal-root\", children })\nfunction Portal({ target, children }) {\n  return {\n    __tova: true,\n    tag: '__portal',\n    props: { target },\n    children: children || [],\n  };\n}\n\n// ─── Suspense ────────────────────────────────────────────\n// Renders fallback while any child lazy() component is loading.\n// Usage: Suspense({ fallback: loadingEl, children: [LazyComp(props)] })\n\nconst SuspenseContext = createContext(null);\nfunction Suspense({ fallback, children }) {\n  const [pending, setPending] = createSignal(0);\n  const childContent = children && children.length === 1 ? children[0] : tova_fragment(children || []);\n\n  const boundary = {\n    register() {\n      setPending(p => p + 1);\n    },\n    resolve() {\n      setPending(p => Math.max(0, p - 1));\n    },\n  };\n\n  return {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    compute: () => {\n      provide(SuspenseContext, boundary);\n      if (pending() > 0) {\n        return typeof fallback === 'function' ? fallback() : fallback;\n      }\n      return childContent;\n    },\n  };\n}\n\n// ─── Lazy ───────────────────────────────────────────────\n// Async component loading with optional fallback.\n// Usage: const LazyComp = lazy(() => import('./HeavyComponent.js'))\nfunction lazy(loader) {\n  let resolved = null;\n  let loadError = null;\n  let promise = null;\n\n  return function LazyWrapper(props) {\n    if (resolved) {\n      return resolved(props);\n    }\n\n    // Check for Suspense boundary\n    const suspense = inject(SuspenseContext);\n\n    if (!promise) {\n      if (suspense) suspense.register();\n      promise = loader()\n        .then(mod => {\n          resolved = mod.default || mod;\n          if (suspense) suspense.resolve();\n        })\n        .catch(e => {\n          loadError = e;\n          if (suspense) suspense.resolve();\n        });\n    }\n\n    const [tick, setTick] = createSignal(0);\n\n    // Trigger re-render when promise settles\n    promise.then(() => setTick(1)).catch(() => setTick(1));\n\n    return {\n      __tova: true,\n      tag: '__dynamic',\n      props: {},\n      children: [],\n      compute: () => {\n        tick(); // Track for reactivity\n        if (loadError) return tova_el('span', { className: 'tova-error' }, [String(loadError)]);\n        if (resolved) return resolved(props);\n        // Fallback while loading (individual or Suspense-level)\n        return props && props.fallback ? props.fallback : null;\n      },\n    };\n  };\n}\n\n// ─── Context (Provide/Inject) ────────────────────────────\n// Tree-based: values are stored on the ownership tree, inject walks up.\nfunction createContext(defaultValue) {\n  const id = Symbol('context');\n  return { _id: id, _default: defaultValue };\n}\nfunction provide(context, value) {\n  const owner = currentOwner;\n  if (owner) {\n    if (!owner._contexts) owner._contexts = new Map();\n    owner._contexts.set(context._id, value);\n  }\n}\nfunction inject(context) {\n  let owner = currentOwner;\n  while (owner) {\n    if (owner._contexts && owner._contexts.has(context._id)) {\n      return owner._contexts.get(context._id);\n    }\n    owner = owner._owner;\n  }\n  return context._default;\n}\n\n// ─── DOM Rendering ────────────────────────────────────────\n\n// Inject scoped CSS into the page (idempotent — only injects once per id)\nconst __tovaInjectedStyles = new Set();\nfunction tova_inject_css(id, css) {\n  if (__tovaInjectedStyles.has(id)) return;\n  __tovaInjectedStyles.add(id);\n  const style = document.createElement('style');\n  style.setAttribute('data-tova-style', id);\n  style.textContent = css;\n  document.head.appendChild(style);\n}\nfunction tova_el(tag, props = {}, children = []) {\n  return { __tova: true, tag, props, children };\n}\nfunction tova_fragment(children) {\n  return { __tova: true, tag: '__fragment', props: {}, children };\n}\n\n// ─── Transitions ──────────────────────────────────────────\n// CSS transition directives for mount/unmount animations.\n// Usage: tova_transition(vnode, \"fade\", { duration: 300 })\n\nconst TRANSITION_DEFAULTS = {\n  fade: { duration: 200, easing: 'ease' },\n  slide: { duration: 300, easing: 'ease-out', axis: 'y' },\n  scale: { duration: 200, easing: 'ease' },\n  fly: { duration: 300, easing: 'ease-out', x: 0, y: -20 },\n};\n\nfunction getTransitionCSS(name, config, phase) {\n  const opts = { ...TRANSITION_DEFAULTS[name], ...config };\n  const dur = opts.duration + 'ms';\n  const ease = opts.easing;\n\n  switch (name) {\n    case 'fade':\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { opacity: '0', transition: `opacity ${dur} ${ease}` };\n      }\n      return { opacity: '1', transition: `opacity ${dur} ${ease}` };\n\n    case 'slide': {\n      const axis = opts.axis || 'y';\n      const prop = axis === 'x' ? 'translateX' : 'translateY';\n      const dist = (opts.distance || 20) + 'px';\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { transform: `${prop}(${dist})`, opacity: '0', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n      }\n      return { transform: `${prop}(0)`, opacity: '1', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n    }\n\n    case 'scale':\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { transform: 'scale(0)', opacity: '0', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n      }\n      return { transform: 'scale(1)', opacity: '1', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n\n    case 'fly': {\n      const x = (opts.x || 0) + 'px';\n      const y = (opts.y || -20) + 'px';\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { transform: `translate(${x}, ${y})`, opacity: '0', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n      }\n      return { transform: 'translate(0, 0)', opacity: '1', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n    }\n\n    default:\n      return {};\n  }\n}\nfunction tova_transition(vnode, nameOrConfig, config = {}) {\n  if (!vnode || !vnode.__tova) return vnode;\n\n  // Directional transitions: tova_transition(vnode, { in: {...}, out: {...} })\n  if (typeof nameOrConfig === 'object' && nameOrConfig !== null && !nameOrConfig.__tova && (nameOrConfig.in || nameOrConfig.out)) {\n    vnode._transition = { directional: true, in: nameOrConfig.in, out: nameOrConfig.out };\n    return vnode;\n  }\n\n  // Custom transition function: tova_transition(vnode, myTransitionFn, config)\n  if (typeof nameOrConfig === 'function') {\n    vnode._transition = { custom: nameOrConfig, config };\n    return vnode;\n  }\n\n  // Built-in transition: tova_transition(vnode, \"fade\", config)\n  vnode._transition = { name: nameOrConfig, config };\n  return vnode;\n}\n\n// ─── Actions ──────────────────────────────────────────────\n// use: directive support. Calls actionFn(el, param) after render.\n// Returns the wrapped vnode. The action lifecycle (update/destroy) is managed.\nfunction __tova_action(vnode, actionFn, param) {\n  if (!vnode || !vnode.__tova) return vnode;\n  if (!vnode._actions) vnode._actions = [];\n  vnode._actions.push({ fn: actionFn, param });\n  return vnode;\n}\n\n// Apply enter transition to a DOM element after render\nfunction applyEnterTransition(el, trans) {\n  if (!trans) return;\n\n  // Custom transition function\n  if (trans.custom) {\n    const result = trans.custom(el, trans.config || {}, 'enter');\n    if (result && typeof result === 'object' && !result.then) {\n      Object.assign(el.style, result);\n    }\n    return;\n  }\n\n  // Directional: use 'in' config for enter\n  const name = trans.directional ? (trans.in ? trans.in.name : null) : trans.name;\n  const config = trans.directional ? (trans.in ? trans.in.config : {}) : trans.config;\n  if (!name) return;\n\n  const fromStyles = getTransitionCSS(name, config, 'enter-from');\n  const toStyles = getTransitionCSS(name, config, 'enter-to');\n\n  // Set initial state\n  Object.assign(el.style, fromStyles);\n\n  // Force reflow, then apply target state\n  void el.offsetHeight;\n  Object.assign(el.style, toStyles);\n}\n\n// Apply leave transition and return a Promise that resolves when done\nfunction applyLeaveTransition(el, trans) {\n  if (!trans) return Promise.resolve();\n\n  // Custom transition function\n  if (trans.custom) {\n    const result = trans.custom(el, trans.config || {}, 'leave');\n    if (result && typeof result.then === 'function') {\n      // Race with timeout to prevent leaked promises from custom transitions\n      const dur = (trans.config && trans.config.duration) || 5000;\n      return Promise.race([result, new Promise(r => setTimeout(r, dur + 100))]);\n    }\n    if (result && typeof result === 'object') {\n      Object.assign(el.style, result);\n    }\n    const dur = (trans.config && trans.config.duration) || 200;\n    return new Promise(resolve => setTimeout(resolve, dur));\n  }\n\n  // Directional: use 'out' config for leave\n  const name = trans.directional ? (trans.out ? trans.out.name : null) : trans.name;\n  const config = trans.directional ? (trans.out ? trans.out.config : {}) : trans.config;\n  if (!name) return Promise.resolve();\n\n  const duration = (config && config.duration) || TRANSITION_DEFAULTS[name]?.duration || 200;\n  const toStyles = getTransitionCSS(name, config, 'leave-to');\n  Object.assign(el.style, toStyles);\n\n  return new Promise(resolve => {\n    const handler = () => {\n      el.removeEventListener('transitionend', handler);\n      resolve();\n    };\n    el.addEventListener('transitionend', handler);\n    // Fallback timeout in case transitionend doesn't fire\n    setTimeout(resolve, duration + 50);\n  });\n}\n\n// Inject a key prop into a vnode for keyed reconciliation\nfunction tova_keyed(key, vnode) {\n  if (vnode && vnode.__tova) {\n    vnode.props = { ...vnode.props, key };\n  }\n  return vnode;\n}\n\n// Flatten nested arrays and vnodes into a flat list of vnodes\nfunction flattenVNodes(children) {\n  const result = [];\n  for (const child of children) {\n    if (child === null || child === undefined) {\n      continue;\n    } else if (Array.isArray(child)) {\n      result.push(...flattenVNodes(child));\n    } else {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\n// ─── Marker-based DOM helpers ─────────────────────────────\n// Instead of wrapping dynamic blocks/fragments in <span style=\"display:contents\">,\n// we use comment node markers. A marker's __tovaNodes tracks its content nodes.\n// Content nodes have __tovaOwner pointing to their owning marker.\n\n// Recursively dispose ownership roots attached to a DOM subtree\nfunction disposeNode(node) {\n  if (!node) return;\n  if (node.__tovaRoot) {\n    node.__tovaRoot();\n    node.__tovaRoot = null;\n  }\n  // If this is a marker, dispose and remove its content nodes\n  if (node.__tovaNodes) {\n    for (const cn of node.__tovaNodes) {\n      disposeNode(cn);\n      if (cn.parentNode) cn.parentNode.removeChild(cn);\n    }\n    node.__tovaNodes = [];\n  }\n  if (node.childNodes) {\n    for (const child of Array.from(node.childNodes)) {\n      disposeNode(child);\n    }\n  }\n}\n\n// Check if a node is transitively owned by a marker (walks __tovaOwner chain)\nfunction isOwnedBy(node, marker) {\n  let owner = node.__tovaOwner;\n  while (owner) {\n    if (owner === marker) return true;\n    owner = owner.__tovaOwner;\n  }\n  return false;\n}\n\n// Get logical children of a parent element (skips marker content nodes)\nfunction getLogicalChildren(parent) {\n  const logical = [];\n  for (let i = 0; i < parent.childNodes.length; i++) {\n    const node = parent.childNodes[i];\n    if (!node.__tovaOwner) {\n      logical.push(node);\n    }\n  }\n  return logical;\n}\n\n// Find the first DOM sibling after all of a marker's content\nfunction nextSiblingAfterMarker(marker) {\n  if (!marker.__tovaNodes || marker.__tovaNodes.length === 0) {\n    return marker.nextSibling;\n  }\n  let last = marker.__tovaNodes[marker.__tovaNodes.length - 1];\n  // If last content is itself a marker, recurse to find physical end\n  while (last && last.__tovaNodes && last.__tovaNodes.length > 0) {\n    last = last.__tovaNodes[last.__tovaNodes.length - 1];\n  }\n  return last ? last.nextSibling : marker.nextSibling;\n}\n\n// Remove a logical node (marker + its content, or a regular node) from the DOM\nfunction removeLogicalNode(parent, node) {\n  disposeNode(node);\n  if (node.parentNode === parent) parent.removeChild(node);\n}\n\n// Insert rendered result (could be single node or DocumentFragment) before ref,\n// setting __tovaOwner on top-level inserted nodes. Returns array of inserted nodes.\nfunction insertRendered(parent, rendered, ref, owner) {\n  if (rendered.nodeType === 11) {\n    const nodes = Array.from(rendered.childNodes);\n    for (const n of nodes) {\n      if (!n.__tovaOwner) n.__tovaOwner = owner;\n    }\n    parent.insertBefore(rendered, ref);\n    return nodes;\n  }\n  if (!rendered.__tovaOwner) rendered.__tovaOwner = owner;\n  parent.insertBefore(rendered, ref);\n  return [rendered];\n}\n\n// Clear a marker's content from the DOM and reset __tovaNodes\nfunction clearMarkerContent(marker) {\n  for (const node of marker.__tovaNodes) {\n    // If element has a leave transition, animate out before removing\n    if (node.__tovaTransition && node.nodeType === 1) {\n      const el = node;\n      applyLeaveTransition(el, el.__tovaTransition).then(() => {\n        disposeNode(el);\n        if (el.parentNode) el.parentNode.removeChild(el);\n      }).catch(() => {\n        disposeNode(el);\n        if (el.parentNode) el.parentNode.removeChild(el);\n      });\n    } else {\n      disposeNode(node);\n      if (node.parentNode) node.parentNode.removeChild(node);\n    }\n  }\n  marker.__tovaNodes = [];\n}\n\n// ─── Render ───────────────────────────────────────────────\n\n// Create real DOM nodes from a vnode (with fine-grained reactive bindings).\n// Returns a single DOM node for elements/text, or a DocumentFragment for\n// markers (dynamic blocks, fragments) containing [marker, ...content].\nfunction render(vnode) {\n  if (vnode === null || vnode === undefined) {\n    return document.createTextNode('');\n  }\n\n  // Reactive dynamic block (JSXIf, JSXFor, reactive text, etc.)\n  if (typeof vnode === 'function') {\n    const marker = document.createComment('');\n    marker.__tovaDynamic = true;\n    marker.__tovaNodes = [];\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    createEffect(() => {\n      const val = vnode();\n      const parent = marker.parentNode;\n      const ref = nextSiblingAfterMarker(marker);\n\n      // Array: keyed or positional reconciliation within marker range\n      if (Array.isArray(val)) {\n        const flat = flattenVNodes(val);\n        const hasKeys = flat.some(c => getKey(c) != null);\n        if (hasKeys) {\n          patchKeyedInMarker(marker, flat);\n        } else {\n          patchPositionalInMarker(marker, flat);\n        }\n        return;\n      }\n\n      // Text: optimize single text node update in place\n      if (val == null || typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {\n        const text = val == null ? '' : String(val);\n        if (marker.__tovaNodes.length === 1 && marker.__tovaNodes[0].nodeType === 3) {\n          if (marker.__tovaNodes[0].textContent !== text) {\n            marker.__tovaNodes[0].textContent = text;\n          }\n          return;\n        }\n        clearMarkerContent(marker);\n        const textNode = document.createTextNode(text);\n        textNode.__tovaOwner = marker;\n        parent.insertBefore(textNode, ref);\n        marker.__tovaNodes = [textNode];\n        return;\n      }\n\n      // Vnode or other: clear and re-render\n      clearMarkerContent(marker);\n      if (val && val.__tova) {\n        const rendered = render(val);\n        marker.__tovaNodes = insertRendered(parent, rendered, ref, marker);\n      } else {\n        const textNode = document.createTextNode(String(val));\n        textNode.__tovaOwner = marker;\n        parent.insertBefore(textNode, ref);\n        marker.__tovaNodes = [textNode];\n      }\n    });\n\n    return frag;\n  }\n\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    return document.createTextNode(String(vnode));\n  }\n\n  if (Array.isArray(vnode)) {\n    const fragment = document.createDocumentFragment();\n    for (const child of vnode) {\n      fragment.appendChild(render(child));\n    }\n    return fragment;\n  }\n\n  if (!vnode.__tova) {\n    return document.createTextNode(String(vnode));\n  }\n\n  // Fragment — marker + children (no wrapper element)\n  if (vnode.tag === '__fragment') {\n    const marker = document.createComment('');\n    marker.__tovaFragment = true;\n    marker.__tovaNodes = [];\n    marker.__vnode = vnode;\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    for (const child of flattenVNodes(vnode.children)) {\n      const rendered = render(child);\n      const inserted = insertRendered(frag, rendered, null, marker);\n      marker.__tovaNodes.push(...inserted);\n    }\n\n    return frag;\n  }\n\n  // Dynamic reactive node (ErrorBoundary, Dynamic component, etc.)\n  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {\n    const marker = document.createComment('');\n    marker.__tovaDynamic = true;\n    marker.__tovaNodes = [];\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    let prevDispose = null;\n    const errHandler = vnode._errorHandler || null;\n    createEffect(() => {\n      if (errHandler) pushErrorHandler(errHandler);\n      try {\n        const inner = vnode.compute();\n        const parent = marker.parentNode;\n        const ref = nextSiblingAfterMarker(marker);\n\n        if (prevDispose) {\n          prevDispose();\n          prevDispose = null;\n        }\n        clearMarkerContent(marker);\n\n        createRoot((dispose) => {\n          prevDispose = dispose;\n          const rendered = render(inner);\n          marker.__tovaNodes = insertRendered(parent, rendered, ref, marker);\n        });\n      } catch (e) {\n        if (errHandler) {\n          errHandler(e);\n        } else if (currentErrorHandler) {\n          currentErrorHandler(e);\n        } else {\n          console.error('Uncaught error during render:', e);\n        }\n      } finally {\n        if (errHandler) popErrorHandler();\n      }\n    });\n\n    return frag;\n  }\n\n  // Portal — render children into a different DOM target\n  if (vnode.tag === '__portal') {\n    const placeholder = document.createComment('portal');\n    const targetSelector = vnode.props.target;\n    queueMicrotask(() => {\n      const targetEl = typeof targetSelector === 'string'\n        ? document.querySelector(targetSelector)\n        : targetSelector;\n      if (targetEl) {\n        for (const child of flattenVNodes(vnode.children)) {\n          targetEl.appendChild(render(child));\n        }\n      }\n    });\n    return placeholder;\n  }\n\n  // Element\n  const el = document.createElement(vnode.tag);\n  applyReactiveProps(el, vnode.props);\n\n  // Set data-tova-component attribute for DevTools\n  if (vnode._componentName) {\n    el.setAttribute('data-tova-component', vnode._componentName);\n    if (__devtools_hooks && __devtools_hooks.onComponentRender) {\n      __devtools_hooks.onComponentRender(vnode._componentName, el, 0);\n    }\n  }\n\n  // Render children\n  for (const child of flattenVNodes(vnode.children)) {\n    el.appendChild(render(child));\n  }\n\n  // Store vnode reference for patching\n  el.__vnode = vnode;\n\n  // Apply enter transition if present\n  if (vnode._transition) {\n    el.__tovaTransition = vnode._transition;\n    applyEnterTransition(el, vnode._transition);\n  }\n\n  // Apply use: actions if present\n  if (vnode._actions && vnode._actions.length > 0) {\n    for (const action of vnode._actions) {\n      const paramValue = typeof action.param === 'function' ? action.param() : action.param;\n      const result = action.fn(el, paramValue);\n      if (result) {\n        // If param is reactive, set up effect for updates\n        if (typeof action.param === 'function') {\n          createEffect(() => {\n            const newVal = action.param();\n            if (result.update) result.update(newVal);\n          });\n        }\n        // Register destroy on cleanup\n        if (result.destroy) {\n          if (currentOwner && !currentOwner._disposed) {\n            currentOwner._cleanups.push(result.destroy);\n          }\n        }\n      }\n    }\n  }\n\n  return el;\n}\n\n// Apply reactive props — function-valued props get their own effect\nfunction applyReactiveProps(el, props) {\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      if (typeof value === 'object' && value !== null && value.handler) {\n        el.addEventListener(eventName, value.handler, value.options);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value.handler;\n        el.__handlerOptions = el.__handlerOptions || {};\n        el.__handlerOptions[eventName] = value.options;\n      } else {\n        el.addEventListener(eventName, value);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value;\n      }\n    } else if (key === 'key') {\n      // Skip\n    } else if (typeof value === 'function' && !key.startsWith('on')) {\n      // Reactive prop — create effect for fine-grained updates\n      createEffect(() => {\n        const val = value();\n        applyPropValue(el, key, val);\n      });\n    } else {\n      applyPropValue(el, key, value);\n    }\n  }\n}\n\nfunction applyPropValue(el, key, val) {\n  if (key === 'className') {\n    if (el.className !== val) el.className = val || '';\n  } else if (key === 'innerHTML' || key === 'dangerouslySetInnerHTML') {\n    const html = typeof val === 'object' && val !== null ? val.__html || '' : val || '';\n    if (__DEV__ && html) {\n      console.warn('Tova: Setting innerHTML can expose your app to XSS attacks. Ensure the content is sanitized.');\n    }\n    if (el.innerHTML !== html) el.innerHTML = html;\n  } else if (key === 'value') {\n    if (el !== document.activeElement && el.value !== val) {\n      el.value = val;\n    }\n  } else if (key === 'checked') {\n    el.checked = !!val;\n  } else if (key === 'disabled' || key === 'readOnly' || key === 'hidden') {\n    el[key] = !!val;\n  } else if (key === 'style' && typeof val === 'object') {\n    // Delta update: only remove properties that were in previous style but not in new\n    if (el.__prevStyle) {\n      for (const prop of Object.keys(el.__prevStyle)) {\n        if (!(prop in val)) el.style.removeProperty(prop);\n      }\n    }\n    el.__prevStyle = { ...val };\n    Object.assign(el.style, val);\n  } else {\n    const s = val == null ? '' : String(val);\n    if (el.getAttribute(key) !== s) {\n      el.setAttribute(key, s);\n    }\n  }\n}\n\n// Apply/update props on a DOM element (used by patcher for full-tree mode)\nfunction applyProps(el, newProps, oldProps) {\n  // Remove old props that are no longer present\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in newProps)) {\n      if (key.startsWith('on')) {\n        const eventName = key.slice(2).toLowerCase();\n        if (el.__handlers && el.__handlers[eventName]) {\n          el.removeEventListener(eventName, el.__handlers[eventName]);\n          delete el.__handlers[eventName];\n        }\n      } else if (key === 'className') {\n        el.className = '';\n      } else if (key === 'style') {\n        el.removeAttribute('style');\n      } else {\n        el.removeAttribute(key);\n      }\n    }\n  }\n\n  // Apply new props\n  for (const [key, value] of Object.entries(newProps)) {\n    if (key === 'className') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.className !== val) el.className = val;\n    } else if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      if (typeof value === 'object' && value !== null && value.handler) {\n        const oldHandler = el.__handlers && el.__handlers[eventName];\n        if (oldHandler !== value.handler) {\n          const oldOpts = el.__handlerOptions && el.__handlerOptions[eventName];\n          if (oldHandler) el.removeEventListener(eventName, oldHandler, oldOpts);\n          el.addEventListener(eventName, value.handler, value.options);\n          if (!el.__handlers) el.__handlers = {};\n          el.__handlers[eventName] = value.handler;\n          el.__handlerOptions = el.__handlerOptions || {};\n          el.__handlerOptions[eventName] = value.options;\n        }\n      } else {\n        const oldHandler = el.__handlers && el.__handlers[eventName];\n        if (oldHandler !== value) {\n          if (oldHandler) el.removeEventListener(eventName, oldHandler);\n          el.addEventListener(eventName, value);\n          if (!el.__handlers) el.__handlers = {};\n          el.__handlers[eventName] = value;\n        }\n      }\n    } else if (key === 'style' && typeof value === 'object') {\n      Object.assign(el.style, value);\n    } else if (key === 'key') {\n      // Skip\n    } else if (key === 'value') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el !== document.activeElement && el.value !== val) {\n        el.value = val;\n      }\n    } else if (key === 'checked') {\n      el.checked = !!value;\n    } else {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.getAttribute(key) !== String(val)) {\n        el.setAttribute(key, val);\n      }\n    }\n  }\n}\n\n// ─── Longest Increasing Subsequence (O(n log n)) ────────\n// Used by keyed reconciliation to minimize DOM moves.\n\nfunction longestIncreasingSubsequence(arr) {\n  const n = arr.length;\n  if (n === 0) return [];\n\n  // tails[i] = index in arr of smallest tail element for IS of length i+1\n  const tails = [];\n  // parent[i] = index in arr of predecessor of arr[i] in the LIS\n  const parent = new Array(n).fill(-1);\n  // indices[i] = index in arr of tails[i]\n  const indices = [];\n\n  for (let i = 0; i < n; i++) {\n    const val = arr[i];\n    if (val < 0) continue; // skip removed items (marker -1)\n\n    // Binary search for the insertion point\n    let lo = 0, hi = tails.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >> 1;\n      if (tails[mid] < val) lo = mid + 1;\n      else hi = mid;\n    }\n\n    tails[lo] = val;\n    indices[lo] = i;\n\n    if (lo > 0) {\n      parent[i] = indices[lo - 1];\n    }\n  }\n\n  // Reconstruct\n  const result = new Array(tails.length);\n  let k = indices[tails.length - 1];\n  for (let i = tails.length - 1; i >= 0; i--) {\n    result[i] = k;\n    k = parent[k];\n  }\n\n  return result;\n}\n\n// ─── Keyed Reconciliation ────────────────────────────────\n\nfunction getKey(vnode) {\n  if (vnode && vnode.__tova && vnode.props) return vnode.props.key;\n  return undefined;\n}\n\nfunction getNodeKey(node) {\n  if (node && node.__vnode && node.__vnode.props) return node.__vnode.props.key;\n  return undefined;\n}\n\n// Keyed reconciliation within a marker's content range\nfunction patchKeyedInMarker(marker, newVNodes) {\n  const parent = marker.parentNode;\n  const oldNodes = [...marker.__tovaNodes];\n  const oldKeyMap = new Map();\n\n  for (const node of oldNodes) {\n    const key = getNodeKey(node);\n    if (key != null) oldKeyMap.set(key, node);\n  }\n\n  const newNodes = [];\n  const usedOld = new Set();\n\n  for (const newChild of newVNodes) {\n    const key = getKey(newChild);\n\n    if (key != null && oldKeyMap.has(key)) {\n      const oldNode = oldKeyMap.get(key);\n      usedOld.add(oldNode);\n\n      if (oldNode.nodeType === 1 && newChild.__tova &&\n          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {\n        const oldVNode = oldNode.__vnode || { props: {}, children: [] };\n        applyProps(oldNode, newChild.props, oldVNode.props);\n        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));\n        oldNode.__vnode = newChild;\n        newNodes.push(oldNode);\n      } else {\n        const node = render(newChild);\n        // render may return Fragment — collect nodes\n        if (node.nodeType === 11) {\n          const nodes = Array.from(node.childNodes);\n          for (const n of nodes) { if (!n.__tovaOwner) n.__tovaOwner = marker; }\n          parent.insertBefore(node, nextSiblingAfterMarker(marker));\n          newNodes.push(...nodes);\n        } else {\n          if (!node.__tovaOwner) node.__tovaOwner = marker;\n          newNodes.push(node);\n        }\n      }\n    } else {\n      const node = render(newChild);\n      if (node.nodeType === 11) {\n        const nodes = Array.from(node.childNodes);\n        for (const n of nodes) { if (!n.__tovaOwner) n.__tovaOwner = marker; }\n        parent.insertBefore(node, nextSiblingAfterMarker(marker));\n        newNodes.push(...nodes);\n      } else {\n        if (!node.__tovaOwner) node.__tovaOwner = marker;\n        newNodes.push(node);\n      }\n    }\n  }\n\n  // Remove unused old nodes\n  for (const node of oldNodes) {\n    if (!usedOld.has(node)) {\n      disposeNode(node);\n      if (node.parentNode === parent) parent.removeChild(node);\n    }\n  }\n\n  // LIS-based reorder: compute old positions, find LIS, only move non-LIS nodes\n  const oldPosMap = new Map();\n  for (let i = 0; i < oldNodes.length; i++) {\n    oldPosMap.set(oldNodes[i], i);\n  }\n  const positions = newNodes.map(n => oldPosMap.has(n) ? oldPosMap.get(n) : -1);\n  const lisIndices = new Set(longestIncreasingSubsequence(positions));\n\n  // Insert nodes: only move nodes not in the LIS\n  let cursor = marker.nextSibling;\n  for (let i = 0; i < newNodes.length; i++) {\n    const node = newNodes[i];\n    if (lisIndices.has(i) && node === cursor) {\n      cursor = node.nextSibling;\n    } else {\n      parent.insertBefore(node, cursor);\n    }\n  }\n\n  marker.__tovaNodes = newNodes;\n}\n\n// Positional reconciliation within a marker's content range\nfunction patchPositionalInMarker(marker, newChildren) {\n  const parent = marker.parentNode;\n  const oldNodes = [...marker.__tovaNodes];\n  const oldCount = oldNodes.length;\n  const newCount = newChildren.length;\n\n  // Patch in place (skip identical vnodes)\n  const patchCount = Math.min(oldCount, newCount);\n  for (let i = 0; i < patchCount; i++) {\n    if (oldNodes[i] === newChildren[i]) continue;\n    patchSingle(parent, oldNodes[i], newChildren[i]);\n  }\n\n  // Append new children\n  const ref = nextSiblingAfterMarker(marker);\n  for (let i = oldCount; i < newCount; i++) {\n    const rendered = render(newChildren[i]);\n    const inserted = insertRendered(parent, rendered, ref, marker);\n    oldNodes.push(...inserted);\n  }\n\n  // Remove excess children\n  for (let i = newCount; i < oldCount; i++) {\n    disposeNode(oldNodes[i]);\n    if (oldNodes[i].parentNode === parent) parent.removeChild(oldNodes[i]);\n  }\n\n  marker.__tovaNodes = oldNodes.slice(0, newCount);\n}\n\n// Keyed reconciliation for children of an element (not marker-based)\nfunction patchKeyedChildren(parent, newVNodes) {\n  const logical = getLogicalChildren(parent);\n  const oldKeyMap = new Map();\n\n  for (const node of logical) {\n    const key = getNodeKey(node);\n    if (key != null) oldKeyMap.set(key, node);\n  }\n\n  const newNodes = [];\n  const usedOld = new Set();\n\n  for (const newChild of newVNodes) {\n    const key = getKey(newChild);\n\n    if (key != null && oldKeyMap.has(key)) {\n      const oldNode = oldKeyMap.get(key);\n      usedOld.add(oldNode);\n\n      if (oldNode.nodeType === 1 && newChild.__tova &&\n          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {\n        const oldVNode = oldNode.__vnode || { props: {}, children: [] };\n        applyProps(oldNode, newChild.props, oldVNode.props);\n        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));\n        oldNode.__vnode = newChild;\n        newNodes.push(oldNode);\n      } else {\n        newNodes.push(render(newChild));\n      }\n    } else {\n      newNodes.push(render(newChild));\n    }\n  }\n\n  // Remove unused old logical nodes\n  for (const node of logical) {\n    if (!usedOld.has(node) && node.parentNode === parent) {\n      removeLogicalNode(parent, node);\n    }\n  }\n\n  // LIS-based reorder for element children\n  const logicalAfterRemove = getLogicalChildren(parent);\n  const oldPosMap = new Map();\n  for (let i = 0; i < logicalAfterRemove.length; i++) {\n    oldPosMap.set(logicalAfterRemove[i], i);\n  }\n  const positions = newNodes.map(n => oldPosMap.has(n) ? oldPosMap.get(n) : -1);\n  const lisIndices = new Set(longestIncreasingSubsequence(positions));\n\n  for (let i = 0; i < newNodes.length; i++) {\n    const expected = newNodes[i];\n    if (!lisIndices.has(i)) {\n      const logicalNow = getLogicalChildren(parent);\n      const current = logicalNow[i];\n      if (current !== expected) {\n        parent.insertBefore(expected, current || null);\n      }\n    }\n  }\n}\n\n// Positional reconciliation for children of an element\nfunction patchPositionalChildren(parent, newChildren) {\n  const logical = getLogicalChildren(parent);\n  const oldCount = logical.length;\n  const newCount = newChildren.length;\n\n  for (let i = 0; i < Math.min(oldCount, newCount); i++) {\n    patchSingle(parent, logical[i], newChildren[i]);\n  }\n\n  for (let i = oldCount; i < newCount; i++) {\n    parent.appendChild(render(newChildren[i]));\n  }\n\n  // Remove excess logical children\n  const currentLogical = getLogicalChildren(parent);\n  while (currentLogical.length > newCount) {\n    const node = currentLogical.pop();\n    removeLogicalNode(parent, node);\n  }\n}\n\n// Patch children of a regular element\nfunction patchChildrenOfElement(el, newChildren) {\n  const hasKeys = newChildren.some(c => getKey(c) != null);\n  if (hasKeys) {\n    patchKeyedChildren(el, newChildren);\n  } else {\n    patchPositionalChildren(el, newChildren);\n  }\n}\n\n// Patch a single logical node in place\nfunction patchSingle(parent, existing, newVNode) {\n  if (!existing) {\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  if (newVNode === null || newVNode === undefined) {\n    removeLogicalNode(parent, existing);\n    return;\n  }\n\n  // Function vnode — replace with new dynamic block\n  if (typeof newVNode === 'function') {\n    const rendered = render(newVNode);\n    if (existing.__tovaNodes) {\n      // Existing is a marker — clear its content and replace\n      clearMarkerContent(existing);\n      parent.replaceChild(rendered, existing);\n    } else {\n      disposeNode(existing);\n      parent.replaceChild(rendered, existing);\n    }\n    return;\n  }\n\n  // Text\n  if (typeof newVNode === 'string' || typeof newVNode === 'number' || typeof newVNode === 'boolean') {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      removeLogicalNode(parent, existing);\n      parent.insertBefore(document.createTextNode(text), null);\n    }\n    return;\n  }\n\n  if (!newVNode.__tova) {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      removeLogicalNode(parent, existing);\n      parent.insertBefore(document.createTextNode(text), null);\n    }\n    return;\n  }\n\n  // Fragment — patch marker content\n  if (newVNode.tag === '__fragment') {\n    if (existing.__tovaFragment) {\n      // Patch children within the marker range\n      const oldNodes = [...existing.__tovaNodes];\n      const newChildren = flattenVNodes(newVNode.children);\n      // Simple approach: clear and re-render fragment content\n      clearMarkerContent(existing);\n      const ref = nextSiblingAfterMarker(existing);\n      for (const child of newChildren) {\n        const rendered = render(child);\n        const inserted = insertRendered(parent, rendered, ref, existing);\n        existing.__tovaNodes.push(...inserted);\n      }\n      existing.__vnode = newVNode;\n      return;\n    }\n    removeLogicalNode(parent, existing);\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  // Element — patch in place\n  if (existing.nodeType === 1 && newVNode.tag &&\n      existing.tagName.toLowerCase() === newVNode.tag.toLowerCase()) {\n    const oldVNode = existing.__vnode || { props: {}, children: [] };\n    applyProps(existing, newVNode.props, oldVNode.props);\n    patchChildrenOfElement(existing, flattenVNodes(newVNode.children));\n    existing.__vnode = newVNode;\n    return;\n  }\n\n  // Different type — full replace\n  removeLogicalNode(parent, existing);\n  parent.appendChild(render(newVNode));\n}\n\n// ─── Hydration (SSR) ─────────────────────────────────────\n// SSR renders flat HTML without markers. Hydration attaches reactivity\n// to existing DOM nodes and inserts markers for dynamic blocks.\n\n// Dev-mode hydration mismatch detection\nfunction checkHydrationMismatch(domNode, vnode) {\n  if (!__DEV__) return;\n  if (!domNode || !vnode || !vnode.__tova) return;\n\n  const props = vnode.props || {};\n\n  // Check className\n  if (props.className !== undefined) {\n    const expected = typeof props.className === 'function' ? props.className() : props.className;\n    const actual = domNode.className || '';\n    if (expected && actual !== expected) {\n      console.warn(`Tova hydration mismatch: <${vnode.tag}> class expected \"${expected}\" but got \"${actual}\"`);\n    }\n  }\n\n  // Check attributes\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'key' || key === 'ref' || key === 'className' || key.startsWith('on')) continue;\n    if (typeof value === 'function') continue; // reactive props — skip static check\n\n    if (domNode.getAttribute) {\n      const attrName = key === 'className' ? 'class' : key;\n      const actual = domNode.getAttribute(attrName);\n      const expected = String(value);\n      if (actual !== null && actual !== expected) {\n        console.warn(`Tova hydration mismatch: <${vnode.tag}> attribute \"${key}\" expected \"${expected}\" but got \"${actual}\"`);\n      }\n    }\n  }\n}\n\n// Check if a DOM node is an SSR marker comment (<!--tova-s:ID-->)\nfunction isSSRMarker(node) {\n  return node && node.nodeType === 8 && typeof node.data === 'string' && node.data.startsWith('tova-s:');\n}\n\n// Find the closing SSR marker and collect content nodes between them\nfunction collectSSRMarkerContent(startMarker) {\n  const id = startMarker.data.replace('tova-s:', '');\n  const closingText = `/tova-s:${id}`;\n  const content = [];\n  let cursor = startMarker.nextSibling;\n  while (cursor) {\n    if (cursor.nodeType === 8 && cursor.data === closingText) {\n      return { content, endMarker: cursor };\n    }\n    content.push(cursor);\n    cursor = cursor.nextSibling;\n  }\n  return { content, endMarker: null };\n}\n\nfunction hydrateVNode(domNode, vnode) {\n  if (!domNode) return null;\n  if (vnode === null || vnode === undefined) return domNode;\n\n  // Function vnode (reactive text, JSXIf, JSXFor)\n  if (typeof vnode === 'function') {\n    if (domNode.nodeType === 3) {\n      // Dev-mode: warn if text content differs\n      if (__DEV__) {\n        const val = vnode();\n        const expected = val == null ? '' : String(val);\n        if (domNode.textContent !== expected) {\n          console.warn(`Tova hydration mismatch: text expected \"${expected}\" but got \"${domNode.textContent}\"`);\n        }\n      }\n      // Reactive text: attach effect to existing text node\n      domNode.__tovaReactive = true;\n      createEffect(() => {\n        const val = vnode();\n        const text = val == null ? '' : String(val);\n        if (domNode.textContent !== text) domNode.textContent = text;\n      });\n      return domNode.nextSibling;\n    }\n    // Complex dynamic block: insert marker-based render, replace SSR node\n    const parent = domNode.parentNode;\n    const next = domNode.nextSibling;\n    const rendered = render(vnode);\n    parent.replaceChild(rendered, domNode);\n    return next;\n  }\n\n  // Primitive text — already correct from SSR\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    if (__DEV__ && domNode.nodeType === 3) {\n      const expected = String(vnode);\n      if (domNode.textContent !== expected) {\n        console.warn(`Tova hydration mismatch: text expected \"${expected}\" but got \"${domNode.textContent}\"`);\n      }\n    }\n    return domNode.nextSibling;\n  }\n\n  // Array\n  if (Array.isArray(vnode)) {\n    let cursor = domNode;\n    for (const child of flattenVNodes(vnode)) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return cursor;\n  }\n\n  if (!vnode.__tova) return domNode.nextSibling;\n\n  // Fragment — children rendered inline in SSR (no wrapper)\n  if (vnode.tag === '__fragment') {\n    const children = flattenVNodes(vnode.children);\n    let cursor = domNode;\n    for (const child of children) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return cursor;\n  }\n\n  // Dynamic node — SSR marker-aware hydration\n  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {\n    // Check if current domNode is an SSR marker (<!--tova-s:ID-->)\n    if (isSSRMarker(domNode)) {\n      const { content, endMarker } = collectSSRMarkerContent(domNode);\n      const parent = domNode.parentNode;\n\n      // Remove SSR markers and content, replace with reactive marker\n      const afterEnd = endMarker ? endMarker.nextSibling : null;\n      for (const node of content) {\n        if (node.parentNode === parent) parent.removeChild(node);\n      }\n      if (endMarker && endMarker.parentNode === parent) parent.removeChild(endMarker);\n\n      const rendered = render(vnode);\n      parent.replaceChild(rendered, domNode);\n      return afterEnd;\n    }\n\n    // No SSR marker — fall back to standard behavior\n    const parent = domNode.parentNode;\n    const next = domNode.nextSibling;\n    const rendered = render(vnode);\n    parent.replaceChild(rendered, domNode);\n    return next;\n  }\n\n  // Element — attach event handlers, reactive props, refs\n  if (domNode.nodeType === 1 && domNode.tagName.toLowerCase() === vnode.tag.toLowerCase()) {\n    if (__DEV__) checkHydrationMismatch(domNode, vnode);\n    hydrateProps(domNode, vnode.props);\n    domNode.__vnode = vnode;\n\n    const children = flattenVNodes(vnode.children || []);\n    let cursor = domNode.firstChild;\n    for (const child of children) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return domNode.nextSibling;\n  }\n\n  // Tag mismatch — fall back to full render\n  if (__DEV__) {\n    const expectedTag = vnode.tag || '(unknown)';\n    const actualTag = domNode.tagName ? domNode.tagName.toLowerCase() : `nodeType:${domNode.nodeType}`;\n    console.warn(`Tova hydration mismatch: expected <${expectedTag}> but got <${actualTag}>, falling back to full render`);\n  }\n  const parent = domNode.parentNode;\n  const next = domNode.nextSibling;\n  const rendered = render(vnode);\n  parent.replaceChild(rendered, domNode);\n  return next;\n}\n\nfunction hydrateProps(el, props) {\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      if (typeof value === 'object' && value !== null && value.handler) {\n        el.addEventListener(eventName, value.handler, value.options);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value.handler;\n        el.__handlerOptions = el.__handlerOptions || {};\n        el.__handlerOptions[eventName] = value.options;\n      } else {\n        el.addEventListener(eventName, value);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value;\n      }\n    } else if (key === 'key') {\n      // Skip\n    } else if (typeof value === 'function' && !key.startsWith('on')) {\n      createEffect(() => {\n        const val = value();\n        applyPropValue(el, key, val);\n      });\n    }\n  }\n}\nfunction hydrate(component, container) {\n  if (!container) {\n    console.error('Tova: Hydration target not found');\n    return;\n  }\n\n  const startTime = typeof performance !== 'undefined' ? performance.now() : 0;\n\n  const result = createRoot(() => {\n    const vnode = typeof component === 'function' ? component() : component;\n    if (container.firstChild) {\n      hydrateVNode(container.firstChild, vnode);\n    }\n  });\n\n  // Dispatch hydration completion event\n  const duration = typeof performance !== 'undefined' ? performance.now() - startTime : 0;\n  if (typeof CustomEvent !== 'undefined' && typeof container.dispatchEvent === 'function') {\n    container.dispatchEvent(new CustomEvent('tova:hydrated', { detail: { duration }, bubbles: true }));\n  }\n\n  if (__devtools_hooks && __devtools_hooks.onHydrate) {\n    __devtools_hooks.onHydrate({ duration });\n  }\n\n  return result;\n}\nfunction mount(component, container) {\n  if (!container) {\n    console.error('Tova: Mount target not found');\n    return;\n  }\n\n  const result = createRoot((dispose) => {\n    const vnode = typeof component === 'function' ? component() : component;\n    container.innerHTML = '';\n    container.appendChild(render(vnode));\n    return dispose;\n  });\n\n  if (__devtools_hooks && __devtools_hooks.onMount) {\n    __devtools_hooks.onMount();\n  }\n\n  return result;\n}\n\n// ─── Progressive Hydration ──────────────────────────────────\n// Hydrate a component only when it becomes visible in the viewport.\nfunction hydrateWhenVisible(component, domNode, options = {}) {\n  if (typeof IntersectionObserver === 'undefined') {\n    // Fallback: hydrate immediately\n    return hydrate(component, domNode);\n  }\n\n  const { rootMargin = '200px' } = options;\n  let hydrated = false;\n\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting && !hydrated) {\n          hydrated = true;\n          observer.disconnect();\n          hydrate(component, domNode);\n        }\n      }\n    },\n    { rootMargin },\n  );\n\n  observer.observe(domNode);\n\n  return () => {\n    observer.disconnect();\n  };\n}";
var STRING_PROTO_CODE = "{\n// Tova string method extensions — bridges Tova method syntax to JavaScript\n// Allows: \"hello\".upper() instead of requiring upper(\"hello\")\n\nconst methods = {\n  upper()       { return this.toUpperCase(); },\n  lower()       { return this.toLowerCase(); },\n  contains(s)   { return this.includes(s); },\n  starts_with(s){ return this.startsWith(s); },\n  ends_with(s)  { return this.endsWith(s); },\n  chars()       { return [...this]; },\n  words()       { return this.split(/\\s+/).filter(Boolean); },\n  lines()       { return this.split('\\n'); },\n  capitalize()  { return this.length ? this.charAt(0).toUpperCase() + this.slice(1) : this; },\n  title_case()  { return this.replace(/\\b\\w/g, c => c.toUpperCase()); },\n  snake_case()  { return this.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },\n  camel_case()  { return this.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },\n};\n\nfor (const [name, fn] of Object.entries(methods)) {\n  if (!String.prototype[name]) {\n    Object.defineProperty(String.prototype, name, {\n      value: fn,\n      writable: true,\n      configurable: true,\n    });\n  }\n}\n}";
var ARRAY_PROTO_CODE = "{\n// Tova array method extensions — bridges Tova method syntax to JavaScript\n// Allows: [1,2,3].sorted() instead of requiring sorted([1,2,3])\n\nconst methods = {\n  sorted(key)     { const c = [...this]; if (key) c.sort((x, y) => { const kx = key(x), ky = key(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; },\n  reversed()      { return [...this].reverse(); },\n  unique()        { return [...new Set(this)]; },\n  chunk(n)        { const r = []; for (let i = 0; i < this.length; i += n) r.push(this.slice(i, i + n)); return r; },\n  flatten()       { return this.flat(); },\n  first()         { return this[0] ?? null; },\n  last()          { return this[this.length - 1] ?? null; },\n  take(n)         { return this.slice(0, n); },\n  drop(n)         { return this.slice(n); },\n  compact()       { return this.filter(v => v != null); },\n  sum()           { return this.reduce((a, b) => a + b, 0); },\n  min_val()       { if (this.length === 0) return null; let m = this[0]; for (let i = 1; i < this.length; i++) if (this[i] < m) m = this[i]; return m; },\n  max_val()       { if (this.length === 0) return null; let m = this[0]; for (let i = 1; i < this.length; i++) if (this[i] > m) m = this[i]; return m; },\n  group_by(fn)    { const r = {}; for (const v of this) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; },\n  partition(fn)   { const y = [], n = []; for (const v of this) { (fn(v) ? y : n).push(v); } return [y, n]; },\n  zip_with(other) { const m = Math.min(this.length, other.length); const r = []; for (let i = 0; i < m; i++) r.push([this[i], other[i]]); return r; },\n  frequencies()   { const r = {}; for (const v of this) { const k = String(v); r[k] = (r[k] || 0) + 1; } return r; },\n};\n\nfor (const [name, fn] of Object.entries(methods)) {\n  if (!Array.prototype[name]) {\n    Object.defineProperty(Array.prototype, name, {\n      value: fn,\n      writable: true,\n      configurable: true,\n    });\n  }\n}\n}";
var STDLIB_CODE = "function print(...args) { console.log(...args); }\nfunction len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }\nfunction range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }\nfunction enumerate(a) { return a.map((v, i) => [i, v]); }\nfunction sum(a) { return a.reduce((x, y) => x + y, 0); }\nfunction sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }\nfunction reversed(a) { return [...a].reverse(); }\nfunction zip(...as) { const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }\nfunction min(a) { return Math.min(...a); }\nfunction max(a) { return Math.max(...a); }\nfunction type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }\nfunction filter(arr, fn) { return arr.filter(fn); }\nfunction map(arr, fn) { return arr.map(fn); }\nfunction flat_map(arr, fn) { return arr.flatMap(fn); }\nfunction any(arr, fn) { return arr.some(fn); }\nfunction all(arr, fn) { return arr.every(fn); }";

// ─── Tova Compiler Bundle ────────────────────────────
(function() {

// ─── src/lexer/tokens.js ───────────────────────────────

// Token type definitions for the Tova language
const TokenType = {
  // Literals
  NUMBER: 'NUMBER',
  STRING: 'STRING',
  STRING_TEMPLATE: 'STRING_TEMPLATE',
  BOOLEAN: 'BOOLEAN',
  NIL: 'NIL',
  IDENTIFIER: 'IDENTIFIER',

  // Keywords
  VAR: 'VAR',
  LET: 'LET',
  FN: 'FN',
  RETURN: 'RETURN',
  IF: 'IF',
  ELIF: 'ELIF',
  ELSE: 'ELSE',
  FOR: 'FOR',
  WHILE: 'WHILE',
  MATCH: 'MATCH',
  TYPE: 'TYPE',
  IMPORT: 'IMPORT',
  FROM: 'FROM',
  EXPORT: 'EXPORT',
  AS: 'AS',

  // Boolean / logic keywords
  AND: 'AND',
  OR: 'OR',
  NOT: 'NOT',
  IN: 'IN',
  TRUE: 'TRUE',
  FALSE: 'FALSE',

  // Control flow
  BREAK: 'BREAK',
  CONTINUE: 'CONTINUE',

  // Error handling
  TRY: 'TRY',
  CATCH: 'CATCH',
  FINALLY: 'FINALLY',

  // Async
  ASYNC: 'ASYNC',
  AWAIT: 'AWAIT',

  // Guard
  GUARD: 'GUARD',

  // Interface
  INTERFACE: 'INTERFACE',
  DERIVE: 'DERIVE',

  // Visibility
  PUB: 'PUB',

  // Impl blocks / traits
  IMPL: 'IMPL',
  TRAIT: 'TRAIT',

  // Defer
  DEFER: 'DEFER',

  // Mutable (alias for var)
  MUT: 'MUT',

  // Loop
  LOOP: 'LOOP',
  WHEN: 'WHEN',

  // Generators
  YIELD: 'YIELD',

  // Extern
  EXTERN: 'EXTERN',

  // Type checking
  IS: 'IS',

  // Resource management
  WITH: 'WITH',

  // Full-stack keywords
  SERVER: 'SERVER',
  CLIENT: 'CLIENT',
  SHARED: 'SHARED',
  ROUTE: 'ROUTE',
  STATE: 'STATE',
  COMPUTED: 'COMPUTED',
  EFFECT: 'EFFECT',
  COMPONENT: 'COMPONENT',
  STORE: 'STORE',
  STYLE_BLOCK: 'STYLE_BLOCK',

  // HTTP methods (used in route declarations)
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',

  // Operators
  PLUS: 'PLUS',               // +
  MINUS: 'MINUS',             // -
  STAR: 'STAR',               // *
  SLASH: 'SLASH',             // /
  PERCENT: 'PERCENT',         // %
  POWER: 'POWER',             // **
  ASSIGN: 'ASSIGN',           // =
  EQUAL: 'EQUAL',             // ==
  NOT_EQUAL: 'NOT_EQUAL',     // !=
  LESS: 'LESS',               // <
  LESS_EQUAL: 'LESS_EQUAL',   // <=
  GREATER: 'GREATER',         // >
  GREATER_EQUAL: 'GREATER_EQUAL', // >=
  AND_AND: 'AND_AND',         // &&
  OR_OR: 'OR_OR',             // ||
  BANG: 'BANG',                // !
  PIPE: 'PIPE',               // |>
  BAR: 'BAR',                 // |
  ARROW: 'ARROW',             // =>
  THIN_ARROW: 'THIN_ARROW',   // ->
  DOT: 'DOT',                 // .
  DOT_DOT: 'DOT_DOT',        // ..
  DOT_DOT_EQUAL: 'DOT_DOT_EQUAL', // ..=
  SPREAD: 'SPREAD',           // ...
  COLON: 'COLON',             // :
  DOUBLE_COLON: 'DOUBLE_COLON', // ::
  QUESTION: 'QUESTION',       // ?
  QUESTION_DOT: 'QUESTION_DOT', // ?.
  QUESTION_QUESTION: 'QUESTION_QUESTION', // ??
  PLUS_ASSIGN: 'PLUS_ASSIGN', // +=
  MINUS_ASSIGN: 'MINUS_ASSIGN', // -=
  STAR_ASSIGN: 'STAR_ASSIGN', // *=
  SLASH_ASSIGN: 'SLASH_ASSIGN', // /=

  // Delimiters
  LPAREN: 'LPAREN',           // (
  RPAREN: 'RPAREN',           // )
  LBRACE: 'LBRACE',           // {
  RBRACE: 'RBRACE',           // }
  LBRACKET: 'LBRACKET',       // [
  RBRACKET: 'RBRACKET',       // ]
  COMMA: 'COMMA',             // ,
  SEMICOLON: 'SEMICOLON',     // ;
  NEWLINE: 'NEWLINE',         // \n (significant in some contexts)

  // JSX
  JSX_OPEN: 'JSX_OPEN',       // <tag
  JSX_CLOSE: 'JSX_CLOSE',     // </tag>
  JSX_SELF_CLOSE: 'JSX_SELF_CLOSE', // />
  JSX_TEXT: 'JSX_TEXT',

  // Regex
  REGEX: 'REGEX',             // /pattern/flags

  // Decorators
  AT: 'AT',                    // @

  // Special
  EOF: 'EOF',
  DOCSTRING: 'DOCSTRING',     // /// comment
};

// Keywords map for quick lookup during lexing
const Keywords = {
  'var': TokenType.VAR,
  'let': TokenType.LET,
  'fn': TokenType.FN,
  'return': TokenType.RETURN,
  'if': TokenType.IF,
  'elif': TokenType.ELIF,
  'else': TokenType.ELSE,
  'for': TokenType.FOR,
  'while': TokenType.WHILE,
  'match': TokenType.MATCH,
  'type': TokenType.TYPE,
  'import': TokenType.IMPORT,
  'from': TokenType.FROM,
  'export': TokenType.EXPORT,
  'as': TokenType.AS,
  'and': TokenType.AND,
  'or': TokenType.OR,
  'not': TokenType.NOT,
  'in': TokenType.IN,
  'true': TokenType.TRUE,
  'false': TokenType.FALSE,
  'nil': TokenType.NIL,
  'break': TokenType.BREAK,
  'continue': TokenType.CONTINUE,
  'try': TokenType.TRY,
  'catch': TokenType.CATCH,
  'finally': TokenType.FINALLY,
  'async': TokenType.ASYNC,
  'await': TokenType.AWAIT,
  'guard': TokenType.GUARD,
  'interface': TokenType.INTERFACE,
  'derive': TokenType.DERIVE,
  'pub': TokenType.PUB,
  'impl': TokenType.IMPL,
  'trait': TokenType.TRAIT,
  'defer': TokenType.DEFER,
  'mut': TokenType.MUT,
  'yield': TokenType.YIELD,
  'loop': TokenType.LOOP,
  'when': TokenType.WHEN,
  'extern': TokenType.EXTERN,
  'is': TokenType.IS,
  'with': TokenType.WITH,
  'server': TokenType.SERVER,
  'client': TokenType.CLIENT,
  'shared': TokenType.SHARED,
  'route': TokenType.ROUTE,
  'state': TokenType.STATE,
  'computed': TokenType.COMPUTED,
  'effect': TokenType.EFFECT,
  'component': TokenType.COMPONENT,
  'store': TokenType.STORE,
};

// Token class
class Token {
  constructor(type, value, line, column) {
    this.type = type;
    this.value = value;
    this.line = line;
    this.column = column;
  }

  toString() {
    return `Token(${this.type}, ${JSON.stringify(this.value)}, ${this.line}:${this.column})`;
  }
}

// ─── src/lexer/lexer.js ────────────────────────────────

class Lexer {
  static MAX_INTERPOLATION_DEPTH = 64;

  // Pre-compiled regex constants (avoid re-compilation in hot loops)
  static UNICODE_LETTER_RE = /\p{Letter}/u;
  static UNICODE_ALPHANUM_RE = /[\p{Letter}\p{Number}\p{Mark}]/u;
  static HEX_DIGIT_RE = /[0-9a-fA-F_]/;
  static BINARY_DIGIT_RE = /[01_]/;
  static OCTAL_DIGIT_RE = /[0-7_]/;
  static REGEX_FLAG_RE = /[gimsuydv]/;
  static REGEX_START_RE = /[\s\/*=]/;
  static JSX_CF_KEYWORDS = new Set(['if', 'for', 'elif', 'else', 'match']);

  constructor(source, filename = '<stdin>', lineOffset = 0, columnOffset = 0, _depth = 0) {
    this.source = source;
    this.filename = filename;
    this.tokens = [];
    this.pos = 0;
    this.line = 1 + lineOffset;
    this.column = 1 + columnOffset;
    this.length = source.length;
    this._depth = _depth;

    // JSX context tracking (consolidated state machine)
    this._jsxStack = [];          // stack of 'tag' or 'cfblock' entries
    this._jsxTagMode = null;      // null | 'open' | 'close' — current tag parsing state
    this._jsxSelfClosing = false; // true when / seen in opening tag (before >)
    this._jsxExprDepth = 0;       // brace depth for {expr} inside JSX
    this._jsxCF = null;           // null | { paren: 0, brace: 0, keyword? } — control flow state
    this._matchBlockDepth = 0;    // brace depth for match body inside JSX
    this._subLexer = null;        // reusable sub-lexer for string interpolation
  }

  reset(source, lineOffset, columnOffset) {
    this.source = source;
    this.tokens = [];
    this.pos = 0;
    this.line = 1 + lineOffset;
    this.column = 1 + columnOffset;
    this.length = source.length;
    this._jsxStack = [];
    this._jsxTagMode = null;
    this._jsxSelfClosing = false;
    this._jsxExprDepth = 0;
    this._jsxCF = null;
    this._matchBlockDepth = 0;
  }

  error(message) {
    throw new Error(`${this.filename}:${this.line}:${this.column} — ${message}`);
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.length ? this.source[idx] : '\0';
  }

  advance() {
    const ch = this.source[this.pos];
    this.pos++;
    if (ch === '\n') {
      this.line++;
      this.column = 1;
    } else {
      this.column++;
    }
    return ch;
  }

  match(expected) {
    if (this.pos < this.length && this.source[this.pos] === expected) {
      this.advance();
      return true;
    }
    return false;
  }

  addToken(type, value) {
    this.tokens.push(new Token(type, value, this.line, this.column));
  }

  isDigit(ch) {
    return ch >= '0' && ch <= '9';
  }

  isAlpha(ch) {
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_') return true;
    // Unicode letter support
    if (ch > '\x7f') return Lexer.UNICODE_LETTER_RE.test(ch);
    return false;
  }

  isAlphaNumeric(ch) {
    if (this.isAlpha(ch) || this.isDigit(ch)) return true;
    // Unicode continue characters (combining marks, etc.)
    if (ch > '\x7f') return Lexer.UNICODE_ALPHANUM_RE.test(ch);
    return false;
  }

  isWhitespace(ch) {
    return ch === ' ' || ch === '\t' || ch === '\r';
  }

  _processEscape(esc) {
    switch (esc) {
      case 'n': return '\n';
      case 't': return '\t';
      case 'r': return '\r';
      case '\\': return '\\';
      case '"': return '"';
      case "'": return "'";
      case '{': return '{';
      case '}': return '}';
      default: return '\\' + esc;
    }
  }

  _isJSXStart() {
    const nextCh = this.peek();
    if (!this.isAlpha(nextCh)) return false;
    // Check the token BEFORE < (LESS was already pushed, so it's at length-2)
    const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
    if (!prev) return true;
    return !Lexer.VALUE_TOKEN_TYPES.has(prev.type);
  }

  tokenize() {
    // Strip shebang line if present (e.g. #!/usr/bin/env tova)
    if (this.pos === 0 && this.source[0] === '#' && this.source[1] === '!') {
      while (this.pos < this.length && this.source[this.pos] !== '\n') this.advance();
      if (this.pos < this.length) this.advance();
    }

    while (this.pos < this.length) {
      this.scanToken();
    }
    this.tokens.push(new Token(TokenType.EOF, null, this.line, this.column));
    return this.tokens;
  }

  scanToken() {
    // In JSX children mode, scan raw text instead of normal tokens
    // (but not inside matchblock — match bodies need normal scanning for patterns/arrows)
    if (this._jsxStack.length > 0 && this._jsxExprDepth === 0 &&
        !this._jsxTagMode && !this._jsxCF && this._matchBlockDepth === 0) {
      return this._scanInJSXChildren();
    }

    const ch = this.peek();

    // Skip whitespace (not newlines) — batch skip for consecutive whitespace
    if (this.isWhitespace(ch)) {
      this.advance();
      while (this.pos < this.length && this.isWhitespace(this.source[this.pos])) {
        this.advance();
      }
      return;
    }

    // Newlines
    if (ch === '\n') {
      this.tokens.push(new Token(TokenType.NEWLINE, '\n', this.line, this.column));
      this.advance();
      return;
    }

    // Comments
    if (ch === '/' && this.peek(1) === '/') {
      this.scanComment();
      return;
    }
    if (ch === '/' && this.peek(1) === '*') {
      this.scanBlockComment();
      return;
    }

    // Regex literals: /pattern/flags
    // Must not be /=, //, /*, and must be in a context where regex makes sense
    if (ch === '/' && this.peek(1) !== '/' && this.peek(1) !== '*' && this.peek(1) !== '='
        && this._jsxStack.length === 0) {
      let prev = null;
      for (let i = this.tokens.length - 1; i >= 0; i--) {
        if (this.tokens[i].type !== TokenType.NEWLINE) {
          prev = this.tokens[i];
          break;
        }
      }
      // Negative list: if previous token ends an expression (produces a value),
      // then / is division. Otherwise, / starts a regex.
      // This is simpler and more robust — new token types default to regex context.
      if (prev && !Lexer.VALUE_TOKEN_TYPES.has(prev.type)) {
        this.scanRegex();
        return;
      }
      // At start of file (no prev token), treat / as regex if followed by a non-space, non-special char
      if (!prev && this.pos + 1 < this.length && !Lexer.REGEX_START_RE.test(this.peek(1))) {
        this.scanRegex();
        return;
      }
    }

    // Numbers
    if (this.isDigit(ch)) {
      this.scanNumber();
      return;
    }

    // Strings
    if (ch === '"') {
      // Triple-quote multiline strings: """..."""
      if (this.peek(1) === '"' && this.peek(2) === '"') {
        this.scanTripleQuoteString();
        return;
      }
      this.scanString();
      return;
    }
    if (ch === "'") {
      this.scanSimpleString();
      return;
    }

    // Identifiers and keywords
    if (this.isAlpha(ch)) {
      this.scanIdentifier();
      return;
    }

    // Operators and delimiters
    this.scanOperator();
  }

  _scanInJSXChildren() {
    const ch = this.peek();

    // Close control flow block: } when top of stack is 'cfblock'
    if (ch === '}' && this._jsxStack.length > 0 && this._jsxStack[this._jsxStack.length - 1] === 'cfblock') {
      this._jsxStack.pop();
      this.scanOperator(); // emits RBRACE
      return;
    }

    // Skip whitespace/newlines silently when followed by structural chars
    if (this.isWhitespace(ch) || ch === '\n') {
      let pp = this.pos;
      while (pp < this.length && (this.source[pp] === ' ' || this.source[pp] === '\t' || this.source[pp] === '\r' || this.source[pp] === '\n')) {
        pp++;
      }
      const nextNonWs = pp < this.length ? this.source[pp] : '\0';
      // Skip whitespace if next meaningful char is structural
      if (nextNonWs === '<' || nextNonWs === '{' || nextNonWs === '}' || nextNonWs === '"' || nextNonWs === "'" || pp >= this.length) {
        while (this.pos < pp) this.advance();
        return;
      }
      // Check if next non-ws starts a keyword (if/for/elif/else)
      if (this.isAlpha(nextNonWs)) {
        let wp = pp;
        while (wp < this.length && this.isAlphaNumeric(this.source[wp])) wp++;
        const word = this.source.substring(pp, wp);
        if (Lexer.JSX_CF_KEYWORDS.has(word)) {
          while (this.pos < pp) this.advance();
          return;
        }
      }
      // Otherwise, fall through to collect as JSX text
    }

    if (ch === '{') {
      this.scanOperator();
      this._jsxExprDepth = 1;
      return;
    }
    if (ch === '<') {
      // In JSX children, set tag mode directly (heuristic may fail after STRING tokens)
      const nextCh = this.peek(1);
      if (nextCh === '/') {
        this._jsxTagMode = 'close';
      } else if (nextCh === '>' || this.isAlpha(nextCh)) {
        // <tag or <> (fragment)
        this._jsxTagMode = 'open';
      }
      this.scanOperator();
      return;
    }
    if (ch === '"') { this.scanString(); return; }
    if (ch === "'") { this.scanSimpleString(); return; }

    // Check for JSX control flow keywords: if, for, elif, else, match
    if (this.isAlpha(ch)) {
      let peekPos = this.pos;
      while (peekPos < this.length && this.isAlphaNumeric(this.source[peekPos])) peekPos++;
      const word = this.source.substring(this.pos, peekPos);
      if (Lexer.JSX_CF_KEYWORDS.has(word)) {
        this.scanIdentifier();
        // After keyword, enter control flow mode for normal scanning
        this._jsxCF = { paren: 0, brace: 0, keyword: word };
        return;
      }
    }

    // Everything else: scan as raw JSX text
    this._scanJSXText();
  }

  _scanJSXText() {
    const startLine = this.line, startCol = this.column;
    let text = '';
    while (this.pos < this.length) {
      const ch = this.peek();
      if (ch === '<' || ch === '{' || ch === '"' || ch === "'") break;
      // Stop at keywords if, for, elif, else preceded by whitespace
      if (this.isAlpha(ch) && text.length > 0) {
        const lastCh = text[text.length - 1];
        if (lastCh === ' ' || lastCh === '\t' || lastCh === '\n' || lastCh === '\r') {
          let pp = this.pos;
          while (pp < this.length && this.isAlphaNumeric(this.source[pp])) pp++;
          const word = this.source.substring(this.pos, pp);
          if (Lexer.JSX_CF_KEYWORDS.has(word)) break;
        }
      }
      text += this.advance();
    }
    if (text.length > 0) {
      this.tokens.push(new Token(TokenType.JSX_TEXT, text, startLine, startCol));
    }
  }

  scanComment() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // /
    this.advance(); // /

    // Check for docstring ///
    const isDocstring = this.peek() === '/';
    if (isDocstring) this.advance();

    let value = '';
    while (this.pos < this.length && this.peek() !== '\n') {
      value += this.advance();
    }

    if (isDocstring) {
      this.tokens.push(new Token(TokenType.DOCSTRING, value.trim(), startLine, startCol));
    }
    // Regular comments are discarded
  }

  scanBlockComment() {
    this.advance(); // /
    this.advance(); // *
    let depth = 1;

    while (this.pos < this.length && depth > 0) {
      if (this.peek() === '/' && this.peek(1) === '*') {
        depth++;
        this.advance();
        this.advance();
      } else if (this.peek() === '*' && this.peek(1) === '/') {
        depth--;
        this.advance();
        this.advance();
      } else {
        this.advance();
      }
    }

    if (depth !== 0) {
      this.error('Unterminated block comment');
    }
  }

  scanNumber() {
    const startLine = this.line;
    const startCol = this.column;
    let value = '';

    // Handle hex, octal, binary
    if (this.peek() === '0') {
      const next = this.peek(1);
      if (next === 'x' || next === 'X') {
        this.advance(); // 0
        this.advance(); // x
        while (this.pos < this.length && Lexer.HEX_DIGIT_RE.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected hex digits after 0x');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 16), startLine, startCol));
        return;
      }
      if (next === 'b' || next === 'B') {
        this.advance(); // 0
        this.advance(); // b
        while (this.pos < this.length && Lexer.BINARY_DIGIT_RE.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected binary digits after 0b');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 2), startLine, startCol));
        return;
      }
      if (next === 'o' || next === 'O') {
        this.advance(); // 0
        this.advance(); // o
        while (this.pos < this.length && Lexer.OCTAL_DIGIT_RE.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected octal digits after 0o');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 8), startLine, startCol));
        return;
      }
    }

    // Fast path: scan decimal number using index advancement (no string concat)
    // Handles digits, underscores, decimal point, and exponent
    const numStart = this.pos;
    let hasUnderscore = false;
    while (this.pos < this.length) {
      const ch = this.source[this.pos];
      if (ch >= '0' && ch <= '9') { this.pos++; this.column++; }
      else if (ch === '_') { hasUnderscore = true; this.pos++; this.column++; }
      else break;
    }

    // Decimal point — only consume if followed by a digit or underscore (not e.g. 15.minutes)
    if (this.pos < this.length && this.source[this.pos] === '.') {
      const next = this.pos + 1 < this.length ? this.source[this.pos + 1] : '';
      if (next !== '.' && ((next >= '0' && next <= '9') || next === '_')) {
        this.pos++; this.column++; // .
        while (this.pos < this.length) {
          const ch = this.source[this.pos];
          if (ch >= '0' && ch <= '9') { this.pos++; this.column++; }
          else if (ch === '_') { hasUnderscore = true; this.pos++; this.column++; }
          else break;
        }
      }
    }

    // Exponent
    if (this.pos < this.length) {
      const ech = this.source[this.pos];
      if (ech === 'e' || ech === 'E') {
        const savedPos = this.pos;
        const savedCol = this.column;
        this.pos++; this.column++;
        if (this.pos < this.length && (this.source[this.pos] === '+' || this.source[this.pos] === '-')) {
          this.pos++; this.column++;
        }
        if (this.pos < this.length && this.source[this.pos] >= '0' && this.source[this.pos] <= '9') {
          while (this.pos < this.length && this.source[this.pos] >= '0' && this.source[this.pos] <= '9') {
            this.pos++; this.column++;
          }
        } else {
          // No digits after exponent — backtrack
          this.pos = savedPos;
          this.column = savedCol;
        }
      }
    }

    let numStr = this.source.substring(numStart, this.pos);
    if (hasUnderscore) numStr = numStr.replace(/_/g, '');
    value = numStr;
    this.tokens.push(new Token(TokenType.NUMBER, parseFloat(value), startLine, startCol));
  }

  scanString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening "

    const parts = [];
    let current = '';

    while (this.pos < this.length && this.peek() !== '"') {
      // Escape sequences
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated string');
        }
        current += this._processEscape(this.advance());
        continue;
      }

      // String interpolation: {expr}
      if (this.peek() === '{') {
        this.advance(); // {
        if (current.length > 0) {
          parts.push({ type: 'text', value: current });
          current = '';
        }

        // Lex the interpolation expression, respecting nested strings
        const exprStartLine = this.line - 1; // 0-based offset for sub-lexer
        const exprStartCol = this.column - 1;
        let depth = 1;
        // Use array-based building to avoid O(n^2) string concatenation
        const exprParts = [];
        while (this.pos < this.length && depth > 0) {
          const ch = this.peek();
          // Skip over string literals so braces inside them don't affect depth
          if (ch === '"' || ch === "'" || ch === '`') {
            const quote = ch;
            exprParts.push(this.advance()); // opening quote
            let strDepth = 0; // track interpolation depth inside nested strings
            while (this.pos < this.length) {
              if (this.peek() === '\\') {
                exprParts.push(this.advance()); // backslash
                if (this.pos < this.length) exprParts.push(this.advance()); // escaped char
              } else if (quote === '"' && this.peek() === '{') {
                strDepth++;
                exprParts.push(this.advance());
              } else if (quote === '"' && this.peek() === '}' && strDepth > 0) {
                strDepth--;
                exprParts.push(this.advance());
              } else if (this.peek() === quote && strDepth === 0) {
                break;
              } else {
                exprParts.push(this.advance());
              }
            }
            if (this.pos < this.length) exprParts.push(this.advance()); // closing quote
            continue;
          }
          if (ch === '{') depth++;
          if (ch === '}') {
            depth--;
            if (depth === 0) break;
          }
          exprParts.push(this.advance());
        }
        const exprSource = exprParts.join('');

        if (this.peek() !== '}') {
          this.error('Unterminated string interpolation');
        }
        this.advance(); // }

        // Sub-lex the expression with correct file position offsets
        if (this._depth + 1 > Lexer.MAX_INTERPOLATION_DEPTH) {
          this.error('String interpolation nested too deeply (max ' + Lexer.MAX_INTERPOLATION_DEPTH + ' levels)');
        }
        if (!this._subLexer) {
          this._subLexer = new Lexer(exprSource, this.filename, exprStartLine, exprStartCol, this._depth + 1);
        } else {
          this._subLexer.reset(exprSource, exprStartLine, exprStartCol);
        }
        const exprTokens = this._subLexer.tokenize();
        // Remove the EOF token
        exprTokens.pop();

        parts.push({ type: 'expr', tokens: exprTokens, source: exprSource });
        continue;
      }

      current += this.advance();
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing "

    // If there are no interpolation parts, emit a simple string
    if (parts.length === 0) {
      this.tokens.push(new Token(TokenType.STRING, current, startLine, startCol));
    } else {
      if (current.length > 0) {
        parts.push({ type: 'text', value: current });
      }
      this.tokens.push(new Token(TokenType.STRING_TEMPLATE, parts, startLine, startCol));
    }
  }

  scanTripleQuoteString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // first "
    this.advance(); // second "
    this.advance(); // third "

    // Skip a leading newline immediately after opening """
    if (this.pos < this.length && this.peek() === '\n') {
      this.advance();
    } else if (this.pos < this.length && this.peek() === '\r' && this.peek(1) === '\n') {
      this.advance();
      this.advance();
    }

    const parts = [];
    let current = '';

    while (this.pos < this.length) {
      // Check for closing """
      if (this.peek() === '"' && this.peek(1) === '"' && this.peek(2) === '"') {
        break;
      }

      // Escape sequences (same as regular strings)
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated multiline string');
        }
        current += this._processEscape(this.advance());
        continue;
      }

      // String interpolation: {expr}
      if (this.peek() === '{') {
        this.advance(); // {
        if (current.length > 0) {
          parts.push({ type: 'text', value: current });
          current = '';
        }

        const exprStartLine = this.line - 1;
        const exprStartCol = this.column - 1;
        let depth = 1;
        const exprParts = [];
        while (this.pos < this.length && depth > 0) {
          const ch = this.peek();
          if (ch === '"' || ch === "'" || ch === '`') {
            const quote = ch;
            exprParts.push(this.advance());
            let strDepth = 0;
            while (this.pos < this.length) {
              if (this.peek() === '\\') {
                exprParts.push(this.advance());
                if (this.pos < this.length) exprParts.push(this.advance());
              } else if (quote === '"' && this.peek() === '{') {
                strDepth++;
                exprParts.push(this.advance());
              } else if (quote === '"' && this.peek() === '}' && strDepth > 0) {
                strDepth--;
                exprParts.push(this.advance());
              } else if (this.peek() === quote && strDepth === 0) {
                break;
              } else {
                exprParts.push(this.advance());
              }
            }
            if (this.pos < this.length) exprParts.push(this.advance());
            continue;
          }
          if (ch === '{') depth++;
          if (ch === '}') {
            depth--;
            if (depth === 0) break;
          }
          exprParts.push(this.advance());
        }
        const exprSource = exprParts.join('');

        if (this.peek() !== '}') {
          this.error('Unterminated string interpolation in multiline string');
        }
        this.advance(); // }

        if (this._depth + 1 > Lexer.MAX_INTERPOLATION_DEPTH) {
          this.error('String interpolation nested too deeply (max ' + Lexer.MAX_INTERPOLATION_DEPTH + ' levels)');
        }
        if (!this._subLexer) {
          this._subLexer = new Lexer(exprSource, this.filename, exprStartLine, exprStartCol, this._depth + 1);
        } else {
          this._subLexer.reset(exprSource, exprStartLine, exprStartCol);
        }
        const exprTokens = this._subLexer.tokenize();
        exprTokens.pop();

        parts.push({ type: 'expr', tokens: exprTokens, source: exprSource });
        continue;
      }

      current += this.advance();
    }

    if (this.pos >= this.length || this.peek() !== '"') {
      this.error('Unterminated multiline string (expected closing \"\"\")')
    }
    this.advance(); // first closing "
    this.advance(); // second closing "
    this.advance(); // third closing "

    // Auto-dedent: find the indentation of the closing """ line
    // Look back in `current` for the last newline to get the indentation
    let rawContent = current;
    if (parts.length === 0) {
      // Simple string, no interpolation — auto-dedent
      const dedented = this._dedentTripleQuote(rawContent);
      this.tokens.push(new Token(TokenType.STRING, dedented, startLine, startCol));
    } else {
      // Template string — dedent text parts
      if (current.length > 0) {
        parts.push({ type: 'text', value: current });
      }
      const dedentedParts = this._dedentTripleQuoteParts(parts);
      if (dedentedParts.length === 1 && dedentedParts[0].type === 'text') {
        this.tokens.push(new Token(TokenType.STRING, dedentedParts[0].value, startLine, startCol));
      } else {
        this.tokens.push(new Token(TokenType.STRING_TEMPLATE, dedentedParts, startLine, startCol));
      }
    }
  }

  _dedentTripleQuote(text) {
    // Remove trailing whitespace-only line (the line before closing """)
    if (text.endsWith('\n')) {
      text = text.slice(0, -1);
    } else {
      // Check for trailing whitespace-only content after last newline
      const lastNl = text.lastIndexOf('\n');
      if (lastNl !== -1) {
        const lastLine = text.slice(lastNl + 1);
        if (lastLine.trim() === '') {
          text = text.slice(0, lastNl);
        }
      }
    }

    const lines = text.split('\n');
    // Find minimum indentation of non-empty lines
    let minIndent = Infinity;
    for (const line of lines) {
      if (line.trim().length === 0) continue;
      const indent = line.match(/^[ \t]*/)[0].length;
      if (indent < minIndent) minIndent = indent;
    }
    if (minIndent === Infinity) minIndent = 0;

    // Strip the common indentation
    return lines.map(line => {
      if (line.trim().length === 0) return '';
      return line.slice(minIndent);
    }).join('\n');
  }

  _dedentTripleQuoteParts(parts) {
    // Collect all text to determine minimum indent
    let allText = '';
    for (const p of parts) {
      if (p.type === 'text') allText += p.value;
      else allText += 'X'; // placeholder for expressions
    }

    // Remove trailing whitespace-only line
    if (allText.endsWith('\n')) {
      // Trim trailing newline from last text part
      for (let i = parts.length - 1; i >= 0; i--) {
        if (parts[i].type === 'text' && parts[i].value.endsWith('\n')) {
          parts[i] = { type: 'text', value: parts[i].value.slice(0, -1) };
          break;
        }
      }
    }

    // Find minimum indentation from text parts
    let minIndent = Infinity;
    for (const p of parts) {
      if (p.type !== 'text') continue;
      const lines = p.value.split('\n');
      for (const line of lines) {
        if (line.trim().length === 0) continue;
        const indent = line.match(/^[ \t]*/)[0].length;
        if (indent < minIndent) minIndent = indent;
      }
    }
    if (minIndent === Infinity || minIndent === 0) return parts;

    // Dedent text parts
    return parts.map(p => {
      if (p.type !== 'text') return p;
      const lines = p.value.split('\n');
      const dedented = lines.map(line => {
        if (line.trim().length === 0) return '';
        return line.slice(Math.min(minIndent, line.match(/^[ \t]*/)[0].length));
      }).join('\n');
      return { type: 'text', value: dedented };
    });
  }

  scanSimpleString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening '

    let value = '';
    while (this.pos < this.length && this.peek() !== "'") {
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated string');
        }
        value += this._processEscape(this.advance());
      } else {
        value += this.advance();
      }
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing '

    this.tokens.push(new Token(TokenType.STRING, value, startLine, startCol));
  }

  scanRegex() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening /

    let pattern = '';
    let escaped = false;
    let inCharClass = false;

    while (this.pos < this.length) {
      const ch = this.peek();
      if (ch === '\n') {
        this.error('Unterminated regex literal');
      }
      if (escaped) {
        pattern += ch;
        this.advance();
        escaped = false;
        continue;
      }
      if (ch === '\\') {
        pattern += ch;
        this.advance();
        escaped = true;
        continue;
      }
      if (ch === '[') inCharClass = true;
      if (ch === ']') inCharClass = false;
      if (ch === '/' && !inCharClass) break;
      pattern += this.advance();
    }

    if (this.pos >= this.length || this.peek() !== '/') {
      this.error('Unterminated regex literal');
    }
    this.advance(); // closing /

    // Read flags
    let flags = '';
    while (this.pos < this.length && Lexer.REGEX_FLAG_RE.test(this.peek())) {
      flags += this.advance();
    }

    this.tokens.push(new Token(TokenType.REGEX, { pattern, flags }, startLine, startCol));
  }

  scanIdentifier() {
    const startLine = this.line;
    const startCol = this.column;
    const startPos = this.pos;

    // Fast path: scan ASCII identifier using index advancement (no string concat)
    while (this.pos < this.length) {
      const ch = this.source[this.pos];
      if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_' || (ch >= '0' && ch <= '9')) {
        this.pos++;
        this.column++;
      } else if (ch > '\x7f' && Lexer.UNICODE_ALPHANUM_RE.test(ch)) {
        this.pos++;
        this.column++;
      } else {
        break;
      }
    }
    const value = this.source.substring(startPos, this.pos);

    // Raw string: r"no\escapes"
    if (value === 'r' && this.pos < this.length && this.peek() === '"') {
      this.advance(); // opening "
      const rawParts = [];
      while (this.pos < this.length && this.peek() !== '"') {
        rawParts.push(this.advance());
      }
      const raw = rawParts.join('');
      if (this.pos >= this.length) {
        this.error('Unterminated raw string');
      }
      this.advance(); // closing "
      this.tokens.push(new Token(TokenType.STRING, raw, startLine, startCol));
      return;
    }

    // f-string: f"Hello, {name}!" — explicit interpolation sigil
    // Delegates to scanString() which already handles interpolation
    if (value === 'f' && this.pos < this.length && this.peek() === '"') {
      this.scanString();
      return;
    }

    // Special case: "style {" → read raw CSS block
    if (value === 'style') {
      const savedPos = this.pos;
      const savedLine = this.line;
      const savedCol = this.column;
      // Skip whitespace (including newlines) to check for {
      while (this.pos < this.length && (this.isWhitespace(this.peek()) || this.peek() === '\n')) {
        this.advance();
      }
      if (this.peek() === '{') {
        this.advance(); // skip {
        let depth = 1;
        let css = '';
        while (depth > 0 && this.pos < this.length) {
          const ch = this.peek();
          if (ch === '{') depth++;
          else if (ch === '}') {
            depth--;
            if (depth === 0) { this.advance(); break; }
          }
          css += this.advance();
        }
        if (depth > 0) {
          this.error('Unterminated style block');
        }
        this.tokens.push(new Token(TokenType.STYLE_BLOCK, css.trim(), startLine, startCol));
        return;
      }
      // Not a style block — restore position
      this.pos = savedPos;
      this.line = savedLine;
      this.column = savedCol;
    }

    // Check if it's a keyword
    const type = Keywords[value] || TokenType.IDENTIFIER;
    this.tokens.push(new Token(type, value, startLine, startCol));
  }

  scanOperator() {
    const startLine = this.line;
    const startCol = this.column;
    const ch = this.advance();

    switch (ch) {
      case '(':
        this.tokens.push(new Token(TokenType.LPAREN, '(', startLine, startCol));
        if (this._jsxCF) this._jsxCF.paren++;
        break;
      case ')':
        this.tokens.push(new Token(TokenType.RPAREN, ')', startLine, startCol));
        if (this._jsxCF && this._jsxCF.paren > 0) this._jsxCF.paren--;
        break;
      case '{':
        this.tokens.push(new Token(TokenType.LBRACE, '{', startLine, startCol));
        if (this._jsxCF) {
          if (this._jsxCF.brace > 0) {
            // Nested brace inside expression (e.g., key={obj.field})
            this._jsxCF.brace++;
          } else if (this._jsxCF.paren > 0) {
            // Inside parens, this is an expression brace
            this._jsxCF.brace++;
          } else {
            // Check if prev token is ASSIGN (key={...}) or FOR (destructuring: for {a,b} in ...)
            const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
            if (prev && (prev.type === TokenType.ASSIGN || prev.type === TokenType.FOR)) {
              this._jsxCF.brace++;
            } else if (this._jsxCF.keyword === 'match') {
              // Match body: scan normally (patterns, =>, etc.) — not JSX children mode
              this._jsxCF = null;
              this._jsxStack.push('matchblock');
              this._matchBlockDepth = 1;
            } else {
              // This is the block opener for the control flow body
              this._jsxCF = null;
              this._jsxStack.push('cfblock');
            }
          }
        } else if (this._jsxExprDepth > 0) {
          this._jsxExprDepth++;
        } else if (this._matchBlockDepth > 0) {
          this._matchBlockDepth++;
        }
        break;
      case '}':
        this.tokens.push(new Token(TokenType.RBRACE, '}', startLine, startCol));
        if (this._jsxCF && this._jsxCF.brace > 0) {
          this._jsxCF.brace--;
        } else if (this._matchBlockDepth > 0) {
          this._matchBlockDepth--;
          if (this._matchBlockDepth === 0) {
            // Match body closed — pop matchblock from JSX stack
            if (this._jsxStack.length > 0 && this._jsxStack[this._jsxStack.length - 1] === 'matchblock') {
              this._jsxStack.pop();
            }
          }
        } else if (this._jsxExprDepth > 0) {
          this._jsxExprDepth--;
        }
        break;
      case '[':
        this.tokens.push(new Token(TokenType.LBRACKET, '[', startLine, startCol));
        if (this._jsxCF) this._jsxCF.paren++;
        break;
      case ']':
        this.tokens.push(new Token(TokenType.RBRACKET, ']', startLine, startCol));
        if (this._jsxCF && this._jsxCF.paren > 0) this._jsxCF.paren--;
        break;
      case ',':
        this.tokens.push(new Token(TokenType.COMMA, ',', startLine, startCol));
        break;
      case ';':
        this.tokens.push(new Token(TokenType.SEMICOLON, ';', startLine, startCol));
        break;

      case '+':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.PLUS_ASSIGN, '+=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.PLUS, '+', startLine, startCol));
        }
        break;

      case '-':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.THIN_ARROW, '->', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.MINUS_ASSIGN, '-=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.MINUS, '-', startLine, startCol));
        }
        break;

      case '*':
        if (this.match('*')) {
          this.tokens.push(new Token(TokenType.POWER, '**', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.STAR_ASSIGN, '*=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.STAR, '*', startLine, startCol));
        }
        break;

      case '/':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.SLASH_ASSIGN, '/=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.SLASH, '/', startLine, startCol));
          if (this._jsxTagMode === 'open') this._jsxSelfClosing = true;
        }
        break;

      case '%':
        this.tokens.push(new Token(TokenType.PERCENT, '%', startLine, startCol));
        break;

      case '=':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.EQUAL, '==', startLine, startCol));
        } else if (this.match('>')) {
          this.tokens.push(new Token(TokenType.ARROW, '=>', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.ASSIGN, '=', startLine, startCol));
        }
        break;

      case '!':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.NOT_EQUAL, '!=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.BANG, '!', startLine, startCol));
        }
        break;

      case '<':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.LESS_EQUAL, '<=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.LESS, '<', startLine, startCol));
          // Don't override tag mode already set by _scanInJSXChildren
          if (!this._jsxTagMode) {
            if (this.peek() === '/') {
              this._jsxTagMode = 'close';
            } else if (this.peek() === '>') {
              // Fragment: <> — use same heuristic as _isJSXStart
              // to avoid false positives in expressions
              if (this._jsxStack.length > 0) {
                this._jsxTagMode = 'open';
              } else {
                const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
                if (!prev || !Lexer.VALUE_TOKEN_TYPES.has(prev.type)) {
                  this._jsxTagMode = 'open';
                }
              }
            } else if (this._isJSXStart()) {
              this._jsxTagMode = 'open';
            }
          }
        }
        break;

      case '>':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.GREATER_EQUAL, '>=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.GREATER, '>', startLine, startCol));
          // JSX state transitions on >
          if (this._jsxSelfClosing) {
            // Self-closing tag: <br/> — don't push to stack
            this._jsxTagMode = null;
            this._jsxSelfClosing = false;
          } else if (this._jsxTagMode === 'close') {
            // Closing tag: </div> or </> — pop 'tag' from stack
            this._jsxTagMode = null;
            if (this._jsxStack.length > 0) this._jsxStack.pop();
          } else if (this._jsxTagMode === 'open') {
            // Opening tag: <div> or <> — push 'tag' to stack (entering children mode)
            this._jsxTagMode = null;
            this._jsxStack.push('tag');
          }
        }
        break;

      case '&':
        if (this.match('&')) {
          this.tokens.push(new Token(TokenType.AND_AND, '&&', startLine, startCol));
        } else if (this._jsxStack.length > 0) {
          // Inside JSX, & is valid text - should not reach here normally
          // but handle gracefully by treating as text
          this.tokens.push(new Token(TokenType.JSX_TEXT, '&', startLine, startCol));
        } else {
          this.error(`Unexpected character: '&'. Did you mean '&&'?`);
        }
        break;

      case '|':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.PIPE, '|>', startLine, startCol));
        } else if (this.match('|')) {
          this.tokens.push(new Token(TokenType.OR_OR, '||', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.BAR, '|', startLine, startCol));
        }
        break;

      case '.':
        if (this.match('.')) {
          if (this.match('=')) {
            this.tokens.push(new Token(TokenType.DOT_DOT_EQUAL, '..=', startLine, startCol));
          } else if (this.match('.')) {
            this.tokens.push(new Token(TokenType.SPREAD, '...', startLine, startCol));
          } else {
            this.tokens.push(new Token(TokenType.DOT_DOT, '..', startLine, startCol));
          }
        } else {
          this.tokens.push(new Token(TokenType.DOT, '.', startLine, startCol));
        }
        break;

      case ':':
        if (this.match(':')) {
          this.tokens.push(new Token(TokenType.DOUBLE_COLON, '::', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.COLON, ':', startLine, startCol));
        }
        break;

      case '?':
        if (this.match('.')) {
          this.tokens.push(new Token(TokenType.QUESTION_DOT, '?.', startLine, startCol));
        } else if (this.match('?')) {
          this.tokens.push(new Token(TokenType.QUESTION_QUESTION, '??', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.QUESTION, '?', startLine, startCol));
        }
        break;

      case '@':
        this.tokens.push(new Token(TokenType.AT, '@', startLine, startCol));
        break;

      default:
        this.error(`Unexpected character: '${ch}'`);
    }
  }
}

// Initialize static Set after class definition (depends on TokenType)
Lexer.VALUE_TOKEN_TYPES = new Set([
  TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.STRING,
  TokenType.STRING_TEMPLATE, TokenType.RPAREN, TokenType.RBRACKET, TokenType.RBRACE,
  TokenType.TRUE, TokenType.FALSE, TokenType.NIL
]);

// ─── src/parser/client-ast.js ──────────────────────────

// Client-specific AST Node definitions for the Tova language
// Extracted from ast.js for lazy loading — only loaded when client { } blocks are used.

// ============================================================
// Client-specific nodes
// ============================================================
class StateDeclaration {
  constructor(name, typeAnnotation, initialValue, loc) {
    this.type = 'StateDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.initialValue = initialValue;
    this.loc = loc;
  }
}
class ComputedDeclaration {
  constructor(name, expression, loc) {
    this.type = 'ComputedDeclaration';
    this.name = name;
    this.expression = expression;
    this.loc = loc;
  }
}
class EffectDeclaration {
  constructor(body, loc) {
    this.type = 'EffectDeclaration';
    this.body = body;
    this.loc = loc;
  }
}
class ComponentDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'ComponentDeclaration';
    this.name = name;
    this.params = params;
    this.body = body; // Array of JSX elements and statements
    this.loc = loc;
  }
}
class ComponentStyleBlock {
  constructor(css, loc) {
    this.type = 'ComponentStyleBlock';
    this.css = css; // raw CSS string
    this.loc = loc;
  }
}
class StoreDeclaration {
  constructor(name, body, loc) {
    this.type = 'StoreDeclaration';
    this.name = name;   // e.g. "TodoStore"
    this.body = body;   // Array of StateDeclaration, ComputedDeclaration, FunctionDeclaration
    this.loc = loc;
  }
}

// ============================================================
// JSX-like nodes
// ============================================================
class JSXElement {
  constructor(tag, attributes, children, selfClosing, loc) {
    this.type = 'JSXElement';
    this.tag = tag;
    this.attributes = attributes; // Array of JSXAttribute
    this.children = children;     // Array of JSXElement, JSXText, JSXExpression
    this.selfClosing = selfClosing;
    this.loc = loc;
  }
}
class JSXAttribute {
  constructor(name, value, loc) {
    this.type = 'JSXAttribute';
    this.name = name;   // string (e.g., "class", "on:click")
    this.value = value;  // Expression or string
    this.loc = loc;
  }
}
class JSXSpreadAttribute {
  constructor(expression, loc) {
    this.type = 'JSXSpreadAttribute';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXFragment {
  constructor(children, loc) {
    this.type = 'JSXFragment';
    this.children = children;     // Array of JSXElement, JSXText, JSXExpression, etc.
    this.loc = loc;
  }
}
class JSXText {
  constructor(value, loc) {
    this.type = 'JSXText';
    this.value = value;
    this.loc = loc;
  }
}
class JSXExpression {
  constructor(expression, loc) {
    this.type = 'JSXExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXFor {
  constructor(variable, iterable, body, loc, keyExpr = null) {
    this.type = 'JSXFor';
    this.variable = variable;
    this.iterable = iterable;
    this.body = body;
    this.keyExpr = keyExpr; // optional key expression for keyed reconciliation
    this.loc = loc;
  }
}
class JSXIf {
  constructor(condition, consequent, alternate, loc, alternates = []) {
    this.type = 'JSXIf';
    this.condition = condition;
    this.consequent = consequent;
    this.alternates = alternates; // Array of { condition, body } for elif chains
    this.alternate = alternate;   // else body (or null)
    this.loc = loc;
  }
}
class JSXMatch {
  constructor(subject, arms, loc) {
    this.type = 'JSXMatch';
    this.subject = subject;     // expression being matched
    this.arms = arms;           // Array of { pattern, guard, body: [JSXChild] }
    this.loc = loc;
  }
}

// ─── src/parser/server-ast.js ──────────────────────────

// Server-specific AST Node definitions for the Tova language
// Extracted from ast.js for lazy loading — only loaded when server { } blocks are used.
class RouteDeclaration {
  constructor(method, path, handler, loc, decorators = [], bodyType = null, responseType = null) {
    this.type = 'RouteDeclaration';
    this.method = method;   // GET, POST, PUT, DELETE, PATCH
    this.path = path;       // string literal
    this.handler = handler; // Identifier or FunctionDeclaration
    this.decorators = decorators; // Array of { name, args } for "with auth, role("admin")"
    this.bodyType = bodyType;       // TypeAnnotation — request body type (e.g., body: User)
    this.responseType = responseType; // TypeAnnotation — response type (e.g., -> [User])
    this.loc = loc;
  }
}
class MiddlewareDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'MiddlewareDeclaration';
    this.name = name;
    this.params = params;   // Array of Parameter nodes (req, next)
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class HealthCheckDeclaration {
  constructor(path, loc) {
    this.type = 'HealthCheckDeclaration';
    this.path = path;       // string literal, e.g. "/health"
    this.loc = loc;
  }
}
class CorsDeclaration {
  constructor(config, loc) {
    this.type = 'CorsDeclaration';
    this.config = config;   // { origins: ArrayLiteral, methods: ArrayLiteral, headers: ArrayLiteral }
    this.loc = loc;
  }
}
class ErrorHandlerDeclaration {
  constructor(params, body, loc) {
    this.type = 'ErrorHandlerDeclaration';
    this.params = params;   // Array of Parameter nodes (err, req)
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class WebSocketDeclaration {
  constructor(handlers, loc, config = null) {
    this.type = 'WebSocketDeclaration';
    this.handlers = handlers; // { on_open, on_message, on_close, on_error } — each is { params, body } or null
    this.config = config;     // { auth: expression } or null
    this.loc = loc;
  }
}
class StaticDeclaration {
  constructor(path, dir, loc, fallback = null) {
    this.type = 'StaticDeclaration';
    this.path = path;       // URL prefix, e.g. "/public"
    this.dir = dir;         // directory path, e.g. "./public"
    this.fallback = fallback; // fallback file, e.g. "index.html"
    this.loc = loc;
  }
}
class DiscoverDeclaration {
  constructor(peerName, urlExpression, loc, config = null) {
    this.type = 'DiscoverDeclaration';
    this.peerName = peerName;         // string — the peer server name
    this.urlExpression = urlExpression; // Expression — the URL
    this.config = config;             // { threshold, timeout } or null
    this.loc = loc;
  }
}
class AuthDeclaration {
  constructor(config, loc) {
    this.type = 'AuthDeclaration';
    this.config = config; // { type, secret, ... } object config
    this.loc = loc;
  }
}
class MaxBodyDeclaration {
  constructor(limit, loc) {
    this.type = 'MaxBodyDeclaration';
    this.limit = limit; // Expression — max body size in bytes
    this.loc = loc;
  }
}
class RouteGroupDeclaration {
  constructor(prefix, body, loc, version = null) {
    this.type = 'RouteGroupDeclaration';
    this.prefix = prefix; // string — URL prefix, e.g. "/api/v1"
    this.body = body;     // Array of server statements
    this.version = version; // version config: { version, deprecated, sunset } or null
    this.loc = loc;
  }
}
class RateLimitDeclaration {
  constructor(config, loc) {
    this.type = 'RateLimitDeclaration';
    this.config = config;
    this.loc = loc;
  }
}
class LifecycleHookDeclaration {
  constructor(hook, params, body, loc) {
    this.type = 'LifecycleHookDeclaration';
    this.hook = hook;       // "start" or "stop"
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class SubscribeDeclaration {
  constructor(event, params, body, loc) {
    this.type = 'SubscribeDeclaration';
    this.event = event;     // string — event name
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class EnvDeclaration {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'EnvDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.defaultValue = defaultValue;
    this.loc = loc;
  }
}
class ScheduleDeclaration {
  constructor(pattern, name, params, body, loc) {
    this.type = 'ScheduleDeclaration';
    this.pattern = pattern;   // string — interval or cron pattern
    this.name = name;         // optional function name
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class UploadDeclaration {
  constructor(config, loc) {
    this.type = 'UploadDeclaration';
    this.config = config;   // { max_size, allowed_types, ... }
    this.loc = loc;
  }
}
class SessionDeclaration {
  constructor(config, loc) {
    this.type = 'SessionDeclaration';
    this.config = config;   // { secret, max_age, cookie_name, ... }
    this.loc = loc;
  }
}
class DbDeclaration {
  constructor(config, loc) {
    this.type = 'DbDeclaration';
    this.config = config;   // { path, wal, ... }
    this.loc = loc;
  }
}
class TlsDeclaration {
  constructor(config, loc) {
    this.type = 'TlsDeclaration';
    this.config = config;   // { cert, key, ... }
    this.loc = loc;
  }
}
class CompressionDeclaration {
  constructor(config, loc) {
    this.type = 'CompressionDeclaration';
    this.config = config;   // { enabled, min_size, ... }
    this.loc = loc;
  }
}
class BackgroundJobDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'BackgroundJobDeclaration';
    this.name = name;
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class CacheDeclaration {
  constructor(config, loc) {
    this.type = 'CacheDeclaration';
    this.config = config;   // { max_age, stale_while_revalidate, ... }
    this.loc = loc;
  }
}
class SseDeclaration {
  constructor(path, params, body, loc) {
    this.type = 'SseDeclaration';
    this.path = path;       // string — SSE endpoint path
    this.params = params;   // Array of Parameter nodes
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class ModelDeclaration {
  constructor(name, config, loc) {
    this.type = 'ModelDeclaration';
    this.name = name;       // string — type name to generate CRUD for
    this.config = config;   // { table, timestamps, ... } or null
    this.loc = loc;
  }
}
class AiConfigDeclaration {
  constructor(name, config, loc) {
    this.type = 'AiConfigDeclaration';
    this.name = name;    // optional string name (null for default)
    this.config = config; // key-value config object
    this.loc = loc;
  }
}

// ─── src/parser/ast.js ─────────────────────────────────

// AST Node definitions for the Tova language

// Sentinel value for pipe target placeholder (used in method pipe |> .method())
const PIPE_TARGET = '__pipe_target__';

// ============================================================
// Program (root node)
// ============================================================
class Program {
  constructor(body) {
    this.type = 'Program';
    this.body = body; // Array of top-level statements/blocks
  }
}

// ============================================================
// Full-stack blocks
// ============================================================
class ServerBlock {
  constructor(body, loc, name = null) {
    this.type = 'ServerBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class ClientBlock {
  constructor(body, loc, name = null) {
    this.type = 'ClientBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class SharedBlock {
  constructor(body, loc, name = null) {
    this.type = 'SharedBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}

// ============================================================
// Declarations
// ============================================================
class Assignment {
  constructor(targets, values, loc) {
    this.type = 'Assignment';
    this.targets = targets;   // Array of identifiers (supports multiple: a, b = 1, 2)
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class VarDeclaration {
  constructor(targets, values, loc) {
    this.type = 'VarDeclaration';
    this.targets = targets;   // Array of identifiers
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class LetDestructure {
  constructor(pattern, value, loc) {
    this.type = 'LetDestructure';
    this.pattern = pattern;   // ObjectPattern or ArrayPattern
    this.value = value;       // Expression
    this.loc = loc;
  }
}
class FunctionDeclaration {
  constructor(name, params, body, returnType, loc, isAsync = false, typeParams = [], decorators = []) {
    this.type = 'FunctionDeclaration';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (generics)
    this.params = params;     // Array of Parameter nodes
    this.body = body;         // BlockStatement or Expression (implicit return)
    this.returnType = returnType; // optional type annotation
    this.isAsync = isAsync;
    this.decorators = decorators; // Array of { name, args } for @decorator syntax
    this.loc = loc;
  }
}
class Parameter {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'Parameter';
    this.name = name;
    this.typeAnnotation = typeAnnotation; // optional
    this.defaultValue = defaultValue;     // optional
    this.loc = loc;
  }
}
class TypeDeclaration {
  constructor(name, typeParams, variants, loc) {
    this.type = 'TypeDeclaration';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (generics)
    this.variants = variants;     // Array of TypeVariant or TypeField
    this.loc = loc;
  }
}
class TypeVariant {
  constructor(name, fields, loc) {
    this.type = 'TypeVariant';
    this.name = name;
    this.fields = fields; // Array of { name, typeAnnotation }
    this.loc = loc;
  }
}
class TypeField {
  constructor(name, typeAnnotation, loc) {
    this.type = 'TypeField';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.loc = loc;
  }
}

// ============================================================
// Import / Export
// ============================================================
class ImportDeclaration {
  constructor(specifiers, source, loc) {
    this.type = 'ImportDeclaration';
    this.specifiers = specifiers; // Array of { imported, local }
    this.source = source;         // string literal
    this.loc = loc;
  }
}
class ImportSpecifier {
  constructor(imported, local, loc) {
    this.type = 'ImportSpecifier';
    this.imported = imported;
    this.local = local || imported;
    this.loc = loc;
  }
}
class ImportDefault {
  constructor(local, source, loc) {
    this.type = 'ImportDefault';
    this.local = local;
    this.source = source;
    this.loc = loc;
  }
}
class ImportWildcard {
  constructor(local, source, loc) {
    this.type = 'ImportWildcard';
    this.local = local;    // namespace binding name
    this.source = source;
    this.loc = loc;
  }
}

// ============================================================
// Statements
// ============================================================
class BlockStatement {
  constructor(body, loc) {
    this.type = 'BlockStatement';
    this.body = body;
    this.loc = loc;
  }
}
class ReturnStatement {
  constructor(value, loc) {
    this.type = 'ReturnStatement';
    this.value = value;
    this.loc = loc;
  }
}
class IfStatement {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfStatement';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement or null
    this.loc = loc;
  }
}
class ForStatement {
  constructor(variable, iterable, body, elseBody, loc, guard = null, label = null, isAsync = false) {
    this.type = 'ForStatement';
    this.variable = variable;   // Identifier or destructure pattern
    this.iterable = iterable;   // Expression
    this.body = body;           // BlockStatement
    this.elseBody = elseBody;   // BlockStatement or null (for-else)
    this.guard = guard;         // Expression or null (when guard)
    this.label = label;         // string or null (for named loops)
    this.isAsync = isAsync;     // true for `async for x in stream`
    this.loc = loc;
  }
}
class WhileStatement {
  constructor(condition, body, loc, label = null) {
    this.type = 'WhileStatement';
    this.condition = condition;
    this.body = body;
    this.label = label;         // string or null (for named loops)
    this.loc = loc;
  }
}
class LoopStatement {
  constructor(body, label, loc) {
    this.type = 'LoopStatement';
    this.body = body;           // BlockStatement
    this.label = label;         // string or null (for named loops)
    this.loc = loc;
  }
}
class IfExpression {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfExpression';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement (required)
    this.loc = loc;
  }
}
class TryCatchStatement {
  constructor(tryBody, catchParam, catchBody, loc, finallyBody = null) {
    this.type = 'TryCatchStatement';
    this.tryBody = tryBody;         // Array of statements
    this.catchParam = catchParam;   // string (error variable name) or null
    this.catchBody = catchBody;     // Array of statements (or null if try/finally only)
    this.finallyBody = finallyBody; // Array of statements or null
    this.loc = loc;
  }
}
class BreakStatement {
  constructor(loc, label = null) {
    this.type = 'BreakStatement';
    this.label = label;         // string or null (for named break)
    this.loc = loc;
  }
}
class ContinueStatement {
  constructor(loc, label = null) {
    this.type = 'ContinueStatement';
    this.label = label;         // string or null (for named continue)
    this.loc = loc;
  }
}
class GuardStatement {
  constructor(condition, elseBody, loc) {
    this.type = 'GuardStatement';
    this.condition = condition;
    this.elseBody = elseBody; // BlockStatement
    this.loc = loc;
  }
}
class ExpressionStatement {
  constructor(expression, loc) {
    this.type = 'ExpressionStatement';
    this.expression = expression;
    this.loc = loc;
  }
}

// ============================================================
// Expressions
// ============================================================
class Identifier {
  constructor(name, loc) {
    this.type = 'Identifier';
    this.name = name;
    this.loc = loc;
  }
}
class NumberLiteral {
  constructor(value, loc) {
    this.type = 'NumberLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class StringLiteral {
  constructor(value, loc) {
    this.type = 'StringLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class TemplateLiteral {
  constructor(parts, loc) {
    this.type = 'TemplateLiteral';
    this.parts = parts; // Array of { type: 'text'|'expr', value }
    this.loc = loc;
  }
}
class BooleanLiteral {
  constructor(value, loc) {
    this.type = 'BooleanLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class NilLiteral {
  constructor(loc) {
    this.type = 'NilLiteral';
    this.loc = loc;
  }
}
class RegexLiteral {
  constructor(pattern, flags, loc) {
    this.type = 'RegexLiteral';
    this.pattern = pattern;
    this.flags = flags;
    this.loc = loc;
  }
}
class ArrayLiteral {
  constructor(elements, loc) {
    this.type = 'ArrayLiteral';
    this.elements = elements;
    this.loc = loc;
  }
}
class ObjectLiteral {
  constructor(properties, loc) {
    this.type = 'ObjectLiteral';
    this.properties = properties; // Array of { key, value, shorthand }
    this.loc = loc;
  }
}
class BinaryExpression {
  constructor(operator, left, right, loc) {
    this.type = 'BinaryExpression';
    this.operator = operator;
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class UnaryExpression {
  constructor(operator, operand, prefix, loc) {
    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
    this.prefix = prefix;
    this.loc = loc;
  }
}
class ChainedComparison {
  constructor(operands, operators, loc) {
    this.type = 'ChainedComparison';
    this.operands = operands;   // [a, b, c] for a < b < c
    this.operators = operators; // ['<', '<']
    this.loc = loc;
  }
}
class LogicalExpression {
  constructor(operator, left, right, loc) {
    this.type = 'LogicalExpression';
    this.operator = operator; // 'and', 'or', '&&', '||'
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class CallExpression {
  constructor(callee, args, loc) {
    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = args;
    this.loc = loc;
  }
}
class NamedArgument {
  constructor(name, value, loc) {
    this.type = 'NamedArgument';
    this.name = name;
    this.value = value;
    this.loc = loc;
  }
}
class MemberExpression {
  constructor(object, property, computed, loc) {
    this.type = 'MemberExpression';
    this.object = object;
    this.property = property;
    this.computed = computed; // true for obj[expr], false for obj.prop
    this.loc = loc;
  }
}
class OptionalChain {
  constructor(object, property, computed, loc) {
    this.type = 'OptionalChain';
    this.object = object;
    this.property = property;
    this.computed = computed;
    this.loc = loc;
  }
}
class PipeExpression {
  constructor(left, right, loc) {
    this.type = 'PipeExpression';
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class LambdaExpression {
  constructor(params, body, loc, isAsync = false) {
    this.type = 'LambdaExpression';
    this.params = params;
    this.body = body;
    this.isAsync = isAsync;
    this.loc = loc;
  }
}
class MatchExpression {
  constructor(subject, arms, loc) {
    this.type = 'MatchExpression';
    this.subject = subject;
    this.arms = arms; // Array of MatchArm
    this.loc = loc;
  }
}
class MatchArm {
  constructor(pattern, guard, body, loc) {
    this.type = 'MatchArm';
    this.pattern = pattern;
    this.guard = guard;   // optional guard expression (if condition)
    this.body = body;
    this.loc = loc;
  }
}
class RangeExpression {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangeExpression';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive; // true for ..=, false for ..
    this.loc = loc;
  }
}
class SliceExpression {
  constructor(object, start, end, step, loc) {
    this.type = 'SliceExpression';
    this.object = object;
    this.start = start;
    this.end = end;
    this.step = step;
    this.loc = loc;
  }
}
class SpreadExpression {
  constructor(argument, loc) {
    this.type = 'SpreadExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class PropagateExpression {
  constructor(expression, loc) {
    this.type = 'PropagateExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class ListComprehension {
  constructor(expression, variable, iterable, condition, loc) {
    this.type = 'ListComprehension';
    this.expression = expression;
    this.variable = variable;
    this.iterable = iterable;
    this.condition = condition; // optional filter
    this.loc = loc;
  }
}
class DictComprehension {
  constructor(key, value, variables, iterable, condition, loc) {
    this.type = 'DictComprehension';
    this.key = key;
    this.value = value;
    this.variables = variables;
    this.iterable = iterable;
    this.condition = condition;
    this.loc = loc;
  }
}
class IsExpression {
  constructor(value, typeName, negated, loc) {
    this.type = 'IsExpression';
    this.value = value;
    this.typeName = typeName;     // string: "String", "Int", "Nil", etc.
    this.negated = negated;       // true for "is not"
    this.loc = loc;
  }
}
class MembershipExpression {
  constructor(value, collection, negated, loc) {
    this.type = 'MembershipExpression';
    this.value = value;
    this.collection = collection;
    this.negated = negated; // true for "not in"
    this.loc = loc;
  }
}
class CompoundAssignment {
  constructor(target, operator, value, loc) {
    this.type = 'CompoundAssignment';
    this.target = target;
    this.operator = operator; // +=, -=, *=, /=
    this.value = value;
    this.loc = loc;
  }
}
class AwaitExpression {
  constructor(argument, loc) {
    this.type = 'AwaitExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class InterfaceDeclaration {
  constructor(name, methods, loc) {
    this.type = 'InterfaceDeclaration';
    this.name = name;
    this.methods = methods; // Array of { name, params, returnType }
    this.loc = loc;
  }
}
class StringConcatPattern {
  constructor(prefix, rest, loc) {
    this.type = 'StringConcatPattern';
    this.prefix = prefix; // StringLiteral value
    this.rest = rest;     // BindingPattern or WildcardPattern
    this.loc = loc;
  }
}

// ============================================================
// Patterns (for destructuring and match)
// ============================================================
class ObjectPattern {
  constructor(properties, loc) {
    this.type = 'ObjectPattern';
    this.properties = properties; // Array of { key, value (alias), defaultValue }
    this.loc = loc;
  }
}
class ArrayPattern {
  constructor(elements, loc) {
    this.type = 'ArrayPattern';
    this.elements = elements;
    this.loc = loc;
  }
}
class WildcardPattern {
  constructor(loc) {
    this.type = 'WildcardPattern';
    this.loc = loc;
  }
}
class LiteralPattern {
  constructor(value, loc) {
    this.type = 'LiteralPattern';
    this.value = value;
    this.loc = loc;
  }
}
class VariantPattern {
  constructor(name, fields, loc) {
    this.type = 'VariantPattern';
    this.name = name;
    this.fields = fields;
    this.loc = loc;
  }
}
class BindingPattern {
  constructor(name, loc) {
    this.type = 'BindingPattern';
    this.name = name;
    this.loc = loc;
  }
}
class RangePattern {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangePattern';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive;
    this.loc = loc;
  }
}

// ============================================================
// Client-specific nodes (lazy-loaded from client-ast.js, re-exported for backward compat)
// ============================================================

// ============================================================
// Server-specific nodes (lazy-loaded from server-ast.js, re-exported for backward compat)
// ============================================================
class TestBlock {
  constructor(name, body, loc, options = {}) {
    this.type = 'TestBlock';
    this.name = name;       // optional string name
    this.body = body;       // Array of statements
    this.timeout = options.timeout || null;  // optional timeout in ms
    this.beforeEach = options.beforeEach || null; // Array of statements or null
    this.afterEach = options.afterEach || null;   // Array of statements or null
    this.loc = loc;
  }
}
class BenchBlock {
  constructor(name, body, loc) {
    this.type = 'BenchBlock';
    this.name = name;       // optional string name
    this.body = body;       // Array of statements (expressions to benchmark)
    this.loc = loc;
  }
}

// ============================================================
// Extern declarations
// ============================================================
class ExternDeclaration {
  constructor(name, params, returnType, loc, isAsync = false) {
    this.type = 'ExternDeclaration';
    this.name = name;
    this.params = params;     // Array of Parameter nodes (types only, names optional)
    this.returnType = returnType; // TypeAnnotation or null
    this.isAsync = isAsync;
    this.loc = loc;
  }
}

// ============================================================
// Type annotations
// ============================================================
class TypeAnnotation {
  constructor(name, typeParams, loc) {
    this.type = 'TypeAnnotation';
    this.name = name;         // "Int", "String", "Bool", "Float", etc.
    this.typeParams = typeParams; // Array of TypeAnnotation (for generics)
    this.loc = loc;
  }
}
class ArrayTypeAnnotation {
  constructor(elementType, loc) {
    this.type = 'ArrayTypeAnnotation';
    this.elementType = elementType;
    this.loc = loc;
  }
}
class FunctionTypeAnnotation {
  constructor(paramTypes, returnType, loc) {
    this.type = 'FunctionTypeAnnotation';
    this.paramTypes = paramTypes;
    this.returnType = returnType;
    this.loc = loc;
  }
}
class UnionTypeAnnotation {
  constructor(members, loc) {
    this.type = 'UnionTypeAnnotation';
    this.members = members; // Array of TypeAnnotation nodes
    this.loc = loc;
  }
}

// ============================================================
// Impl blocks
// ============================================================
class ImplDeclaration {
  constructor(typeName, methods, loc, traitName = null) {
    this.type = 'ImplDeclaration';
    this.typeName = typeName;
    this.traitName = traitName; // null for plain impl, string for `impl Trait for Type`
    this.methods = methods;     // Array of FunctionDeclaration (first param is self)
    this.loc = loc;
  }
}

// ============================================================
// Trait declarations
// ============================================================
class TraitDeclaration {
  constructor(name, methods, loc) {
    this.type = 'TraitDeclaration';
    this.name = name;
    this.methods = methods; // Array of { name, params, returnType, body (optional for defaults) }
    this.loc = loc;
  }
}

// ============================================================
// Type aliases
// ============================================================
class TypeAlias {
  constructor(name, typeParams, typeExpr, loc) {
    this.type = 'TypeAlias';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (for generics)
    this.typeExpr = typeExpr; // TypeAnnotation
    this.loc = loc;
  }
}

// ============================================================
// Defer statement
// ============================================================
class WithStatement {
  constructor(expression, name, body, loc) {
    this.type = 'WithStatement';
    this.expression = expression; // resource expression
    this.name = name;             // binding name (string)
    this.body = body;             // BlockStatement
    this.loc = loc;
  }
}
class DeferStatement {
  constructor(body, loc) {
    this.type = 'DeferStatement';
    this.body = body; // Expression or BlockStatement
    this.loc = loc;
  }
}

// ============================================================
// Yield expression (generators)
// ============================================================
class YieldExpression {
  constructor(argument, delegate, loc) {
    this.type = 'YieldExpression';
    this.argument = argument; // expression to yield
    this.delegate = delegate; // true for `yield from`
    this.loc = loc;
  }
}

// ============================================================
// Tuple expression/pattern/type
// ============================================================
class TupleExpression {
  constructor(elements, loc) {
    this.type = 'TupleExpression';
    this.elements = elements; // Array of expressions
    this.loc = loc;
  }
}
class TuplePattern {
  constructor(elements, loc) {
    this.type = 'TuplePattern';
    this.elements = elements; // Array of patterns
    this.loc = loc;
  }
}
class TupleTypeAnnotation {
  constructor(elementTypes, loc) {
    this.type = 'TupleTypeAnnotation';
    this.elementTypes = elementTypes;
    this.loc = loc;
  }
}

// ============================================================
// Column expressions (for table operations)
// ============================================================
class ColumnExpression {
  constructor(name, loc) {
    this.type = 'ColumnExpression';
    this.name = name;  // column name, e.g. "age" for .age
    this.loc = loc;
  }
}
class ColumnAssignment {
  constructor(target, expression, loc) {
    this.type = 'ColumnAssignment';
    this.target = target;       // column name to assign to
    this.expression = expression; // expression computing the value
    this.loc = loc;
  }
}
class NegatedColumnExpression {
  constructor(name, loc) {
    this.type = 'NegatedColumnExpression';
    this.name = name;  // column name for exclusion, e.g. "password" for -.password
    this.loc = loc;
  }
}

// ============================================================
// Data block nodes
// ============================================================
class DataBlock {
  constructor(body, loc) {
    this.type = 'DataBlock';
    this.body = body;  // Array of SourceDeclaration, PipelineDeclaration, ValidateBlock, RefreshPolicy
    this.loc = loc;
  }
}
class SourceDeclaration {
  constructor(name, typeAnnotation, expression, loc) {
    this.type = 'SourceDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.expression = expression;
    this.loc = loc;
  }
}
class PipelineDeclaration {
  constructor(name, expression, loc) {
    this.type = 'PipelineDeclaration';
    this.name = name;
    this.expression = expression;
    this.loc = loc;
  }
}
class ValidateBlock {
  constructor(typeName, rules, loc) {
    this.type = 'ValidateBlock';
    this.typeName = typeName;
    this.rules = rules;  // Array of expression predicates
    this.loc = loc;
  }
}
class RefreshPolicy {
  constructor(sourceName, interval, loc) {
    this.type = 'RefreshPolicy';
    this.sourceName = sourceName;
    this.interval = interval;  // { value, unit } or "on_demand"
    this.loc = loc;
  }
}

// ============================================================
// Refinement types
// ============================================================
class RefinementType {
  constructor(name, baseType, predicate, loc) {
    this.type = 'RefinementType';
    this.name = name;
    this.baseType = baseType;      // TypeAnnotation
    this.predicate = predicate;    // Expression (body of where block, uses 'it')
    this.loc = loc;
  }
}

// AST namespace shim for parser.js compatibility

const AST = { Program, ServerBlock, ClientBlock, SharedBlock, Assignment, VarDeclaration, LetDestructure, FunctionDeclaration, Parameter, TypeDeclaration, TypeVariant, TypeField, ImportDeclaration, ImportSpecifier, ImportDefault, ImportWildcard, BlockStatement, ReturnStatement, IfStatement, ForStatement, WhileStatement, LoopStatement, IfExpression, TryCatchStatement, BreakStatement, ContinueStatement, GuardStatement, ExpressionStatement, Identifier, NumberLiteral, StringLiteral, TemplateLiteral, BooleanLiteral, NilLiteral, RegexLiteral, ArrayLiteral, ObjectLiteral, BinaryExpression, UnaryExpression, ChainedComparison, LogicalExpression, CallExpression, NamedArgument, MemberExpression, OptionalChain, PipeExpression, LambdaExpression, MatchExpression, MatchArm, RangeExpression, SliceExpression, SpreadExpression, PropagateExpression, ListComprehension, DictComprehension, IsExpression, MembershipExpression, CompoundAssignment, AwaitExpression, InterfaceDeclaration, StringConcatPattern, ObjectPattern, ArrayPattern, WildcardPattern, LiteralPattern, VariantPattern, BindingPattern, RangePattern, TestBlock, BenchBlock, ExternDeclaration, TypeAnnotation, ArrayTypeAnnotation, FunctionTypeAnnotation, UnionTypeAnnotation, ImplDeclaration, TraitDeclaration, TypeAlias, WithStatement, DeferStatement, YieldExpression, TupleExpression, TuplePattern, TupleTypeAnnotation, ColumnExpression, ColumnAssignment, NegatedColumnExpression, DataBlock, SourceDeclaration, PipelineDeclaration, ValidateBlock, RefreshPolicy, RefinementType, StateDeclaration, ComputedDeclaration, EffectDeclaration, ComponentDeclaration, ComponentStyleBlock, StoreDeclaration, JSXElement, JSXAttribute, JSXSpreadAttribute, JSXFragment, JSXText, JSXExpression, JSXFor, JSXIf, JSXMatch, RouteDeclaration, MiddlewareDeclaration, HealthCheckDeclaration, CorsDeclaration, ErrorHandlerDeclaration, WebSocketDeclaration, StaticDeclaration, DiscoverDeclaration, AuthDeclaration, MaxBodyDeclaration, RouteGroupDeclaration, RateLimitDeclaration, LifecycleHookDeclaration, SubscribeDeclaration, EnvDeclaration, ScheduleDeclaration, UploadDeclaration, SessionDeclaration, DbDeclaration, TlsDeclaration, CompressionDeclaration, BackgroundJobDeclaration, CacheDeclaration, SseDeclaration, ModelDeclaration, AiConfigDeclaration };

// ─── src/parser/server-parser.js ───────────────────────

// Server-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when server { } blocks are encountered.
function installServerParser(ParserClass) {
  if (ParserClass.prototype._serverParserInstalled) return;
  ParserClass.prototype._serverParserInstalled = true;

  ParserClass.prototype.parseServerBlock = function() {
    const l = this.loc();
    this.expect(TokenType.SERVER);
    // Optional block name: server "api" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'server'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseServerStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close server block");
    return new AST.ServerBlock(body, l, name);
  };

  ParserClass.prototype.parseServerStatement = function() {
    if (this.check(TokenType.ROUTE)) return this.parseRoute();

    // Contextual keywords in server blocks
    if (this.check(TokenType.IDENTIFIER)) {
      const val = this.current().value;
      if (val === 'middleware' && this.peek(1).type === TokenType.FN) {
        return this.parseMiddleware();
      }
      if (val === 'health') {
        return this.parseHealthCheck();
      }
      if (val === 'cors' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCorsConfig();
      }
      if (val === 'on_error' && this.peek(1).type === TokenType.FN) {
        return this.parseErrorHandler();
      }
      if (val === 'ws' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseWebSocket();
      }
      if (val === 'static' && this.peek(1).type === TokenType.STRING) {
        return this.parseStaticDeclaration();
      }
      if (val === 'discover' && this.peek(1).type === TokenType.STRING) {
        return this.parseDiscover();
      }
      if (val === 'auth' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseAuthConfig();
      }
      if (val === 'max_body') {
        return this.parseMaxBody();
      }
      if (val === 'routes' && this.peek(1).type === TokenType.STRING) {
        return this.parseRouteGroup();
      }
      if (val === 'rate_limit' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseRateLimitConfig();
      }
      if (val === 'on_start' && this.peek(1).type === TokenType.FN) {
        return this.parseLifecycleHook('start');
      }
      if (val === 'on_stop' && this.peek(1).type === TokenType.FN) {
        return this.parseLifecycleHook('stop');
      }
      if (val === 'subscribe' && this.peek(1).type === TokenType.STRING) {
        return this.parseSubscribe();
      }
      if (val === 'env' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseEnvDeclaration();
      }
      if (val === 'schedule' && this.peek(1).type === TokenType.STRING) {
        return this.parseSchedule();
      }
      if (val === 'upload' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseUploadConfig();
      }
      if (val === 'session' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSessionConfig();
      }
      if (val === 'db' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseDbConfig();
      }
      if (val === 'tls' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseTlsConfig();
      }
      if (val === 'compression' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCompressionConfig();
      }
      if (val === 'background' && this.peek(1).type === TokenType.FN) {
        return this.parseBackgroundJob();
      }
      if (val === 'cache' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCacheConfig();
      }
      if (val === 'sse' && this.peek(1).type === TokenType.STRING) {
        return this.parseSseDeclaration();
      }
      if (val === 'model' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseModelDeclaration();
      }
      // ai { ... } or ai "name" { ... }
      if (val === 'ai' && (this.peek(1).type === TokenType.LBRACE || this.peek(1).type === TokenType.STRING)) {
        return this.parseAiConfig();
      }
    }

    return this.parseStatement();
  };

  ParserClass.prototype.parseMiddleware = function() {
    const l = this.loc();
    this.advance(); // consume 'middleware'
    this.expect(TokenType.FN);
    const name = this.expect(TokenType.IDENTIFIER, "Expected middleware name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after middleware name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after middleware parameters");
    const body = this.parseBlock();
    return new AST.MiddlewareDeclaration(name, params, body, l);
  };

  ParserClass.prototype.parseHealthCheck = function() {
    const l = this.loc();
    this.advance(); // consume 'health'
    const path = this.expect(TokenType.STRING, "Expected health check path string");
    return new AST.HealthCheckDeclaration(path.value, l);
  };

  ParserClass.prototype.parseCorsConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'cors'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cors'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected cors config key").value;
      this.expect(TokenType.COLON, "Expected ':' after cors key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cors config");
    return new AST.CorsDeclaration(config, l);
  };

  ParserClass.prototype.parseErrorHandler = function() {
    const l = this.loc();
    this.advance(); // consume 'on_error'
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after error handler parameters");
    const body = this.parseBlock();
    return new AST.ErrorHandlerDeclaration(params, body, l);
  };

  ParserClass.prototype.parseWebSocket = function() {
    const l = this.loc();
    this.advance(); // consume 'ws'
    this.expect(TokenType.LBRACE, "Expected '{' after 'ws'");

    const handlers = {};
    const config = {};
    const validEvents = ['on_open', 'on_message', 'on_close', 'on_error'];
    const validConfigKeys = ['auth'];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const name = this.expect(TokenType.IDENTIFIER, "Expected WebSocket event handler name or config key").value;
      if (validConfigKeys.includes(name)) {
        // Config key: auth: <expr>
        this.expect(TokenType.COLON, `Expected ':' after '${name}'`);
        config[name] = this.parseExpression();
        this.match(TokenType.COMMA);
      } else if (validEvents.includes(name)) {
        this.expect(TokenType.FN, "Expected 'fn' after event name");
        this.expect(TokenType.LPAREN);
        const params = this.parseParameterList();
        this.expect(TokenType.RPAREN);
        const body = this.parseBlock();
        handlers[name] = { params, body };
      } else {
        this.error(`Invalid WebSocket key '${name}'. Expected one of: ${[...validConfigKeys, ...validEvents].join(', ')}`);
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close ws block");
    const wsConfig = Object.keys(config).length > 0 ? config : null;
    return new AST.WebSocketDeclaration(handlers, l, wsConfig);
  };

  ParserClass.prototype.parseStaticDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'static'
    const urlPath = this.expect(TokenType.STRING, "Expected URL path for static files").value;
    this.expect(TokenType.ARROW, "Expected '=>' after static path");
    const dir = this.expect(TokenType.STRING, "Expected directory path for static files").value;
    let fallback = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'fallback') {
      this.advance(); // consume 'fallback'
      fallback = this.expect(TokenType.STRING, "Expected fallback file path").value;
    }
    return new AST.StaticDeclaration(urlPath, dir, l, fallback);
  };

  ParserClass.prototype.parseDiscover = function() {
    const l = this.loc();
    this.advance(); // consume 'discover'
    const peerName = this.expect(TokenType.STRING, "Expected peer name string after 'discover'").value;
    // Expect 'at' as contextual keyword
    const atTok = this.expect(TokenType.IDENTIFIER, "Expected 'at' after peer name");
    if (atTok.value !== 'at') {
      this.error("Expected 'at' after peer name in discover declaration");
    }
    const urlExpression = this.parseExpression();
    let config = null;
    if (this.check(TokenType.WITH)) {
      this.advance(); // consume 'with'
      this.expect(TokenType.LBRACE, "Expected '{' after 'with'");
      config = {};
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const key = this.expect(TokenType.IDENTIFIER, "Expected config key").value;
        this.expect(TokenType.COLON, "Expected ':' after config key");
        const value = this.parseExpression();
        config[key] = value;
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close discover config");
    }
    return new AST.DiscoverDeclaration(peerName, urlExpression, l, config);
  };

  ParserClass.prototype.parseAuthConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'auth'
    this.expect(TokenType.LBRACE, "Expected '{' after 'auth'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      // Accept keywords (like 'type') and identifiers as config keys
      let key;
      if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.TYPE)) {
        key = this.advance().value;
      } else {
        this.error("Expected auth config key");
      }
      this.expect(TokenType.COLON, "Expected ':' after auth key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close auth config");
    return new AST.AuthDeclaration(config, l);
  };

  ParserClass.prototype.parseMaxBody = function() {
    const l = this.loc();
    this.advance(); // consume 'max_body'
    const limit = this.parseExpression();
    return new AST.MaxBodyDeclaration(limit, l);
  };

  ParserClass.prototype.parseRouteGroup = function() {
    const l = this.loc();
    this.advance(); // consume 'routes'
    const prefix = this.expect(TokenType.STRING, "Expected route group prefix string").value;

    // Optional version config: routes "/api/v2" version: "2" deprecated: true { ... }
    let version = null;
    while (this.check(TokenType.IDENTIFIER) && !this.isAtEnd()) {
      const key = this.current().value;
      if (key === 'version' || key === 'deprecated' || key === 'sunset') {
        this.advance(); // consume key
        this.expect(TokenType.COLON, `Expected ':' after '${key}'`);
        const value = this.parseExpression();
        if (!version) version = {};
        if (key === 'version') {
          version.version = value.value !== undefined ? value.value : value;
        } else if (key === 'deprecated') {
          version.deprecated = value.value !== undefined ? value.value : true;
        } else if (key === 'sunset') {
          version.sunset = value.value !== undefined ? value.value : value;
        }
      } else {
        break;
      }
    }

    this.expect(TokenType.LBRACE, "Expected '{' after route group prefix");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseServerStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close route group");
    return new AST.RouteGroupDeclaration(prefix, body, l, version);
  };

  ParserClass.prototype.parseRateLimitConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'rate_limit'
    this.expect(TokenType.LBRACE, "Expected '{' after 'rate_limit'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected rate_limit config key").value;
      this.expect(TokenType.COLON, "Expected ':' after rate_limit key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close rate_limit config");
    return new AST.RateLimitDeclaration(config, l);
  };

  ParserClass.prototype.parseLifecycleHook = function(hookName) {
    const l = this.loc();
    this.advance(); // consume 'on_start' or 'on_stop'
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after lifecycle hook parameters");
    const body = this.parseBlock();
    return new AST.LifecycleHookDeclaration(hookName, params, body, l);
  };

  ParserClass.prototype.parseSubscribe = function() {
    const l = this.loc();
    this.advance(); // consume 'subscribe'
    const event = this.expect(TokenType.STRING, "Expected event name string").value;
    this.expect(TokenType.FN, "Expected 'fn' after event name");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after subscribe parameters");
    const body = this.parseBlock();
    return new AST.SubscribeDeclaration(event, params, body, l);
  };

  ParserClass.prototype.parseEnvDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'env'
    const name = this.expect(TokenType.IDENTIFIER, "Expected env variable name").value;
    this.expect(TokenType.COLON, "Expected ':' after env variable name");
    const typeAnnotation = this.parseTypeAnnotation();
    let defaultValue = null;
    if (this.match(TokenType.ASSIGN)) {
      defaultValue = this.parseExpression();
    }
    return new AST.EnvDeclaration(name, typeAnnotation, defaultValue, l);
  };

  ParserClass.prototype.parseSchedule = function() {
    const l = this.loc();
    this.advance(); // consume 'schedule'
    const pattern = this.expect(TokenType.STRING, "Expected schedule pattern string").value;
    this.expect(TokenType.FN, "Expected 'fn' after schedule pattern");
    let name = null;
    if (this.check(TokenType.IDENTIFIER)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LPAREN, "Expected '(' after schedule fn");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after schedule parameters");
    const body = this.parseBlock();
    return new AST.ScheduleDeclaration(pattern, name, params, body, l);
  };

  ParserClass.prototype.parseUploadConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'upload'
    this.expect(TokenType.LBRACE, "Expected '{' after 'upload'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected upload config key").value;
      this.expect(TokenType.COLON, "Expected ':' after upload key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close upload config");
    return new AST.UploadDeclaration(config, l);
  };

  ParserClass.prototype.parseSessionConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'session'
    this.expect(TokenType.LBRACE, "Expected '{' after 'session'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected session config key").value;
      this.expect(TokenType.COLON, "Expected ':' after session key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close session config");
    return new AST.SessionDeclaration(config, l);
  };

  ParserClass.prototype.parseAiConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'ai'

    // Optional name: ai "claude" { ... }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }

    this.expect(TokenType.LBRACE, "Expected '{' after 'ai'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected ai config key").value;
      this.expect(TokenType.COLON, "Expected ':' after ai config key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close ai config");
    return new AST.AiConfigDeclaration(name, config, l);
  };

  ParserClass.prototype.parseDbConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'db'
    this.expect(TokenType.LBRACE, "Expected '{' after 'db'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected db config key").value;
      this.expect(TokenType.COLON, "Expected ':' after db key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close db config");
    return new AST.DbDeclaration(config, l);
  };

  ParserClass.prototype.parseTlsConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'tls'
    this.expect(TokenType.LBRACE, "Expected '{' after 'tls'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected tls config key").value;
      this.expect(TokenType.COLON, "Expected ':' after tls key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close tls config");
    return new AST.TlsDeclaration(config, l);
  };

  ParserClass.prototype.parseCompressionConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'compression'
    this.expect(TokenType.LBRACE, "Expected '{' after 'compression'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected compression config key").value;
      this.expect(TokenType.COLON, "Expected ':' after compression key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close compression config");
    return new AST.CompressionDeclaration(config, l);
  };

  ParserClass.prototype.parseBackgroundJob = function() {
    const l = this.loc();
    this.advance(); // consume 'background'
    this.expect(TokenType.FN, "Expected 'fn' after 'background'");
    const name = this.expect(TokenType.IDENTIFIER, "Expected background job name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after background job name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after background job parameters");
    const body = this.parseBlock();
    return new AST.BackgroundJobDeclaration(name, params, body, l);
  };

  ParserClass.prototype.parseCacheConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'cache'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cache'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected cache config key").value;
      this.expect(TokenType.COLON, "Expected ':' after cache key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cache config");
    return new AST.CacheDeclaration(config, l);
  };

  ParserClass.prototype.parseSseDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'sse'
    const path = this.expect(TokenType.STRING, "Expected SSE endpoint path").value;
    this.expect(TokenType.FN, "Expected 'fn' after SSE path");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after SSE parameters");
    const body = this.parseBlock();
    return new AST.SseDeclaration(path, params, body, l);
  };

  ParserClass.prototype.parseModelDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'model'
    const name = this.expect(TokenType.IDENTIFIER, "Expected model/type name after 'model'").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume '{'
      config = {};
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const key = this.expect(TokenType.IDENTIFIER, "Expected model config key").value;
        this.expect(TokenType.COLON, "Expected ':' after model config key");
        const value = this.parseExpression();
        config[key] = value;
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close model config");
    }
    return new AST.ModelDeclaration(name, config, l);
  };

  ParserClass.prototype.parseRoute = function() {
    const l = this.loc();
    this.expect(TokenType.ROUTE);

    // HTTP method: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS (as identifiers)
    const methodTok = this.expect(TokenType.IDENTIFIER, "Expected HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)");
    const method = methodTok.value.toUpperCase();
    if (!['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'].includes(method)) {
      this.error(`Invalid HTTP method: ${method}`);
    }

    const path = this.expect(TokenType.STRING, "Expected route path string");

    // Optional body type annotation: route POST "/api/users" body: User => handler
    let bodyType = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'body') {
      const next = this.peek(1);
      if (next && next.type === TokenType.COLON) {
        this.advance(); // consume 'body'
        this.advance(); // consume ':'
        bodyType = this.parseTypeAnnotation();
      }
    }

    // Optional decorators: route GET "/path" with auth, role("admin") => handler
    let decorators = [];
    if (this.check(TokenType.WITH)) {
      this.advance(); // consume 'with'
      // Parse comma-separated decorator list
      do {
        const decName = this.expect(TokenType.IDENTIFIER, "Expected decorator name").value;
        let decArgs = [];
        if (this.check(TokenType.LPAREN)) {
          this.advance(); // (
          while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
            decArgs.push(this.parseExpression());
            if (!this.match(TokenType.COMMA)) break;
          }
          this.expect(TokenType.RPAREN, "Expected ')' after decorator arguments");
        }
        decorators.push({ name: decName, args: decArgs });
      } while (this.match(TokenType.COMMA));
    }

    // Optional response type annotation: route GET "/api/users" -> [User] => handler
    let responseType = null;
    if (this.check(TokenType.THIN_ARROW)) {
      this.advance(); // consume '->'
      responseType = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ARROW, "Expected '=>' after route path");
    const handler = this.parseExpression();

    return new AST.RouteDeclaration(method, path.value, handler, l, decorators, bodyType, responseType);
  };
}

// ─── src/parser/client-parser.js ───────────────────────

// Client-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when client { } blocks are encountered.
function installClientParser(ParserClass) {
  if (ParserClass.prototype._clientParserInstalled) return;
  ParserClass.prototype._clientParserInstalled = true;

  ParserClass.prototype.parseClientBlock = function() {
    const l = this.loc();
    this.expect(TokenType.CLIENT);
    // Optional block name: client "admin" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'client'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseClientStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close client block");
    return new AST.ClientBlock(body, l, name);
  };

  ParserClass.prototype.parseClientStatement = function() {
    if (this.check(TokenType.STATE)) return this.parseState();
    if (this.check(TokenType.COMPUTED)) return this.parseComputed();
    if (this.check(TokenType.EFFECT)) return this.parseEffect();
    if (this.check(TokenType.COMPONENT)) return this.parseComponent();
    if (this.check(TokenType.STORE)) return this.parseStore();
    return this.parseStatement();
  };

  ParserClass.prototype.parseStore = function() {
    const l = this.loc();
    this.expect(TokenType.STORE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected store name").value;
    this.expect(TokenType.LBRACE, "Expected '{' after store name");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.STATE)) {
        body.push(this.parseState());
      } else if (this.check(TokenType.COMPUTED)) {
        body.push(this.parseComputed());
      } else if (this.check(TokenType.FN) && (this.peek(1).type === TokenType.IDENTIFIER || this._isContextualKeywordToken(this.peek(1)))) {
        body.push(this.parseFunctionDeclaration());
      } else {
        this.error("Expected 'state', 'computed', or 'fn' inside store block");
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close store block");

    return new AST.StoreDeclaration(name, body, l);
  };

  ParserClass.prototype.parseState = function() {
    const l = this.loc();
    this.expect(TokenType.STATE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected state variable name").value;

    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in state declaration");
    const value = this.parseExpression();

    return new AST.StateDeclaration(name, typeAnnotation, value, l);
  };

  ParserClass.prototype.parseComputed = function() {
    const l = this.loc();
    this.expect(TokenType.COMPUTED);
    const name = this.expect(TokenType.IDENTIFIER, "Expected computed variable name").value;
    this.expect(TokenType.ASSIGN, "Expected '=' in computed declaration");
    const expr = this.parseExpression();

    return new AST.ComputedDeclaration(name, expr, l);
  };

  ParserClass.prototype.parseEffect = function() {
    const l = this.loc();
    this.expect(TokenType.EFFECT);
    const body = this.parseBlock();
    return new AST.EffectDeclaration(body, l);
  };

  ParserClass.prototype.parseComponent = function() {
    const l = this.loc();
    this.expect(TokenType.COMPONENT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected component name").value;

    let params = [];
    if (this.match(TokenType.LPAREN)) {
      params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after component parameters");
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open component body");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.STYLE_BLOCK)) {
        const sl = this.loc();
        const css = this.current().value;
        this.advance();
        body.push(new AST.ComponentStyleBlock(css, sl));
      } else if (this.check(TokenType.LESS) && this._looksLikeJSX()) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STATE)) {
        body.push(this.parseState());
      } else if (this.check(TokenType.COMPUTED)) {
        body.push(this.parseComputed());
      } else if (this.check(TokenType.EFFECT)) {
        body.push(this.parseEffect());
      } else if (this.check(TokenType.COMPONENT)) {
        body.push(this.parseComponent());
      } else {
        body.push(this.parseStatement());
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close component body");

    return new AST.ComponentDeclaration(name, params, body, l);
  };

  // ─── JSX-like parsing ─────────────────────────────────────

  ParserClass.prototype._collapseJSXWhitespace = function(text) {
    let result = text.replace(/\s+/g, ' ');
    if (result.trim() === '') return '';
    return result.trim();
  };

  ParserClass.prototype.parseJSXElementOrFragment = function() {
    // Check if this is a fragment: <>...</>
    if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.GREATER) {
      return this.parseJSXFragment();
    }
    return this.parseJSXElement();
  };

  ParserClass.prototype.parseJSXFragment = function() {
    const l = this.loc();
    this.expect(TokenType.LESS, "Expected '<'");
    this.expect(TokenType.GREATER, "Expected '>' in fragment opening");

    // Parse children until </>
    const children = this.parseJSXFragmentChildren();

    return new AST.JSXFragment(children, l);
  };

  ParserClass.prototype.parseJSXFragmentChildren = function() {
    const children = [];

    while (!this.isAtEnd()) {
      // Closing fragment: </>
      if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.SLASH) {
        // Check for </> (fragment close) vs </tag> (error)
        if (this.peek(2).type === TokenType.GREATER) {
          this.advance(); // <
          this.advance(); // /
          this.advance(); // >
          break;
        } else {
          this.error("Unexpected closing tag inside fragment. Use </> to close a fragment");
        }
      }

      // Nested element or fragment
      if (this.check(TokenType.LESS)) {
        if (this.peek(1).type === TokenType.GREATER) {
          children.push(this.parseJSXFragment());
        } else {
          children.push(this.parseJSXElement());
        }
        continue;
      }

      // String literal as text
      if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        const str = this.parseStringLiteral();
        children.push(new AST.JSXText(str, this.loc()));
        continue;
      }

      // Unquoted JSX text
      if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          children.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
        continue;
      }

      // Expression in braces: {expr}
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after JSX expression");
        children.push(new AST.JSXExpression(expr, this.loc()));
        continue;
      }

      // for loop inside JSX
      if (this.check(TokenType.FOR)) {
        children.push(this.parseJSXFor());
        continue;
      }

      // if inside JSX
      if (this.check(TokenType.IF)) {
        children.push(this.parseJSXIf());
        continue;
      }

      // match inside JSX
      if (this.check(TokenType.MATCH)) {
        children.push(this.parseJSXMatch());
        continue;
      }

      break;
    }

    return children;
  };

  ParserClass.prototype.parseJSXElement = function() {
    const l = this.loc();
    this.expect(TokenType.LESS, "Expected '<'");

    const tag = this.expect(TokenType.IDENTIFIER, "Expected tag name").value;

    // Parse attributes (including spread: {...expr})
    const attributes = [];
    while (!this.check(TokenType.GREATER) && !this.check(TokenType.SLASH) && !this.isAtEnd()) {
      // Check for spread attribute: {...expr}
      if (this.check(TokenType.LBRACE) && this.peek(1).type === TokenType.SPREAD) {
        const sl = this.loc();
        this.advance(); // {
        this.advance(); // ...
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after spread expression");
        attributes.push(new AST.JSXSpreadAttribute(expr, sl));
      } else {
        attributes.push(this.parseJSXAttribute());
      }
    }

    // Self-closing tag: />
    if (this.match(TokenType.SLASH)) {
      this.expect(TokenType.GREATER, "Expected '>' in self-closing tag");
      return new AST.JSXElement(tag, attributes, [], true, l);
    }

    this.expect(TokenType.GREATER, "Expected '>'");

    // Parse children
    const children = this.parseJSXChildren(tag);

    return new AST.JSXElement(tag, attributes, children, false, l);
  };

  ParserClass.prototype.parseJSXAttribute = function() {
    const l = this.loc();
    // Accept keywords as attribute names (type, class, for, async, defer, etc. are valid HTML attributes)
    let name;
    if (this.check(TokenType.IDENTIFIER) || (this.peek().value in Keywords)) {
      name = this.advance().value;
    } else {
      this.error("Expected attribute name");
    }

    // Handle namespaced attributes: on:click, bind:value, class:active
    if (this.match(TokenType.COLON)) {
      let suffix;
      if (this.check(TokenType.IDENTIFIER) || (this.peek().value in Keywords)) {
        suffix = this.advance().value;
      } else {
        suffix = this.expect(TokenType.IDENTIFIER, "Expected name after ':'").value;
      }
      name = `${name}:${suffix}`;
      // Consume event modifiers: on:click.stop.prevent
      if (name.startsWith('on:') && this.check(TokenType.DOT)) {
        while (this.match(TokenType.DOT)) {
          const mod = this.expect(TokenType.IDENTIFIER, "Expected modifier name after '.'").value;
          name += `.${mod}`;
        }
      }
    }

    if (!this.match(TokenType.ASSIGN)) {
      // Boolean attribute: <input disabled />
      return new AST.JSXAttribute(name, new AST.BooleanLiteral(true, l), l);
    }

    // Value can be {expression} or "string"
    if (this.match(TokenType.LBRACE)) {
      const expr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after attribute expression");
      return new AST.JSXAttribute(name, expr, l);
    }

    if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
      const val = this.parseStringLiteral();
      return new AST.JSXAttribute(name, val, l);
    }

    this.error("Expected attribute value");
  };

  ParserClass.prototype.parseJSXChildren = function(parentTag) {
    const children = [];

    while (!this.isAtEnd()) {
      // Closing tag: </tag>
      if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.SLASH) {
        this.advance(); // <
        this.advance(); // /
        const closeTag = this.expect(TokenType.IDENTIFIER, "Expected closing tag name").value;
        if (closeTag !== parentTag) {
          this.error(`Mismatched closing tag: expected </${parentTag}>, got </${closeTag}>`);
        }
        this.expect(TokenType.GREATER, "Expected '>' in closing tag");
        break;
      }

      // Nested element or fragment
      if (this.check(TokenType.LESS)) {
        children.push(this.parseJSXElementOrFragment());
        continue;
      }

      // String literal as text
      if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        const str = this.parseStringLiteral();
        children.push(new AST.JSXText(str, this.loc()));
        continue;
      }

      // Unquoted JSX text
      if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          children.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
        continue;
      }

      // Expression in braces: {expr}
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after JSX expression");
        children.push(new AST.JSXExpression(expr, this.loc()));
        continue;
      }

      // for loop inside JSX
      if (this.check(TokenType.FOR)) {
        children.push(this.parseJSXFor());
        continue;
      }

      // if inside JSX
      if (this.check(TokenType.IF)) {
        children.push(this.parseJSXIf());
        continue;
      }

      // match inside JSX
      if (this.check(TokenType.MATCH)) {
        children.push(this.parseJSXMatch());
        continue;
      }

      break;
    }

    return children;
  };

  ParserClass.prototype.parseJSXFor = function() {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // Support destructuring: for [i, item] in ..., for {name, age} in ...
    let variable;
    if (this.check(TokenType.LBRACKET)) {
      // Array destructuring: [a, b]
      this.advance(); // consume [
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' in destructuring pattern");
      variable = new AST.ArrayPattern(elements, l);
    } else if (this.check(TokenType.LBRACE)) {
      // Object destructuring: {name, age}
      this.advance(); // consume {
      const props = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        props.push({ key: this.expect(TokenType.IDENTIFIER, "Expected property name in object pattern").value });
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in destructuring pattern");
      variable = new AST.ObjectPattern(props, l);
    } else {
      variable = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
    }

    this.expect(TokenType.IN, "Expected 'in' in for loop");
    const iterable = this.parseExpression();

    // Optional key expression: for item in items key={item.id} { ... }
    let keyExpr = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'key') {
      this.advance(); // consume 'key'
      this.expect(TokenType.ASSIGN, "Expected '=' after 'key'");
      this.expect(TokenType.LBRACE, "Expected '{' after 'key='");
      keyExpr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after key expression");
    }

    this.expect(TokenType.LBRACE, "Expected '{' in JSX for body");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else if (this.check(TokenType.FOR)) {
        body.push(this.parseJSXFor());
      } else if (this.check(TokenType.IF)) {
        body.push(this.parseJSXIf());
      } else if (this.check(TokenType.MATCH)) {
        body.push(this.parseJSXMatch());
      } else {
        break;
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX for body");

    return new AST.JSXFor(variable, iterable, body, l, keyExpr);
  };

  ParserClass.prototype._parseJSXIfBody = function() {
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else if (this.check(TokenType.FOR)) {
        body.push(this.parseJSXFor());
      } else if (this.check(TokenType.IF)) {
        body.push(this.parseJSXIf());
      } else if (this.check(TokenType.MATCH)) {
        body.push(this.parseJSXMatch());
      } else {
        break;
      }
    }
    return body;
  };

  ParserClass.prototype.parseJSXIf = function() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' in JSX if body");
    const consequent = this._parseJSXIfBody();
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX if body");

    // Parse elif chains
    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance(); // consume 'elif'
      const elifCond = this.parseExpression();
      this.expect(TokenType.LBRACE, "Expected '{' in JSX elif body");
      const elifBody = this._parseJSXIfBody();
      this.expect(TokenType.RBRACE, "Expected '}' to close JSX elif body");
      alternates.push({ condition: elifCond, body: elifBody });
    }

    // Parse optional else
    let alternate = null;
    if (this.check(TokenType.ELSE)) {
      this.advance();
      this.expect(TokenType.LBRACE);
      alternate = this._parseJSXIfBody();
      this.expect(TokenType.RBRACE);
    }

    return new AST.JSXIf(condition, consequent, alternate, l, alternates);
  };

  ParserClass.prototype.parseJSXMatch = function() {
    const l = this.loc();
    this.expect(TokenType.MATCH);
    const subject = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' to open JSX match body");

    const arms = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const al = this.loc();
      const pattern = this.parsePattern();

      let guard = null;
      if (this.match(TokenType.IF)) {
        guard = this.parseExpression();
      }

      this.expect(TokenType.ARROW, "Expected '=>' in JSX match arm");

      // Parse arm body as JSX children
      const body = [];
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else if (this.check(TokenType.FOR)) {
        body.push(this.parseJSXFor());
      } else if (this.check(TokenType.IF)) {
        body.push(this.parseJSXIf());
      } else {
        // Fallback to regular expression (e.g., null, number literals)
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
      }

      arms.push({ pattern, guard, body, loc: al });
      this.match(TokenType.COMMA); // Optional comma between arms
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close JSX match body");
    return new AST.JSXMatch(subject, arms, l);
  };
}

// ─── src/parser/parser.js ──────────────────────────────

class Parser {
  static MAX_EXPRESSION_DEPTH = 200;
  static COMPARISON_OPS = null; // initialized after class definition

  constructor(tokens, filename = '<stdin>') {
    // Pre-filter: build array of significant tokens for O(1) peek
    const significant = [];
    const docs = [];
    for (const t of tokens) {
      const type = t.type;
      if (type === TokenType.NEWLINE || type === TokenType.SEMICOLON) continue;
      if (type === TokenType.DOCSTRING) { docs.push(t); continue; }
      significant.push(t);
    }
    this.tokens = significant;
    this._eof = significant[significant.length - 1]; // cache EOF for hot-path methods
    this.filename = filename;
    this.pos = 0;
    this.errors = [];
    this._expressionDepth = 0;
    this.docstrings = docs;
  }

  // ─── Helpers ───────────────────────────────────────────────

  error(message, code = null) {
    const tok = this.current();
    const err = new Error(
      `${this.filename}:${tok.line}:${tok.column} — Parse error: ${message}\n  Got: ${tok.type} (${JSON.stringify(tok.value)})`
    );
    err.loc = { line: tok.line, column: tok.column, file: this.filename };
    if (code) err.code = code;
    throw err;
  }

  current() {
    return this.tokens[this.pos] || this._eof;
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.tokens.length ? this.tokens[idx] : this._eof;
  }

  advance() {
    return this.tokens[this.pos++] || this._eof;
  }

  check(type) {
    return this.current().type === type;
  }

  checkValue(type, value) {
    const tok = this.current();
    return tok.type === type && tok.value === value;
  }

  match(...types) {
    for (const type of types) {
      if (this.check(type)) {
        return this.advance();
      }
    }
    return null;
  }

  expect(type, message) {
    if (this.check(type)) {
      return this.advance();
    }
    this.error(message || `Expected ${type}, got ${this.current().type}`);
  }

  loc() {
    const tok = this.current();
    return { line: tok.line, column: tok.column, file: this.filename };
  }

  isAtEnd() {
    return this.check(TokenType.EOF);
  }

  _synchronize() {
    const startPos = this.pos;
    this.advance(); // skip the problematic token
    while (!this.isAtEnd()) {
      const tok = this.current();
      // Statement-starting keywords — safe to resume parsing here
      if (tok.type === TokenType.FN || tok.type === TokenType.TYPE ||
          tok.type === TokenType.IF || tok.type === TokenType.FOR ||
          tok.type === TokenType.WHILE || tok.type === TokenType.RETURN ||
          tok.type === TokenType.IMPORT || tok.type === TokenType.MATCH ||
          tok.type === TokenType.TRY || tok.type === TokenType.SERVER ||
          tok.type === TokenType.CLIENT || tok.type === TokenType.SHARED ||
          tok.type === TokenType.GUARD || tok.type === TokenType.INTERFACE ||
          tok.type === TokenType.IMPL || tok.type === TokenType.TRAIT ||
          tok.type === TokenType.PUB || tok.type === TokenType.DEFER ||
          tok.type === TokenType.EXTERN ||
          tok.type === TokenType.VAR || tok.type === TokenType.ASYNC) {
        return;
      }
      if (tok.type === TokenType.RBRACE) {
        this.advance();
        return;
      }
      this.advance();
    }
    // Safety: if we didn't advance at all, force advance to avoid infinite loop
    if (this.pos === startPos && !this.isAtEnd()) {
      this.advance();
    }
  }

  // Full-stack keywords (route, state, computed, effect, component, store) are contextual —
  // they act as keywords inside server/client blocks but can be used as identifiers elsewhere.
  _isContextualKeyword() {
    const t = this.current().type;
    return t === TokenType.ROUTE || t === TokenType.STATE || t === TokenType.COMPUTED ||
           t === TokenType.EFFECT || t === TokenType.COMPONENT || t === TokenType.STORE;
  }

  _isContextualKeywordToken(token) {
    const t = token.type;
    return t === TokenType.ROUTE || t === TokenType.STATE || t === TokenType.COMPUTED ||
           t === TokenType.EFFECT || t === TokenType.COMPONENT || t === TokenType.STORE;
  }

  _synchronizeBlock() {
    // Don't advance if already at } — that's the block closer we need
    if (!this.isAtEnd() && this.current().type !== TokenType.RBRACE) {
      this.advance(); // skip the problematic token
    }
    while (!this.isAtEnd()) {
      const tok = this.current();
      // Stop at } WITHOUT consuming — let the block close properly
      if (tok.type === TokenType.RBRACE) return;
      // Statement-starting keywords — safe to resume parsing here
      if (tok.type === TokenType.FN || tok.type === TokenType.TYPE ||
          tok.type === TokenType.IF || tok.type === TokenType.FOR ||
          tok.type === TokenType.WHILE || tok.type === TokenType.RETURN ||
          tok.type === TokenType.IMPORT || tok.type === TokenType.MATCH ||
          tok.type === TokenType.TRY || tok.type === TokenType.SERVER ||
          tok.type === TokenType.CLIENT || tok.type === TokenType.SHARED ||
          tok.type === TokenType.GUARD || tok.type === TokenType.INTERFACE ||
          tok.type === TokenType.IMPL || tok.type === TokenType.TRAIT ||
          tok.type === TokenType.PUB || tok.type === TokenType.DEFER ||
          tok.type === TokenType.EXTERN || tok.type === TokenType.VAR || tok.type === TokenType.MUT ||
          tok.type === TokenType.STATE || tok.type === TokenType.ROUTE ||
          tok.type === TokenType.IDENTIFIER) {
        return;
      }
      this.advance();
    }
  }

  // Detect if current < starts a JSX tag (vs comparison operator)
  _looksLikeJSX() {
    if (!this.check(TokenType.LESS)) return false;
    const next = this.peek(1);
    // Fragment: <>
    if (next.type === TokenType.GREATER) return true;
    if (next.type !== TokenType.IDENTIFIER) return false;
    // Uppercase tag is always a component reference, never a comparison variable
    if (/^[A-Z]/.test(next.value)) return true;
    const afterIdent = this.peek(2);
    // Negative check: if afterIdent is a comparison/logical operator, this is NOT JSX
    // This catches `a < b && c > d` being misread as JSX
    if (afterIdent.type === TokenType.LESS ||
        afterIdent.type === TokenType.LESS_EQUAL ||
        afterIdent.type === TokenType.GREATER_EQUAL ||
        afterIdent.type === TokenType.AND_AND ||
        afterIdent.type === TokenType.OR_OR ||
        afterIdent.type === TokenType.EQUAL ||
        afterIdent.type === TokenType.NOT_EQUAL) {
      return false;
    }
    // JSX patterns: <div>, <div/>, <div attr=...>, <div on:click=...>
    // After the tag name, we can see >, /, an attribute name (identifier or keyword), or :
    return afterIdent.type === TokenType.GREATER ||
           afterIdent.type === TokenType.SLASH ||
           afterIdent.type === TokenType.IDENTIFIER ||
           afterIdent.type === TokenType.COLON ||
           afterIdent.type === TokenType.STATE ||
           afterIdent.type === TokenType.TYPE ||
           afterIdent.type === TokenType.FOR ||
           afterIdent.type === TokenType.IN ||
           afterIdent.type === TokenType.IF ||
           afterIdent.type === TokenType.ELSE ||
           afterIdent.type === TokenType.MATCH ||
           afterIdent.type === TokenType.RETURN ||
           afterIdent.type === TokenType.NUMBER;
  }

  // ─── Program ───────────────────────────────────────────────

  parse() {
    const body = [];
    const maxErrors = 50; // Stop after 50 errors to avoid cascading noise
    while (!this.isAtEnd()) {
      if (this.errors.length >= maxErrors) break;
      try {
        const stmt = this.parseTopLevel();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronize();
      }
    }
    if (this.errors.length > 0) {
      const program = new AST.Program(body);
      this._attachDocstrings(program);
      const combined = new Error(this.errors.map(e => e.message).join('\n'));
      combined.errors = this.errors;
      combined.partialAST = program;
      if (this.errors.length >= maxErrors) {
        combined.truncated = true;
      }
      throw combined;
    }
    const program = new AST.Program(body);
    this._attachDocstrings(program);
    return program;
  }

  _attachDocstrings(program) {
    // Use pre-extracted docstring tokens
    const docTokens = this.docstrings;
    if (docTokens.length === 0) return;

    // Group consecutive docstring lines
    const groups = [];
    let current = [docTokens[0]];
    for (let i = 1; i < docTokens.length; i++) {
      if (docTokens[i].line === current[current.length - 1].line + 1) {
        current.push(docTokens[i]);
      } else {
        groups.push(current);
        current = [docTokens[i]];
      }
    }
    groups.push(current);

    // Map: endLine → docstring text
    const docsByEndLine = new Map();
    for (const group of groups) {
      const endLine = group[group.length - 1].line;
      const text = group.map(t => t.value).join('\n');
      docsByEndLine.set(endLine, text);
    }

    // Walk top-level nodes and attach docstrings
    const docTypes = new Set(['FunctionDeclaration', 'TypeDeclaration', 'InterfaceDeclaration', 'Assignment', 'TraitDeclaration']);
    const walk = (nodes) => {
      for (const node of nodes) {
        if (!node || !node.loc) continue;
        if (docTypes.has(node.type)) {
          const doc = docsByEndLine.get(node.loc.line - 1);
          if (doc) node.docstring = doc;
        }
        // Walk into blocks
        if (node.body && Array.isArray(node.body)) walk(node.body);
        if (node.type === 'ServerBlock' || node.type === 'ClientBlock' || node.type === 'SharedBlock') {
          if (node.body) walk(node.body);
        }
      }
    };
    walk(program.body);
  }

  parseTopLevel() {
    if (this.check(TokenType.SERVER)) {
      if (!Parser.prototype._serverParserInstalled) {
        installServerParser(Parser);
      }
      return this.parseServerBlock();
    }
    if (this.check(TokenType.CLIENT)) {
      if (!Parser.prototype._clientParserInstalled) {
        installClientParser(Parser);
      }
      return this.parseClientBlock();
    }
    if (this.check(TokenType.SHARED)) return this.parseSharedBlock();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    // data block: data { ... }
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'data' && this.peek(1).type === TokenType.LBRACE) {
      return this.parseDataBlock();
    }
    // test block: test "name" { ... } or test { ... }
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'test') {
      const next = this.peek(1);
      if (next.type === TokenType.LBRACE || next.type === TokenType.STRING) {
        return this.parseTestBlock();
      }
    }
    // bench block: bench "name" { ... } or bench { ... }
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'bench') {
      const next = this.peek(1);
      if (next.type === TokenType.LBRACE || next.type === TokenType.STRING) {
        return this.parseBenchBlock();
      }
    }
    return this.parseStatement();
  }

  parseTestBlock() {
    const l = this.loc();
    this.advance(); // consume 'test'
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    // Parse optional timeout=N
    let timeout = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'timeout' && this.peek(1).type === TokenType.ASSIGN) {
      this.advance(); // consume 'timeout'
      this.advance(); // consume '='
      const tok = this.expect(TokenType.NUMBER, "Expected number after timeout=");
      timeout = Number(tok.value);
    }
    this.expect(TokenType.LBRACE, "Expected '{' after test block name");
    const body = [];
    let beforeEach = null;
    let afterEach = null;
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        // Check for before_each { ... }
        if (this.check(TokenType.IDENTIFIER) && this.current().value === 'before_each' && this.peek(1).type === TokenType.LBRACE) {
          this.advance(); // consume 'before_each'
          this.expect(TokenType.LBRACE, "Expected '{' after before_each");
          beforeEach = [];
          while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
            const s = this.parseStatement();
            if (s) beforeEach.push(s);
          }
          this.expect(TokenType.RBRACE, "Expected '}' to close before_each");
          continue;
        }
        // Check for after_each { ... }
        if (this.check(TokenType.IDENTIFIER) && this.current().value === 'after_each' && this.peek(1).type === TokenType.LBRACE) {
          this.advance(); // consume 'after_each'
          this.expect(TokenType.LBRACE, "Expected '{' after after_each");
          afterEach = [];
          while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
            const s = this.parseStatement();
            if (s) afterEach.push(s);
          }
          this.expect(TokenType.RBRACE, "Expected '}' to close after_each");
          continue;
        }
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close test block");
    return new AST.TestBlock(name, body, l, { timeout, beforeEach, afterEach });
  }

  parseBenchBlock() {
    const l = this.loc();
    this.advance(); // consume 'bench'
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after bench block name");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close bench block");
    return new AST.BenchBlock(name, body, l);
  }

  // ─── Full-stack blocks ────────────────────────────────────
  // parseClientBlock() and client-specific methods are in client-parser.js (lazy-loaded)

  parseSharedBlock() {
    const l = this.loc();
    this.expect(TokenType.SHARED);
    // Optional block name: shared "models" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'shared'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close shared block");
    return new AST.SharedBlock(body, l, name);
  }

  // ─── Data block ────────────────────────────────────────────

  parseDataBlock() {
    const l = this.loc();
    this.advance(); // consume 'data'
    this.expect(TokenType.LBRACE, "Expected '{' after 'data'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseDataStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close data block");
    return new AST.DataBlock(body, l);
  }

  parseDataStatement() {
    if (!this.check(TokenType.IDENTIFIER)) {
      return this.parseStatement();
    }

    const val = this.current().value;

    // source customers: Table<Customer> = read("customers.csv")
    if (val === 'source') {
      return this.parseSourceDeclaration();
    }

    // pipeline clean_customers = customers |> where(...)
    if (val === 'pipeline') {
      return this.parsePipelineDeclaration();
    }

    // validate Customer { .email |> contains("@"), ... }
    if (val === 'validate') {
      return this.parseValidateBlock();
    }

    // refresh customers every 15.minutes
    // refresh orders on_demand
    if (val === 'refresh') {
      return this.parseRefreshPolicy();
    }

    return this.parseStatement();
  }

  parseSourceDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'source'
    const name = this.expect(TokenType.IDENTIFIER, "Expected source name").value;

    // Optional type annotation: source customers: Table<Customer>
    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ASSIGN, "Expected '=' after source name");
    const expression = this.parseExpression();

    return new AST.SourceDeclaration(name, typeAnnotation, expression, l);
  }

  parsePipelineDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'pipeline'
    const name = this.expect(TokenType.IDENTIFIER, "Expected pipeline name").value;
    this.expect(TokenType.ASSIGN, "Expected '=' after pipeline name");
    const expression = this.parseExpression();
    return new AST.PipelineDeclaration(name, expression, l);
  }

  parseValidateBlock() {
    const l = this.loc();
    this.advance(); // consume 'validate'
    const typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'validate'").value;
    this.expect(TokenType.LBRACE, "Expected '{' after validate type name");

    const rules = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const rule = this.parseExpression();
      rules.push(rule);
      this.match(TokenType.COMMA); // optional comma separator
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close validate block");
    return new AST.ValidateBlock(typeName, rules, l);
  }

  parseRefreshPolicy() {
    const l = this.loc();
    this.advance(); // consume 'refresh'
    const sourceName = this.expect(TokenType.IDENTIFIER, "Expected source name after 'refresh'").value;

    // refresh X every N.unit  OR  refresh X on_demand
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'on_demand') {
      this.advance();
      return new AST.RefreshPolicy(sourceName, 'on_demand', l);
    }

    // expect 'every'
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'every') {
      this.advance(); // consume 'every'
    }

    // Parse interval: N.unit (e.g., 15.minutes, 1.hour)
    const value = this.expect(TokenType.NUMBER, "Expected interval value").value;
    this.expect(TokenType.DOT, "Expected '.' after interval value");
    const unit = this.expect(TokenType.IDENTIFIER, "Expected time unit (minutes, hours, seconds)").value;

    return new AST.RefreshPolicy(sourceName, { value, unit }, l);
  }

  // Client-specific statements and JSX parsing are in client-parser.js (lazy-loaded)

  // ─── Statements ───────────────────────────────────────────

  parseStatement() {
    // pub modifier: pub fn, pub type, pub x = ...
    if (this.check(TokenType.PUB)) return this.parsePubDeclaration();
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FOR) {
      this.advance(); // consume async
      return this.parseForStatement(null, true);
    }
    if (this.check(TokenType.AT)) return this.parseDecoratedDeclaration();
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN) return this.parseAsyncFunctionDeclaration();
    if (this.check(TokenType.FN) && (this.peek(1).type === TokenType.IDENTIFIER || this._isContextualKeywordToken(this.peek(1)))) return this.parseFunctionDeclaration();
    if (this.check(TokenType.TYPE)) return this.parseTypeDeclaration();
    if (this.check(TokenType.MUT)) this.error("'mut' is not supported in Tova. Use 'var' for mutable variables");
    if (this.check(TokenType.VAR)) return this.parseVarDeclaration();
    if (this.check(TokenType.LET)) return this.parseLetDestructure();
    if (this.check(TokenType.IF)) return this.parseIfStatement();
    if (this.check(TokenType.FOR)) return this.parseForStatement();
    if (this.check(TokenType.WHILE)) return this.parseWhileStatement();
    if (this.check(TokenType.LOOP)) return this.parseLoopStatement();
    if (this.check(TokenType.RETURN)) return this.parseReturnStatement();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    if (this.check(TokenType.MATCH)) return this.parseMatchAsStatement();
    if (this.check(TokenType.TRY)) return this.parseTryCatch();
    if (this.check(TokenType.BREAK)) return this.parseBreakStatement();
    if (this.check(TokenType.CONTINUE)) return this.parseContinueStatement();
    if (this.check(TokenType.GUARD)) return this.parseGuardStatement();
    if (this.check(TokenType.INTERFACE)) return this.parseInterfaceDeclaration();
    if (this.check(TokenType.IMPL)) return this.parseImplDeclaration();
    if (this.check(TokenType.TRAIT)) return this.parseTraitDeclaration();
    if (this.check(TokenType.DEFER)) return this.parseDeferStatement();
    if (this.check(TokenType.WITH)) return this.parseWithStatement();
    if (this.check(TokenType.EXTERN)) return this.parseExternDeclaration();

    // Labeled loops: name: for/while/loop
    if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
      const afterColon = this.peek(2).type;
      if (afterColon === TokenType.FOR || afterColon === TokenType.WHILE || afterColon === TokenType.LOOP) {
        const label = this.advance().value; // consume identifier
        this.advance(); // consume colon
        if (this.check(TokenType.FOR)) return this.parseForStatement(label);
        if (this.check(TokenType.WHILE)) return this.parseWhileStatement(label);
        if (this.check(TokenType.LOOP)) return this.parseLoopStatement(label);
      }
    }

    return this.parseExpressionOrAssignment();
  }

  parsePubDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'pub'
    if (this.check(TokenType.PUB)) {
      this.error("Duplicate 'pub' modifier");
    }
    const stmt = this.parseStatement();
    if (stmt) stmt.isPublic = true;
    return stmt;
  }

  parseImplDeclaration() {
    const l = this.loc();
    this.expect(TokenType.IMPL);
    const firstName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'impl'").value;

    // Check for `impl Trait for Type`
    let typeName, traitName = null;
    if (this.check(TokenType.FOR)) {
      this.advance();
      traitName = firstName;
      typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'for'").value;
    } else {
      typeName = firstName;
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open impl block");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const isAsync = this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN;
      if (isAsync) {
        methods.push(this.parseAsyncFunctionDeclaration());
      } else {
        this.expect(TokenType.FN, "Expected 'fn' in impl block");
        const methodLoc = this.loc();
        const name = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
        this.expect(TokenType.LPAREN, "Expected '(' after method name");
        const params = this.parseParameterList();
        this.expect(TokenType.RPAREN, "Expected ')' after parameters");
        let returnType = null;
        if (this.match(TokenType.THIN_ARROW)) {
          returnType = this.parseTypeAnnotation();
        }
        const body = this.parseBlock();
        methods.push(new AST.FunctionDeclaration(name, params, body, returnType, methodLoc));
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close impl block");
    return new AST.ImplDeclaration(typeName, methods, l, traitName);
  }

  parseTraitDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TRAIT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected trait name").value;
    this.expect(TokenType.LBRACE, "Expected '{' to open trait body");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      this.expect(TokenType.FN, "Expected 'fn' in trait body");
      const methodName = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
      this.expect(TokenType.LPAREN, "Expected '(' after method name");
      const params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after parameters");
      let returnType = null;
      if (this.match(TokenType.THIN_ARROW)) {
        returnType = this.parseTypeAnnotation();
      }
      // Optional default implementation
      let body = null;
      if (this.check(TokenType.LBRACE)) {
        body = this.parseBlock();
      }
      methods.push({ name: methodName, params, returnType, body });
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close trait body");
    return new AST.TraitDeclaration(name, methods, l);
  }

  parseDeferStatement() {
    const l = this.loc();
    this.expect(TokenType.DEFER);
    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }
    return new AST.DeferStatement(body, l);
  }

  parseWithStatement() {
    const l = this.loc();
    this.expect(TokenType.WITH);
    const expression = this.parseExpression();
    this.expect(TokenType.AS, "Expected 'as' after with expression");
    const name = this.expect(TokenType.IDENTIFIER, "Expected variable name after 'as'").value;
    const body = this.parseBlock();
    return new AST.WithStatement(expression, name, body, l);
  }

  parseExternDeclaration() {
    const l = this.loc();
    this.expect(TokenType.EXTERN);

    const isAsync = !!this.match(TokenType.ASYNC);
    this.expect(TokenType.FN, "Expected 'fn' after 'extern'");
    const name = this.expect(TokenType.IDENTIFIER, "Expected function name in extern declaration").value;
    this.expect(TokenType.LPAREN, "Expected '(' after extern function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after extern parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    return new AST.ExternDeclaration(name, params, returnType, l, isAsync);
  }

  parseDecoratedDeclaration() {
    const decorators = [];
    while (this.check(TokenType.AT)) {
      this.advance(); // consume @
      const decName = this.expect(TokenType.IDENTIFIER, "Expected decorator name after '@'").value;
      let decArgs = [];
      if (this.check(TokenType.LPAREN)) {
        this.advance(); // consume (
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          decArgs.push(this.parseExpression());
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN, "Expected ')' after decorator arguments");
      }
      decorators.push({ name: decName, args: decArgs });
    }
    // After decorators, expect fn or async fn
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN) {
      const node = this.parseAsyncFunctionDeclaration(decorators);
      return node;
    }
    if (this.check(TokenType.FN)) {
      const node = this.parseFunctionDeclaration(decorators);
      return node;
    }
    this.error("Expected 'fn' or 'async fn' after decorator");
  }

  parseFunctionDeclaration(decorators = []) {
    const l = this.loc();
    this.expect(TokenType.FN);
    let name;
    if (this._isContextualKeyword()) {
      name = this.advance().value;
    } else {
      name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    }

    // Parse optional type parameters: fn name<T, U>(...)
    let typeParams = [];
    if (this.check(TokenType.LESS)) {
      this.advance(); // consume <
      while (!this.check(TokenType.GREATER) && !this.isAtEnd()) {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.GREATER, "Expected '>' after type parameters");
    }

    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l, false, typeParams, decorators);
  }

  parseAsyncFunctionDeclaration(decorators = []) {
    const l = this.loc();
    this.expect(TokenType.ASYNC);
    this.expect(TokenType.FN);
    let name;
    if (this._isContextualKeyword()) {
      name = this.advance().value;
    } else {
      name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    }

    // Parse optional type parameters: async fn name<T, U>(...)
    let typeParams = [];
    if (this.check(TokenType.LESS)) {
      this.advance(); // consume <
      while (!this.check(TokenType.GREATER) && !this.isAtEnd()) {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.GREATER, "Expected '>' after type parameters");
    }

    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l, true, typeParams, decorators);
  }

  parseBreakStatement() {
    const l = this.loc();
    this.expect(TokenType.BREAK);
    // Optional label: break outer
    let label = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().line === l.line) {
      label = this.advance().value;
    }
    return new AST.BreakStatement(l, label);
  }

  parseContinueStatement() {
    const l = this.loc();
    this.expect(TokenType.CONTINUE);
    // Optional label: continue outer
    let label = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().line === l.line) {
      label = this.advance().value;
    }
    return new AST.ContinueStatement(l, label);
  }

  parseGuardStatement() {
    const l = this.loc();
    this.expect(TokenType.GUARD);
    const condition = this.parseExpression();
    this.expect(TokenType.ELSE, "Expected 'else' after guard condition");
    const elseBody = this.parseBlock();
    return new AST.GuardStatement(condition, elseBody, l);
  }

  parseInterfaceDeclaration() {
    const l = this.loc();
    this.expect(TokenType.INTERFACE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected interface name").value;
    this.expect(TokenType.LBRACE, "Expected '{' to open interface body");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      this.expect(TokenType.FN, "Expected 'fn' in interface body");
      const methodName = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
      this.expect(TokenType.LPAREN, "Expected '(' after method name");
      const params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after parameters");
      let returnType = null;
      if (this.match(TokenType.THIN_ARROW)) {
        returnType = this.parseTypeAnnotation();
      }
      methods.push({ name: methodName, params, returnType });
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close interface body");
    return new AST.InterfaceDeclaration(name, methods, l);
  }

  parseParameterList() {
    const params = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      const l = this.loc();

      // Destructuring pattern parameter: {name, email}: User or [head, ...tail]
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const properties = [];
        while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
          const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
          let value = key;
          let defaultValue = null;
          if (this.match(TokenType.COLON)) {
            value = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
          }
          if (this.match(TokenType.ASSIGN)) {
            defaultValue = this.parseExpression();
          }
          properties.push({ key, value, defaultValue });
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RBRACE, "Expected '}'");
        const pattern = new AST.ObjectPattern(properties, l);
        const param = new AST.Parameter(null, null, null, l);
        param.destructure = pattern;
        // Optional type annotation after destructure: {name, age}: User
        if (this.match(TokenType.COLON)) {
          param.typeAnnotation = this.parseTypeAnnotation();
        }
        params.push(param);
      } else if (this.check(TokenType.LBRACKET)) {
        this.advance();
        const elements = [];
        while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
          // Support spread in array destructure: [head, ...tail]
          if (this.check(TokenType.SPREAD)) {
            this.advance(); // consume ...
            const restName = this.expect(TokenType.IDENTIFIER, "Expected identifier after '...'").value;
            elements.push('...' + restName);
            break; // rest must be last
          }
          elements.push(this.expect(TokenType.IDENTIFIER, "Expected element name").value);
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RBRACKET, "Expected ']'");
        const pattern = new AST.ArrayPattern(elements, l);
        const param = new AST.Parameter(null, null, null, l);
        param.destructure = pattern;
        // Optional type annotation after destructure: [head, ...tail]: [Int]
        if (this.match(TokenType.COLON)) {
          param.typeAnnotation = this.parseTypeAnnotation();
        }
        params.push(param);
      } else {
        let name;
        if (this._isContextualKeyword()) {
          name = this.advance().value;
        } else {
          name = this.expect(TokenType.IDENTIFIER, "Expected parameter name").value;
        }

        let typeAnnotation = null;
        if (this.match(TokenType.COLON)) {
          typeAnnotation = this.parseTypeAnnotation();
        }

        let defaultValue = null;
        if (this.match(TokenType.ASSIGN)) {
          defaultValue = this.parseExpression();
        }

        params.push(new AST.Parameter(name, typeAnnotation, defaultValue, l));
      }

      if (!this.match(TokenType.COMMA)) break;
    }
    return params;
  }

  parseTypeAnnotation() {
    const l = this.loc();
    const first = this._parseSingleTypeAnnotation();

    // Union types: Type | Type | Type
    if (this.check(TokenType.BAR)) {
      const members = [first];
      while (this.match(TokenType.BAR)) {
        members.push(this._parseSingleTypeAnnotation());
      }
      return new AST.UnionTypeAnnotation(members, l);
    }

    return first;
  }

  // Parse a single type annotation without union (used as union member)
  _parseSingleTypeAnnotation() {
    const l = this.loc();

    // [Type] — array type shorthand
    if (this.match(TokenType.LBRACKET)) {
      const elementType = this._parseSingleTypeAnnotation();
      this.expect(TokenType.RBRACKET, "Expected ']' in array type");
      return new AST.ArrayTypeAnnotation(elementType, l);
    }

    // (Type, Type) — tuple type or function type
    if (this.check(TokenType.LPAREN)) {
      this.advance();
      const types = [];
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        types.push(this.parseTypeAnnotation());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RPAREN, "Expected ')' in type annotation");
      if (this.match(TokenType.THIN_ARROW)) {
        const returnType = this.parseTypeAnnotation();
        return new AST.FunctionTypeAnnotation(types, returnType, l);
      }
      return new AST.TupleTypeAnnotation(types, l);
    }

    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.parseTypeAnnotation());
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    return new AST.TypeAnnotation(name, typeParams, l);
  }

  parseTypeDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TYPE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    // Optional type parameters: Type<T, E>
    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    // Type alias: type Name = TypeExpr
    // OR Refinement type: type Name = TypeExpr where { ... }
    if (this.match(TokenType.ASSIGN)) {
      const typeExpr = this.parseTypeAnnotation();

      // Check for refinement type: type Email = String where { ... }
      if (this.check(TokenType.IDENTIFIER) && this.current().value === 'where') {
        this.advance(); // consume 'where'
        this.expect(TokenType.LBRACE, "Expected '{' after 'where'");

        // Parse predicate block — uses 'it' as implicit parameter
        const predicates = [];
        while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
          predicates.push(this.parseExpression());
          this.match(TokenType.COMMA); // optional comma between predicates
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close where block");

        // Combine predicates with 'and'
        let predicate = predicates[0];
        for (let i = 1; i < predicates.length; i++) {
          predicate = new AST.LogicalExpression('and', predicate, predicates[i], l);
        }

        return new AST.RefinementType(name, typeExpr, predicate, l);
      }

      // Simple enum syntax: type Color = Red | Green | Blue
      // Detect when the type expression is a union of bare identifiers (PascalCase, no type params)
      // But NOT when any member is a known built-in type (that's a type alias, not an enum)
      if (typeExpr.type === 'UnionTypeAnnotation') {
        const builtinTypes = new Set(['String', 'Int', 'Float', 'Bool', 'List', 'Map', 'Set', 'Option', 'Result', 'Any', 'Nil', 'Void', 'Number', 'Array', 'Object', 'Promise', 'Tuple']);
        const isSimpleEnum = typeExpr.members.every(m =>
          m.type === 'TypeAnnotation' && m.typeParams.length === 0 && /^[A-Z]/.test(m.name)
        );
        const hasBuiltinType = typeExpr.members.some(m =>
          m.type === 'TypeAnnotation' && builtinTypes.has(m.name)
        );
        if (isSimpleEnum && !hasBuiltinType) {
          const variants = typeExpr.members.map(m =>
            new AST.TypeVariant(m.name, [], m.loc)
          );
          return new AST.TypeDeclaration(name, typeParams, variants, l);
        }
      }

      return new AST.TypeAlias(name, typeParams, typeExpr, l);
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open type body");

    const variants = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const vl = this.loc();
      const vname = this.expect(TokenType.IDENTIFIER, "Expected variant or field name").value;

      if (this.match(TokenType.LPAREN)) {
        // Variant with fields: Circle(radius: Float)
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          const fl = this.loc();
          const fname = this.expect(TokenType.IDENTIFIER, "Expected field name").value;
          let ftype = null;
          if (this.match(TokenType.COLON)) {
            ftype = this.parseTypeAnnotation();
          }
          fields.push(new AST.TypeField(fname, ftype, fl));
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN, "Expected ')' after variant fields");
        variants.push(new AST.TypeVariant(vname, fields, vl));
      } else if (this.match(TokenType.COLON)) {
        // Simple field: name: String
        const ftype = this.parseTypeAnnotation();
        variants.push(new AST.TypeField(vname, ftype, vl));
      } else {
        // Bare variant: None
        variants.push(new AST.TypeVariant(vname, [], vl));
      }

      this.match(TokenType.COMMA);
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close type body");

    // Optional derive clause: type Foo { ... } derive [Eq, Show, JSON]
    const node = new AST.TypeDeclaration(name, typeParams, variants, l);
    if (this.match(TokenType.DERIVE)) {
      this.expect(TokenType.LBRACKET, "Expected '[' after derive");
      node.derive = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        node.derive.push(this.expect(TokenType.IDENTIFIER, "Expected derive trait name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' after derive traits");
    }
    return node;
  }

  parseVarDeclaration() {
    const l = this.loc();
    this.expect(TokenType.VAR);

    const targets = [];
    do {
      targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
    } while (this.match(TokenType.COMMA));

    this.expect(TokenType.ASSIGN, "Expected '=' in var declaration");

    const values = [this.parseExpression()];
    while (this.match(TokenType.COMMA)) {
      values.push(this.parseExpression());
    }

    return new AST.VarDeclaration(targets, values, l);
  }

  parseLetDestructure() {
    const l = this.loc();
    this.expect(TokenType.LET);

    let pattern;
    if (this.check(TokenType.LBRACE)) {
      pattern = this.parseObjectPattern();
    } else if (this.check(TokenType.LBRACKET)) {
      pattern = this.parseArrayPattern();
    } else if (this.check(TokenType.LPAREN)) {
      // Tuple destructuring: let (a, b) = expr
      pattern = this.parseTuplePattern();
    } else if (this.check(TokenType.IDENTIFIER)) {
      const name = this.current().value;
      this.error(`Use '${name} = value' for binding or 'var ${name} = value' for mutable. 'let' is only for destructuring: let {a, b} = obj`);
    } else {
      this.error("Expected '{', '[', or '(' after 'let' for destructuring");
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in destructuring");
    const value = this.parseExpression();

    return new AST.LetDestructure(pattern, value, l);
  }

  parseObjectPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);
    const properties = [];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
      let valueName = key;
      let defaultValue = null;

      if (this.match(TokenType.COLON)) {
        valueName = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
      }
      if (this.match(TokenType.ASSIGN)) {
        defaultValue = this.parseExpression();
      }

      properties.push({ key, value: valueName, defaultValue });
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACE, "Expected '}' in object pattern");
    return new AST.ObjectPattern(properties, l);
  }

  parseArrayPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);
    const elements = [];

    while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
      if (this.check(TokenType.IDENTIFIER) && this.current().value === '_') {
        elements.push(null); // skip placeholder
        this.advance();
      } else {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACKET, "Expected ']' in array pattern");
    return new AST.ArrayPattern(elements, l);
  }

  parseTuplePattern() {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const elements = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in tuple pattern").value);
      if (!this.match(TokenType.COMMA)) break;
    }
    this.expect(TokenType.RPAREN, "Expected ')' in tuple pattern");
    return new AST.TuplePattern(elements, l);
  }

  parseIfStatement() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF) ||
           (this.check(TokenType.ELSE) && this.peek(1).type === TokenType.IF)) {
      if (this.check(TokenType.ELIF)) {
        this.advance();
      } else {
        this.advance(); // else
        this.advance(); // if
      }
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.IfStatement(condition, consequent, alternates, elseBody, l);
  }

  parseForStatement(label = null, isAsync = false) {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // For variable(s) — supports simple, pair, array destructuring, and object destructuring
    let variable;
    if (this.check(TokenType.LBRACKET)) {
      // Array destructuring: for [a, b] in ...
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' in destructuring pattern");
      variable = `[${elements.join(', ')}]`;
    } else if (this.check(TokenType.LBRACE)) {
      // Object destructuring: for {name, age} in ...
      this.advance();
      const props = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        props.push(this.expect(TokenType.IDENTIFIER, "Expected property name in object pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in destructuring pattern");
      variable = `{${props.join(', ')}}`;
    } else {
      const firstName = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
      if (this.match(TokenType.COMMA)) {
        const secondName = this.expect(TokenType.IDENTIFIER, "Expected second loop variable").value;
        variable = [firstName, secondName];
      } else {
        variable = firstName;
      }
    }

    this.expect(TokenType.IN, "Expected 'in' after for variable");
    const iterable = this.parseExpression();

    // Optional when guard: for user in users when user.active { ... }
    let guard = null;
    if (this.match(TokenType.WHEN)) {
      guard = this.parseExpression();
    }

    const body = this.parseBlock();

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.ForStatement(variable, iterable, body, elseBody, l, guard, label, isAsync);
  }

  parseWhileStatement(label = null) {
    const l = this.loc();
    this.expect(TokenType.WHILE);
    const condition = this.parseExpression();
    const body = this.parseBlock();
    return new AST.WhileStatement(condition, body, l, label);
  }

  parseLoopStatement(label = null) {
    const l = this.loc();
    this.expect(TokenType.LOOP);
    const body = this.parseBlock();
    return new AST.LoopStatement(body, label, l);
  }

  parseTryCatch() {
    const l = this.loc();
    this.expect(TokenType.TRY);
    const tryBlock = this.parseBlock();

    let catchParam = null;
    let catchBody = null;
    let finallyBody = null;

    // Parse optional catch block
    if (this.match(TokenType.CATCH)) {
      if (this.check(TokenType.IDENTIFIER)) {
        catchParam = this.advance().value;
      }
      const catchBlock = this.parseBlock();
      catchBody = catchBlock.body;
    }

    // Parse optional finally block
    if (this.match(TokenType.FINALLY)) {
      const finallyBlock = this.parseBlock();
      finallyBody = finallyBlock.body;
    }

    // Must have at least catch or finally
    if (!catchBody && !finallyBody) {
      this.error("Expected 'catch' or 'finally' after try block");
    }

    return new AST.TryCatchStatement(tryBlock.body, catchParam, catchBody, l, finallyBody);
  }

  parseReturnStatement() {
    const l = this.loc();
    const returnToken = this.expect(TokenType.RETURN);

    let value = null;
    // Only parse return value if the next token is on the same line as `return`
    // This prevents `return\nx = 5` from being parsed as `return x` then `= 5`
    if (!this.check(TokenType.RBRACE) && !this.isAtEnd() && this.current().line === returnToken.line) {
      value = this.parseExpression();
    }

    return new AST.ReturnStatement(value, l);
  }

  parseImport() {
    const l = this.loc();
    this.expect(TokenType.IMPORT);

    // import * as name from "module"
    if (this.check(TokenType.STAR)) {
      this.advance(); // consume *
      this.expect(TokenType.AS, "Expected 'as' after '*' in wildcard import");
      const name = this.expect(TokenType.IDENTIFIER, "Expected namespace name after 'as'").value;
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportWildcard(name, source, l);
    }

    // import { a, b } from "module"
    if (this.match(TokenType.LBRACE)) {
      const specifiers = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const imported = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
        let local = imported;
        if (this.match(TokenType.AS)) {
          local = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
        }
        specifiers.push(new AST.ImportSpecifier(imported, local, this.loc()));
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in import");
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportDeclaration(specifiers, source, l);
    }

    // import Name from "module"
    const name = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
    this.expect(TokenType.FROM, "Expected 'from' in import");
    const source = this.expect(TokenType.STRING, "Expected module path").value;
    return new AST.ImportDefault(name, source, l);
  }

  parseBlock() {
    const l = this.loc();
    this.expect(TokenType.LBRACE, "Expected '{'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}'");
    return new AST.BlockStatement(body, l);
  }

  // ─── Expression or Assignment ─────────────────────────────

  parseExpressionOrAssignment() {
    const l = this.loc();
    const expr = this.parseExpression();

    // Multiple assignment: a, b = 1, 2
    if (this.check(TokenType.COMMA) && expr.type === 'Identifier') {
      const targets = [expr.name];
      while (this.match(TokenType.COMMA)) {
        targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
      }
      this.expect(TokenType.ASSIGN, "Expected '=' in multiple assignment");
      const values = [this.parseExpression()];
      while (this.match(TokenType.COMMA)) {
        values.push(this.parseExpression());
      }
      return new AST.Assignment(targets, values, l);
    }

    // Simple assignment: x = expr (creates immutable binding), obj.x = expr, arr[i] = expr
    if (this.match(TokenType.ASSIGN)) {
      if (expr.type === 'Identifier') {
        const value = this.parseExpression();
        return new AST.Assignment([expr.name], [value], l);
      }
      if (expr.type === 'MemberExpression') {
        const value = this.parseExpression();
        return new AST.Assignment([expr], [value], l);
      }
      // Destructuring without let: {name, age} = user  or  [a, b] = list
      if (expr.type === 'ObjectLiteral') {
        const pattern = new AST.ObjectPattern(
          expr.properties.map(p => ({ key: typeof p.key === 'string' ? p.key : p.key.name || p.key, value: typeof p.key === 'string' ? p.key : p.key.name || p.key })),
          expr.loc
        );
        const value = this.parseExpression();
        return new AST.LetDestructure(pattern, value, l);
      }
      if (expr.type === 'ArrayLiteral') {
        const pattern = new AST.ArrayPattern(
          expr.elements.map(e => e.type === 'Identifier' ? e.name : '_'),
          expr.loc
        );
        const value = this.parseExpression();
        return new AST.LetDestructure(pattern, value, l);
      }
      this.error("Invalid assignment target");
    }

    // Compound assignment: x += expr
    const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
    if (compoundOp) {
      if (expr.type !== 'Identifier' && expr.type !== 'MemberExpression') {
        this.error("Invalid compound assignment target");
      }
      const value = this.parseExpression();
      return new AST.CompoundAssignment(expr, compoundOp.value, value, l);
    }

    return new AST.ExpressionStatement(expr, l);
  }

  parseMatchAsStatement() {
    const expr = this.parseMatchExpression();
    return new AST.ExpressionStatement(expr, this.loc());
  }

  parseIfExpression() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF) ||
           (this.check(TokenType.ELSE) && this.peek(1).type === TokenType.IF)) {
      if (this.check(TokenType.ELIF)) {
        this.advance();
      } else {
        this.advance(); // else
        this.advance(); // if
      }
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    if (!this.check(TokenType.ELSE)) {
      this.error("if expression requires an else branch");
    }
    this.advance();
    const elseBody = this.parseBlock();

    return new AST.IfExpression(condition, consequent, alternates, elseBody, l);
  }

  // ─── Expressions (precedence climbing) ────────────────────

  parseExpression() {
    if (this._expressionDepth >= Parser.MAX_EXPRESSION_DEPTH) {
      this.error('Expression nested too deeply (max ' + Parser.MAX_EXPRESSION_DEPTH + ' levels)');
    }
    this._expressionDepth++;
    try {
      return this.parsePipe();
    } finally {
      this._expressionDepth--;
    }
  }

  parsePipe() {
    let left = this.parseNullCoalesce();
    while (this.match(TokenType.PIPE)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      // Method pipe: |> .method(args) — parse as MemberExpression with empty Identifier
      if (this.check(TokenType.DOT)) {
        this.advance(); // consume .
        const method = this.expect(TokenType.IDENTIFIER, "Expected method name after '.'").value;
        const placeholder = new AST.Identifier(AST.PIPE_TARGET, l);
        const memberExpr = new AST.MemberExpression(placeholder, method, false, l);
        if (this.check(TokenType.LPAREN)) {
          const call = this.parseCallExpression(memberExpr);
          left = new AST.PipeExpression(left, call, l);
        } else {
          left = new AST.PipeExpression(left, memberExpr, l);
        }
      } else {
        const right = this.parseNullCoalesce();
        left = new AST.PipeExpression(left, right, l);
      }
    }
    return left;
  }

  parseNullCoalesce() {
    let left = this.parseOr();
    while (this.match(TokenType.QUESTION_QUESTION)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const right = this.parseOr();
      left = new AST.BinaryExpression('??', left, right, l);
    }
    return left;
  }

  parseOr() {
    let left = this.parseAnd();
    while (this.match(TokenType.OR_OR) || this.match(TokenType.OR)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const right = this.parseAnd();
      left = new AST.LogicalExpression('or', left, right, l);
    }
    return left;
  }

  parseAnd() {
    let left = this.parseNot();
    while (this.match(TokenType.AND_AND) || this.match(TokenType.AND)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const right = this.parseNot();
      left = new AST.LogicalExpression('and', left, right, l);
    }
    return left;
  }

  parseNot() {
    if (this.match(TokenType.NOT) || this.match(TokenType.BANG)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const operand = this.parseNot();
      return new AST.UnaryExpression('not', operand, true, l);
    }
    return this.parseComparison();
  }

  parseComparison() {
    let left = this.parseMembership();

    // Check for chained comparisons: a < b < c
    if (Parser.COMPARISON_OPS.has(this.current().type)) {
      // Don't parse < as comparison if it looks like JSX
      if (this.check(TokenType.LESS) && this._looksLikeJSX()) {
        return left;
      }
      const l = this.loc(); // capture loc at the operator
      const operands = [left];
      const operators = [];

      while (Parser.COMPARISON_OPS.has(this.current().type)) {
        const op = this.advance();
        operators.push(op.value);
        operands.push(this.parseMembership());
      }

      if (operators.length === 1) {
        return new AST.BinaryExpression(operators[0], operands[0], operands[1], l);
      }
      return new AST.ChainedComparison(operands, operators, l);
    }

    return left;
  }

  parseMembership() {
    let left = this.parseRange();

    // "is" / "is not" — type checking: value is String, value is not Nil
    if (this.check(TokenType.IS)) {
      const l = this.loc();
      this.advance(); // is
      let negated = false;
      if (this.check(TokenType.NOT)) {
        this.advance(); // not
        negated = true;
      }
      const typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'is'").value;
      return new AST.IsExpression(left, typeName, negated, l);
    }

    // "in" / "not in"
    if (this.check(TokenType.NOT) && this.peek(1).type === TokenType.IN) {
      const l = this.loc();
      this.advance(); // not
      this.advance(); // in
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, true, l);
    }

    if (this.check(TokenType.IN)) {
      const l = this.loc();
      this.advance();
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, false, l);
    }

    return left;
  }

  parseRange() {
    let left = this.parseAddition();

    if (this.check(TokenType.DOT_DOT_EQUAL)) {
      const l = this.loc();
      this.advance();
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, true, l);
    }
    if (this.check(TokenType.DOT_DOT)) {
      const l = this.loc();
      this.advance();
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, false, l);
    }

    return left;
  }

  parseAddition() {
    let left = this.parseMultiplication();
    while (true) {
      const l = this.loc();
      const op = this.match(TokenType.PLUS, TokenType.MINUS);
      if (!op) break;
      const right = this.parseMultiplication();
      left = new AST.BinaryExpression(op.value, left, right, l);
    }
    return left;
  }

  parseMultiplication() {
    let left = this.parsePower();
    while (true) {
      const l = this.loc();
      const op = this.match(TokenType.STAR, TokenType.SLASH, TokenType.PERCENT);
      if (!op) break;
      const right = this.parsePower();
      left = new AST.BinaryExpression(op.value, left, right, l);
    }
    return left;
  }

  parsePower() {
    let base = this.parseUnary();
    if (this.check(TokenType.POWER)) {
      const l = this.loc();
      this.advance();
      const exp = this.parsePower(); // Right-associative
      return new AST.BinaryExpression('**', base, exp, l);
    }
    return base;
  }

  parseUnary() {
    if (this.check(TokenType.AWAIT)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.AwaitExpression(operand, l);
    }
    if (this.check(TokenType.YIELD)) {
      const l = this.loc();
      this.advance();
      // yield from expr
      let delegate = false;
      if (this.check(TokenType.FROM)) {
        this.advance();
        delegate = true;
      }
      const operand = this.parseUnary();
      return new AST.YieldExpression(operand, delegate, l);
    }
    // Negated column expression: -.column (for select exclusion)
    if (this.check(TokenType.MINUS) && this.peek(1).type === TokenType.DOT && this.peek(2).type === TokenType.IDENTIFIER) {
      const l = this.loc();
      this.advance(); // consume -
      this.advance(); // consume .
      const name = this.advance().value;
      return new AST.NegatedColumnExpression(name, l);
    }
    if (this.check(TokenType.MINUS)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.UnaryExpression('-', operand, true, l);
    }
    if (this.check(TokenType.SPREAD)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.SpreadExpression(operand, l);
    }
    return this.parsePostfix();
  }

  parsePostfix() {
    let expr = this.parsePrimary();

    while (true) {
      if (this.check(TokenType.DOT)) {
        const l = this.loc();
        this.advance();
        // Tuple index access: t.0, t.1, etc.
        if (this.check(TokenType.NUMBER) && Number.isInteger(this.current().value) && this.current().value >= 0) {
          const idx = this.advance().value;
          expr = new AST.MemberExpression(expr, new AST.NumberLiteral(idx, l), true, l);
          continue;
        }
        const prop = this.expect(TokenType.IDENTIFIER, "Expected property name after '.'").value;
        expr = new AST.MemberExpression(expr, prop, false, l);
        continue;
      }

      if (this.check(TokenType.QUESTION_DOT)) {
        const l = this.loc();
        this.advance();
        const prop = this.expect(TokenType.IDENTIFIER, "Expected property name after '?.'").value;
        expr = new AST.OptionalChain(expr, prop, false, l);
        continue;
      }

      if (this.check(TokenType.LBRACKET)) {
        // Don't treat [ as subscript if it's on a new line (avoids ambiguity with array patterns in match)
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine > prevLine) break;
        expr = this.parseSubscript(expr);
        continue;
      }

      if (this.check(TokenType.LPAREN)) {
        // Don't treat ( as call if it's on a new line (avoids ambiguity with grouped expressions)
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine > prevLine) break;
        expr = this.parseCallExpression(expr);
        continue;
      }

      if (this.check(TokenType.QUESTION)) {
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine === prevLine) {
          const l = this.loc();
          this.advance();
          expr = new AST.PropagateExpression(expr, l);
          continue;
        }
      }

      break;
    }

    return expr;
  }

  parseSubscript(object) {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    // Handle [::step] — DOUBLE_COLON is lexed as one token
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, null, step, l);
    }

    // Check for slice: obj[start:end:step]
    if (this.check(TokenType.COLON)) {
      // [:end] or [:end:step]
      this.advance();
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, end, step, l);
    }

    const start = this.parseExpression();

    // Handle [start::step] — DOUBLE_COLON after start expression
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, null, step, l);
    }

    if (this.match(TokenType.COLON)) {
      // [start:end] or [start:end:step]
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, end, step, l);
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.MemberExpression(object, start, true, l);
  }

  parseCallExpression(callee) {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const args = [];

    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      // Check for named argument: name: value
      if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
        const name = this.advance().value;
        this.advance(); // :
        const value = this.parseExpression();
        args.push(new AST.NamedArgument(name, this._maybeWrapItLambda(value), this.loc()));
      } else {
        args.push(this._maybeWrapItLambda(this.parseExpression()));
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RPAREN, "Expected ')' after arguments");
    return new AST.CallExpression(callee, args, l);
  }

  // ─── Primary expressions ──────────────────────────────────

  parsePrimary() {
    const l = this.loc();
    const tokenType = this.current().type;

    switch (tokenType) {
      case TokenType.NUMBER:
        return new AST.NumberLiteral(this.advance().value, l);

      case TokenType.STRING:
      case TokenType.STRING_TEMPLATE:
        return this.parseStringLiteral();

      case TokenType.REGEX: {
        const token = this.advance();
        return new AST.RegexLiteral(token.value.pattern, token.value.flags, l);
      }

      case TokenType.TRUE:
        this.advance();
        return new AST.BooleanLiteral(true, l);

      case TokenType.FALSE:
        this.advance();
        return new AST.BooleanLiteral(false, l);

      case TokenType.NIL:
        this.advance();
        return new AST.NilLiteral(l);

      case TokenType.MATCH:
        return this.parseMatchExpression();

      case TokenType.IF:
        return this.parseIfExpression();

      case TokenType.ASYNC:
        if (this.peek(1).type === TokenType.FN) {
          return this.parseAsyncLambda();
        }
        break;

      case TokenType.FN:
        if (this.peek(1).type === TokenType.LPAREN) {
          return this.parseLambda();
        }
        break;

      case TokenType.LBRACKET:
        return this.parseArrayOrComprehension();

      case TokenType.LBRACE:
        return this.parseObjectOrDictComprehension();

      case TokenType.DOT:
        // Column expression: .column (for table operations)
        if (this.peek(1).type === TokenType.IDENTIFIER) {
          this.advance(); // consume .
          const name = this.advance().value; // consume identifier
          // Check for column assignment: .col = expr (used in derive)
          if (this.check(TokenType.ASSIGN)) {
            this.advance(); // consume =
            const expr = this.parseExpression();
            return new AST.ColumnAssignment(name, expr, l);
          }
          return new AST.ColumnExpression(name, l);
        }
        break;

      case TokenType.LPAREN:
        return this.parseParenOrArrowLambda();

      case TokenType.SERVER:
      case TokenType.CLIENT:
      case TokenType.SHARED:
      case TokenType.DERIVE:
        return new AST.Identifier(this.advance().value, l);

      case TokenType.IDENTIFIER: {
        const name = this.advance().value;
        // Check for arrow lambda: x => expr or x -> expr
        if (this.check(TokenType.ARROW) || this.check(TokenType.THIN_ARROW)) {
          this.advance();
          const body = this.parseExpression();
          return new AST.LambdaExpression(
            [new AST.Parameter(name, null, null, l)],
            body,
            l
          );
        }
        return new AST.Identifier(name, l);
      }
    }

    // Contextual keywords that can appear as identifiers in expression position
    if (this._isContextualKeyword()) {
      return new AST.Identifier(this.advance().value, l);
    }

    this.error(`Unexpected token: ${this.current().type}`);
  }

  parseStringLiteral() {
    const l = this.loc();
    const tok = this.advance();

    if (tok.type === TokenType.STRING) {
      return new AST.StringLiteral(tok.value, l);
    }

    // String template with interpolation
    const parts = tok.value.map(part => {
      if (part.type === 'text') {
        return { type: 'text', value: part.value };
      }
      // Re-parse the expression tokens
      const subParser = new Parser(
        [...part.tokens, { type: TokenType.EOF, value: null, line: 0, column: 0 }],
        this.filename
      );
      const expr = subParser.parseExpression();
      return { type: 'expr', value: expr };
    });

    return new AST.TemplateLiteral(parts, l);
  }

  parseLambda() {
    const l = this.loc();
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      // Parse expression, then check for compound/simple assignment
      const expr = this.parseExpression();
      const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
      if (compoundOp) {
        const value = this.parseExpression();
        body = new AST.CompoundAssignment(expr, compoundOp.value, value, l);
      } else if (this.match(TokenType.ASSIGN)) {
        if (expr.type === 'Identifier') {
          const value = this.parseExpression();
          body = new AST.Assignment([expr.name], [value], l);
        } else {
          body = expr;
        }
      } else {
        body = expr;
      }
    }

    return new AST.LambdaExpression(params, body, l);
  }

  parseAsyncLambda() {
    const l = this.loc();
    this.expect(TokenType.ASYNC);
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.LambdaExpression(params, body, l, true);
  }

  parseMatchExpression() {
    const l = this.loc();
    this.expect(TokenType.MATCH);
    const subject = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' to open match body");

    const arms = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      arms.push(this.parseMatchArm());
      this.match(TokenType.COMMA); // Optional comma between arms
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close match body");
    return new AST.MatchExpression(subject, arms, l);
  }

  parseMatchArm() {
    const l = this.loc();
    const pattern = this.parsePattern();

    let guard = null;
    if (this.match(TokenType.IF)) {
      guard = this.parseExpression();
    }

    this.expect(TokenType.ARROW, "Expected '=>' in match arm");

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.MatchArm(pattern, guard, body, l);
  }

  parsePattern() {
    const l = this.loc();

    // Wildcard _
    if (this.checkValue(TokenType.IDENTIFIER, '_')) {
      this.advance();
      return new AST.WildcardPattern(l);
    }

    // Negative number literal pattern: -1, -3.14
    if (this.check(TokenType.MINUS) && this.peek(1).type === TokenType.NUMBER) {
      this.advance(); // consume -
      const val = -this.advance().value;
      // Check for range pattern: -5..0
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const endNeg = this.match(TokenType.MINUS);
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, endNeg ? -end : end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const endNeg = this.match(TokenType.MINUS);
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, endNeg ? -end : end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // Number literal pattern
    if (this.check(TokenType.NUMBER)) {
      const val = this.advance().value;
      // Check for range pattern: 1..10
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // String literal pattern, possibly with ++ concat pattern
    if (this.check(TokenType.STRING)) {
      const strVal = this.advance().value;
      // Check for string concat pattern: "prefix" ++ rest
      // Verify the two + tokens are adjacent (no space between them) to distinguish from arithmetic
      if (this.check(TokenType.PLUS) && this.peek(1).type === TokenType.PLUS &&
          this.current().column + 1 === this.peek(1).column && this.current().line === this.peek(1).line) {
        this.advance(); // first +
        this.advance(); // second +
        const rest = this.parsePattern();
        return new AST.StringConcatPattern(strVal, rest, l);
      }
      return new AST.LiteralPattern(strVal, l);
    }

    // Boolean literal pattern
    if (this.check(TokenType.TRUE)) {
      this.advance();
      return new AST.LiteralPattern(true, l);
    }
    if (this.check(TokenType.FALSE)) {
      this.advance();
      return new AST.LiteralPattern(false, l);
    }

    // Nil pattern
    if (this.check(TokenType.NIL)) {
      this.advance();
      return new AST.LiteralPattern(null, l);
    }

    // Array pattern: [a, b, c] or [0, _]
    if (this.check(TokenType.LBRACKET)) {
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.parsePattern());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET);
      return new AST.ArrayPattern(elements, l);
    }

    // Tuple pattern: (a, b)
    if (this.check(TokenType.LPAREN)) {
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        elements.push(this.parsePattern());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RPAREN, "Expected ')' in tuple pattern");
      return new AST.TuplePattern(elements, l);
    }

    // Identifier: could be variant pattern or binding pattern
    if (this.check(TokenType.IDENTIFIER)) {
      const name = this.advance().value;

      // Variant pattern: Circle(r), Some(Ok(value))
      if (this.match(TokenType.LPAREN)) {
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          fields.push(this.parsePattern());
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN);
        return new AST.VariantPattern(name, fields, l);
      }

      // Binding pattern (lowercase = binding, uppercase = variant without args)
      if (name[0] === name[0].toUpperCase() && name[0] !== '_') {
        return new AST.VariantPattern(name, [], l);
      }
      return new AST.BindingPattern(name, l);
    }

    this.error("Expected pattern");
  }

  parseArrayOrComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    if (this.check(TokenType.RBRACKET)) {
      this.advance();
      return new AST.ArrayLiteral([], l);
    }

    // Parse first expression
    const first = this.parseExpression();

    // Check if this is a list comprehension: [expr for x in items]
    if (this.check(TokenType.FOR)) {
      this.advance();
      const variable = this.expect(TokenType.IDENTIFIER, "Expected variable in comprehension").value;
      this.expect(TokenType.IN, "Expected 'in' in comprehension");
      const iterable = this.parseExpression();

      let condition = null;
      if (this.match(TokenType.IF)) {
        condition = this.parseExpression();
      }

      this.expect(TokenType.RBRACKET, "Expected ']' to close comprehension");
      return new AST.ListComprehension(first, variable, iterable, condition, l);
    }

    // Regular array literal
    const elements = [first];
    while (this.match(TokenType.COMMA)) {
      if (this.check(TokenType.RBRACKET)) break; // trailing comma
      elements.push(this.parseExpression());
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.ArrayLiteral(elements, l);
  }

  _parseObjectProperty() {
    // Spread property: ...expr
    if (this.check(TokenType.SPREAD)) {
      const sl = this.loc();
      this.advance();
      const argument = this.parseUnary();
      return { spread: true, argument };
    }
    const key = this.parseExpression();
    if (this.match(TokenType.COLON)) {
      const value = this.parseExpression();
      return { key, value, shorthand: false };
    }
    if (key.type === 'Identifier') {
      return { key, value: key, shorthand: true };
    }
    this.error("Expected ':' in object literal");
  }

  parseObjectOrDictComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);

    if (this.check(TokenType.RBRACE)) {
      this.advance();
      return new AST.ObjectLiteral([], l);
    }

    // Check for spread as first element — always an object literal
    if (this.check(TokenType.SPREAD)) {
      const properties = [this._parseObjectProperty()];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        properties.push(this._parseObjectProperty());
      }
      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    // Try to parse first key: value pair
    const firstKey = this.parseExpression();

    if (this.match(TokenType.COLON)) {
      const firstValue = this.parseExpression();

      // Dict comprehension: {k: v for k, v in pairs}
      if (this.check(TokenType.FOR)) {
        this.advance();
        const vars = [];
        vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        if (this.match(TokenType.COMMA)) {
          vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        }
        this.expect(TokenType.IN, "Expected 'in' in comprehension");
        const iterable = this.parseExpression();
        let condition = null;
        if (this.match(TokenType.IF)) {
          condition = this.parseExpression();
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close dict comprehension");
        return new AST.DictComprehension(firstKey, firstValue, vars, iterable, condition, l);
      }

      // Regular object literal
      const properties = [{ key: firstKey, value: firstValue, shorthand: false }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        properties.push(this._parseObjectProperty());
      }

      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    // Shorthand object: { x, y } or mixed { x, y: 10 }
    if (firstKey.type === 'Identifier') {
      const properties = [{ key: firstKey, value: firstKey, shorthand: true }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        properties.push(this._parseObjectProperty());
      }
      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    this.error("Invalid object literal");
  }

  parseParenOrArrowLambda() {
    const l = this.loc();

    // Save position to backtrack if needed
    const savedPos = this.pos;

    this.expect(TokenType.LPAREN);

    // Empty parens: () => expr or () -> expr
    if (this.check(TokenType.RPAREN)) {
      this.advance();
      if (this.check(TokenType.ARROW) || this.check(TokenType.THIN_ARROW)) {
        this.advance();
        const body = this.parseExpression();
        return new AST.LambdaExpression([], body, l);
      }
      // Empty parens but not arrow — error or unit value
      this.error("Unexpected '()'");
    }

    // Try to parse as arrow lambda params
    // Look ahead: if we see ) => then it's a lambda
    const params = [];
    let isLambda = true;

    const savedErrors = this.errors.length;
    try {
      const innerSaved = this.pos;
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        if (!this.check(TokenType.IDENTIFIER)) {
          isLambda = false;
          break;
        }
        const pname = this.advance().value;
        let ptype = null;
        let pdefault = null;
        if (this.match(TokenType.COLON)) {
          // Could be a type annotation or named argument
          if (this.check(TokenType.IDENTIFIER)) {
            ptype = this.parseTypeAnnotation();
          } else {
            isLambda = false;
            break;
          }
        }
        if (this.match(TokenType.ASSIGN)) {
          pdefault = this.parseExpression();
        }
        params.push(new AST.Parameter(pname, ptype, pdefault, l));
        if (!this.match(TokenType.COMMA)) break;
      }

      if (isLambda && this.check(TokenType.RPAREN)) {
        this.advance(); // )
        if (this.check(TokenType.ARROW) || this.check(TokenType.THIN_ARROW)) {
          this.advance(); // =>
          const body = this.check(TokenType.LBRACE) ? this.parseBlock() : this.parseExpression();
          return new AST.LambdaExpression(params, body, l);
        }
        // Helpful hint: user may have typed = instead of -> or =>
        if (this.check(TokenType.ASSIGN) || this.check(TokenType.EQUAL)) {
          this.error("Use '->' or '=>' for arrow functions: (x, y) -> expr");
        }
      }
    } catch (e) {
      // Speculative parse failure — expected during backtracking, not a real error
    }

    // Backtrack and parse as parenthesized expression or tuple
    // Also restore errors to discard any ghost errors from speculative parsing
    this.errors.length = savedErrors;
    this.pos = savedPos;
    this.expect(TokenType.LPAREN);
    const expr = this.parseExpression();

    // Tuple: (a, b, c) — requires at least one comma
    if (this.check(TokenType.COMMA)) {
      const elements = [expr];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RPAREN)) break; // trailing comma
        elements.push(this.parseExpression());
      }
      this.expect(TokenType.RPAREN, "Expected ')'");
      return new AST.TupleExpression(elements, l);
    }

    this.expect(TokenType.RPAREN, "Expected ')'");
    return expr;
  }

  // ─── Implicit `it` parameter support ─────────────────────

  _containsFreeIt(node) {
    if (!node) return false;
    if (node.type === 'Identifier' && node.name === 'it') return true;
    if (node.type === 'LambdaExpression' || node.type === 'FunctionDeclaration') return false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsFreeIt(item)) return true;
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsFreeIt(val)) return true;
      }
    }
    return false;
  }

  _maybeWrapItLambda(node) {
    if (node.type === 'Identifier' && node.name === 'it') return node;
    if (node.type === 'LambdaExpression') return node;
    if (node.type === 'FunctionDeclaration') return node;
    if (this._containsFreeIt(node)) {
      const loc = node.loc || this.loc();
      return new AST.LambdaExpression(
        [new AST.Parameter('it', null, null, loc)],
        node, loc
      );
    }
    return node;
  }
}

// Initialize static Set after class definition (depends on TokenType)
Parser.COMPARISON_OPS = new Set([
  TokenType.LESS, TokenType.LESS_EQUAL,
  TokenType.GREATER, TokenType.GREATER_EQUAL,
  TokenType.EQUAL, TokenType.NOT_EQUAL
]);

// ─── src/analyzer/scope.js ─────────────────────────────

// Scope and symbol management for the Tova analyzer
class Symbol {
  constructor(name, kind, type, mutable, loc) {
    this.name = name;
    this.kind = kind;       // 'variable', 'function', 'type', 'parameter', 'state', 'computed', 'component'
    this.type = type;       // Type object or raw type annotation (optional)
    this.mutable = mutable; // true for 'var' declarations
    this.loc = loc;
    this.used = false;
    this.declaredType = null; // raw annotation for display purposes
  }
}
class Scope {
  constructor(parent = null, context = 'module') {
    this.parent = parent;
    this.context = context; // 'module', 'server', 'client', 'shared', 'function', 'block'
    this.symbols = new Map();
    this.children = [];
    this.startLoc = null; // { line, column } for positional scope lookup
    this.endLoc = null;
    this._indexed = false;
  }

  define(name, symbol) {
    if (this.symbols.has(name)) {
      const existing = this.symbols.get(name);
      // Allow user code to shadow builtins
      if (existing.kind === 'builtin') {
        this.symbols.set(name, symbol);
        return;
      }
      throw new Error(
        `${symbol.loc.file}:${symbol.loc.line}:${symbol.loc.column} — '${name}' is already defined in this scope`
      );
    }
    this.symbols.set(name, symbol);
  }

  lookup(name) {
    if (this.symbols.has(name)) {
      return this.symbols.get(name);
    }
    if (this.parent) {
      return this.parent.lookup(name);
    }
    return null;
  }

  lookupLocal(name) {
    return this.symbols.get(name) || null;
  }

  getContext() {
    if (this.context === 'server' || this.context === 'client' || this.context === 'shared') {
      return this.context;
    }
    if (this.parent) {
      return this.parent.getContext();
    }
    return 'module';
  }

  child(context) {
    const c = new Scope(this, context || this.context);
    this.children.push(c);
    return c;
  }

  /**
   * Build a sorted index of children for fast binary-search lookup.
   * Call once after analysis is complete.
   */
  buildIndex() {
    // Sort children with position info by start line, then column
    if (this.children.length > 1) {
      this.children.sort((a, b) => {
        if (!a.startLoc) return 1;
        if (!b.startLoc) return -1;
        if (a.startLoc.line !== b.startLoc.line) return a.startLoc.line - b.startLoc.line;
        return a.startLoc.column - b.startLoc.column;
      });
    }
    this._indexed = true;
    for (const child of this.children) {
      child.buildIndex();
    }
  }

  /**
   * Find the narrowest scope containing a given position.
   * Uses binary search if buildIndex() has been called.
   */
  findScopeAtPosition(line, column) {
    if (this._indexed && this.children.length > 4) {
      return this._findScopeIndexed(line, column);
    }
    // Linear fallback for small lists or un-indexed scopes
    for (const child of this.children) {
      if (child.startLoc && child.endLoc) {
        if ((line > child.startLoc.line || (line === child.startLoc.line && column >= child.startLoc.column)) &&
            (line < child.endLoc.line || (line === child.endLoc.line && column <= child.endLoc.column))) {
          const nested = child.findScopeAtPosition(line, column);
          return nested || child;
        }
      } else {
        const nested = child.findScopeAtPosition(line, column);
        if (nested) return nested;
      }
    }
    if (this.startLoc && this.endLoc) {
      if ((line > this.startLoc.line || (line === this.startLoc.line && column >= this.startLoc.column)) &&
          (line < this.endLoc.line || (line === this.endLoc.line && column <= this.endLoc.column))) {
        return this;
      }
    }
    return null;
  }

  _findScopeIndexed(line, column) {
    // Binary search for the last child whose start is <= target position
    const children = this.children;
    let lo = 0, hi = children.length - 1;
    let candidate = -1;

    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const c = children[mid];
      if (!c.startLoc) { lo = mid + 1; continue; }
      if (c.startLoc.line < line || (c.startLoc.line === line && c.startLoc.column <= column)) {
        candidate = mid;
        lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }

    // Check candidate and neighbors (scopes can nest, so check a small window)
    if (candidate >= 0) {
      // Check candidate and up to 2 before it (overlapping scopes)
      const start = Math.max(0, candidate - 2);
      const end = Math.min(children.length - 1, candidate + 1);
      for (let i = start; i <= end; i++) {
        const child = children[i];
        if (child.startLoc && child.endLoc) {
          if ((line > child.startLoc.line || (line === child.startLoc.line && column >= child.startLoc.column)) &&
              (line < child.endLoc.line || (line === child.endLoc.line && column <= child.endLoc.column))) {
            const nested = child.findScopeAtPosition(line, column);
            return nested || child;
          }
        }
      }
    }

    // Fallback: check children without position info
    for (const child of children) {
      if (!child.startLoc) {
        const nested = child.findScopeAtPosition(line, column);
        if (nested) return nested;
      }
    }

    if (this.startLoc && this.endLoc) {
      if ((line > this.startLoc.line || (line === this.startLoc.line && column >= this.startLoc.column)) &&
          (line < this.endLoc.line || (line === this.endLoc.line && column <= this.endLoc.column))) {
        return this;
      }
    }
    return null;
  }
}

// ─── src/analyzer/types.js ─────────────────────────────

// Type system for the Tova analyzer
// Replaces string-based type representations with a proper class hierarchy
class Type {
  equals(other) { return false; }
  isAssignableTo(target) { return false; }
  toString() { return 'unknown'; }
  getFieldType(name) { return null; }
}

// ─── Primitive Types ──────────────────────────────────────
class PrimitiveType extends Type {
  constructor(name) {
    super();
    this.name = name;
  }

  equals(other) {
    return other instanceof PrimitiveType && this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof PrimitiveType) {
      if (this.name === target.name) return true;
      // Int -> Float widening is always allowed (safe)
      if (this.name === 'Int' && target.name === 'Float') return true;
      // Float -> Int narrowing: NOT implicitly allowed at type level.
      // The analyzer emits warning/error with conversion hint.
    }
    return false;
  }

  toString() { return this.name; }
}

// ─── Nil Type ──────────────────────────────────────────────
class NilType extends Type {
  equals(other) { return other instanceof NilType; }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof NilType) return true;
    // Nil is compatible with Option types
    if (target instanceof GenericType && target.base === 'Option') return true;
    if (target instanceof PrimitiveType && target.name === 'Option') return true;
    return false;
  }

  toString() { return 'Nil'; }
}

// ─── Any Type ──────────────────────────────────────────────
class AnyType extends Type {
  equals(other) { return other instanceof AnyType; }
  isAssignableTo(_target) { return true; }
  toString() { return 'Any'; }
}

// ─── Unknown Type (gradual typing — compatible with everything) ────
class UnknownType extends Type {
  equals(other) { return other instanceof UnknownType; }
  isAssignableTo(target) {
    // In strict mode, unknown types are NOT assignable to concrete types
    if (Type.strictMode) {
      if (!target) return true;
      if (target instanceof AnyType || target instanceof UnknownType) return true;
      return false;
    }
    return true;
  }
  toString() { return 'unknown'; }
}

// ─── Array Type ────────────────────────────────────────────
class ArrayType extends Type {
  constructor(elementType) {
    super();
    this.elementType = elementType || Type.ANY;
  }

  equals(other) {
    return other instanceof ArrayType && this.elementType.equals(other.elementType);
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof ArrayType) {
      return this.elementType.isAssignableTo(target.elementType);
    }
    return false;
  }

  toString() { return `[${this.elementType.toString()}]`; }
}

// ─── Tuple Type ────────────────────────────────────────────
class TupleType extends Type {
  constructor(elementTypes) {
    super();
    this.elementTypes = elementTypes || [];
  }

  equals(other) {
    if (!(other instanceof TupleType)) return false;
    if (this.elementTypes.length !== other.elementTypes.length) return false;
    return this.elementTypes.every((t, i) => t.equals(other.elementTypes[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof TupleType) {
      if (this.elementTypes.length !== target.elementTypes.length) return false;
      return this.elementTypes.every((t, i) => t.isAssignableTo(target.elementTypes[i]));
    }
    return false;
  }

  toString() {
    return `(${this.elementTypes.map(t => t.toString()).join(', ')})`;
  }
}

// ─── Function Type ─────────────────────────────────────────
class FunctionType extends Type {
  constructor(paramTypes, returnType) {
    super();
    this.paramTypes = paramTypes || [];
    this.returnType = returnType || Type.ANY;
  }

  equals(other) {
    if (!(other instanceof FunctionType)) return false;
    if (this.paramTypes.length !== other.paramTypes.length) return false;
    if (!this.returnType.equals(other.returnType)) return false;
    return this.paramTypes.every((t, i) => t.equals(other.paramTypes[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof FunctionType) return this.equals(target);
    return false;
  }

  toString() { return 'Function'; }
}

// ─── Record Type ───────────────────────────────────────────
class RecordType extends Type {
  constructor(name, fields) {
    super();
    this.name = name;
    this.fields = fields || new Map(); // name -> Type
  }

  equals(other) {
    if (!(other instanceof RecordType)) return false;
    return this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof RecordType) return this.name === target.name;
    if (target instanceof PrimitiveType && target.name === this.name) return true;
    if (target instanceof GenericType && target.base === this.name) return true;
    return false;
  }

  getFieldType(name) {
    return this.fields.get(name) || null;
  }

  toString() { return this.name; }
}

// ─── ADT Type ──────────────────────────────────────────────
class ADTType extends Type {
  constructor(name, typeParams, variants) {
    super();
    this.name = name;
    this.typeParams = typeParams || [];
    this.variants = variants || new Map(); // variantName -> Map<fieldName, Type>
  }

  equals(other) {
    if (!(other instanceof ADTType)) return false;
    return this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof ADTType) return this.name === target.name;
    if (target instanceof PrimitiveType && target.name === this.name) return true;
    if (target instanceof GenericType && target.base === this.name) return true;
    return false;
  }

  getFieldType(name) {
    // Look through all variants for the field
    for (const [, fields] of this.variants) {
      if (fields.has(name)) return fields.get(name);
    }
    return null;
  }

  getVariantNames() {
    return [...this.variants.keys()];
  }

  toString() {
    if (this.typeParams.length > 0) {
      return `${this.name}<${this.typeParams.join(', ')}>`;
    }
    return this.name;
  }
}

// ─── Generic Type ──────────────────────────────────────────
class GenericType extends Type {
  constructor(base, typeArgs) {
    super();
    this.base = base;
    this.typeArgs = typeArgs || [];
  }

  equals(other) {
    if (!(other instanceof GenericType)) return false;
    if (this.base !== other.base) return false;
    if (this.typeArgs.length !== other.typeArgs.length) return false;
    return this.typeArgs.every((t, i) => t.equals(other.typeArgs[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof GenericType) {
      if (this.base !== target.base) return false;
      // If one side has no type args (bare `Result`), compatible (gradual typing)
      if (this.typeArgs.length === 0 || target.typeArgs.length === 0) return true;
      if (this.typeArgs.length !== target.typeArgs.length) return false;
      return this.typeArgs.every((t, i) => t.isAssignableTo(target.typeArgs[i]));
    }
    // Compatible with a PrimitiveType of same base name (e.g. Result<Int, String> assignable to Result)
    if (target instanceof PrimitiveType && target.name === this.base) return true;
    // Compatible with ADTType of same name
    if (target instanceof ADTType && target.name === this.base) return true;
    return false;
  }

  getFieldType(name) {
    // Delegate to the base type if we had structural info — handled via TypeRegistry
    return null;
  }

  toString() {
    if (this.typeArgs.length === 0) return this.base;
    return `${this.base}<${this.typeArgs.map(t => t.toString()).join(', ')}>`;
  }
}

// ─── Type Variable ─────────────────────────────────────────
class TypeVariable extends Type {
  constructor(name) {
    super();
    this.name = name;
  }

  equals(other) {
    return other instanceof TypeVariable && this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof TypeVariable) return this.name === target.name;
    // Type variables are compatible with anything (they're placeholders)
    return true;
  }

  toString() { return this.name; }
}

// ─── Union Type ────────────────────────────────────────────
class UnionType extends Type {
  constructor(members) {
    super();
    this.members = members || [];
  }

  equals(other) {
    if (!(other instanceof UnionType)) return false;
    if (this.members.length !== other.members.length) return false;
    return this.members.every((m, i) => m.equals(other.members[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof UnionType) {
      // Every member of this must be assignable to some member of target
      return this.members.every(m =>
        target.members.some(t => m.isAssignableTo(t))
      );
    }
    // A union is assignable to T if every member is assignable to T
    return this.members.every(m => m.isAssignableTo(target));
  }

  toString() {
    return this.members.map(m => m.toString()).join(' | ');
  }
}

// ─── Strict Mode Flag ────────────────────────────────────

Type.strictMode = false; // Set to true by analyzer in --strict mode

// ─── Singleton Caching ────────────────────────────────────

Type.INT = new PrimitiveType('Int');
Type.FLOAT = new PrimitiveType('Float');
Type.STRING = new PrimitiveType('String');
Type.BOOL = new PrimitiveType('Bool');
Type.NIL = new NilType();
Type.ANY = new AnyType();
Type.UNKNOWN = new UnknownType();
Type.FUNCTION = new FunctionType([], Type.ANY);

const PRIMITIVE_CACHE = new Map([
  ['Int', Type.INT],
  ['Float', Type.FLOAT],
  ['String', Type.STRING],
  ['Bool', Type.BOOL],
  ['Nil', Type.NIL],
  ['Any', Type.ANY],
]);

// ─── Helper Functions ──────────────────────────────────────

/**
 * Convert a parser TypeAnnotation AST node to a Type object.
 */
function typeAnnotationToType(ann) {
  if (!ann) return null;
  if (typeof ann === 'string') return typeFromString(ann);

  switch (ann.type) {
    case 'TypeAnnotation': {
      if (ann.typeParams && ann.typeParams.length > 0) {
        const args = ann.typeParams.map(p => typeAnnotationToType(p) || Type.UNKNOWN);
        return new GenericType(ann.name, args);
      }
      return typeFromString(ann.name);
    }
    case 'ArrayTypeAnnotation': {
      const elType = typeAnnotationToType(ann.elementType) || Type.ANY;
      return new ArrayType(elType);
    }
    case 'TupleTypeAnnotation': {
      const elTypes = ann.elementTypes.map(t => typeAnnotationToType(t) || Type.ANY);
      return new TupleType(elTypes);
    }
    case 'FunctionTypeAnnotation':
      return Type.FUNCTION;
    case 'UnionTypeAnnotation': {
      const members = ann.members.map(m => typeAnnotationToType(m) || Type.UNKNOWN);
      return new UnionType(members);
    }
    default:
      return null;
  }
}

/**
 * Convert a type string to a Type object.
 * Bridge for migrating existing string-based code.
 */
function typeFromString(s) {
  if (!s) return null;

  // Check primitive cache
  if (PRIMITIVE_CACHE.has(s)) return PRIMITIVE_CACHE.get(s);

  // Wildcard / underscore
  if (s === '_') return Type.UNKNOWN;

  // Array type: [ElementType]
  if (s.startsWith('[') && s.endsWith(']')) {
    const inner = s.slice(1, -1);
    return new ArrayType(typeFromString(inner) || Type.ANY);
  }

  // Tuple type: (Type1, Type2)
  if (s.startsWith('(') && s.endsWith(')')) {
    const inner = s.slice(1, -1);
    const parts = splitTopLevel(inner, ',');
    return new TupleType(parts.map(p => typeFromString(p.trim()) || Type.ANY));
  }

  // Generic type: Result<Int, String>
  const ltIdx = s.indexOf('<');
  if (ltIdx !== -1) {
    const base = s.slice(0, ltIdx);
    const inner = s.slice(ltIdx + 1, s.lastIndexOf('>'));
    const params = splitTopLevel(inner, ',');
    const args = params.map(p => typeFromString(p.trim()) || Type.UNKNOWN);
    return new GenericType(base, args);
  }

  // Named type (user-defined) — treated as a primitive-like name
  return new PrimitiveType(s);
}

/**
 * Split a string on a delimiter at the top level (respecting nested <> and ()).
 */
function splitTopLevel(str, delimiter) {
  const parts = [];
  let depth = 0;
  let parenDepth = 0;
  let start = 0;
  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (ch === '<') depth++;
    else if (ch === '>') depth--;
    else if (ch === '(') parenDepth++;
    else if (ch === ')') parenDepth--;
    else if (ch === delimiter && depth === 0 && parenDepth === 0) {
      parts.push(str.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(str.slice(start));
  return parts;
}

/**
 * Null-safe type compatibility check.
 * Returns true if source is assignable to target, or if either is null/unknown.
 */
function typesCompatible(target, source) {
  if (!target || !source) return true;
  if (target instanceof Type && source instanceof Type) {
    return source.isAssignableTo(target);
  }
  // Fallback for string comparison during migration
  if (typeof target === 'string' || typeof source === 'string') {
    const t = typeof target === 'string' ? typeFromString(target) : target;
    const s = typeof source === 'string' ? typeFromString(source) : source;
    if (!t || !s) return true;
    return s.isAssignableTo(t);
  }
  return true;
}

/**
 * Check if a type is numeric (Int or Float)
 */
function isNumericType(type) {
  if (!type) return false;
  if (type instanceof PrimitiveType) {
    return type.name === 'Int' || type.name === 'Float';
  }
  return false;
}

/**
 * Check strict Float -> Int narrowing.
 * Returns true if this is a Float-to-Int assignment (potential data loss).
 */
function isFloatNarrowing(source, target) {
  if (!source || !target) return false;
  return (source instanceof PrimitiveType && source.name === 'Float' &&
          target instanceof PrimitiveType && target.name === 'Int');
}

// ─── src/analyzer/server-analyzer.js ───────────────────

// Server-specific analyzer methods for the Tova language
// Extracted from analyzer.js for lazy loading — only loaded when server { } blocks are encountered.
function collectServerBlockFunctions(ast) {
  const serverBlockFunctions = new Map();
  const collectFns = (stmts) => {
    const fns = [];
    for (const stmt of stmts) {
      if (stmt.type === 'FunctionDeclaration') {
        fns.push(stmt.name);
      } else if (stmt.type === 'RouteGroupDeclaration') {
        fns.push(...collectFns(stmt.body));
      }
    }
    return fns;
  };
  for (const node of ast.body) {
    if (node.type === 'ServerBlock' && node.name) {
      const fns = collectFns(node.body);
      if (serverBlockFunctions.has(node.name)) {
        serverBlockFunctions.get(node.name).push(...fns);
      } else {
        serverBlockFunctions.set(node.name, fns);
      }
    }
  }
  return serverBlockFunctions;
}
function installServerAnalyzer(AnalyzerClass) {
  if (AnalyzerClass.prototype._serverAnalyzerInstalled) return;
  AnalyzerClass.prototype._serverAnalyzerInstalled = true;

  AnalyzerClass.prototype.visitServerBlock = function(node) {
    const prevScope = this.currentScope;
    const prevServerBlockName = this._currentServerBlockName;
    this._currentServerBlockName = node.name || null;
    this.currentScope = this.currentScope.child('server');

    try {
      // Register peer server block names as valid identifiers in this scope
      if (node.name && this.serverBlockFunctions.size > 0) {
        for (const [peerName] of this.serverBlockFunctions) {
          if (peerName !== node.name) {
            try {
              this.currentScope.define(peerName,
                new Symbol(peerName, 'builtin', null, false, { line: 0, column: 0, file: '<peer-server>' }));
            } catch (e) {
              // Ignore if already defined
            }
          }
        }
      }

      // Register AI provider names as variables (named: claude, gpt, etc.; default: ai)
      for (const stmt of node.body) {
        if (stmt.type === 'AiConfigDeclaration') {
          const aiName = stmt.name || 'ai';
          try {
            this.currentScope.define(aiName,
              new Symbol(aiName, 'builtin', null, false, stmt.loc));
          } catch (e) {
            // Ignore if already defined
          }
        }
      }

      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
      this._currentServerBlockName = prevServerBlockName;
    }
  };

  AnalyzerClass.prototype.visitRouteDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'route' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    this.visitExpression(node.handler);

    // Validate body type annotation is only used with POST/PUT/PATCH
    if (node.bodyType && !['POST', 'PUT', 'PATCH'].includes(node.method.toUpperCase())) {
      this.warn(`body type annotation on ${node.method} route is ignored — only POST, PUT, and PATCH routes parse request bodies`, node.loc);
    }

    // Route param ↔ handler signature type safety
    if (node.handler.type === 'Identifier') {
      const handlerName = node.handler.name;
      // Find the function declaration in the current server block scope
      const fnSym = this.currentScope.lookup(handlerName);
      if (fnSym && fnSym.kind === 'function' && fnSym._params) {
        const pathParams = new Set();
        const pathStr = node.path || '';
        const paramMatches = pathStr.match(/:([a-zA-Z_][a-zA-Z0-9_]*)/g);
        if (paramMatches) {
          for (const m of paramMatches) pathParams.add(m.slice(1));
        }
        const handlerParams = fnSym._params.filter(p => p !== 'req');
        for (const hp of handlerParams) {
          if (pathParams.size > 0 && !pathParams.has(hp) && node.method.toUpperCase() === 'GET') {
            // For GET routes, params not in path come from query — this is fine, just a warning
            this.warn(`Handler '${handlerName}' param '${hp}' not in route path '${pathStr}' — will be extracted from query string`, node.loc);
          }
        }
      }
    }
  };

  AnalyzerClass.prototype.visitMiddlewareDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'middleware' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitHealthCheckDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'health' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
  };

  AnalyzerClass.prototype.visitCorsDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'cors' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitErrorHandlerDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'on_error' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitWebSocketDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'ws' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const [, handler] of Object.entries(node.handlers)) {
      if (!handler) continue;
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('function');
      for (const param of handler.params) {
        try {
          this.currentScope.define(param.name,
            new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
      try {
        this.visitNode(handler.body);
      } finally {
        this.currentScope = prevScope;
      }
    }
  };

  AnalyzerClass.prototype.visitStaticDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'static' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
  };

  AnalyzerClass.prototype.visitDiscoverDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'discover' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    this.visitExpression(node.urlExpression);
  };

  AnalyzerClass.prototype.visitAuthDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'auth' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitMaxBodyDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'max_body' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    this.visitExpression(node.limit);
  };

  AnalyzerClass.prototype.visitRouteGroupDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'routes' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
  };

  AnalyzerClass.prototype.visitRateLimitDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'rate_limit' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitLifecycleHookDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'on_${node.hook}' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitSubscribeDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'subscribe' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitEnvDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'env' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'variable', node.typeAnnotation, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    if (node.defaultValue) {
      this.visitExpression(node.defaultValue);
    }
  };

  AnalyzerClass.prototype.visitScheduleDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'schedule' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    if (node.name) {
      try {
        this.currentScope.define(node.name,
          new Symbol(node.name, 'function', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitUploadDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'upload' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitSessionDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'session' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitDbDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'db' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitTlsDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'tls' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitCompressionDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'compression' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitBackgroundJobDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'background' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitCacheDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'cache' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitSseDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'sse' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    for (const p of node.params) {
      this.currentScope.define(p.name, { kind: 'param' });
    }
    try {
      for (const stmt of node.body.body || []) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitModelDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'model' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    if (node.config) {
      for (const value of Object.values(node.config)) {
        this.visitExpression(value);
      }
    }
  };
}

// ─── src/analyzer/client-analyzer.js ───────────────────

// Client-specific analyzer methods for the Tova language
// Extracted from analyzer.js for lazy loading — only loaded when client { } blocks are encountered.
function installClientAnalyzer(AnalyzerClass) {
  if (AnalyzerClass.prototype._clientAnalyzerInstalled) return;
  AnalyzerClass.prototype._clientAnalyzerInstalled = true;

  AnalyzerClass.prototype.visitClientBlock = function(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('client');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitStateDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'state' can only be used inside a client block`, node.loc, "move this inside a client { } block", { code: 'E302' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'state', node.typeAnnotation, true, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.initialValue);
  };

  AnalyzerClass.prototype.visitComputedDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'computed' can only be used inside a client block`, node.loc, "move this inside a client { } block", { code: 'E302' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'computed', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.expression);
  };

  AnalyzerClass.prototype.visitEffectDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'effect' can only be used inside a client block`, node.loc, "move this inside a client { } block", { code: 'E302' });
    }
    this.visitNode(node.body);
  };

  AnalyzerClass.prototype.visitComponentDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'component' can only be used inside a client block`, node.loc, "move this inside a client { } block", { code: 'E302' });
    }
    this._checkNamingConvention(node.name, 'component', node.loc);
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'component', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitStoreDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'store' can only be used inside a client block`, node.loc, "move this inside a client { } block", { code: 'E302' });
    }
    this._checkNamingConvention(node.name, 'store', node.loc);
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitJSXElement = function(node) {
    for (const attr of node.attributes) {
      if (attr.type === 'JSXSpreadAttribute') {
        this.visitExpression(attr.expression);
      } else {
        this.visitExpression(attr.value);
      }
    }
    for (const child of node.children) {
      if (child.type === 'JSXElement') {
        this.visitJSXElement(child);
      } else if (child.type === 'JSXFragment') {
        this.visitJSXFragment(child);
      } else if (child.type === 'JSXExpression') {
        this.visitExpression(child.expression);
      } else if (child.type === 'JSXFor') {
        this.visitJSXFor(child);
      } else if (child.type === 'JSXIf') {
        this.visitJSXIf(child);
      } else if (child.type === 'JSXMatch') {
        this.visitJSXMatch(child);
      }
    }
  };

  AnalyzerClass.prototype.visitJSXFragment = function(node) {
    for (const child of node.children) {
      if (child.type === 'JSXElement') {
        this.visitJSXElement(child);
      } else if (child.type === 'JSXFragment') {
        this.visitJSXFragment(child);
      } else if (child.type === 'JSXExpression') {
        this.visitExpression(child.expression);
      } else if (child.type === 'JSXFor') {
        this.visitJSXFor(child);
      } else if (child.type === 'JSXIf') {
        this.visitJSXIf(child);
      } else if (child.type === 'JSXMatch') {
        this.visitJSXMatch(child);
      }
    }
  };

  AnalyzerClass.prototype.visitJSXFor = function(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      this.visitExpression(node.iterable);
      const variable = node.variable;
      if (typeof variable === 'string') {
        try {
          this.currentScope.define(variable,
            new Symbol(variable, 'variable', null, false, node.loc));
        } catch (e) { this.error(e.message); }
      } else if (variable.type === 'ArrayPattern') {
        for (const el of variable.elements) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'variable', null, false, variable.loc));
          } catch (e) { this.error(e.message); }
        }
      } else if (variable.type === 'ObjectPattern') {
        for (const prop of variable.properties) {
          const name = prop.value || prop.key;
          try {
            this.currentScope.define(name,
              new Symbol(name, 'variable', null, false, variable.loc));
          } catch (e) { this.error(e.message); }
        }
      }
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitJSXIf = function(node) {
    this.visitExpression(node.condition);
    for (const child of node.consequent) {
      this.visitNode(child);
    }
    if (node.alternates) {
      for (const alt of node.alternates) {
        this.visitExpression(alt.condition);
        for (const child of alt.body) {
          this.visitNode(child);
        }
      }
    }
    if (node.alternate) {
      for (const child of node.alternate) {
        this.visitNode(child);
      }
    }
  };

  AnalyzerClass.prototype.visitJSXMatch = function(node) {
    this.visitExpression(node.subject);
    for (const arm of node.arms) {
      // Visit pattern bindings in a child scope
      for (const child of arm.body) {
        this.visitNode(child);
      }
    }
  };
}

// ─── src/analyzer/analyzer.js ──────────────────────────

// Pre-allocated constants for hot-path type checking (avoid per-call allocation)
const ARITHMETIC_OPS = new Set(['-', '*', '/', '%', '**']);
const NUMERIC_TYPES = new Set(['Int', 'Float']);

const _JS_GLOBALS = new Set([
  'console', 'document', 'window', 'globalThis', 'self',
  'JSON', 'Math', 'Date', 'RegExp', 'Error', 'TypeError', 'RangeError',
  'Promise', 'Set', 'Map', 'WeakSet', 'WeakMap', 'Symbol',
  'Array', 'Object', 'String', 'Number', 'Boolean', 'Function',
  'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'NaN', 'Infinity',
  'undefined', 'null', 'true', 'false',
  'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
  'queueMicrotask', 'structuredClone',
  'URL', 'URLSearchParams', 'Headers', 'Request', 'Response',
  'FormData', 'Blob', 'File', 'FileReader',
  'AbortController', 'AbortSignal',
  'TextEncoder', 'TextDecoder',
  'crypto', 'performance', 'navigator', 'location', 'history',
  'localStorage', 'sessionStorage',
  'fetch', 'alert', 'confirm', 'prompt',
  'Bun', 'Deno', 'process', 'require', 'module', 'exports', '__dirname', '__filename',
  'Buffer', 'atob', 'btoa',
]);

function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  // Ensure a is the shorter string for O(min(n,m)) space
  if (a.length > b.length) { const t = a; a = b; b = t; }
  const len = a.length;
  let prev = new Array(len + 1);
  let curr = new Array(len + 1);
  for (let j = 0; j <= len; j++) prev[j] = j;
  for (let i = 1; i <= b.length; i++) {
    curr[0] = i;
    for (let j = 1; j <= len; j++) {
      curr[j] = b[i-1] === a[j-1]
        ? prev[j-1]
        : Math.min(prev[j-1], curr[j-1], prev[j]) + 1;
    }
    const tmp = prev; prev = curr; curr = tmp;
  }
  return prev[len];
}

const _TOVA_RUNTIME = new Set([
  'Ok', 'Err', 'Some', 'None', 'Result', 'Option',
  'db', 'server', 'client', 'shared',
]);

// Pre-built static candidate set for Levenshtein suggestions (N1 optimization)
// Lazily initialized on first use since BUILTIN_NAMES, _JS_GLOBALS, _TOVA_RUNTIME never change.
let _STATIC_SUGGESTION_NAMES = null;
function _getStaticSuggestionNames() {
  if (!_STATIC_SUGGESTION_NAMES) {
    _STATIC_SUGGESTION_NAMES = [];
    for (const n of BUILTIN_NAMES) _STATIC_SUGGESTION_NAMES.push(n);
    for (const n of _JS_GLOBALS) _STATIC_SUGGESTION_NAMES.push(n);
    for (const n of _TOVA_RUNTIME) _STATIC_SUGGESTION_NAMES.push(n);
  }
  return _STATIC_SUGGESTION_NAMES;
}
class Analyzer {
  constructor(ast, filename = '<stdin>', options = {}) {
    this.ast = ast;
    this.filename = filename;
    this.errors = [];
    this.warnings = [];
    this.tolerant = options.tolerant || false;
    this.strict = options.strict || false;
    this.globalScope = new Scope(null, 'module');
    this.currentScope = this.globalScope;
    this._allScopes = []; // Track all scopes for unused variable checking
    this._functionReturnTypeStack = []; // Stack of expected return types for type checking
    this._asyncDepth = 0; // Track nesting inside async functions for await validation

    // Propagate strict mode to the type system
    Type.strictMode = this.strict;

    // Type registry for LSP
    this.typeRegistry = {
      types: new Map(),   // type name → ADTType | RecordType
      impls: new Map(),   // type name → [{ name, params, returnType }]
      traits: new Map(),  // trait name → [{ name, paramTypes, returnType }]
    };

    // Register built-in types
    this.registerBuiltins();
  }

  registerBuiltins() {
    const builtins = [
      'Int', 'Float', 'String', 'Bool', 'Nil', 'Any',
      'print', 'range', 'len', 'type_of', 'enumerate', 'zip',
      'map', 'filter', 'reduce', 'sum', 'sorted', 'reversed',
      'fetch', 'db',
      'Ok', 'Err', 'Some', 'None', 'Result', 'Option',
      // Collections
      'find', 'any', 'all', 'flat_map', 'unique', 'group_by',
      'chunk', 'flatten', 'take', 'drop', 'first', 'last',
      'count', 'partition',
      // Math
      'abs', 'floor', 'ceil', 'round', 'clamp', 'sqrt', 'pow', 'random',
      // Strings
      'trim', 'split', 'join', 'replace', 'repeat',
      // Utility
      'keys', 'values', 'entries', 'merge', 'freeze', 'clone',
      // Async
      'sleep',
      // String functions
      'upper', 'lower', 'contains', 'starts_with', 'ends_with',
      'chars', 'words', 'lines', 'capitalize', 'title_case',
      'snake_case', 'camel_case',
      // Math extras
      'min', 'max',
      // Table operations
      'Table', 'table_where', 'table_select', 'table_derive',
      'table_group_by', 'table_agg', 'table_sort_by', 'table_limit',
      'table_join', 'table_pivot', 'table_unpivot', 'table_explode',
      'table_union', 'table_drop_duplicates', 'table_rename',
      // Table aggregation helpers
      'agg_sum', 'agg_count', 'agg_mean', 'agg_median', 'agg_min', 'agg_max',
      // Data exploration
      'peek', 'describe', 'schema_of',
      // Data cleaning
      'cast', 'drop_nil', 'fill_nil', 'filter_ok', 'filter_err',
      // I/O
      'read', 'write', 'stream',
      // CSV/JSONL helpers
      '__parseCSV', '__parseJSONL',
      // Table operation aliases (short names)
      'where', 'select', 'derive', 'agg', 'sort_by', 'limit',
      'pivot', 'unpivot', 'explode', 'union', 'drop_duplicates', 'rename',
      'mean', 'median',
      // Strings (new)
      'index_of', 'last_index_of', 'count_of', 'reverse_str', 'substr',
      'is_empty', 'kebab_case', 'center',
      // Collections (new)
      'zip_with', 'frequencies', 'scan', 'min_by', 'max_by', 'sum_by',
      'product', 'from_entries', 'has_key', 'get', 'pick', 'omit',
      'map_values', 'sliding_window',
      // JSON
      'json_parse', 'json_stringify', 'json_pretty',
      // Functional
      'compose', 'pipe_fn', 'identity', 'memoize', 'debounce', 'throttle',
      'once', 'negate',
      // Error handling
      'try_fn', 'try_async',
      // Async
      'parallel', 'timeout', 'retry',
      // Encoding
      'base64_encode', 'base64_decode', 'url_encode', 'url_decode',
      // Math (new)
      'hypot', 'lerp', 'divmod', 'avg',
      // Date/Time
      'now', 'now_iso',
      // Scripting
      'env', 'set_env', 'args', 'exit',
      'exists', 'is_dir', 'is_file', 'ls', 'glob_files',
      'mkdir', 'rm', 'cp', 'mv', 'cwd', 'chdir',
      'read_text', 'read_bytes', 'write_text',
      'sh', 'exec',
      // Scripting: new
      'read_stdin', 'read_lines',
      'script_path', 'script_dir',
      'parse_args',
      'color', 'bold', 'dim',
      // Scripting: signals, file stat, path utils, symlinks, async shell
      'on_signal',
      'file_stat', 'file_size',
      'path_join', 'path_dirname', 'path_basename', 'path_resolve', 'path_ext', 'path_relative',
      'symlink', 'readlink', 'is_symlink',
      'spawn',
      // Namespace modules
      'math', 'str', 'arr', 'dt', 're', 'json', 'fs', 'url',
      // Advanced collections
      'OrderedDict', 'DefaultDict', 'Counter', 'Deque', 'collections',
    ];
    for (const name of builtins) {
      this.globalScope.define(name, new Symbol(name, 'builtin', null, false, { line: 0, column: 0, file: '<builtin>' }));
    }
  }

  error(message, loc, hint = null, opts = {}) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    const e = {
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    };
    if (hint) e.hint = hint;
    if (opts.code) e.code = opts.code;
    if (opts.length) e.length = opts.length;
    if (opts.fix) e.fix = opts.fix;
    this.errors.push(e);
  }

  warn(message, loc, hint = null, opts = {}) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    const w = {
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    };
    if (hint) w.hint = hint;
    if (opts.code) w.code = opts.code;
    if (opts.length) w.length = opts.length;
    if (opts.fix) w.fix = opts.fix;
    this.warnings.push(w);
  }

  strictError(message, loc, hint = null, opts = {}) {
    if (this.strict) {
      this.error(message, loc, hint, opts);
    } else {
      this.warn(message, loc, hint, opts);
    }
  }

  // ─── Naming convention helpers ─────────────────────────────

  _isSnakeCase(name) {
    if (name.startsWith('_')) return true;
    if (name.length === 1) return true;
    if (/^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/.test(name)) return true; // UPPER_SNAKE_CASE
    return /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/.test(name);
  }

  _isPascalCase(name) {
    return /^[A-Z][a-zA-Z0-9]*$/.test(name);
  }

  _isUpperSnakeCase(name) {
    return /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/.test(name);
  }

  _toSnakeCase(name) {
    return name.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
  }

  _toPascalCase(name) {
    return name.replace(/(^|_)([a-z])/g, (_, __, c) => c.toUpperCase());
  }

  _checkNamingConvention(name, kind, loc) {
    if (!name || name.startsWith('_') || name.length === 1) return;
    if (this._isUpperSnakeCase(name)) return; // constants are valid for variables

    if (kind === 'type' || kind === 'component' || kind === 'store') {
      if (!this._isPascalCase(name)) {
        const suggested = this._toPascalCase(name);
        this.warn(
          `${kind[0].toUpperCase() + kind.slice(1)} '${name}' should use PascalCase`,
          loc,
          `Rename '${name}' to '${suggested}'`,
          { code: 'W100', length: name.length, fix: { description: `Rename to '${suggested}'`, replacement: suggested } }
        );
      }
    } else {
      // function, variable, parameter
      if (!this._isSnakeCase(name)) {
        const suggested = this._toSnakeCase(name);
        this.warn(
          `${kind[0].toUpperCase() + kind.slice(1)} '${name}' should use snake_case`,
          loc,
          `Rename '${name}' to '${suggested}'`,
          { code: 'W100', length: name.length, fix: { description: `Rename to '${suggested}'`, replacement: suggested } }
        );
      }
    }
  }

  analyze() {
    // Pre-pass: collect named server block functions for inter-server RPC validation
    const hasServerBlocks = this.ast.body.some(n => n.type === 'ServerBlock');
    if (hasServerBlocks) {
      installServerAnalyzer(Analyzer);
      this.serverBlockFunctions = collectServerBlockFunctions(this.ast);
    } else {
      this.serverBlockFunctions = new Map();
    }

    this.visitProgram(this.ast);

    // Check for unused variables/imports (#9)
    this._collectAllScopes(this.globalScope);
    this._checkUnusedSymbols();

    if (this.errors.length > 0) {
      if (this.tolerant) {
        return { warnings: this.warnings, errors: this.errors, scope: this.globalScope, typeRegistry: this.typeRegistry };
      }
      const msgs = this.errors.map(e => `  ${e.file}:${e.line}:${e.column} — ${e.message}`);
      const err = new Error(`Analysis errors:\n${msgs.join('\n')}`);
      err.errors = this.errors;
      err.warnings = this.warnings;
      throw err;
    }

    return { warnings: this.warnings, scope: this.globalScope, typeRegistry: this.typeRegistry };
  }

  _checkUnusedSymbols() {
    for (const scope of this._allScopes) {
      // Only check inside functions, not module/server/client level
      if (!this._isScopeInsideFunction(scope)) continue;

      for (const [name, sym] of scope.symbols) {
        if (sym.kind === 'builtin') continue;
        if (name.startsWith('_')) continue;
        if (sym.kind === 'type') continue;
        if (sym.kind === 'parameter') continue;

        if (!sym.used && sym.loc && sym.loc.line > 0) {
          this.warn(`'${name}' is declared but never used`, sym.loc, "prefix with _ to suppress", {
            code: 'W001',
            length: name.length,
            fix: { description: `Prefix with _ to suppress: _${name}`, replacement: `_${name}` },
          });
        }
      }
    }

    // Check unused functions at module/server/client/shared level
    for (const scope of this._allScopes) {
      if (scope.context !== 'module' && scope.context !== 'server' &&
          scope.context !== 'client' && scope.context !== 'shared') continue;

      for (const [name, sym] of scope.symbols) {
        if (sym.kind !== 'function') continue;
        if (name.startsWith('_')) continue;
        if (sym.isPublic) continue;
        if (sym.extern) continue;
        if (sym._variantOf) continue; // ADT variant constructors
        if (name === 'main') continue;

        if (!sym.used && sym.loc && sym.loc.line > 0) {
          this.warn(`Function '${name}' is declared but never used`, sym.loc, "prefix with _ to suppress", {
            code: 'W002',
            length: name.length,
            fix: { description: `Prefix with _ to suppress: _${name}`, replacement: `_${name}` },
          });
        }
      }
    }
  }

  _collectAllScopes(scope) {
    this._allScopes.push(scope);
    for (const child of scope.children) {
      this._collectAllScopes(child);
    }
  }

  _isScopeInsideFunction(scope) {
    let s = scope;
    while (s) {
      if (s.context === 'function') return true;
      if (s.context === 'module' || s.context === 'server' || s.context === 'client' || s.context === 'shared') return false;
      s = s.parent;
    }
    return false;
  }

  // ─── Type Inference ──────────────────────────────────────

  _inferType(expr) {
    if (!expr) return null;
    switch (expr.type) {
      case 'NumberLiteral':
        return Number.isInteger(expr.value) ? 'Int' : 'Float';
      case 'StringLiteral':
      case 'TemplateLiteral':
        return 'String';
      case 'BooleanLiteral':
        return 'Bool';
      case 'NilLiteral':
        return 'Nil';
      case 'ArrayLiteral':
        if (expr.elements.length > 0) {
          const elType = this._inferType(expr.elements[0]);
          return elType ? `[${elType}]` : '[Any]';
        }
        return '[Any]';
      case 'CallExpression':
        if (expr.callee.type === 'Identifier') {
          const name = expr.callee.name;
          if (name === 'Ok') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Result<${innerType}, _>` : 'Result';
          }
          if (name === 'Err') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Result<_, ${innerType}>` : 'Result';
          }
          if (name === 'Some') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Option<${innerType}>` : 'Option';
          }
          if (name === 'len' || name === 'count') return 'Int';
          if (name === 'type_of') return 'String';
          if (name === 'random') return 'Float';
          // Look up declared return type from function symbol
          const fnSym = this.currentScope.lookup(name);
          if (fnSym && fnSym.kind === 'function') {
            if (fnSym._variantOf) return fnSym._variantOf;
            if (fnSym.type) {
              let retType = this._typeAnnotationToString(fnSym.type);
              // For generic functions, infer type params from call arguments
              if (fnSym._typeParams && fnSym._typeParams.length > 0 && fnSym._paramTypes) {
                const typeParamBindings = new Map();
                for (let i = 0; i < expr.arguments.length && i < fnSym._paramTypes.length; i++) {
                  const arg = expr.arguments[i];
                  if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
                  const paramTypeAnn = fnSym._paramTypes[i];
                  if (!paramTypeAnn) continue;
                  const actualType = this._inferType(arg);
                  if (actualType) {
                    this._inferTypeParamBindings(paramTypeAnn, actualType, fnSym._typeParams, typeParamBindings);
                  }
                }
                if (typeParamBindings.size > 0) {
                  retType = this._substituteTypeParams(retType, typeParamBindings);
                }
              }
              return retType;
            }
          }
        }
        return null;
      case 'Identifier':
        if (expr.name === 'None') return 'Option<_>';
        if (expr.name === 'true' || expr.name === 'false') return 'Bool';
        // Look up stored type
        const sym = this.currentScope.lookup(expr.name);
        return sym ? sym.inferredType : null;
      case 'TupleExpression':
        return `(${expr.elements.map(e => this._inferType(e) || 'Any').join(', ')})`;
      case 'BinaryExpression':
        if (expr.operator === '++') return 'String';
        if (['+', '-', '*', '/', '%', '**'].includes(expr.operator)) {
          const lt = this._inferType(expr.left);
          const rt = this._inferType(expr.right);
          if (!lt && !rt) return null;
          if (lt === 'Float' || rt === 'Float') return 'Float';
          if (lt === 'String' || rt === 'String') return 'String';
          return 'Int';
        }
        if (['==', '!=', '<', '>', '<=', '>='].includes(expr.operator)) return 'Bool';
        return null;
      case 'UnaryExpression':
        if (expr.operator === 'not' || expr.operator === '!') return 'Bool';
        if (expr.operator === '-') return this._inferType(expr.operand);
        return null;
      case 'LogicalExpression':
        return 'Bool';
      case 'PipeExpression':
        return this._inferPipeType(expr);
      case 'MemberExpression':
        // Infer .length as Int
        if (expr.property === 'length') return 'Int';
        return null;
      default:
        return null;
    }
  }

  /**
   * Infer the result type of a pipe expression like `arr |> filter(fn(x) x > 0) |> map(fn(x) x * 2)`.
   * The left side provides the input type; the right side determines the output type.
   */
  _inferPipeType(expr) {
    const inputType = this._inferType(expr.left);
    const right = expr.right;

    if (right.type === 'CallExpression' && right.callee.type === 'Identifier') {
      const fnName = right.callee.name;

      // Collection operations that preserve the array type
      if (['filter', 'sorted', 'reversed', 'unique', 'take', 'drop', 'skip'].includes(fnName)) {
        return inputType; // Same type as input
      }

      // map: transforms element type based on the mapper function
      if (fnName === 'map') {
        if (inputType && inputType.startsWith('[') && inputType.endsWith(']')) {
          // Try to infer the return type from the mapper function
          const mapperArg = right.arguments.length > 0 ? right.arguments[0] : null;
          if (mapperArg) {
            const mapperRetType = this._inferLambdaReturnType(mapperArg, inputType.slice(1, -1));
            if (mapperRetType) return `[${mapperRetType}]`;
          }
        }
        return inputType; // Fallback: preserve input type
      }

      // flat_map / flatten: reduce nesting
      if (fnName === 'flat_map' || fnName === 'flatMap') {
        if (inputType && inputType.startsWith('[') && inputType.endsWith(']')) {
          return inputType; // Simplified: same element type
        }
      }
      if (fnName === 'flatten') {
        if (inputType && inputType.startsWith('[[') && inputType.endsWith(']]')) {
          return inputType.slice(1, -1); // [[T]] -> [T]
        }
        return inputType;
      }

      // Reduction operations
      if (fnName === 'reduce' || fnName === 'fold') return null; // Can't easily infer
      if (fnName === 'join') return 'String';
      if (fnName === 'count' || fnName === 'len' || fnName === 'length') return 'Int';
      if (fnName === 'sum') return inputType === '[Float]' ? 'Float' : 'Int';
      if (fnName === 'any' || fnName === 'all' || fnName === 'every' || fnName === 'some') return 'Bool';
      if (fnName === 'first' || fnName === 'last' || fnName === 'find') {
        if (inputType && inputType.startsWith('[') && inputType.endsWith(']')) {
          return inputType.slice(1, -1); // [T] -> T
        }
      }

      // For user-defined functions, fall back to checking their return type
      const fnSym = this.currentScope.lookup(fnName);
      if (fnSym && fnSym.kind === 'function' && fnSym.type) {
        return this._typeAnnotationToString(fnSym.type);
      }
    }

    // If we can't infer the right side, return null
    return null;
  }

  /**
   * Try to infer the return type of a lambda expression given the input element type.
   */
  _inferLambdaReturnType(lambdaExpr, inputElementType) {
    if (!lambdaExpr) return null;
    if (lambdaExpr.type === 'LambdaExpression') {
      // For simple expression bodies, infer the result type
      if (lambdaExpr.body && lambdaExpr.body.type !== 'BlockStatement') {
        return this._inferType(lambdaExpr.body);
      }
    }
    return null;
  }

  _typeAnnotationToString(ann) {
    if (!ann) return null;
    if (typeof ann === 'string') return ann;
    switch (ann.type) {
      case 'TypeAnnotation':
        if (ann.typeParams && ann.typeParams.length > 0) {
          const params = ann.typeParams.map(p => this._typeAnnotationToString(p)).join(', ');
          return `${ann.name}<${params}>`;
        }
        return ann.name;
      case 'ArrayTypeAnnotation':
        return `[${this._typeAnnotationToString(ann.elementType) || 'Any'}]`;
      case 'TupleTypeAnnotation':
        return `(${ann.elementTypes.map(t => this._typeAnnotationToString(t) || 'Any').join(', ')})`;
      case 'FunctionTypeAnnotation':
        return 'Function';
      case 'UnionTypeAnnotation':
        return ann.members.map(m => this._typeAnnotationToString(m) || 'Any').join(' | ');
      default:
        return null;
    }
  }

  _parseGenericType(typeStr) {
    if (!typeStr) return { base: typeStr, params: [] };
    // Check cache first
    if (!this._parseGenericCache) this._parseGenericCache = new Map();
    const cached = this._parseGenericCache.get(typeStr);
    if (cached) return cached;

    const ltIdx = typeStr.indexOf('<');
    if (ltIdx === -1) {
      const result = { base: typeStr, params: [] };
      this._parseGenericCache.set(typeStr, result);
      return result;
    }
    const base = typeStr.slice(0, ltIdx);
    const inner = typeStr.slice(ltIdx + 1, typeStr.lastIndexOf('>'));
    // Split on top-level commas (respecting nested <>)
    const params = [];
    let depth = 0;
    let start = 0;
    for (let i = 0; i < inner.length; i++) {
      if (inner[i] === '<') depth++;
      else if (inner[i] === '>') depth--;
      else if (inner[i] === ',' && depth === 0) {
        params.push(inner.slice(start, i).trim());
        start = i + 1;
      }
    }
    params.push(inner.slice(start).trim());
    const result = { base, params };
    this._parseGenericCache.set(typeStr, result);
    return result;
  }

  _typesCompatible(expected, actual) {
    // Unknown types are always compatible (gradual typing)
    if (!expected || !actual) return true;
    if (expected === 'Any' || actual === 'Any') return true;
    if (expected === '_' || actual === '_') return true;
    // Resolve type aliases before comparison
    expected = this._resolveTypeAlias(expected);
    actual = this._resolveTypeAlias(actual);
    // Exact match
    if (expected === actual) return true;
    // Numeric compatibility: Int -> Float widening is safe; Float -> Int requires explicit conversion
    if (expected === 'Float' && actual === 'Int') return true;
    if (expected === 'Int' && actual === 'Float') return false; // caller should emit warning/error
    // Nil is compatible with Option
    if (actual === 'Nil' && (expected === 'Option' || expected.startsWith('Option'))) return true;
    if ((expected === 'Nil') && (actual === 'Option' || actual.startsWith('Option'))) return true;
    // Union type compatibility: actual must be assignable to one of the expected union members
    if (expected.includes(' | ')) {
      const members = expected.split(' | ').map(m => m.trim());
      return members.some(m => this._typesCompatible(m, actual));
    }
    // If actual is a union, every member must be compatible with expected
    if (actual.includes(' | ')) {
      const members = actual.split(' | ').map(m => m.trim());
      return members.every(m => this._typesCompatible(expected, m));
    }
    // Nil is compatible with union types that include Nil
    if (actual === 'Nil' && expected.includes('Nil')) return true;
    // Array compatibility: check element types
    if (expected.startsWith('[') && actual.startsWith('[')) {
      const expEl = expected.slice(1, -1);
      const actEl = actual.slice(1, -1);
      return this._typesCompatible(expEl, actEl);
    }
    // Tuple compatibility: check element types pairwise
    if (expected.startsWith('(') && actual.startsWith('(')) {
      const expEls = expected.slice(1, -1).split(', ');
      const actEls = actual.slice(1, -1).split(', ');
      if (expEls.length !== actEls.length) return false;
      return expEls.every((e, i) => this._typesCompatible(e, actEls[i]));
    }
    // Generic type compatibility: Result<Int, String> vs Result<String, Int>
    const expG = this._parseGenericType(expected);
    const actG = this._parseGenericType(actual);
    if (expG.params.length > 0 || actG.params.length > 0) {
      // Base types must match
      if (expG.base !== actG.base) return false;
      // If one has no params (plain `Result`), compatible with any parameterized version (gradual typing)
      if (expG.params.length === 0 || actG.params.length === 0) return true;
      // Compare params pairwise
      if (expG.params.length !== actG.params.length) return false;
      return expG.params.every((ep, i) => this._typesCompatible(ep, actG.params[i]));
    }
    return false;
  }

  // ─── Visitors ─────────────────────────────────────────────

  visitProgram(node) {
    for (const stmt of node.body) {
      if (this.tolerant) {
        try { this.visitNode(stmt); } catch (e) { /* skip nodes that crash in tolerant mode */ }
      } else {
        this.visitNode(stmt);
      }
    }
  }

  visitNode(node) {
    if (!node) return;

    switch (node.type) {
      case 'ServerBlock':
      case 'RouteDeclaration':
      case 'MiddlewareDeclaration':
      case 'HealthCheckDeclaration':
      case 'CorsDeclaration':
      case 'ErrorHandlerDeclaration':
      case 'WebSocketDeclaration':
      case 'StaticDeclaration':
      case 'DiscoverDeclaration':
      case 'AuthDeclaration':
      case 'MaxBodyDeclaration':
      case 'RouteGroupDeclaration':
      case 'RateLimitDeclaration':
      case 'LifecycleHookDeclaration':
      case 'SubscribeDeclaration':
      case 'EnvDeclaration':
      case 'ScheduleDeclaration':
      case 'UploadDeclaration':
      case 'SessionDeclaration':
      case 'DbDeclaration':
      case 'TlsDeclaration':
      case 'CompressionDeclaration':
      case 'BackgroundJobDeclaration':
      case 'CacheDeclaration':
      case 'SseDeclaration':
      case 'ModelDeclaration':
        return this._visitServerNode(node);
      case 'AiConfigDeclaration': return; // handled at block level
      case 'ClientBlock':
      case 'StateDeclaration':
      case 'ComputedDeclaration':
      case 'EffectDeclaration':
      case 'ComponentDeclaration':
      case 'StoreDeclaration':
        return this._visitClientNode(node);
      case 'SharedBlock': return this.visitSharedBlock(node);
      case 'Assignment': return this.visitAssignment(node);
      case 'VarDeclaration': return this.visitVarDeclaration(node);
      case 'LetDestructure': return this.visitLetDestructure(node);
      case 'FunctionDeclaration': return this.visitFunctionDeclaration(node);
      case 'TypeDeclaration': return this.visitTypeDeclaration(node);
      case 'ImportDeclaration': return this.visitImportDeclaration(node);
      case 'ImportDefault': return this.visitImportDefault(node);
      case 'ImportWildcard': return this.visitImportWildcard(node);
      case 'IfStatement': return this.visitIfStatement(node);
      case 'ForStatement': return this.visitForStatement(node);
      case 'WhileStatement': return this.visitWhileStatement(node);
      case 'LoopStatement': return this.visitLoopStatement(node);
      case 'TryCatchStatement': return this.visitTryCatchStatement(node);
      case 'ReturnStatement': return this.visitReturnStatement(node);
      case 'ExpressionStatement': return this.visitExpression(node.expression);
      case 'BlockStatement': return this.visitBlock(node);
      case 'CompoundAssignment': return this.visitCompoundAssignment(node);
      case 'BreakStatement': return this.visitBreakStatement(node);
      case 'ContinueStatement': return this.visitContinueStatement(node);
      case 'GuardStatement': return this.visitGuardStatement(node);
      case 'InterfaceDeclaration': return this.visitInterfaceDeclaration(node);
      case 'DataBlock': return this.visitDataBlock(node);
      case 'SourceDeclaration': return;
      case 'PipelineDeclaration': return;
      case 'ValidateBlock': return;
      case 'RefreshPolicy': return;
      case 'RefinementType': return;
      case 'TestBlock': return this.visitTestBlock(node);
      case 'BenchBlock': return this.visitTestBlock(node);
      case 'ComponentStyleBlock': return; // raw CSS — no analysis needed
      case 'ImplDeclaration': return this.visitImplDeclaration(node);
      case 'TraitDeclaration': return this.visitTraitDeclaration(node);
      case 'TypeAlias': return this.visitTypeAlias(node);
      case 'DeferStatement': return this.visitDeferStatement(node);
      case 'ExternDeclaration': return this.visitExternDeclaration(node);
      default:
        // Expression nodes
        this.visitExpression(node);
    }
  }

  _visitServerNode(node) {
    if (!Analyzer.prototype._serverAnalyzerInstalled) {
      installServerAnalyzer(Analyzer);
    }
    const methodName = 'visit' + node.type;
    return this[methodName](node);
  }

  _visitClientNode(node) {
    if (!Analyzer.prototype._clientAnalyzerInstalled) {
      installClientAnalyzer(Analyzer);
    }
    const methodName = 'visit' + node.type;
    return this[methodName](node);
  }

  visitExpression(node) {
    if (!node) return;

    switch (node.type) {
      case 'Identifier':
        return this.visitIdentifier(node);
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return;
      case 'TemplateLiteral':
        for (const part of node.parts) {
          if (part.type === 'expr') this.visitExpression(part.value);
        }
        return;
      case 'BinaryExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        this._checkBinaryExprTypes(node);
        return;
      case 'UnaryExpression':
        this.visitExpression(node.operand);
        return;
      case 'LogicalExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'ChainedComparison':
        for (const op of node.operands) this.visitExpression(op);
        return;
      case 'MembershipExpression':
        this.visitExpression(node.value);
        this.visitExpression(node.collection);
        return;
      case 'CallExpression':
        // Validate inter-server RPC calls: peerName.functionName()
        if (this._currentServerBlockName && node.callee.type === 'MemberExpression' &&
            node.callee.object.type === 'Identifier' && !node.callee.computed) {
          const targetName = node.callee.object.name;
          const fnName = node.callee.property;
          if (targetName === this._currentServerBlockName) {
            this.warn(`Server block "${targetName}" is calling itself via RPC — consider calling the function directly`, node.loc);
          } else if (this.serverBlockFunctions.has(targetName)) {
            const peerFns = this.serverBlockFunctions.get(targetName);
            if (!peerFns.includes(fnName)) {
              this.error(`No function '${fnName}' in server block "${targetName}"`, node.loc);
            }
          }
        }
        // Argument count and type validation for known functions
        this._checkCallArgCount(node);
        this._checkCallArgTypes(node);
        this.visitExpression(node.callee);
        for (const arg of node.arguments) {
          if (arg.type === 'NamedArgument') {
            this.visitExpression(arg.value);
          } else {
            this.visitExpression(arg);
          }
        }
        return;
      case 'MemberExpression':
      case 'OptionalChain':
        this.visitExpression(node.object);
        if (node.computed) this.visitExpression(node.property);
        return;
      case 'PipeExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'LambdaExpression':
        return this.visitLambda(node);
      case 'MatchExpression':
        return this.visitMatchExpression(node);
      case 'ArrayLiteral':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'ObjectLiteral':
        for (const prop of node.properties) {
          if (prop.spread) {
            // Spread property: {...expr}
            this.visitExpression(prop.argument);
          } else if (prop.shorthand) {
            // Shorthand: {name} — key IS the variable reference
            this.visitExpression(prop.key);
          } else {
            // Non-shorthand: {key: value} — only visit value, key is a label
            this.visitExpression(prop.value);
          }
        }
        return;
      case 'ListComprehension':
        return this.visitListComprehension(node);
      case 'DictComprehension':
        return this.visitDictComprehension(node);
      case 'RangeExpression':
        this.visitExpression(node.start);
        this.visitExpression(node.end);
        return;
      case 'SliceExpression':
        this.visitExpression(node.object);
        if (node.start) this.visitExpression(node.start);
        if (node.end) this.visitExpression(node.end);
        if (node.step) this.visitExpression(node.step);
        return;
      case 'SpreadExpression':
        this.visitExpression(node.argument);
        return;
      case 'PropagateExpression':
        this.visitExpression(node.expression);
        return;
      case 'AwaitExpression':
        if (this._asyncDepth === 0) {
          this.error("'await' can only be used inside an async function", node.loc, "add 'async' to the enclosing function declaration", { code: 'E300' });
        }
        this.visitExpression(node.argument);
        return;
      case 'YieldExpression':
        if (node.argument) this.visitExpression(node.argument);
        return;
      case 'TupleExpression':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'IfExpression':
        this.visitExpression(node.condition);
        this.visitNode(node.consequent);
        for (const alt of node.alternates) {
          this.visitExpression(alt.condition);
          this.visitNode(alt.body);
        }
        this.visitNode(node.elseBody);
        return;
      case 'JSXElement':
      case 'JSXFragment':
        return this._visitClientNode(node);
      // Column expressions (for table operations) — no semantic analysis needed
      case 'ColumnExpression':
        return;
      case 'ColumnAssignment':
        this.visitExpression(node.expression);
        return;
      case 'NegatedColumnExpression':
        return;
    }
  }

  // ─── Block visitors ───────────────────────────────────────

  visitDataBlock(node) {
    // Register source and pipeline names in global scope
    for (const stmt of node.body) {
      if (stmt.type === 'SourceDeclaration') {
        try {
          this.currentScope.define(stmt.name,
            new Symbol(stmt.name, 'variable', null, false, stmt.loc));
        } catch (e) { /* already defined */ }
        if (stmt.expression) this.visitExpression(stmt.expression);
      } else if (stmt.type === 'PipelineDeclaration') {
        try {
          this.currentScope.define(stmt.name,
            new Symbol(stmt.name, 'variable', null, false, stmt.loc));
        } catch (e) { /* already defined */ }
        if (stmt.expression) this.visitExpression(stmt.expression);
      }
    }
  }

  // visitClientBlock and other client visitors are in client-analyzer.js (lazy-loaded)

  visitSharedBlock(node) {
    const prevScope = this.currentScope;
    const sharedScope = this.currentScope.child('shared');
    this.currentScope = sharedScope;
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
    // Promote shared types and functions to parent scope
    // so server/client blocks can reference them (but not variables)
    for (const [name, sym] of sharedScope.symbols) {
      if (!prevScope.symbols.has(name) && (sym.kind === 'type' || sym.kind === 'function')) {
        prevScope.symbols.set(name, sym);
      }
    }
  }

  // ─── Declaration visitors ─────────────────────────────────

  visitAssignment(node) {
    // Visit values first (for type inference)
    for (const val of node.values) {
      this.visitExpression(val);
    }

    // Check if any target is already defined (immutable reassignment check)
    for (let i = 0; i < node.targets.length; i++) {
      const target = node.targets[i];

      // Complex targets (e.g., arr[i] = val, obj.prop = val) — visit and skip declaration logic
      if (typeof target !== 'string') {
        this.visitExpression(target);
        continue;
      }

      const existing = this._lookupAssignTarget(target);
      if (existing) {
        // Allow user code to shadow builtins (e.g., url = "/api")
        if (existing.kind === 'builtin') {
          this.currentScope.define(target, new Symbol(target, 'variable', null, false, node.loc));
          continue;
        }
        if (!existing.mutable) {
          this.error(`Cannot reassign immutable variable '${target}'. Use 'var' for mutable variables.`, node.loc, null, {
            code: 'E202',
            length: target.length,
            fix: { description: `Change to 'var ${target}' at the original declaration to make it mutable` },
          });
        }
        // Type check reassignment
        if (existing.inferredType && i < node.values.length) {
          const newType = this._inferType(node.values[i]);
          if (!this._typesCompatible(existing.inferredType, newType)) {
            this.strictError(`Type mismatch: '${target}' is ${existing.inferredType}, but assigned ${newType}`, node.loc, this._conversionHint(existing.inferredType, newType), { code: 'E102' });
          }
          // Float narrowing warning in strict mode
          if (this.strict && newType === 'Float' && existing.inferredType === 'Int') {
            this.warn(`Potential data loss: assigning Float to Int variable '${target}'`, node.loc, "use floor() or round() for explicit conversion", { code: 'W204' });
          }
        }
        existing.used = true;
      } else {
        // New binding — define in current scope with inferred type
        const inferredType = i < node.values.length ? this._inferType(node.values[i]) : null;
        // Warn if this shadows a variable from an outer function scope
        if (this._existsInOuterScope(target)) {
          this.warn(`Variable '${target}' shadows a binding in an outer scope`, node.loc, null, { code: 'W101', length: target.length });
        }
        try {
          const sym = new Symbol(target, 'variable', null, false, node.loc);
          sym.inferredType = inferredType;
          this.currentScope.define(target, sym);
        } catch (e) {
          this.error(e.message);
        }
        this._checkNamingConvention(target, 'variable', node.loc);
      }
    }
  }

  visitVarDeclaration(node) {
    // Visit values first so type inference can work
    for (const val of node.values) {
      this.visitExpression(val);
    }
    for (let i = 0; i < node.targets.length; i++) {
      const target = node.targets[i];
      const inferredType = i < node.values.length ? this._inferType(node.values[i]) : null;
      try {
        const sym = new Symbol(target, 'variable', null, true, node.loc);
        sym.inferredType = inferredType;
        this.currentScope.define(target, sym);
      } catch (e) {
        this.error(e.message);
      }
      this._checkNamingConvention(target, 'variable', node.loc);
    }
  }

  visitLetDestructure(node) {
    this.visitExpression(node.value);

    if (node.pattern.type === 'ObjectPattern') {
      for (const prop of node.pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (node.pattern.type === 'ArrayPattern' || node.pattern.type === 'TuplePattern') {
      for (const el of node.pattern.elements) {
        if (el) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'variable', null, false, node.loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitFunctionDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'function', node.returnType, false, node.loc);
      sym._params = node.params.map(p => p.name);
      sym._totalParamCount = node.params.length;
      sym._requiredParamCount = node.params.filter(p => !p.defaultValue).length;
      sym._paramTypes = node.params.map(p => p.typeAnnotation || null);
      sym._typeParams = node.typeParams || [];
      sym.isPublic = node.isPublic || false;
      this.currentScope.define(node.name, sym);
    } catch (e) {
      this.error(e.message);
    }

    // Naming convention check (skip variant constructors — handled in visitTypeDeclaration)
    this._checkNamingConvention(node.name, 'function', node.loc);

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    if (node.loc) {
      this.currentScope.startLoc = { line: node.loc.line, column: node.loc.column };
    }

    // Push expected return type for return-statement checking
    const expectedReturn = node.returnType ? this._typeAnnotationToString(node.returnType) : null;
    this._functionReturnTypeStack.push(expectedReturn);
    const prevAsyncDepth = this._asyncDepth;
    if (node.isAsync) {
      this._asyncDepth++;
    } else {
      this._asyncDepth = 0; // Non-async function resets async context
    }

    try {
      for (const param of node.params) {
        if (param.destructure) {
          this._defineDestructureParams(param.destructure, param.loc);
        } else {
          try {
            const paramSym = new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc);
            paramSym.inferredType = param.typeAnnotation ? this._typeAnnotationToString(param.typeAnnotation) : null;
            this.currentScope.define(param.name, paramSym);
          } catch (e) {
            this.error(e.message);
          }
          this._checkNamingConvention(param.name, 'parameter', param.loc);
        }
        if (param.defaultValue) {
          this.visitExpression(param.defaultValue);
        }
      }

      this.visitNode(node.body);

      // Return path analysis: check that all paths return a value
      // Skip for @wasm/@fast functions — they use implicit returns or specialized codegen
      const isWasm = node.decorators && node.decorators.some(d => d.name === 'wasm' || d.name === 'fast');
      if (expectedReturn && node.body.type === 'BlockStatement' && !isWasm) {
        if (!this._definitelyReturns(node.body)) {
          this.warn(`Function '${node.name}' declares return type ${expectedReturn} but not all code paths return a value`, node.loc, null, { code: 'W205' });
        }
      }
    } finally {
      this._asyncDepth = prevAsyncDepth;
      this._functionReturnTypeStack.pop();
      this.currentScope = prevScope;
    }
  }

  visitExternDeclaration(node) {
    const sym = new Symbol(node.name, 'function', node.returnType, false, node.loc);
    sym._params = node.params.map(p => p.name || `arg${node.params.indexOf(p)}`);
    sym._totalParamCount = node.params.length;
    sym._requiredParamCount = node.params.filter(p => !p.defaultValue).length;
    sym._paramTypes = node.params.map(p => p.typeAnnotation || null);
    sym.extern = true;
    sym.isAsync = node.isAsync;
    // Extern declarations can override builtins (they provide more precise type info)
    const existing = this.currentScope.lookupLocal(node.name);
    if (existing && existing.kind === 'builtin') {
      this.currentScope.symbols.set(node.name, sym);
    } else {
      try {
        this.currentScope.define(node.name, sym);
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  _defineDestructureParams(pattern, loc) {
    if (pattern.type === 'ObjectPattern') {
      for (const prop of pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'parameter', null, false, loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (pattern.type === 'ArrayPattern' || pattern.type === 'TuplePattern') {
      for (const el of pattern.elements) {
        if (el) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'parameter', null, false, loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitTypeDeclaration(node) {
    this._checkNamingConvention(node.name, 'type', node.loc);

    // Build ADT type structure
    const variants = new Map();
    for (const variant of node.variants) {
      if (variant.type === 'TypeVariant') {
        const fields = new Map();
        for (const f of variant.fields) {
          const fieldType = f.typeAnnotation ? typeAnnotationToType(f.typeAnnotation) : Type.ANY;
          fields.set(f.name, fieldType || Type.ANY);
        }
        variants.set(variant.name, fields);
      }
    }
    const adtType = new ADTType(node.name, node.typeParams || [], variants);

    try {
      const typeSym = new Symbol(node.name, 'type', null, false, node.loc);
      typeSym._typeParams = node.typeParams || [];
      typeSym._typeStructure = adtType;
      this.currentScope.define(node.name, typeSym);

      // Register in type registry for LSP
      this.typeRegistry.types.set(node.name, adtType);
    } catch (e) {
      this.error(e.message);
    }

    // Define variant constructors as functions
    for (const variant of node.variants) {
      if (variant.type === 'TypeVariant') {
        try {
          const varSym = new Symbol(variant.name, 'function', null, false, variant.loc);
          varSym._params = variant.fields.map(f => f.name);
          varSym._totalParamCount = variant.fields.length;
          varSym._requiredParamCount = variant.fields.length;
          varSym._variantOf = node.name;
          varSym._paramTypes = variant.fields.map(f => f.typeAnnotation || null);
          this.currentScope.define(variant.name, varSym);
        } catch (e) {
          this.error(e.message);
        }
      }
    }

    // Validate derive traits
    if (node.derive) {
      const builtinTraits = new Set(['Eq', 'Show', 'JSON']);
      for (const trait of node.derive) {
        if (!builtinTraits.has(trait)) {
          const traitSym = this.currentScope.lookup(trait);
          if (!traitSym || !traitSym._interfaceMethods) {
            this.warn(`Unknown trait '${trait}' in derive clause`, node.loc, null, { code: 'W303' });
          }
        }
      }
    }
  }

  visitImportDeclaration(node) {
    for (const spec of node.specifiers) {
      try {
        this.currentScope.define(spec.local,
          new Symbol(spec.local, 'variable', null, false, spec.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  visitImportDefault(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  visitImportWildcard(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'module', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  // ─── Statement visitors ───────────────────────────────────

  visitBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    if (node.loc) {
      this.currentScope.startLoc = { line: node.loc.line, column: node.loc.column };
    }
    try {
      let terminated = false;
      for (const stmt of node.body) {
        if (terminated) {
          this.warn("Unreachable code after return/break/continue", stmt.loc || node.loc, null, { code: 'W201' });
          break; // Only warn once per block
        }
        this.visitNode(stmt);
        if (stmt.type === 'ReturnStatement' || stmt.type === 'BreakStatement' || stmt.type === 'ContinueStatement') {
          terminated = true;
        }
      }
    } finally {
      if (node.loc) {
        this.currentScope.endLoc = { line: node.endLoc?.line || node.loc.line + 100, column: node.endLoc?.column || 0 };
      }
      this.currentScope = prevScope;
    }
  }

  visitIfStatement(node) {
    // Constant conditional check
    if (node.condition && node.condition.type === 'BooleanLiteral') {
      if (node.condition.value === true) {
        this.warn("Condition is always true", node.condition.loc || node.loc, null, { code: 'W202' });
      } else {
        this.warn("Condition is always false — branch never executes", node.condition.loc || node.loc, null, { code: 'W203' });
      }
    }

    this.visitExpression(node.condition);

    // Type narrowing: detect patterns like typeOf(x) == "String", x != nil, x.isOk()
    const narrowing = this._extractNarrowingInfo(node.condition);

    // Visit consequent with narrowed type
    if (narrowing) {
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('block');
      const sym = this.currentScope.lookup(narrowing.varName);
      if (sym) {
        // Store narrowed type info in the scope
        const narrowedSym = new Symbol(narrowing.varName, sym.kind, null, false, sym.loc);
        narrowedSym.inferredType = narrowing.narrowedType;
        narrowedSym._narrowed = true;
        try { this.currentScope.define(narrowing.varName, narrowedSym); } catch (e) { /* already defined */ }
      }
      for (const stmt of node.consequent.body) {
        this.visitNode(stmt);
      }
      this.currentScope = prevScope;
    } else {
      this.visitNode(node.consequent);
    }

    for (const alt of node.alternates) {
      this.visitExpression(alt.condition);
      this.visitNode(alt.body);
    }

    // Visit else body with inverse narrowing
    if (node.elseBody) {
      if (narrowing && narrowing.inverseType) {
        const prevScope = this.currentScope;
        this.currentScope = this.currentScope.child('block');
        const sym = this.currentScope.lookup(narrowing.varName);
        if (sym) {
          const narrowedSym = new Symbol(narrowing.varName, sym.kind, null, false, sym.loc);
          narrowedSym.inferredType = narrowing.inverseType;
          narrowedSym._narrowed = true;
          try { this.currentScope.define(narrowing.varName, narrowedSym); } catch (e) { /* already defined */ }
        }
        for (const stmt of node.elseBody.body) {
          this.visitNode(stmt);
        }
        this.currentScope = prevScope;
      } else {
        this.visitNode(node.elseBody);
      }
    }
  }

  _extractNarrowingInfo(condition) {
    if (!condition) return null;

    // Pattern: typeOf(x) == "String"  or  typeOf(x) == "Int"
    if (condition.type === 'BinaryExpression' && condition.operator === '==') {
      const { left, right } = condition;

      // typeOf(x) == "TypeName"
      if (left.type === 'CallExpression' &&
          left.callee.type === 'Identifier' &&
          (left.callee.name === 'typeOf' || left.callee.name === 'type_of') &&
          left.arguments.length === 1 &&
          left.arguments[0].type === 'Identifier' &&
          right.type === 'StringLiteral') {
        const varName = left.arguments[0].name;
        const typeName = right.value;
        // Map JS typeof strings to Tova types
        const typeMap = { 'string': 'String', 'number': 'Int', 'boolean': 'Bool', 'function': 'Function' };
        const narrowedType = typeMap[typeName] || typeName;
        return { varName, narrowedType, inverseType: null };
      }

      // "TypeName" == typeOf(x) (reversed)
      if (right.type === 'CallExpression' &&
          right.callee.type === 'Identifier' &&
          (right.callee.name === 'typeOf' || right.callee.name === 'type_of') &&
          right.arguments.length === 1 &&
          right.arguments[0].type === 'Identifier' &&
          left.type === 'StringLiteral') {
        const varName = right.arguments[0].name;
        const typeName = left.value;
        const typeMap = { 'string': 'String', 'number': 'Int', 'boolean': 'Bool', 'function': 'Function' };
        const narrowedType = typeMap[typeName] || typeName;
        return { varName, narrowedType, inverseType: null };
      }
    }

    // Pattern: x != nil  (narrow to non-nil)
    if (condition.type === 'BinaryExpression' && condition.operator === '!=' &&
        condition.right.type === 'NilLiteral' &&
        condition.left.type === 'Identifier') {
      // Try to compute a precise narrowed type by stripping Nil from the variable's type
      const varName = condition.left.name;
      const sym = this.currentScope.lookup(varName);
      let narrowedType = 'nonnil';
      if (sym && sym.inferredType) {
        const stripped = this._stripNilFromType(sym.inferredType);
        if (stripped) narrowedType = stripped;
      }
      return { varName, narrowedType, inverseType: 'Nil' };
    }

    // Pattern: nil != x  (reversed)
    if (condition.type === 'BinaryExpression' && condition.operator === '!=' &&
        condition.left.type === 'NilLiteral' &&
        condition.right.type === 'Identifier') {
      const varName = condition.right.name;
      const sym = this.currentScope.lookup(varName);
      let narrowedType = 'nonnil';
      if (sym && sym.inferredType) {
        const stripped = this._stripNilFromType(sym.inferredType);
        if (stripped) narrowedType = stripped;
      }
      return { varName, narrowedType, inverseType: 'Nil' };
    }

    // Pattern: x == nil  (narrow to Nil in consequent, non-nil in else)
    if (condition.type === 'BinaryExpression' && condition.operator === '==' &&
        condition.right.type === 'NilLiteral' &&
        condition.left.type === 'Identifier') {
      const varName = condition.left.name;
      const sym = this.currentScope.lookup(varName);
      let inverseType = 'nonnil';
      if (sym && sym.inferredType) {
        const stripped = this._stripNilFromType(sym.inferredType);
        if (stripped) inverseType = stripped;
      }
      return { varName, narrowedType: 'Nil', inverseType };
    }

    // Pattern: x.isOk()  (narrow to Ok variant)
    if (condition.type === 'CallExpression' &&
        condition.callee.type === 'MemberExpression' &&
        condition.callee.object.type === 'Identifier' &&
        condition.callee.property === 'isOk') {
      return { varName: condition.callee.object.name, narrowedType: 'Result<Ok>', inverseType: 'Result<Err>' };
    }

    // Pattern: x.isSome()  (narrow to Some variant)
    if (condition.type === 'CallExpression' &&
        condition.callee.type === 'MemberExpression' &&
        condition.callee.object.type === 'Identifier' &&
        condition.callee.property === 'isSome') {
      return { varName: condition.callee.object.name, narrowedType: 'Option<Some>', inverseType: 'Option<None>' };
    }

    return null;
  }

  /**
   * Strip Nil from a union type string. E.g., "String | Nil" -> "String".
   * For Option types, returns the inner type.
   */
  _stripNilFromType(typeStr) {
    if (!typeStr) return null;
    // Handle union types: "String | Nil" -> "String"
    if (typeStr.includes(' | ')) {
      const parts = typeStr.split(' | ').map(p => p.trim()).filter(p => p !== 'Nil');
      if (parts.length === 0) return null;
      if (parts.length === 1) return parts[0];
      return parts.join(' | ');
    }
    // Handle Option types: "Option<String>" -> "String"
    if (typeStr.startsWith('Option<') && typeStr.endsWith('>')) {
      return typeStr.slice(7, -1);
    }
    if (typeStr === 'Option') return 'Any';
    // If not a union/option, narrowing past nil means the variable keeps its type
    return typeStr;
  }

  visitForStatement(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    if (node.label) this.currentScope._loopLabel = node.label;

    try {
      this.visitExpression(node.iterable);

      // Define loop variable(s)
      const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
      for (const v of vars) {
        try {
          this.currentScope.define(v,
            new Symbol(v, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }

      if (node.guard) {
        this.visitExpression(node.guard);
      }

      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }

    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
  }

  visitWhileStatement(node) {
    // while false is suspicious (loop body never executes)
    if (node.condition && node.condition.type === 'BooleanLiteral' && node.condition.value === false) {
      this.warn("Condition is always false — loop never executes", node.condition.loc || node.loc, null, { code: 'W203' });
    }

    this.visitExpression(node.condition);
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    if (node.label) this.currentScope._loopLabel = node.label;
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitLoopStatement(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    if (node.label) this.currentScope._loopLabel = node.label;
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitTryCatchStatement(node) {
    const prevScope = this.currentScope;

    this.currentScope = prevScope.child('block');
    try {
      for (const stmt of node.tryBody) this.visitNode(stmt);
    } finally {
      this.currentScope = prevScope;
    }

    if (node.catchBody) {
      this.currentScope = prevScope.child('block');
      try {
        if (node.catchParam) {
          this.currentScope.define(node.catchParam, new Symbol(node.catchParam, 'variable', null, false, node.loc));
        }
        for (const stmt of node.catchBody) this.visitNode(stmt);
      } finally {
        this.currentScope = prevScope;
      }
    }

    if (node.finallyBody) {
      this.currentScope = prevScope.child('block');
      try {
        for (const stmt of node.finallyBody) this.visitNode(stmt);
      } finally {
        this.currentScope = prevScope;
      }
    }
  }

  visitReturnStatement(node) {
    if (node.value) {
      this.visitExpression(node.value);
    }
    // Return must be inside a function
    if (this._functionReturnTypeStack.length === 0) {
      this.error("'return' can only be used inside a function", node.loc, null, { code: 'E301' });
      return;
    }
    // Check return type against declared function return type
    if (this._functionReturnTypeStack.length > 0) {
      const expectedReturn = this._functionReturnTypeStack[this._functionReturnTypeStack.length - 1];
      if (expectedReturn) {
        const actualType = node.value ? this._inferType(node.value) : 'Nil';
        if (!this._typesCompatible(expectedReturn, actualType)) {
          this.error(`Type mismatch: function expects return type ${expectedReturn}, but got ${actualType}`, node.loc, this._conversionHint(expectedReturn, actualType), { code: 'E101' });
        }
      }
    }
  }

  visitCompoundAssignment(node) {
    // Target must be mutable
    if (node.target.type === 'Identifier') {
      const sym = this.currentScope.lookup(node.target.name);
      if (sym && !sym.mutable && sym.kind !== 'builtin') {
        this.error(`Cannot use '${node.operator}' on immutable variable '${node.target.name}'`, node.loc, `declare with 'var' to make mutable`, { code: 'E202' });
      }
      // Type check compound assignment
      if (sym && sym.inferredType) {
        const op = node.operator;
        const numerics = new Set(['Int', 'Float']);
        if (['-=', '*=', '/='].includes(op)) {
          if (!numerics.has(sym.inferredType) && sym.inferredType !== 'Any') {
            this.strictError(`Type mismatch: '${op}' requires numeric type, but '${node.target.name}' is ${sym.inferredType}`, node.loc);
          }
          const valType = this._inferType(node.value);
          if (valType && !numerics.has(valType) && valType !== 'Any') {
            this.strictError(`Type mismatch: '${op}' requires numeric value, but got ${valType}`, node.loc);
          }
        } else if (op === '+=') {
          // += on numerics requires numeric value, on strings requires string
          if (numerics.has(sym.inferredType)) {
            const valType = this._inferType(node.value);
            if (valType && !numerics.has(valType) && valType !== 'Any') {
              this.strictError(`Type mismatch: '${op}' on numeric variable requires numeric value, but got ${valType}`, node.loc);
            }
          } else if (sym.inferredType === 'String') {
            const valType = this._inferType(node.value);
            if (valType && valType !== 'String' && valType !== 'Any') {
              this.strictError(`Type mismatch: '${op}' on String variable requires String value, but got ${valType}`, node.loc);
            }
          }
        }
      }
    }
    this.visitExpression(node.target);
    this.visitExpression(node.value);
  }

  // Client-specific visitors (visitState, visitComputed, etc.) are in client-analyzer.js (lazy-loaded)

  visitTestBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  }

  // ─── Expression visitors ──────────────────────────────────

  visitIdentifier(node) {
    if (node.name === '_') return; // wildcard is always valid
    if (node.name === PIPE_TARGET) return; // pipe target placeholder from method pipe

    // Common mistake: using `throw` (not a Tova keyword)
    if (node.name === 'throw') {
      this.warn("'throw' is not a Tova keyword — use Result for error handling, e.g. Err(\"message\")", node.loc, "try Err(value) instead of throw", { code: 'W206' });
      return;
    }

    const sym = this.currentScope.lookup(node.name);
    if (!sym) {
      if (!this._isKnownGlobal(node.name)) {
        const suggestion = this._findClosestMatch(node.name);
        const hint = suggestion ? `did you mean '${suggestion}'?` : null;
        const fixOpts = { code: 'E200', length: node.name.length };
        if (suggestion) fixOpts.fix = { description: `Replace with '${suggestion}'`, replacement: suggestion };
        this.warn(`'${node.name}' is not defined`, node.loc, hint, fixOpts);
      }
    } else {
      sym.used = true;
    }
  }

  _isKnownGlobal(name) {
    // Tova stdlib (auto-synced from BUILTIN_FUNCTIONS in inline.js)
    if (BUILTIN_NAMES.has(name)) return true;

    // Tova runtime names
    if (_TOVA_RUNTIME.has(name)) return true;

    // JS globals / platform APIs
    return _JS_GLOBALS.has(name);
  }

  _findClosestMatch(name) {
    const candidates = [];
    // Collect scope symbols (these change per call)
    let scope = this.currentScope;
    while (scope) {
      for (const n of scope.symbols.keys()) candidates.push(n);
      scope = scope.parent;
    }

    let best = null;
    let bestDist = Infinity;
    const maxDist = Math.max(2, Math.floor(name.length * 0.4));
    const nameLower = name.toLowerCase();

    // Check scope symbols first
    for (let i = 0; i < candidates.length; i++) {
      const c = candidates[i];
      if (Math.abs(c.length - name.length) > maxDist) continue;
      const d = levenshtein(nameLower, c.toLowerCase());
      if (d < bestDist && d <= maxDist && d > 0) {
        bestDist = d;
        best = c;
      }
    }

    // Check static global names (BUILTIN_NAMES, _JS_GLOBALS, _TOVA_RUNTIME)
    const staticNames = _getStaticSuggestionNames();
    for (let i = 0; i < staticNames.length; i++) {
      const c = staticNames[i];
      if (Math.abs(c.length - name.length) > maxDist) continue;
      const d = levenshtein(nameLower, c.toLowerCase());
      if (d < bestDist && d <= maxDist && d > 0) {
        bestDist = d;
        best = c;
      }
    }
    return best;
  }

  _conversionHint(expected, actual) {
    if (!expected || !actual) return null;
    const key = `${actual}->${expected}`;
    const hints = {
      'Int->String': "try toString(value) to convert",
      'Float->String': "try toString(value) to convert",
      'Bool->String': "try toString(value) to convert",
      'String->Int': "try toInt(value) to parse",
      'String->Float': "try toFloat(value) to parse",
      'Float->Int': "try floor(value) or round(value) to convert",
    };
    if (hints[key]) return hints[key];
    if (expected.startsWith('Result')) return "try Ok(value) to wrap in Result";
    if (expected.startsWith('Option')) return "try Some(value) to wrap in Option";
    return null;
  }

  visitLambda(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');

    const expectedReturn = node.returnType ? this._typeAnnotationToString(node.returnType) : null;
    this._functionReturnTypeStack.push(expectedReturn);
    const prevAsyncDepth = this._asyncDepth;
    if (node.isAsync) {
      this._asyncDepth++;
    } else {
      this._asyncDepth = 0; // Non-async lambda resets async context
    }

    try {
      for (const param of node.params) {
        try {
          const paramSym = new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc);
          paramSym.inferredType = param.typeAnnotation ? this._typeAnnotationToString(param.typeAnnotation) : null;
          this.currentScope.define(param.name, paramSym);
        } catch (e) {
          this.error(e.message);
        }
      }
      if (node.body.type === 'BlockStatement') {
        this.visitNode(node.body);
        // Return path analysis for lambdas with block bodies and declared return types
        if (expectedReturn && !this._definitelyReturns(node.body)) {
          this.warn(`Lambda declares return type ${expectedReturn} but not all code paths return a value`, node.loc, null, { code: 'W205' });
        }
      } else {
        // Single-expression body — always returns implicitly
        this.visitExpression(node.body);
      }
    } finally {
      this._asyncDepth = prevAsyncDepth;
      this._functionReturnTypeStack.pop();
      this.currentScope = prevScope;
    }
  }

  visitMatchExpression(node) {
    this.visitExpression(node.subject);
    let catchAllSeen = false;
    for (const arm of node.arms) {
      // Warn about unreachable arms after catch-all
      if (catchAllSeen) {
        this.warn("Unreachable match arm after catch-all pattern", arm.pattern.loc || arm.body.loc || node.loc, null, { code: 'W207' });
        continue; // Still visit remaining arms for completeness but skip analysis
      }

      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('block');

      try {
        this.visitPattern(arm.pattern);
        if (arm.guard) this.visitExpression(arm.guard);

        if (arm.body.type === 'BlockStatement') {
          this.visitNode(arm.body);
        } else {
          this.visitExpression(arm.body);
        }
      } finally {
        this.currentScope = prevScope;
      }

      // Check if this arm is a catch-all (wildcard or unguarded binding)
      if ((arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') && !arm.guard) {
        catchAllSeen = true;
      }
    }

    // Exhaustive match checking (#12)
    this._checkMatchExhaustiveness(node);
  }

  _checkMatchExhaustiveness(node) {
    // Check if the match has a wildcard/binding catch-all
    const hasWildcard = node.arms.some(arm =>
      arm.pattern.type === 'WildcardPattern' ||
      (arm.pattern.type === 'BindingPattern' && !arm.guard)
    );
    if (hasWildcard) return; // Catch-all exists, always exhaustive

    // Try to resolve the subject type for better checking
    let subjectType = null;
    if (node.subject) {
      const subjectTypeStr = this._inferType(node.subject);
      if (subjectTypeStr) {
        // Look up type structure from type registry
        const typeStructure = this.typeRegistry.types.get(subjectTypeStr);
        if (typeStructure instanceof ADTType) {
          subjectType = typeStructure;
        }
      }
      // Also try to find type from identifier
      if (!subjectType && node.subject.type === 'Identifier') {
        const sym = this.currentScope.lookup(node.subject.name);
        if (sym && sym.inferredType) {
          const typeStructure = this.typeRegistry.types.get(sym.inferredType);
          if (typeStructure instanceof ADTType) {
            subjectType = typeStructure;
          }
        }
      }
    }

    const variantNames = new Set();
    const coveredVariants = new Set();

    // Collect all variant patterns used in the match
    for (const arm of node.arms) {
      if (arm.pattern.type === 'VariantPattern') {
        coveredVariants.add(arm.pattern.name);
      }
    }

    // If we have variant patterns, check if all known variants are covered
    if (coveredVariants.size > 0) {
      // If we have the ADT type structure, use it for precise checking
      if (subjectType) {
        const allVariants = subjectType.getVariantNames();
        for (const v of allVariants) {
          if (!coveredVariants.has(v)) {
            this.warn(`Non-exhaustive match: missing '${v}' variant from type '${subjectType.name}'`, node.loc, `add a '${v}' arm or use '_ =>' as a catch-all`, { code: 'W200' });
          }
        }
        return; // Done — used precise ADT checking
      }

      // Check built-in Result/Option types
      if (coveredVariants.has('Ok') || coveredVariants.has('Err')) {
        if (!coveredVariants.has('Ok')) {
          this.warn(`Non-exhaustive match: missing 'Ok' variant`, node.loc, "add an 'Ok(value) =>' arm", { code: 'W200' });
        }
        if (!coveredVariants.has('Err')) {
          this.warn(`Non-exhaustive match: missing 'Err' variant`, node.loc, "add an 'Err(e) =>' arm", { code: 'W200' });
        }
      }
      if (coveredVariants.has('Some') || coveredVariants.has('None')) {
        if (!coveredVariants.has('Some')) {
          this.warn(`Non-exhaustive match: missing 'Some' variant`, node.loc, "add a 'Some(value) =>' arm", { code: 'W200' });
        }
        if (!coveredVariants.has('None')) {
          this.warn(`Non-exhaustive match: missing 'None' variant`, node.loc, "add a 'None =>' arm", { code: 'W200' });
        }
      }

      // Check user-defined types — find the single best-matching type whose variants
      // contain ALL covered variant names (avoids false positives with shared names)
      const candidates = [];
      this._collectTypeCandidates(this.ast.body, coveredVariants, candidates);

      let matched = null;
      if (candidates.length === 1) {
        matched = candidates[0];
      } else if (candidates.length > 1) {
        // Disambiguate using subject's inferred type name
        let subjectTypeName = null;
        if (node.subject) {
          subjectTypeName = this._inferType(node.subject);
          if (!subjectTypeName && node.subject.type === 'Identifier') {
            const sym = this.currentScope.lookup(node.subject.name);
            if (sym) subjectTypeName = sym.inferredType;
          }
        }
        if (subjectTypeName) {
          const exact = candidates.find(([name]) => name === subjectTypeName);
          if (exact) matched = exact;
        }
      }

      if (matched) {
        const [typeName, typeVariants] = matched;
        for (const v of typeVariants) {
          if (!coveredVariants.has(v)) {
            this.warn(`Non-exhaustive match: missing '${v}' variant from type '${typeName}'`, node.loc, `add a '${v}' arm or use '_ =>' as a catch-all`, { code: 'W200' });
          }
        }
      }
    }
  }

  // Check if a match expression covers all variants without a wildcard (for return path analysis)
  _isMatchExhaustive(node) {
    const coveredVariants = new Set();
    for (const arm of node.arms) {
      if (arm.pattern.type === 'VariantPattern') {
        coveredVariants.add(arm.pattern.name);
      }
    }
    if (coveredVariants.size === 0) return false;

    // Check subject's inferred type
    if (node.subject) {
      const subjectTypeStr = this._inferType(node.subject);
      if (subjectTypeStr) {
        const typeStructure = this.typeRegistry.types.get(subjectTypeStr);
        if (typeStructure instanceof ADTType) {
          return typeStructure.getVariantNames().every(v => coveredVariants.has(v));
        }
      }
      if (node.subject.type === 'Identifier') {
        const sym = this.currentScope.lookup(node.subject.name);
        if (sym && sym.inferredType) {
          const typeStructure = this.typeRegistry.types.get(sym.inferredType);
          if (typeStructure instanceof ADTType) {
            return typeStructure.getVariantNames().every(v => coveredVariants.has(v));
          }
        }
      }
    }

    // Built-in Result type
    if ((coveredVariants.has('Ok') || coveredVariants.has('Err')) &&
        coveredVariants.has('Ok') && coveredVariants.has('Err')) return true;
    // Built-in Option type
    if ((coveredVariants.has('Some') || coveredVariants.has('None')) &&
        coveredVariants.has('Some') && coveredVariants.has('None')) return true;

    // Fallback: check user-defined types
    const candidates = [];
    this._collectTypeCandidates(this.ast.body, coveredVariants, candidates);

    let matched = null;
    if (candidates.length === 1) {
      matched = candidates[0];
    } else if (candidates.length > 1 && node.subject) {
      // Disambiguate using subject's inferred type name
      let subjectTypeName = this._inferType(node.subject);
      if (!subjectTypeName && node.subject.type === 'Identifier') {
        const sym = this.currentScope.lookup(node.subject.name);
        if (sym) subjectTypeName = sym.inferredType;
      }
      if (subjectTypeName) {
        const exact = candidates.find(([name]) => name === subjectTypeName);
        if (exact) matched = exact;
      }
    }

    if (matched) {
      const [, typeVariants] = matched;
      return typeVariants.every(v => coveredVariants.has(v));
    }
    return false;
  }

  _collectTypeCandidates(nodes, coveredVariants, candidates) {
    for (const node of nodes) {
      if (node.type === 'TypeDeclaration') {
        const typeVariants = node.variants.filter(v => v.type === 'TypeVariant').map(v => v.name);
        if (typeVariants.length === 0) continue;
        // All covered variants must be contained in this type's variants
        const allCovered = [...coveredVariants].every(v => typeVariants.includes(v));
        if (allCovered) {
          candidates.push([node.name, typeVariants]);
        }
      }
      if (node.type === 'SharedBlock' || node.type === 'ServerBlock' || node.type === 'ClientBlock') {
        this._collectTypeCandidates(node.body, coveredVariants, candidates);
      }
    }
  }

  visitPattern(pattern) {
    if (!pattern) return;

    switch (pattern.type) {
      case 'WildcardPattern':
      case 'LiteralPattern':
      case 'RangePattern':
        break;
      case 'BindingPattern':
        try {
          this.currentScope.define(pattern.name,
            new Symbol(pattern.name, 'variable', null, false, pattern.loc));
        } catch (e) {
          this.error(e.message);
        }
        break;
      case 'VariantPattern':
        for (const field of pattern.fields) {
          if (typeof field === 'string') {
            // Legacy: plain string field names
            try {
              this.currentScope.define(field,
                new Symbol(field, 'variable', null, false, pattern.loc));
            } catch (e) {
              this.error(e.message);
            }
          } else {
            // Nested pattern (e.g., Some(Ok(value)))
            this.visitPattern(field);
          }
        }
        break;
      case 'ArrayPattern':
      case 'TuplePattern':
        if (pattern.elements) {
          for (const el of pattern.elements) {
            this.visitPattern(el);
          }
        }
        break;
      case 'StringConcatPattern':
        if (pattern.rest) {
          this.visitPattern(pattern.rest);
        }
        break;
    }
  }

  visitListComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    try {
      this.visitExpression(node.iterable);
      try {
        this.currentScope.define(node.variable,
          new Symbol(node.variable, 'variable', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
      if (node.condition) this.visitExpression(node.condition);
      this.visitExpression(node.expression);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitDictComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    try {
      this.visitExpression(node.iterable);
      for (const v of node.variables) {
        try {
          this.currentScope.define(v,
            new Symbol(v, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
      if (node.condition) this.visitExpression(node.condition);
      this.visitExpression(node.key);
      this.visitExpression(node.value);
    } finally {
      this.currentScope = prevScope;
    }
  }

  // visitJSXElement, visitJSXFragment, visitJSXFor, visitJSXIf are in client-analyzer.js (lazy-loaded)

  // ─── New feature visitors ─────────────────────────────────

  visitBreakStatement(node) {
    if (!this._isInsideLoop()) {
      this.error("'break' can only be used inside a loop", node.loc);
    } else if (node.label && !this._isLabelInScope(node.label)) {
      this.error(`'break ${node.label}' references undefined label '${node.label}'`, node.loc);
    }
  }

  visitContinueStatement(node) {
    if (!this._isInsideLoop()) {
      this.error("'continue' can only be used inside a loop", node.loc);
    } else if (node.label && !this._isLabelInScope(node.label)) {
      this.error(`'continue ${node.label}' references undefined label '${node.label}'`, node.loc);
    }
  }

  _definitelyReturns(node) {
    if (!node) return false;
    switch (node.type) {
      case 'ReturnStatement':
        return true;
      case 'BlockStatement':
        if (node.body.length === 0) return false;
        // Any statement that definitely returns makes the block definitely return
        return node.body.some(stmt => this._definitelyReturns(stmt));
      case 'IfStatement':
        if (!node.elseBody) return false;
        const consequentReturns = this._definitelyReturns(node.consequent);
        const elseReturns = this._definitelyReturns(node.elseBody);
        const allAlternatesReturn = (node.alternates || []).every(alt => this._definitelyReturns(alt.body));
        return consequentReturns && elseReturns && allAlternatesReturn;
      case 'GuardStatement':
        // Guard only handles the failure case — when condition is true, execution falls through
        // A guard alone never guarantees return on ALL paths
        return false;
      case 'MatchExpression': {
        const hasWildcard = node.arms.some(arm =>
          arm.pattern.type === 'WildcardPattern' ||
          (arm.pattern.type === 'BindingPattern' && !arm.guard)
        );
        const isExhaustive = hasWildcard || this._isMatchExhaustive(node);
        if (!isExhaustive) return false;
        // Match arms with expression bodies (not block statements) are implicit returns
        return node.arms.every(arm =>
          arm.body.type !== 'BlockStatement' || this._definitelyReturns(arm.body)
        );
      }
      case 'TryCatchStatement': {
        const tryReturns = node.tryBody.length > 0 &&
          node.tryBody.some(s => this._definitelyReturns(s));
        const catchReturns = !node.catchBody || (node.catchBody.length > 0 &&
          node.catchBody.some(s => this._definitelyReturns(s)));
        return tryReturns && catchReturns;
      }
      case 'ExpressionStatement':
        return this._definitelyReturns(node.expression);
      case 'CallExpression':
        return false;
      default:
        return false;
    }
  }

  _checkCallArgCount(node) {
    if (node.callee.type !== 'Identifier') return;
    const fnSym = this.currentScope.lookup(node.callee.name);
    if (!fnSym || fnSym.kind === 'builtin' || fnSym._totalParamCount === undefined) return;

    // Skip check if any argument uses spread (unknown count)
    const hasSpread = node.arguments.some(a => a.type === 'SpreadExpression');
    if (hasSpread) return;

    // Named arguments are collapsed into a single object at codegen
    const hasNamedArgs = node.arguments.some(a => a.type === 'NamedArgument');
    if (hasNamedArgs) {
      const positionalCount = node.arguments.filter(a => a.type !== 'NamedArgument').length;
      var actualCount = positionalCount + 1; // named args become one object
    } else {
      var actualCount = node.arguments.length;
    }
    const name = node.callee.name;

    if (actualCount > fnSym._totalParamCount) {
      this.strictError(`'${name}' expects ${fnSym._totalParamCount} argument${fnSym._totalParamCount !== 1 ? 's' : ''}, but got ${actualCount}`, node.loc);
    } else if (actualCount < fnSym._requiredParamCount) {
      this.strictError(`'${name}' expects at least ${fnSym._requiredParamCount} argument${fnSym._requiredParamCount !== 1 ? 's' : ''}, but got ${actualCount}`, node.loc);
    }
  }

  _checkCallArgTypes(node) {
    if (node.callee.type !== 'Identifier') return;
    const fnSym = this.currentScope.lookup(node.callee.name);
    if (!fnSym || fnSym.kind === 'builtin' || !fnSym._paramTypes) return;

    const hasSpread = node.arguments.some(a => a.type === 'SpreadExpression');
    if (hasSpread) return;

    // Infer type parameter bindings from arguments for generic functions
    const typeParamBindings = new Map();
    if (fnSym._typeParams && fnSym._typeParams.length > 0) {
      for (let i = 0; i < node.arguments.length && i < fnSym._paramTypes.length; i++) {
        const arg = node.arguments[i];
        if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
        const paramTypeAnn = fnSym._paramTypes[i];
        if (!paramTypeAnn) continue;
        const actualType = this._inferType(arg);
        if (actualType) {
          this._inferTypeParamBindings(paramTypeAnn, actualType, fnSym._typeParams, typeParamBindings);
        }
      }
    }

    for (let i = 0; i < node.arguments.length && i < fnSym._paramTypes.length; i++) {
      const arg = node.arguments[i];
      if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
      const paramTypeAnn = fnSym._paramTypes[i];
      if (!paramTypeAnn) continue;
      let expectedType = this._typeAnnotationToString(paramTypeAnn);
      // Substitute type parameters with inferred bindings
      if (typeParamBindings.size > 0) {
        expectedType = this._substituteTypeParams(expectedType, typeParamBindings);
      }
      // Skip check if expected type is still a bare type parameter (couldn't infer)
      if (fnSym._typeParams && fnSym._typeParams.includes(expectedType)) continue;
      const actualType = this._inferType(arg);
      if (!this._typesCompatible(expectedType, actualType)) {
        const paramName = fnSym._params ? fnSym._params[i] : `argument ${i + 1}`;
        this.error(`Type mismatch: '${paramName}' expects ${expectedType}, but got ${actualType}`, arg.loc || node.loc, this._conversionHint(expectedType, actualType));
      }
    }
  }

  /**
   * Infer type parameter bindings by matching a type annotation against an actual type string.
   * E.g., matching param annotation `T` against actual `Int` binds T=Int.
   * Matching `[T]` against `[Int]` binds T=Int.
   */
  _inferTypeParamBindings(ann, actualType, typeParams, bindings) {
    if (!ann || !actualType) return;
    const annStr = typeof ann === 'string' ? ann : (ann.type === 'TypeAnnotation' ? ann.name : null);
    if (!annStr) return;

    // Direct type parameter match: T -> Int
    if (typeParams.includes(annStr) && !bindings.has(annStr)) {
      bindings.set(annStr, actualType);
      return;
    }

    // Array type: [T] -> [Int]
    if (ann.type === 'ArrayTypeAnnotation' && actualType.startsWith('[') && actualType.endsWith(']')) {
      const innerActual = actualType.slice(1, -1);
      this._inferTypeParamBindings(ann.elementType, innerActual, typeParams, bindings);
      return;
    }

    // Generic type: Result<T, E> -> Result<Int, String>
    if (ann.type === 'TypeAnnotation' && ann.typeParams && ann.typeParams.length > 0) {
      const parsed = this._parseGenericType(actualType);
      if (parsed.base === ann.name && parsed.params.length === ann.typeParams.length) {
        for (let i = 0; i < ann.typeParams.length; i++) {
          this._inferTypeParamBindings(ann.typeParams[i], parsed.params[i], typeParams, bindings);
        }
      }
    }
  }

  /**
   * Substitute type parameter names in a type string with their inferred bindings.
   */
  _substituteTypeParams(typeStr, bindings) {
    if (!typeStr || bindings.size === 0) return typeStr;
    // Direct match
    if (bindings.has(typeStr)) return bindings.get(typeStr);
    // Array type
    if (typeStr.startsWith('[') && typeStr.endsWith(']')) {
      const inner = typeStr.slice(1, -1);
      return `[${this._substituteTypeParams(inner, bindings)}]`;
    }
    // Generic type
    const parsed = this._parseGenericType(typeStr);
    if (parsed.params.length > 0) {
      const substituted = parsed.params.map(p => this._substituteTypeParams(p, bindings));
      return `${parsed.base}<${substituted.join(', ')}>`;
    }
    return typeStr;
  }

  /**
   * Resolve a type alias to its underlying type string.
   * E.g., if `type UserList = [User]`, resolves 'UserList' -> '[User]'.
   * For generic aliases like `type Callback<T> = fn(T) -> Result<T, String>`,
   * resolves 'Callback<Int>' by substituting T=Int.
   */
  _resolveTypeAlias(typeStr) {
    if (!typeStr) return typeStr;
    const parsed = this._parseGenericType(typeStr);
    const baseName = parsed.params.length > 0 ? parsed.base : typeStr;

    // Look up the type in scope
    const sym = this.currentScope.lookup(baseName);
    if (!sym || sym.kind !== 'type' || !sym._typeAliasExpr) return typeStr;

    // Resolve the alias
    let resolved = this._typeAnnotationToString(sym._typeAliasExpr);
    if (!resolved) return typeStr;

    // Substitute type parameters if the alias is generic
    if (sym._typeParams && sym._typeParams.length > 0 && parsed.params.length > 0) {
      const bindings = new Map();
      for (let i = 0; i < sym._typeParams.length && i < parsed.params.length; i++) {
        bindings.set(sym._typeParams[i], parsed.params[i]);
      }
      resolved = this._substituteTypeParams(resolved, bindings);
    }

    return resolved;
  }

  _checkBinaryExprTypes(node) {
    const op = node.operator;
    const leftType = this._inferType(node.left);
    const rightType = this._inferType(node.right);

    if (op === '++') {
      // String concatenation: both sides should be String
      if (leftType && leftType !== 'String' && leftType !== 'Any') {
        this.strictError(`Type mismatch: '++' expects String on left side, but got ${leftType}`, node.loc, "try toString(value) to convert");
      }
      if (rightType && rightType !== 'String' && rightType !== 'Any') {
        this.strictError(`Type mismatch: '++' expects String on right side, but got ${rightType}`, node.loc, "try toString(value) to convert");
      }
    } else if (ARITHMETIC_OPS.has(op)) {
      // String literal * Int is valid (string repeat) — skip warning for that case
      if (op === '*') {
        const leftIsStr = node.left.type === 'StringLiteral' || node.left.type === 'TemplateLiteral';
        const rightIsStr = node.right.type === 'StringLiteral' || node.right.type === 'TemplateLiteral';
        if (leftIsStr || rightIsStr) return;
      }
      // Arithmetic: both sides must be numeric
      if (leftType && !NUMERIC_TYPES.has(leftType) && leftType !== 'Any') {
        const hint = leftType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '${op}' expects numeric type, but got ${leftType}`, node.loc, hint);
      }
      if (rightType && !NUMERIC_TYPES.has(rightType) && rightType !== 'Any') {
        const hint = rightType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '${op}' expects numeric type, but got ${rightType}`, node.loc, hint);
      }
    } else if (op === '+') {
      // Addition: both sides must be numeric (Tova uses ++ for strings)
      if (leftType && !NUMERIC_TYPES.has(leftType) && leftType !== 'Any') {
        const hint = leftType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '+' expects numeric type, but got ${leftType}`, node.loc, hint);
      }
      if (rightType && !NUMERIC_TYPES.has(rightType) && rightType !== 'Any') {
        const hint = rightType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '+' expects numeric type, but got ${rightType}`, node.loc, hint);
      }
    }
  }

  // Search for a variable from current scope up to the nearest function/module boundary.
  // This ensures `x = 20` inside an if/for block finds `x = 10` from the enclosing function,
  // preventing silent shadowing of immutable bindings within the same function.
  _lookupAssignTarget(name) {
    let scope = this.currentScope;
    while (scope) {
      const sym = scope.symbols.get(name);
      if (sym) return sym;
      // Stop after checking a function or top-level scope (don't cross function boundaries)
      if (scope.context === 'function' || scope.context === 'module' ||
          scope.context === 'server' || scope.context === 'client' || scope.context === 'shared') {
        break;
      }
      scope = scope.parent;
    }
    return null;
  }

  // Check if a name exists in any outer scope beyond the current function boundary.
  // Used to warn about shadowing of outer variables.
  _existsInOuterScope(name) {
    let scope = this.currentScope;
    let crossedBoundary = false;
    while (scope) {
      if (!crossedBoundary && (scope.context === 'function' || scope.context === 'module' ||
          scope.context === 'server' || scope.context === 'client' || scope.context === 'shared')) {
        crossedBoundary = true;
        scope = scope.parent;
        continue;
      }
      if (crossedBoundary) {
        const sym = scope.symbols.get(name);
        if (sym && sym.kind !== 'builtin') return true;
      }
      scope = scope.parent;
    }
    return false;
  }

  pushScope(context) {
    this.currentScope = this.currentScope.child(context);
  }

  popScope() {
    this.currentScope = this.currentScope.parent;
  }

  _isInsideLoop() {
    // Walk up the AST context — check if any parent is a for/while loop scope
    // Stop at function boundaries so break/continue inside lambdas is rejected
    let scope = this.currentScope;
    while (scope) {
      if (scope._isLoop) return true;
      if (scope.context === 'function') return false;
      scope = scope.parent;
    }
    return false;
  }

  _isLabelInScope(label) {
    // Walk up scopes to find a matching loop label
    let scope = this.currentScope;
    while (scope) {
      if (scope._isLoop && scope._loopLabel === label) return true;
      if (scope.context === 'function') return false;
      scope = scope.parent;
    }
    return false;
  }

  visitGuardStatement(node) {
    this.visitExpression(node.condition);
    this.visitNode(node.elseBody);

    // Type narrowing after guard: guard x != nil else { return }
    // The condition being true means x is non-nil for the rest of the scope
    const narrowing = this._extractNarrowingInfo(node.condition);
    if (narrowing) {
      const sym = this.currentScope.lookup(narrowing.varName);
      if (sym) {
        // Narrow the variable in the current scope (not a new child scope)
        const narrowedSym = new Symbol(narrowing.varName, sym.kind, null, sym.mutable, sym.loc);
        narrowedSym.inferredType = narrowing.narrowedType;
        narrowedSym._narrowed = true;
        narrowedSym.used = sym.used;
        // Replace in current scope so the rest of the function sees the narrowed type
        this.currentScope.symbols.set(narrowing.varName, narrowedSym);
      }
    }
  }

  visitInterfaceDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'type', null, false, node.loc);
      // Store method signatures for conformance checking
      sym._interfaceMethods = (node.methods || []).map(m => ({
        name: m.name,
        paramTypes: (m.params || []).map(p => typeAnnotationToType(p.typeAnnotation)),
        returnType: typeAnnotationToType(m.returnType),
        paramCount: (m.params || []).filter(p => p.name !== 'self').length,
      }));
      this.currentScope.define(node.name, sym);

      // Register in type registry for LSP
      this.typeRegistry.traits.set(node.name, sym._interfaceMethods);
    } catch (e) {
      this.error(e.message);
    }
  }

  visitImplDeclaration(node) {
    // Collect provided method names for conformance checking
    const providedMethods = new Map();
    for (const method of node.methods) {
      providedMethods.set(method.name, {
        paramCount: (method.params || []).filter(p => p.name !== 'self').length,
        returnType: method.returnType ? typeAnnotationToType(method.returnType) : null,
      });
    }

    // Register impl methods in type registry for LSP
    const typeName = node.typeName || node.target;
    if (typeName) {
      const existingImpls = this.typeRegistry.impls.get(typeName) || [];
      for (const method of node.methods) {
        existingImpls.push({
          name: method.name,
          params: (method.params || []).map(p => p.name),
          paramTypes: (method.params || []).map(p => typeAnnotationToType(p.typeAnnotation)),
          returnType: typeAnnotationToType(method.returnType),
        });
      }
      this.typeRegistry.impls.set(typeName, existingImpls);
    }

    // Trait/interface conformance checking
    if (node.traitName) {
      const traitSym = this.currentScope.lookup(node.traitName);
      if (traitSym && traitSym._interfaceMethods) {
        for (const required of traitSym._interfaceMethods) {
          const provided = providedMethods.get(required.name);
          if (!provided) {
            this.warn(`Impl for '${typeName || 'type'}' missing required method '${required.name}' from trait '${node.traitName}'`, node.loc, null, { code: 'W300' });
          } else {
            // Check parameter count matches (excluding self)
            if (required.paramCount > 0 && provided.paramCount !== required.paramCount) {
              this.warn(`Method '${required.name}' in impl for '${typeName}' has ${provided.paramCount} parameters, but trait '${node.traitName}' expects ${required.paramCount}`, node.loc, null, { code: 'W301' });
            }
            // Check return type matches if both are annotated
            if (required.returnType && provided.returnType) {
              if (!provided.returnType.isAssignableTo(required.returnType)) {
                this.warn(`Method '${required.name}' return type mismatch in impl for '${typeName}': expected ${required.returnType}, got ${provided.returnType}`, node.loc, null, { code: 'W302' });
              }
            }
          }
        }
      }
    }

    // Validate that methods reference the type
    for (const method of node.methods) {
      this.pushScope('function');
      try {
        // self is implicitly available
        try {
          this.currentScope.define('self',
            new Symbol('self', 'variable', null, true, method.loc));
        } catch (e) { /* ignore */ }
        for (const p of method.params) {
          if (p.name && p.name !== 'self') {
            try {
              this.currentScope.define(p.name,
                new Symbol(p.name, 'variable', null, false, p.loc));
            } catch (e) { /* ignore */ }
          }
        }
        if (method.body) {
          this.visitBlock(method.body);
        }
      } finally {
        this.popScope();
      }
    }
  }

  visitTraitDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'type', null, false, node.loc);
      // Store method signatures for conformance checking
      sym._interfaceMethods = (node.methods || []).map(m => ({
        name: m.name,
        paramTypes: (m.params || []).map(p => typeAnnotationToType(p.typeAnnotation)),
        returnType: typeAnnotationToType(m.returnType),
        paramCount: (m.params || []).filter(p => p.name !== 'self').length,
      }));
      this.currentScope.define(node.name, sym);

      // Register in type registry for LSP
      this.typeRegistry.traits.set(node.name, sym._interfaceMethods);
    } catch (e) {
      this.error(e.message);
    }
    // Visit default implementations
    for (const method of node.methods) {
      if (method.body) {
        this.pushScope('function');
        try {
          for (const p of method.params) {
            if (p.name) {
              try {
                this.currentScope.define(p.name,
                  new Symbol(p.name, 'variable', null, false, p.loc || node.loc));
              } catch (e) { /* ignore */ }
            }
          }
          this.visitBlock(method.body);
        } finally {
          this.popScope();
        }
      }
    }
  }

  visitTypeAlias(node) {
    try {
      const typeSym = new Symbol(node.name, 'type', null, false, node.loc);
      // Store type alias info for resolution
      if (node.typeExpr) {
        typeSym._typeAliasExpr = node.typeExpr;
        typeSym._typeParams = node.typeParams || [];
        const resolved = typeAnnotationToType(node.typeExpr);
        if (resolved) {
          typeSym._typeStructure = resolved;
          this.typeRegistry.types.set(node.name, resolved);
        }
      }
      this.currentScope.define(node.name, typeSym);
    } catch (e) {
      this.error(e.message);
    }
  }

  visitDeferStatement(node) {
    // Validate defer is inside a function
    let scope = this.currentScope;
    let insideFunction = false;
    while (scope) {
      if (scope.context === 'function') {
        insideFunction = true;
        break;
      }
      scope = scope.parent;
    }
    if (!insideFunction) {
      this.warn("'defer' used outside of a function", node.loc, null, { code: 'W208' });
    }
    if (node.body) {
      if (node.body.type === 'BlockStatement') {
        this.visitBlock(node.body);
      } else {
        this.visitExpression(node.body);
      }
    }
  }
}

// ─── src/stdlib/inline.js ──────────────────────────────

// Tova standard library — inline string versions for codegen
// Single source of truth for all inline stdlib code used in code generation.
// Used by: base-codegen.js, client-codegen.js, bin/tova.js
const RESULT_OPTION = `class _Ok { constructor(value) { this.value = value; } }
_Ok.prototype.__tag = "Ok";
_Ok.prototype.map = function(fn) { return new _Ok(fn(this.value)); };
_Ok.prototype.flatMap = function(fn) { const r = fn(this.value); if (r && r.__tag) return r; throw new Error("flatMap callback must return Ok/Err"); };
_Ok.prototype.andThen = _Ok.prototype.flatMap;
_Ok.prototype.unwrap = function() { return this.value; };
_Ok.prototype.unwrapOr = function(_) { return this.value; };
_Ok.prototype.expect = function(_) { return this.value; };
_Ok.prototype.isOk = function() { return true; };
_Ok.prototype.isErr = function() { return false; };
_Ok.prototype.mapErr = function(_) { return this; };
_Ok.prototype.unwrapErr = function() { throw new Error("Called unwrapErr on Ok"); };
_Ok.prototype.or = function(_) { return this; };
_Ok.prototype.and = function(other) { return other; };
_Ok.prototype.context = function(_) { return this; };
function Ok(value) { return new _Ok(value); }
class _Err { constructor(error) { this.error = error; } }
_Err.prototype.__tag = "Err";
_Err.prototype.map = function(_) { return this; };
_Err.prototype.flatMap = function(_) { return this; };
_Err.prototype.andThen = _Err.prototype.flatMap;
_Err.prototype.unwrap = function() { throw new Error("Called unwrap on Err: " + (typeof this.error === "object" ? JSON.stringify(this.error) : this.error)); };
_Err.prototype.unwrapOr = function(def) { return def; };
_Err.prototype.expect = function(msg) { throw new Error(msg); };
_Err.prototype.isOk = function() { return false; };
_Err.prototype.isErr = function() { return true; };
_Err.prototype.mapErr = function(fn) { return new _Err(fn(this.error)); };
_Err.prototype.unwrapErr = function() { return this.error; };
_Err.prototype.or = function(other) { return other; };
_Err.prototype.and = function(_) { return this; };
_Err.prototype.context = function(msg) { const inner = typeof this.error === "object" ? JSON.stringify(this.error) : String(this.error); return new _Err(msg + " \\u2192 caused by: " + inner); };
function Err(error) { return new _Err(error); }
class _Some { constructor(value) { this.value = value; } }
_Some.prototype.__tag = "Some";
_Some.prototype.map = function(fn) { return new _Some(fn(this.value)); };
_Some.prototype.flatMap = function(fn) { const r = fn(this.value); if (r && r.__tag) return r; throw new Error("flatMap callback must return Some/None"); };
_Some.prototype.andThen = _Some.prototype.flatMap;
_Some.prototype.unwrap = function() { return this.value; };
_Some.prototype.unwrapOr = function(_) { return this.value; };
_Some.prototype.expect = function(_) { return this.value; };
_Some.prototype.isSome = function() { return true; };
_Some.prototype.isNone = function() { return false; };
_Some.prototype.or = function(_) { return this; };
_Some.prototype.and = function(other) { return other; };
_Some.prototype.filter = function(pred) { return pred(this.value) ? this : None; };
function Some(value) { return new _Some(value); }
const None = Object.freeze({ __tag: "None", map(_) { return None; }, flatMap(_) { return None; }, andThen(_) { return None; }, unwrap() { throw new Error("Called unwrap on None"); }, unwrapOr(def) { return def; }, expect(msg) { throw new Error(msg); }, isSome() { return false; }, isNone() { return true; }, or(other) { return other; }, and(_) { return None; }, filter(_) { return None; } });`;
const PROPAGATE = `function __propagate(val) {
  if (val && val.__tag === "Err") throw { __tova_propagate: true, value: val };
  if (val && val.__tag === "None") throw { __tova_propagate: true, value: val };
  if (val && val.__tag === "Ok") return val.value;
  if (val && val.__tag === "Some") return val.value;
  return val;
}`;

// Individual builtin functions for tree-shaking
const BUILTIN_FUNCTIONS = {
  print: `function print(...args) { console.log(...args); }`,
  len: `function len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v) || ArrayBuffer.isView(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }`,
  range: `function range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; if (st === 0) return []; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }`,
  enumerate: `function enumerate(a) { return a.map((v, i) => [i, v]); }`,
  sum: `function sum(a) { return a.reduce((x, y) => x + y, 0); }`,
  sorted: `function sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else if (c.length > 0 && typeof c[0] === 'number') { if (typeof __tova_native !== 'undefined' && __tova_native && c.length > 128) { const f = new Float64Array(c); __tova_native.tova_sort_f64(f, f.length); for (let i = 0; i < c.length; i++) c[i] = f[i]; } else if (c.length > 128) { const f = new Float64Array(c); f.sort(); for (let i = 0; i < c.length; i++) c[i] = f[i]; } else { c.sort((a, b) => a - b); } } else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }`,
  reversed: `function reversed(a) { return [...a].reverse(); }`,
  zip: `function zip(...as) { if (as.length === 0) return []; const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }`,
  min: `function min(a) { if (a.length === 0) return null; let m = a[0]; for (let i = 1; i < a.length; i++) if (a[i] < m) m = a[i]; return m; }`,
  max: `function max(a) { if (a.length === 0) return null; let m = a[0]; for (let i = 1; i < a.length; i++) if (a[i] > m) m = a[i]; return m; }`,
  type_of: `function type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }`,
  filter: `function filter(arr, fn) { return arr.filter(fn); }`,
  map: `function map(arr, fn) { return arr.map(fn); }`,
  find: `function find(arr, fn) { return arr.find(fn) ?? null; }`,
  any: `function any(arr, fn) { return arr.some(fn); }`,
  all: `function all(arr, fn) { return arr.every(fn); }`,
  flat_map: `function flat_map(arr, fn) { return arr.flatMap(fn); }`,
  reduce: `function reduce(arr, fn, init) { return init === undefined ? arr.reduce(fn) : arr.reduce(fn, init); }`,
  unique: `function unique(arr) { return [...new Set(arr)]; }`,
  group_by: `function group_by(arr, fn) { const r = {}; for (const v of arr) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; }`,
  chunk: `function chunk(arr, n) { const r = []; for (let i = 0; i < arr.length; i += n) r.push(arr.slice(i, i + n)); return r; }`,
  flatten: `function flatten(arr) { return arr.flat(); }`,
  take: `function take(arr, n) { return arr.slice(0, n); }`,
  drop: `function drop(arr, n) { return arr.slice(n); }`,
  first: `function first(arr) { return arr.length > 0 ? arr[0] : null; }`,
  last: `function last(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }`,
  count: `function count(arr, fn) { return arr.filter(fn).length; }`,
  partition: `function partition(arr, fn) { const y = [], n = []; for (const v of arr) { (fn(v) ? y : n).push(v); } return [y, n]; }`,
  abs: `function abs(n) { return Math.abs(n); }`,
  floor: `function floor(n) { return Math.floor(n); }`,
  ceil: `function ceil(n) { return Math.ceil(n); }`,
  round: `function round(n) { return Math.round(n); }`,
  clamp: `function clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); }`,
  sqrt: `function sqrt(n) { return Math.sqrt(n); }`,
  pow: `function pow(b, e) { return Math.pow(b, e); }`,
  random: `function random() { return Math.random(); }`,
  trim: `function trim(s) { return s.trim(); }`,
  split: `function split(s, sep) { return s.split(sep); }`,
  join: `function join(arr, sep) { return arr.join(sep); }`,
  replace: `function replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); }`,
  repeat: `function repeat(s, n) { return s.repeat(n); }`,
  keys: `function keys(obj) { return Object.keys(obj); }`,
  values: `function values(obj) { return Object.values(obj); }`,
  entries: `function entries(obj) { return Object.entries(obj); }`,
  merge: `function merge(...objs) { return Object.assign({}, ...objs); }`,
  freeze: `function freeze(obj) { return Object.freeze(obj); }`,
  clone: `function clone(obj) { return structuredClone(obj); }`,
  sleep: `function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }`,
  parallel_map: `async function parallel_map(arr, fn, numWorkers) {
  if (!arr || arr.length === 0) return [];
  const cores = numWorkers || (typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : 4) || 4;
  const n = Math.min(cores, arr.length);
  if (n <= 1 || arr.length < 4) return arr.map(fn);
  if (!parallel_map._pool) {
    const { Worker } = await import("worker_threads");
    const wc = 'const{parentPort}=require("worker_threads");parentPort.on("message",m=>{const fn=(0,eval)("("+m.f+")");try{const r=m.c.map(fn);parentPort.postMessage({i:m.i,r})}catch(e){parentPort.postMessage({i:m.i,e:e.message})}})';
    parallel_map._pool = Array.from({length: n}, () => { const w = new Worker(wc, {eval: true}); w.unref(); return w; });
    parallel_map._cid = 0;
  }
  const pool = parallel_map._pool;
  const cs = Math.ceil(arr.length / pool.length);
  const fnStr = fn.toString();
  const cid = ++parallel_map._cid;
  const promises = [];
  for (let ci = 0; ci < pool.length && ci * cs < arr.length; ci++) {
    const chunk = arr.slice(ci * cs, (ci + 1) * cs);
    const mid = cid * 1000 + ci;
    promises.push(new Promise((resolve, reject) => {
      const w = pool[ci];
      const h = (msg) => { if (msg.i === mid) { w.removeListener("message", h); if (msg.e) reject(new Error(msg.e)); else resolve(msg.r); } };
      w.on("message", h);
      w.postMessage({i: mid, c: chunk, f: fnStr});
    }));
  }
  return (await Promise.all(promises)).flat();
}`,
  upper: `function upper(s) { return s.toUpperCase(); }`,
  lower: `function lower(s) { return s.toLowerCase(); }`,
  contains: `function contains(s, sub) { return s.includes(sub); }`,
  starts_with: `function starts_with(s, prefix) { return s.startsWith(prefix); }`,
  ends_with: `function ends_with(s, suffix) { return s.endsWith(suffix); }`,
  chars: `function chars(s) { return [...s]; }`,
  words: `function words(s) { return s.split(/\\s+/).filter(Boolean); }`,
  lines: `function lines(s) { return s.split('\\n'); }`,
  capitalize: `function capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; }`,
  title_case: `function title_case(s) { return s.replace(/\\b\\w/g, c => c.toUpperCase()); }`,
  snake_case: `function snake_case(s) { return s.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); }`,
  camel_case: `function camel_case(s) { return s.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); }`,
  assert_eq: `function assert_eq(a, b, msg) { if (a !== b) throw new Error(msg || \`Assertion failed: \${JSON.stringify(a)} !== \${JSON.stringify(b)}\`); }`,
  assert_ne: `function assert_ne(a, b, msg) { if (a === b) throw new Error(msg || \`Assertion failed: values should not be equal: \${JSON.stringify(a)}\`); }`,
  assert: `function assert(cond, msg) { if (!cond) throw new Error(msg || "Assertion failed"); }`,
  assert_throws: `function assert_throws(fn, expected) {
  try { fn(); } catch (e) {
    if (expected !== undefined) {
      const msg = e instanceof Error ? e.message : String(e);
      if (typeof expected === 'string' && !msg.includes(expected)) {
        throw new Error("Expected error containing \\"" + expected + "\\" but got \\"" + msg + "\\"");
      }
      if (expected instanceof RegExp && !expected.test(msg)) {
        throw new Error("Expected error matching " + expected + " but got \\"" + msg + "\\"");
      }
    }
    return e;
  }
  throw new Error("Expected function to throw" + (expected ? " \\"" + expected + "\\"" : "") + " but it did not");
}`,

  // ── Missing from module files (synced to BUILTIN_FUNCTIONS) ──
  find_index: `function find_index(arr, fn) { const i = arr.findIndex(fn); return i === -1 ? null : i; }`,
  includes: `function includes(arr, value) { return arr.includes(value); }`,
  replace_first: `function replace_first(s, from, to) { return s.replace(from, to); }`,
  pad_start: `function pad_start(s, n, fill) { return s.padStart(n, fill || ' '); }`,
  pad_end: `function pad_end(s, n, fill) { return s.padEnd(n, fill || ' '); }`,
  char_at: `function char_at(s, i) { return i < s.length ? s[i] : null; }`,
  trim_start: `function trim_start(s) { return s.trimStart(); }`,
  trim_end: `function trim_end(s) { return s.trimEnd(); }`,

  // ── Math constants ────────────────────────────────────
  PI: `const PI = Math.PI;`,
  E: `const E = Math.E;`,
  INF: `const INF = Infinity;`,

  // ── Trigonometric ─────────────────────────────────────
  sin: `function sin(n) { return Math.sin(n); }`,
  cos: `function cos(n) { return Math.cos(n); }`,
  tan: `function tan(n) { return Math.tan(n); }`,
  asin: `function asin(n) { return Math.asin(n); }`,
  acos: `function acos(n) { return Math.acos(n); }`,
  atan: `function atan(n) { return Math.atan(n); }`,
  atan2: `function atan2(y, x) { return Math.atan2(y, x); }`,

  // ── Logarithmic / Exponential ─────────────────────────
  log: `function log(n) { return Math.log(n); }`,
  log2: `function log2(n) { return Math.log2(n); }`,
  log10: `function log10(n) { return Math.log10(n); }`,
  exp: `function exp(n) { return Math.exp(n); }`,

  // ── Numeric Utilities ─────────────────────────────────
  sign: `function sign(n) { return Math.sign(n); }`,
  trunc: `function trunc(n) { return Math.trunc(n); }`,
  is_nan: `function is_nan(n) { return Number.isNaN(n); }`,
  is_finite: `function is_finite(n) { return Number.isFinite(n); }`,
  is_close: `function is_close(a, b, tol) { return Math.abs(a - b) <= (tol === undefined ? 1e-9 : tol); }`,
  to_radians: `function to_radians(deg) { return deg * Math.PI / 180; }`,
  to_degrees: `function to_degrees(rad) { return rad * 180 / Math.PI; }`,

  // ── Integer Math ──────────────────────────────────────
  gcd: `function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); while (b) { [a, b] = [b, a % b]; } return a; }`,
  lcm: `function lcm(a, b) { if (a === 0 && b === 0) return 0; let x = Math.abs(a), y = Math.abs(b); while (y) { const t = y; y = x % y; x = t; } return Math.abs(a * b) / x; }`,
  factorial: `function factorial(n) { if (n < 0) return null; if (n <= 1) return 1; let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; }`,

  // ── Randomness ────────────────────────────────────────
  random_int: `function random_int(lo, hi) { return Math.floor(Math.random() * (hi - lo + 1)) + lo; }`,
  random_float: `function random_float(lo, hi) { return Math.random() * (hi - lo) + lo; }`,
  choice: `function choice(arr) { return arr.length === 0 ? null : arr[Math.floor(Math.random() * arr.length)]; }`,
  sample: `function sample(arr, n) { const c = [...arr]; for (let i = c.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [c[i], c[j]] = [c[j], c[i]]; } return c.slice(0, n); }`,
  shuffle: `function shuffle(arr) { const c = [...arr]; for (let i = c.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [c[i], c[j]] = [c[j], c[i]]; } return c; }`,

  // ── Type Conversion ───────────────────────────────────
  to_int: `function to_int(v) { if (typeof v === 'boolean') return v ? 1 : 0; const n = typeof v === 'string' ? parseInt(v, 10) : Math.trunc(Number(v)); return isNaN(n) ? null : n; }`,
  to_float: `function to_float(v) { if (typeof v === 'boolean') return v ? 1.0 : 0.0; const n = Number(v); return isNaN(n) ? null : n; }`,
  to_string: `function to_string(v) { if (v == null) return 'nil'; if (v && v.__tag) return v.__tag + (v.value !== undefined ? '(' + String(v.value) + ')' : ''); return String(v); }`,
  to_bool: `function to_bool(v) { if (typeof v === 'string') return v !== '' && v !== '0' && v !== 'false'; return Boolean(v); }`,

  // ── Table runtime ───────────────────────────────────
  Table: `function Table(rows, columns) { if (rows instanceof Table) return rows; const t = Object.create(Table.prototype); t._rows = Array.isArray(rows) ? rows : []; t._columns = columns || (t._rows.length > 0 ? Object.keys(t._rows[0]) : []); return t; }
Table.prototype = { get rows() { return this._rows.length; }, get columns() { return [...this._columns]; }, get shape() { return [this._rows.length, this._columns.length]; }, get length() { return this._rows.length; }, [Symbol.iterator]() { return this._rows[Symbol.iterator](); }, at(i) { if (i < 0) i = this._rows.length + i; return this._rows[i] ?? null; }, slice(s, e) { return Table(this._rows.slice(s, e), this._columns); }, getColumn(n) { return this._rows.map(r => r[n]); }, toArray() { return [...this._rows]; }, toJSON() { return this._rows; }, toString() { if (this._rows.length === 0) return 'Table(0 rows, 0 columns)'; return 'Table(' + this._rows.length + ' rows, ' + this._columns.length + ' columns)'; }, _format(maxRows, title) { const lines = []; if (title) lines.push('── ' + title + ' ──'); const cols = this._columns; const dr = this._rows.slice(0, maxRows || 10); if (cols.length === 0 || dr.length === 0) { lines.push('(empty table)'); lines.push(this._rows.length + ' rows × ' + cols.length + ' columns'); return lines.join('\\n'); } const w = {}; for (const c of cols) { w[c] = c.length; for (const r of dr) { const s = r[c] == null ? 'nil' : String(r[c]); w[c] = Math.max(w[c], s.length); } w[c] = Math.min(w[c], 30); } lines.push(cols.map(c => c.padEnd(w[c])).join(' │ ')); lines.push(cols.map(c => '─'.repeat(w[c])).join('─┼─')); for (const r of dr) { lines.push(cols.map(c => { const s = r[c] == null ? 'nil' : String(r[c]); return s.slice(0, 30).padEnd(w[c]); }).join(' │ ')); } if (this._rows.length > (maxRows || 10)) lines.push('... ' + (this._rows.length - (maxRows || 10)) + ' more rows'); lines.push(this._rows.length + ' rows × ' + cols.length + ' columns'); return lines.join('\\n'); } };`,

  // ── Table operations ────────────────────────────────
  table_where: `function table_where(table, pred) { return Table(table._rows.filter(pred), table._columns); }`,
  table_select: `function table_select(table, ...args) { let cols; if (args.length === 1 && args[0] && args[0].__exclude) { const ex = new Set(Array.isArray(args[0].__exclude) ? args[0].__exclude : [args[0].__exclude]); cols = table._columns.filter(c => !ex.has(c)); } else { cols = args.filter(a => typeof a === 'string'); } const rows = table._rows.map(r => { const row = {}; for (const c of cols) row[c] = r[c]; return row; }); return Table(rows, cols); }`,
  table_derive: `function table_derive(table, derivations) { const nc = [...table._columns]; for (const k of Object.keys(derivations)) { if (!nc.includes(k)) nc.push(k); } const rows = table._rows.map(r => { const row = { ...r }; for (const [k, fn] of Object.entries(derivations)) { row[k] = typeof fn === 'function' ? fn(r) : fn; } return row; }); return Table(rows, nc); }`,
  table_group_by: `function table_group_by(table, keyFn) { const groups = new Map(); for (const row of table._rows) { const key = typeof keyFn === 'function' ? keyFn(row) : row[keyFn]; const ks = String(key); if (!groups.has(ks)) groups.set(ks, { key, rows: [] }); groups.get(ks).rows.push(row); } return { __grouped: true, groups, columns: table._columns }; }`,
  table_agg: `function table_agg(grouped, aggregations) { if (!grouped || !grouped.__grouped) throw new Error('agg() must be called after group_by()'); const rows = []; for (const [, { key, rows: gr }] of grouped.groups) { const row = typeof key === 'object' && key !== null ? { ...key } : { _group: key }; for (const [n, fn] of Object.entries(aggregations)) { row[n] = fn(gr); } rows.push(row); } return Table(rows, rows.length > 0 ? Object.keys(rows[0]) : []); }`,
  table_sort_by: `function table_sort_by(table, keyFn, opts) { const desc = opts && opts.desc; const rows = [...table._rows].sort((a, b) => { const ka = typeof keyFn === 'function' ? keyFn(a) : a[keyFn]; const kb = typeof keyFn === 'function' ? keyFn(b) : b[keyFn]; let c = ka < kb ? -1 : ka > kb ? 1 : 0; return desc ? -c : c; }); return Table(rows, table._columns); }`,
  table_limit: `function table_limit(table, n) { return Table(table._rows.slice(0, n), table._columns); }`,
  table_join: `function table_join(table, other, opts) { const { left, right, how } = opts || {}; if (!left || !right) throw new Error('join() requires left and right key functions'); const rows = []; const ri = new Map(); for (const r of other._rows) { const k = typeof right === 'function' ? right(r) : r[right]; const ks = String(k); if (!ri.has(ks)) ri.set(ks, []); ri.get(ks).push(r); } const cc = [...new Set([...table._columns, ...other._columns])]; for (const lr of table._rows) { const k = typeof left === 'function' ? left(lr) : lr[left]; const ms = ri.get(String(k)) || []; if (ms.length > 0) { for (const rr of ms) rows.push({ ...lr, ...rr }); } else if (how === 'left' || how === 'outer') { const row = { ...lr }; for (const c of other._columns) { if (!(c in row)) row[c] = null; } rows.push(row); } } return Table(rows, cc); }`,
  table_pivot: `function table_pivot(table, opts) { const { index, columns: colFn, values: valFn } = opts || {}; const pm = new Map(); const ac = new Set(); for (const row of table._rows) { const ik = typeof index === 'function' ? index(row) : row[index]; const col = typeof colFn === 'function' ? colFn(row) : row[colFn]; const val = typeof valFn === 'function' ? valFn(row) : row[valFn]; const ks = String(ik); if (!pm.has(ks)) pm.set(ks, { _index: ik }); pm.get(ks)[String(col)] = val; ac.add(String(col)); } return Table([...pm.values()], ['_index', ...ac]); }`,
  table_unpivot: `function table_unpivot(table, opts) { const { id, columns: uc } = opts || {}; const cn = uc.filter(c => typeof c === 'string'); const rows = []; for (const row of table._rows) { const iv = typeof id === 'function' ? id(row) : row[id]; for (const col of cn) rows.push({ id: iv, variable: col, value: row[col] }); } return Table(rows, ['id', 'variable', 'value']); }`,
  table_explode: `function table_explode(table, colFn) { const rows = []; for (const row of table._rows) { const arr = typeof colFn === 'function' ? colFn(row) : row[colFn]; if (Array.isArray(arr)) { const cn = typeof colFn === 'string' ? colFn : null; for (const val of arr) { const r = { ...row }; if (cn) r[cn] = val; rows.push(r); } } else { rows.push({ ...row }); } } return Table(rows, table._columns); }`,
  table_union: `function table_union(table, other) { return Table([...table._rows, ...other._rows], [...new Set([...table._columns, ...other._columns])]); }`,
  table_drop_duplicates: `function table_drop_duplicates(table, opts) { const by = opts && opts.by; const seen = new Set(); const rows = []; for (const row of table._rows) { const k = by ? (typeof by === 'function' ? String(by(row)) : String(row[by])) : JSON.stringify(row); if (!seen.has(k)) { seen.add(k); rows.push(row); } } return Table(rows, table._columns); }`,
  table_rename: `function table_rename(table, oldName, newName) { const cols = table._columns.map(c => c === oldName ? newName : c); const rows = table._rows.map(r => { const row = {}; for (const c of table._columns) row[c === oldName ? newName : c] = r[c]; return row; }); return Table(rows, cols); }`,

  // ── Lazy Table Query Builder ────────────────────────
  lazy: `function lazy(table) { return new LazyTable(table); }`,
  collect: `function collect(v) { if (v instanceof LazyTable) return v.collect(); if (v && v._gen) return v.collect(); return v; }`,
  LazyTable: `class LazyTable {
  constructor(source) {
    this._source = source;
    this._steps = [];
  }
  _push(step) { const lt = new LazyTable(this._source); lt._steps = [...this._steps, step]; return lt; }
  where(pred) { return this._push({ op: 'where', fn: pred }); }
  select(...args) {
    let cols;
    if (args.length === 1 && args[0] && args[0].__exclude) {
      cols = { exclude: new Set(Array.isArray(args[0].__exclude) ? args[0].__exclude : [args[0].__exclude]) };
    } else { cols = args.filter(a => typeof a === 'string'); }
    return this._push({ op: 'select', cols });
  }
  derive(derivations) { return this._push({ op: 'derive', derivations }); }
  limit(n) { return this._push({ op: 'limit', n }); }
  drop_duplicates(opts) { return this._push({ op: 'dedup', by: opts && opts.by }); }
  rename(oldName, newName) { return this._push({ op: 'rename', oldName, newName }); }
  sort_by(keyFn, opts) { return this._push({ op: 'sort', keyFn, desc: opts && opts.desc }); }
  group_by(keyFn) {
    const rows = this.collect()._rows;
    const src = Table(rows, this._resolveColumns());
    return table_group_by(src, keyFn);
  }
  _resolveColumns() {
    let cols = [...this._source._columns];
    for (const s of this._steps) {
      if (s.op === 'select') {
        cols = s.cols.exclude ? cols.filter(c => !s.cols.exclude.has(c)) : [...s.cols];
      } else if (s.op === 'derive') {
        for (const k of Object.keys(s.derivations)) { if (!cols.includes(k)) cols.push(k); }
      } else if (s.op === 'rename') {
        cols = cols.map(c => c === s.oldName ? s.newName : c);
      }
    }
    return cols;
  }
  collect() {
    let rows = this._source._rows;
    let cols = [...this._source._columns];
    for (const step of this._steps) {
      switch (step.op) {
        case 'where': rows = rows.filter(step.fn); break;
        case 'select': {
          const sc = step.cols.exclude ? cols.filter(c => !step.cols.exclude.has(c)) : step.cols;
          rows = rows.map(r => { const row = {}; for (const c of sc) row[c] = r[c]; return row; });
          cols = [...sc];
          break;
        }
        case 'derive': {
          for (const k of Object.keys(step.derivations)) { if (!cols.includes(k)) cols.push(k); }
          rows = rows.map(r => { const row = { ...r }; for (const [k, fn] of Object.entries(step.derivations)) { row[k] = typeof fn === 'function' ? fn(r) : fn; } return row; });
          break;
        }
        case 'limit': rows = rows.slice(0, step.n); break;
        case 'dedup': {
          const seen = new Set();
          const filtered = [];
          for (const row of rows) {
            const k = step.by ? (typeof step.by === 'function' ? String(step.by(row)) : String(row[step.by])) : JSON.stringify(row);
            if (!seen.has(k)) { seen.add(k); filtered.push(row); }
          }
          rows = filtered;
          break;
        }
        case 'rename': {
          cols = cols.map(c => c === step.oldName ? step.newName : c);
          rows = rows.map(r => { const row = {}; for (const c of cols) row[c === step.newName ? step.newName : c] = r[c === step.newName ? step.oldName : c]; return row; });
          break;
        }
        case 'sort': {
          rows = [...rows].sort((a, b) => {
            const ka = typeof step.keyFn === 'function' ? step.keyFn(a) : a[step.keyFn];
            const kb = typeof step.keyFn === 'function' ? step.keyFn(b) : b[step.keyFn];
            let c = ka < kb ? -1 : ka > kb ? 1 : 0;
            return step.desc ? -c : c;
          });
          break;
        }
      }
    }
    return Table(rows, cols);
  }
  toArray() { return this.collect()._rows; }
  toJSON() { return this.toArray(); }
  get rows() { return this.collect()._rows.length; }
  get columns() { return this._resolveColumns(); }
  get shape() { const t = this.collect(); return [t._rows.length, t._columns.length]; }
  toString() { return this.collect().toString(); }
  _format(maxRows, title) { return this.collect()._format(maxRows, title); }
  [Symbol.iterator]() { return this.collect()._rows[Symbol.iterator](); }
}`,

  // ── Aggregation helpers ─────────────────────────────
  agg_sum: `function agg_sum(fn) { return (rows) => rows.reduce((a, r) => a + (typeof fn === 'function' ? fn(r) : r[fn]), 0); }`,
  agg_count: `function agg_count(fn) { if (!fn) return (rows) => rows.length; return (rows) => rows.filter(fn).length; }`,
  agg_mean: `function agg_mean(fn) { return (rows) => { if (rows.length === 0) return 0; return rows.reduce((a, r) => a + (typeof fn === 'function' ? fn(r) : r[fn]), 0) / rows.length; }; }`,
  agg_median: `function agg_median(fn) { return (rows) => { if (rows.length === 0) return 0; const vs = rows.map(r => typeof fn === 'function' ? fn(r) : r[fn]).sort((a, b) => a - b); const m = Math.floor(vs.length / 2); return vs.length % 2 !== 0 ? vs[m] : (vs[m - 1] + vs[m]) / 2; }; }`,
  agg_min: `function agg_min(fn) { return (rows) => { if (rows.length === 0) return null; let m = typeof fn === 'function' ? fn(rows[0]) : rows[0][fn]; for (let i = 1; i < rows.length; i++) { const v = typeof fn === 'function' ? fn(rows[i]) : rows[i][fn]; if (v < m) m = v; } return m; }; }`,
  agg_max: `function agg_max(fn) { return (rows) => { if (rows.length === 0) return null; let m = typeof fn === 'function' ? fn(rows[0]) : rows[0][fn]; for (let i = 1; i < rows.length; i++) { const v = typeof fn === 'function' ? fn(rows[i]) : rows[i][fn]; if (v > m) m = v; } return m; }; }`,

  // ── Data exploration ────────────────────────────────
  peek: `function peek(table, opts) { const o = typeof opts === 'object' ? opts : {}; console.log(table._format ? table._format(o.n || 10, o.title) : String(table)); return table; }`,
  describe: `function describe(table) { const stats = []; for (const col of table._columns) { const vals = table._rows.map(r => r[col]).filter(v => v != null); const st = { Column: col, Type: 'Unknown', 'Non-Null': vals.length }; if (vals.length > 0) { const s = vals[0]; if (typeof s === 'number') { st.Type = Number.isInteger(s) ? 'Int' : 'Float'; st.Mean = vals.reduce((a, b) => a + b, 0) / vals.length; let mn = vals[0], mx = vals[0]; for (let i = 1; i < vals.length; i++) { if (vals[i] < mn) mn = vals[i]; if (vals[i] > mx) mx = vals[i]; } st.Min = mn; st.Max = mx; } else if (typeof s === 'string') { st.Type = 'String'; st.Unique = new Set(vals).size; } else if (typeof s === 'boolean') { st.Type = 'Bool'; } } stats.push(st); } const dt = Table(stats); console.log(dt._format(100, 'describe()')); return dt; }`,
  schema_of: `function schema_of(table) { const sc = {}; if (table._rows.length === 0) { for (const c of table._columns) sc[c] = 'Unknown'; } else { const s = table._rows[0]; for (const c of table._columns) { const v = s[c]; if (v == null) sc[c] = 'Nil'; else if (typeof v === 'number') sc[c] = Number.isInteger(v) ? 'Int' : 'Float'; else if (typeof v === 'string') sc[c] = 'String'; else if (typeof v === 'boolean') sc[c] = 'Bool'; else if (Array.isArray(v)) sc[c] = 'Array'; else sc[c] = 'Object'; } } console.log('Schema:'); for (const [c, t] of Object.entries(sc)) console.log('  ' + c + ': ' + t); return sc; }`,

  // ── Data cleaning ───────────────────────────────────
  cast: `function cast(table, colFn, targetType) { const cn = typeof colFn === 'string' ? colFn : null; const rows = table._rows.map(r => { const row = { ...r }; const k = cn; if (k && k in row) { const v = row[k]; if (targetType === 'Int') row[k] = parseInt(v, 10) || 0; else if (targetType === 'Float') row[k] = parseFloat(v) || 0; else if (targetType === 'String') row[k] = String(v); else if (targetType === 'Bool') row[k] = Boolean(v); } return row; }); return Table(rows, table._columns); }`,
  drop_nil: `function drop_nil(table, colFn) { const cn = typeof colFn === 'string' ? colFn : null; const rows = table._rows.filter(r => { const v = cn ? r[cn] : colFn(r); return v != null; }); return Table(rows, table._columns); }`,
  fill_nil: `function fill_nil(table, colFn, defaultValue) { const cn = typeof colFn === 'string' ? colFn : null; const rows = table._rows.map(r => { const row = { ...r }; if (cn && (row[cn] == null)) row[cn] = defaultValue; return row; }); return Table(rows, table._columns); }`,
  filter_ok: `function filter_ok(arr) { return arr.filter(r => r && r.__tag === 'Ok').map(r => r.value); }`,
  filter_err: `function filter_err(arr) { return arr.filter(r => r && r.__tag === 'Err').map(r => r.error); }`,

  // ── I/O functions ───────────────────────────────────
  read: `async function read(sourceOrDb, queryOrOpts, opts) {
  if (sourceOrDb && typeof sourceOrDb === 'object' && sourceOrDb.query) { const result = await sourceOrDb.query(queryOrOpts); return Table(result); }
  const source = sourceOrDb;
  if (typeof source !== 'string') throw new Error('read() expects a file path or URL string');
  const options = typeof queryOrOpts === 'object' ? queryOrOpts : (opts || {});
  if (source.startsWith('http://') || source.startsWith('https://')) {
    const response = await fetch(source);
    if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);
    const ct = response.headers.get('content-type') || '';
    if (ct.includes('json')) { const data = await response.json(); if (Array.isArray(data)) return Table(data); return data; }
    const text = await response.text();
    if (source.endsWith('.csv')) return __parseCSV(text, options);
    if (source.endsWith('.jsonl') || source.endsWith('.ndjson')) return __parseJSONL(text);
    try { const data = JSON.parse(text); if (Array.isArray(data)) return Table(data); return data; } catch { return __parseCSV(text, options); }
  }
  const fs = await import('fs'); const path = await import('path');
  const ext = path.extname(source).toLowerCase(); const text = fs.readFileSync(source, 'utf-8');
  if (ext === '.csv') return __parseCSV(text, options);
  if (ext === '.tsv') return __parseCSV(text, { ...options, delimiter: '\\t' });
  if (ext === '.json') { const data = JSON.parse(text); if (Array.isArray(data)) return Table(data); return data; }
  if (ext === '.jsonl' || ext === '.ndjson') return __parseJSONL(text);
  try { const d = JSON.parse(text); if (Array.isArray(d)) return Table(d); return d; } catch { return __parseCSV(text, options); }
}`,
  write: `async function write(data, destination, opts) {
  const fs = await import('fs'); const path = await import('path');
  const ext = path.extname(destination).toLowerCase();
  const isTable = data && data._rows && data._columns;
  const td = isTable ? data : (Array.isArray(data) ? Table(data) : null);
  let content;
  if (ext === '.csv' || ext === '.tsv') { if (!td) throw new Error('write() to CSV requires table/array data'); const delim = ext === '.tsv' ? '\\t' : ','; const cols = td._columns; const lines = [cols.join(delim)]; for (const row of td._rows) { lines.push(cols.map(c => { const v = row[c]; if (v == null) return ''; const s = String(v); return (s.includes(delim) || s.includes('"') || s.includes('\\n')) ? '"' + s.replace(/"/g, '""') + '"' : s; }).join(delim)); } content = lines.join('\\n'); }
  else if (ext === '.jsonl' || ext === '.ndjson') { if (!td) throw new Error('write() to JSONL requires table/array data'); content = td._rows.map(r => JSON.stringify(r)).join('\\n'); }
  else { content = JSON.stringify(isTable ? data._rows : data, null, 2); }
  if (opts && opts.append) fs.appendFileSync(destination, content + '\\n', 'utf-8');
  else fs.writeFileSync(destination, content, 'utf-8');
}`,

  // ── CSV/JSONL parsing helpers ───────────────────────
  __parseCSV: `function __parseCSV(text, opts) {
  const delim = (opts && opts.delimiter) || ','; const hasHeader = !opts || opts.header !== false;
  const lines = text.split('\\n').filter(l => l.trim());
  if (lines.length === 0) return Table([]);
  const parseLine = (line) => { const fields = []; let cur = ''; let inQ = false; for (let i = 0; i < line.length; i++) { const ch = line[i]; if (inQ) { if (ch === '"' && line[i+1] === '"') { cur += '"'; i++; } else if (ch === '"') { inQ = false; } else { cur += ch; } } else { if (ch === '"') inQ = true; else if (ch === delim) { fields.push(cur.trim()); cur = ''; } else { cur += ch; } } } fields.push(cur.trim()); return fields; };
  const _reInt = /^-?\\d+$/; const _reFloat = /^-?\\d*\\.\\d+$/;
  let headers, ds; if (hasHeader) { headers = parseLine(lines[0]); ds = 1; } else { const fr = parseLine(lines[0]); headers = fr.map((_, i) => 'col_' + i); ds = 0; }
  const rows = []; for (let i = ds; i < lines.length; i++) { const f = parseLine(lines[i]); const row = {}; for (let j = 0; j < headers.length; j++) { let v = f[j] ?? null; if (v !== null && v !== '') { if (_reInt.test(v)) v = parseInt(v, 10); else if (_reFloat.test(v)) v = parseFloat(v); else if (v === 'true') v = true; else if (v === 'false') v = false; else if (v === 'null' || v === 'nil') v = null; } else if (v === '') v = null; row[headers[j]] = v; } rows.push(row); }
  return Table(rows, headers);
}`,
  __parseJSONL: `function __parseJSONL(text) { return Table(text.split('\\n').filter(l => l.trim()).map(l => JSON.parse(l))); }`,

  // ── Table operation aliases (short names for pipe-friendly use) ──
  where: `function where(tableOrArr, pred) { if (tableOrArr instanceof LazyTable) return tableOrArr.where(pred); if (tableOrArr && tableOrArr._rows) return table_where(tableOrArr, pred); return tableOrArr.filter(pred); }`,
  select: `function select(table, ...args) { if (table instanceof LazyTable) return table.select(...args); return table_select(table, ...args); }`,
  derive: `function derive(table, derivations) { if (table instanceof LazyTable) return table.derive(derivations); return table_derive(table, derivations); }`,
  agg: `function agg(grouped, aggregations) { return table_agg(grouped, aggregations); }`,
  sort_by: `function sort_by(table, keyFn, opts) { if (table instanceof LazyTable) return table.sort_by(keyFn, opts); return table_sort_by(table, keyFn, opts); }`,
  limit: `function limit(table, n) { if (table instanceof LazyTable) return table.limit(n); return table_limit(table, n); }`,
  pivot: `function pivot(table, opts) { return table_pivot(table, opts); }`,
  unpivot: `function unpivot(table, opts) { return table_unpivot(table, opts); }`,
  explode: `function explode(table, colFn) { return table_explode(table, colFn); }`,
  union: `function union(a, b) { if (a && a._rows) return table_union(a, b); return [...new Set([...a, ...b])]; }`,
  drop_duplicates: `function drop_duplicates(table, opts) { if (table instanceof LazyTable) return table.drop_duplicates(opts); return table_drop_duplicates(table, opts); }`,
  rename: `function rename(table, oldName, newName) { if (table instanceof LazyTable) return table.rename(oldName, newName); return table_rename(table, oldName, newName); }`,
  mean: `function mean(v) { if (Array.isArray(v)) { return v.length === 0 ? 0 : v.reduce((a, b) => a + b, 0) / v.length; } return agg_mean(v); }`,
  median: `function median(v) { if (Array.isArray(v)) { if (v.length === 0) return null; const s = [...v].sort((a, b) => a - b); const m = Math.floor(s.length / 2); return s.length % 2 === 0 ? (s[m - 1] + s[m]) / 2 : s[m]; } return agg_median(v); }`,

  // ── Strings (new) ──────────────────────────────────────
  index_of: `function index_of(s, sub) { const i = s.indexOf(sub); return i === -1 ? null : i; }`,
  last_index_of: `function last_index_of(s, sub) { const i = s.lastIndexOf(sub); return i === -1 ? null : i; }`,
  count_of: `function count_of(s, sub) { if (!sub) return 0; let c = 0, i = 0; while ((i = s.indexOf(sub, i)) !== -1) { c++; i += sub.length; } return c; }`,
  reverse_str: `function reverse_str(s) { return [...s].reverse().join(''); }`,
  substr: `function substr(s, start, end) { return end === undefined ? s.slice(start) : s.slice(start, end); }`,
  is_empty: `function is_empty(v) { if (v == null) return true; if (typeof v === 'string' || Array.isArray(v)) return v.length === 0; if (typeof v === 'object') return Object.keys(v).length === 0; return false; }`,
  kebab_case: `function kebab_case(s) { return s.replace(/[-\\s]+/g, '-').replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase().replace(/^-/, ''); }`,
  center: `function center(s, n, fill) { if (s.length >= n) return s; const f = fill || ' '; const total = n - s.length; const left = Math.floor(total / 2); const right = total - left; return f.repeat(Math.ceil(left / f.length)).slice(0, left) + s + f.repeat(Math.ceil(right / f.length)).slice(0, right); }`,

  // ── Collections (new) ──────────────────────────────────
  zip_with: `function zip_with(a, b, fn) { const m = Math.min(a.length, b.length); const r = []; for (let i = 0; i < m; i++) r.push(fn(a[i], b[i])); return r; }`,
  frequencies: `function frequencies(arr) { const r = {}; for (const v of arr) { const k = String(v); r[k] = (r[k] || 0) + 1; } return r; }`,
  scan: `function scan(arr, fn, init) { const r = []; let acc = init; for (const v of arr) { acc = fn(acc, v); r.push(acc); } return r; }`,
  min_by: `function min_by(arr, fn) { if (arr.length === 0) return null; let best = arr[0], bestK = fn(arr[0]); for (let i = 1; i < arr.length; i++) { const k = fn(arr[i]); if (k < bestK) { best = arr[i]; bestK = k; } } return best; }`,
  max_by: `function max_by(arr, fn) { if (arr.length === 0) return null; let best = arr[0], bestK = fn(arr[0]); for (let i = 1; i < arr.length; i++) { const k = fn(arr[i]); if (k > bestK) { best = arr[i]; bestK = k; } } return best; }`,
  sum_by: `function sum_by(arr, fn) { let s = 0; for (const v of arr) s += fn(v); return s; }`,
  product: `function product(arr) { return arr.reduce((a, b) => a * b, 1); }`,
  from_entries: `function from_entries(pairs) { return Object.fromEntries(pairs); }`,
  has_key: `function has_key(obj, key) { return obj != null && Object.prototype.hasOwnProperty.call(obj, key); }`,
  get: `function get(obj, path, def) { const keys = Array.isArray(path) ? path : String(path).split('.'); let cur = obj; for (const k of keys) { if (cur == null || typeof cur !== 'object') return def !== undefined ? def : null; cur = cur[k]; } return cur !== undefined ? cur : (def !== undefined ? def : null); }`,
  pick: `function pick(obj, ks) { const r = {}; for (const k of ks) { if (k in obj) r[k] = obj[k]; } return r; }`,
  omit: `function omit(obj, ks) { const s = new Set(ks); const r = {}; for (const k of Object.keys(obj)) { if (!s.has(k)) r[k] = obj[k]; } return r; }`,
  map_values: `function map_values(obj, fn) { const r = {}; for (const [k, v] of Object.entries(obj)) r[k] = fn(v, k); return r; }`,
  sliding_window: `function sliding_window(arr, n) { if (n <= 0 || n > arr.length) return []; const r = []; for (let i = 0; i <= arr.length - n; i++) r.push(arr.slice(i, i + n)); return r; }`,

  // ── JSON (new) ─────────────────────────────────────────
  json_parse: `function json_parse(s) { try { return Ok(JSON.parse(s)); } catch (e) { return Err(e.message); } }`,
  json_stringify: `function json_stringify(v) { return JSON.stringify(v); }`,
  json_pretty: `function json_pretty(v) { return JSON.stringify(v, null, 2); }`,

  // ── Functional (new) ───────────────────────────────────
  compose: `function compose(...fns) { return (x) => fns.reduceRight((v, fn) => fn(v), x); }`,
  pipe_fn: `function pipe_fn(...fns) { return (x) => fns.reduce((v, fn) => fn(v), x); }`,
  identity: `function identity(x) { return x; }`,
  memoize: `function memoize(fn) { const cache = new Map(); return function(...args) { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn.apply(this, args); cache.set(key, result); return result; }; }`,
  debounce: `function debounce(fn, ms) { let timer; return function(...args) { clearTimeout(timer); timer = setTimeout(() => fn.apply(this, args), ms); }; }`,
  throttle: `function throttle(fn, ms) { let last = 0; return function(...args) { const now = Date.now(); if (now - last >= ms) { last = now; return fn.apply(this, args); } }; }`,
  once: `function once(fn) { let called = false, result; return function(...args) { if (!called) { called = true; result = fn.apply(this, args); } return result; }; }`,
  negate: `function negate(fn) { return function(...args) { return !fn.apply(this, args); }; }`,

  // ── Error Handling (new) ───────────────────────────────
  try_fn: `function try_fn(fn) { try { return Ok(fn()); } catch (e) { return Err(e instanceof Error ? e.message : String(e)); } }`,
  try_async: `async function try_async(fn) { try { return Ok(await fn()); } catch (e) { return Err(e instanceof Error ? e.message : String(e)); } }`,

  // ── Async (new) ────────────────────────────────────────
  parallel: `function parallel(list) { return Promise.all(list); }`,
  race: `function race(promises) { return Promise.race(promises); }`,
  timeout: `function timeout(promise, ms) { return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout after ' + ms + 'ms')), ms))]); }`,
  retry: `async function retry(fn, opts) { const o = opts || {}; const times = o.times || 3; const delay = o.delay || 100; const backoff = o.backoff || 1; let lastErr; for (let i = 0; i < times; i++) { try { return await fn(); } catch (e) { lastErr = e; if (i < times - 1) await new Promise(r => setTimeout(r, delay * Math.pow(backoff, i))); } } throw lastErr; }`,

  // ── Encoding (new) ─────────────────────────────────────
  base64_encode: `function base64_encode(s) { return typeof btoa === 'function' ? btoa(unescape(encodeURIComponent(s))) : Buffer.from(s, 'utf-8').toString('base64'); }`,
  base64_decode: `function base64_decode(s) { return typeof atob === 'function' ? decodeURIComponent(escape(atob(s))) : Buffer.from(s, 'base64').toString('utf-8'); }`,
  url_encode: `function url_encode(s) { return encodeURIComponent(s); }`,
  url_decode: `function url_decode(s) { return decodeURIComponent(s); }`,

  // ── Math (new) ─────────────────────────────────────────
  hypot: `function hypot(a, b) { return Math.hypot(a, b); }`,
  lerp: `function lerp(a, b, t) { return a + (b - a) * t; }`,
  divmod: `function divmod(a, b) { const q = Math.floor(a / b); return [q, a - q * b]; }`,
  avg: `function avg(arr) { return arr.length === 0 ? 0 : arr.reduce((a, b) => a + b, 0) / arr.length; }`,

  // ── Date/Time (new) ────────────────────────────────────
  now: `function now() { return Date.now(); }`,
  now_iso: `function now_iso() { return new Date().toISOString(); }`,
  date_parse: `function date_parse(s) { const d = new Date(s); return isNaN(d.getTime()) ? Err('Invalid date: ' + s) : Ok(d); }`,
  date_format: `function date_format(d, fmt) { if (typeof d === 'number') d = new Date(d); if (fmt === 'iso') return d.toISOString(); if (fmt === 'date') return d.toISOString().slice(0, 10); if (fmt === 'time') return d.toTimeString().slice(0, 8); if (fmt === 'datetime') return d.toISOString().slice(0, 10) + ' ' + d.toTimeString().slice(0, 8); return fmt.replace('YYYY', String(d.getFullYear())).replace('MM', String(d.getMonth() + 1).padStart(2, '0')).replace('DD', String(d.getDate()).padStart(2, '0')).replace('HH', String(d.getHours()).padStart(2, '0')).replace('mm', String(d.getMinutes()).padStart(2, '0')).replace('ss', String(d.getSeconds()).padStart(2, '0')); }`,
  date_add: `function date_add(d, amount, unit) { if (typeof d === 'number') d = new Date(d); const r = new Date(d.getTime()); if (unit === 'years') r.setFullYear(r.getFullYear() + amount); else if (unit === 'months') r.setMonth(r.getMonth() + amount); else if (unit === 'days') r.setDate(r.getDate() + amount); else if (unit === 'hours') r.setHours(r.getHours() + amount); else if (unit === 'minutes') r.setMinutes(r.getMinutes() + amount); else if (unit === 'seconds') r.setSeconds(r.getSeconds() + amount); return r; }`,
  date_diff: `function date_diff(d1, d2, unit) { if (typeof d1 === 'number') d1 = new Date(d1); if (typeof d2 === 'number') d2 = new Date(d2); const ms = d2.getTime() - d1.getTime(); if (unit === 'seconds') return Math.floor(ms / 1000); if (unit === 'minutes') return Math.floor(ms / 60000); if (unit === 'hours') return Math.floor(ms / 3600000); if (unit === 'days') return Math.floor(ms / 86400000); if (unit === 'months') return (d2.getFullYear() - d1.getFullYear()) * 12 + (d2.getMonth() - d1.getMonth()); if (unit === 'years') return d2.getFullYear() - d1.getFullYear(); return ms; }`,
  date_from: `function date_from(parts) { return new Date(parts.year || 0, (parts.month || 1) - 1, parts.day || 1, parts.hour || 0, parts.minute || 0, parts.second || 0); }`,
  date_part: `function date_part(d, part) { if (typeof d === 'number') d = new Date(d); if (part === 'year') return d.getFullYear(); if (part === 'month') return d.getMonth() + 1; if (part === 'day') return d.getDate(); if (part === 'hour') return d.getHours(); if (part === 'minute') return d.getMinutes(); if (part === 'second') return d.getSeconds(); if (part === 'weekday') return d.getDay(); return null; }`,
  time_ago: `function time_ago(d) { if (typeof d === 'number') d = new Date(d); const s = Math.floor((Date.now() - d.getTime()) / 1000); if (s < 60) return s + ' seconds ago'; const m = Math.floor(s / 60); if (m < 60) return m + (m === 1 ? ' minute ago' : ' minutes ago'); const h = Math.floor(m / 60); if (h < 24) return h + (h === 1 ? ' hour ago' : ' hours ago'); const dy = Math.floor(h / 24); if (dy < 30) return dy + (dy === 1 ? ' day ago' : ' days ago'); const mo = Math.floor(dy / 30); if (mo < 12) return mo + (mo === 1 ? ' month ago' : ' months ago'); const yr = Math.floor(mo / 12); return yr + (yr === 1 ? ' year ago' : ' years ago'); }`,

  // ── Regex (with compiled regex cache) ─────────────────
  __regex_cache: `const __reCache = new Map(); function __re(p, f) { const k = p + '\\0' + (f || ''); let r = __reCache.get(k); if (!r) { r = new RegExp(p, f); __reCache.set(k, r); if (__reCache.size > 1000) { const first = __reCache.keys().next().value; __reCache.delete(first); } } return r; }`,
  regex_test: `function regex_test(s, pattern, flags) { return __re(pattern, flags).test(s); }`,
  regex_match: `function regex_match(s, pattern, flags) { const m = s.match(__re(pattern, flags)); if (!m) return Err('No match'); return Ok({ match: m[0], index: m.index, groups: m.slice(1) }); }`,
  regex_find_all: `function regex_find_all(s, pattern, flags) { const re = __re(pattern, (flags || '') + (flags && flags.includes('g') ? '' : 'g')); const results = []; let m; re.lastIndex = 0; while ((m = re.exec(s)) !== null) { results.push({ match: m[0], index: m.index, groups: m.slice(1) }); } return results; }`,
  regex_replace: `function regex_replace(s, pattern, replacement, flags) { return s.replace(__re(pattern, flags || 'g'), replacement); }`,
  regex_split: `function regex_split(s, pattern, flags) { return s.split(__re(pattern, flags)); }`,
  regex_capture: `function regex_capture(s, pattern, flags) { const m = s.match(__re(pattern, flags)); if (!m) return Err('No match'); if (!m.groups) return Err('No named groups'); return Ok(m.groups); }`,

  // ── Validation ─────────────────────────────────────────
  is_email: `function is_email(s) { return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(s); }`,
  is_url: `function is_url(s) { try { new URL(s); return true; } catch { return false; } }`,
  is_numeric: `function is_numeric(s) { return typeof s === 'string' && s.length > 0 && !isNaN(Number(s)); }`,
  is_alpha: `function is_alpha(s) { return /^[a-zA-Z]+$/.test(s); }`,
  is_alphanumeric: `function is_alphanumeric(s) { return /^[a-zA-Z0-9]+$/.test(s); }`,
  is_uuid: `function is_uuid(s) { return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(s); }`,
  is_hex: `function is_hex(s) { return /^[0-9a-fA-F]+$/.test(s); }`,

  // ── URL & UUID ─────────────────────────────────────────
  uuid: `function uuid() { return typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0; return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16); }); }`,
  parse_url: `function parse_url(s) { try { const u = new URL(s); return Ok({ protocol: u.protocol.replace(':', ''), host: u.host, pathname: u.pathname, search: u.search, hash: u.hash }); } catch (e) { return Err('Invalid URL: ' + s); } }`,
  build_url: `function build_url(parts) { let url = (parts.protocol || 'https') + '://' + (parts.host || ''); url += parts.pathname || '/'; if (parts.search) url += (parts.search.startsWith('?') ? '' : '?') + parts.search; if (parts.hash) url += (parts.hash.startsWith('#') ? '' : '#') + parts.hash; return url; }`,
  parse_query: `function parse_query(s) { const r = {}; const qs = s.startsWith('?') ? s.slice(1) : s; if (!qs) return r; for (const pair of qs.split('&')) { const [k, ...v] = pair.split('='); r[decodeURIComponent(k)] = decodeURIComponent(v.join('=')); } return r; }`,
  build_query: `function build_query(obj) { return Object.entries(obj).map(([k, v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); }`,

  // ── Set Operations ─────────────────────────────────────
  intersection: `function intersection(a, b) { const s = new Set(b); return a.filter(x => s.has(x)); }`,
  difference: `function difference(a, b) { const s = new Set(b); return a.filter(x => !s.has(x)); }`,
  symmetric_difference: `function symmetric_difference(a, b) { const sa = new Set(a); const sb = new Set(b); return [...a.filter(x => !sb.has(x)), ...b.filter(x => !sa.has(x))]; }`,
  is_subset: `function is_subset(a, b) { const s = new Set(b); return a.every(x => s.has(x)); }`,
  is_superset: `function is_superset(a, b) { const s = new Set(a); return b.every(x => s.has(x)); }`,

  // ── Statistics ─────────────────────────────────────────
  mode: `function mode(arr) { if (arr.length === 0) return null; const freq = {}; let maxF = 0, result = arr[0]; for (const v of arr) { const k = String(v); freq[k] = (freq[k] || 0) + 1; if (freq[k] > maxF) { maxF = freq[k]; result = v; } } return result; }`,
  stdev: `function stdev(arr) { if (arr.length === 0) return 0; const m = arr.reduce((a, b) => a + b, 0) / arr.length; return Math.sqrt(arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length); }`,
  variance: `function variance(arr) { if (arr.length === 0) return 0; const m = arr.reduce((a, b) => a + b, 0) / arr.length; return arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length; }`,
  percentile: `function percentile(arr, p) { if (arr.length === 0) return null; const s = [...arr].sort((a, b) => a - b); const i = (p / 100) * (s.length - 1); const lo = Math.floor(i); const hi = Math.ceil(i); if (lo === hi) return s[lo]; return s[lo] + (s[hi] - s[lo]) * (i - lo); }`,

  // ── Text Utilities ─────────────────────────────────────
  truncate: `function truncate(s, n, suffix) { const sf = suffix !== undefined ? suffix : '...'; return s.length <= n ? s : s.slice(0, n - sf.length) + sf; }`,
  word_wrap: `function word_wrap(s, width) { const ws = s.split(' '); const lines = []; let line = ''; for (const w of ws) { if (line && (line.length + 1 + w.length) > width) { lines.push(line); line = w; } else { line = line ? line + ' ' + w : w; } } if (line) lines.push(line); return lines.join('\\n'); }`,
  dedent: `function dedent(s) { const lines = s.split('\\n'); const nonEmpty = lines.filter(l => l.trim().length > 0); if (nonEmpty.length === 0) return s; const indent = Math.min(...nonEmpty.map(l => l.match(/^(\\s*)/)[1].length)); return lines.map(l => l.slice(indent)).join('\\n'); }`,
  indent_str: `function indent_str(s, n, ch) { const prefix = (ch || ' ').repeat(n); return s.split('\\n').map(l => prefix + l).join('\\n'); }`,
  slugify: `function slugify(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, ''); }`,
  escape_html: `function escape_html(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }`,
  unescape_html: `function unescape_html(s) { return s.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'"); }`,

  // ── Number Formatting ──────────────────────────────────
  format_number: `function format_number(n, opts) { const o = opts || {}; const sep = o.separator || ','; const dec = o.decimals; let s = dec !== undefined ? n.toFixed(dec) : String(n); const parts = s.split('.'); parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, sep); return parts.join('.'); }`,
  to_hex: `function to_hex(n) { return Math.trunc(n).toString(16); }`,
  to_binary: `function to_binary(n) { return Math.trunc(n).toString(2); }`,
  to_octal: `function to_octal(n) { return Math.trunc(n).toString(8); }`,
  to_fixed: `function to_fixed(n, decimals) { return Number(n.toFixed(decimals)); }`,

  // ── Itertools ──────────────────────────────────────────
  pairwise: `function pairwise(arr) { const r = []; for (let i = 0; i < arr.length - 1; i++) r.push([arr[i], arr[i + 1]]); return r; }`,
  combinations: `function combinations(arr, r) { const result = []; const combo = []; function gen(start, depth) { if (depth === r) { result.push([...combo]); return; } for (let i = start; i < arr.length; i++) { combo.push(arr[i]); gen(i + 1, depth + 1); combo.pop(); } } gen(0, 0); return result; }`,
  permutations: `function permutations(arr, r) { const n = r === undefined ? arr.length : r; const result = []; const perm = []; const used = new Array(arr.length).fill(false); function gen() { if (perm.length === n) { result.push([...perm]); return; } for (let i = 0; i < arr.length; i++) { if (!used[i]) { used[i] = true; perm.push(arr[i]); gen(); perm.pop(); used[i] = false; } } } gen(); return result; }`,
  intersperse: `function intersperse(arr, sep) { if (arr.length <= 1) return [...arr]; const r = [arr[0]]; for (let i = 1; i < arr.length; i++) { r.push(sep, arr[i]); } return r; }`,
  interleave: `function interleave(...arrs) { if (arrs.length === 0) return []; const m = Math.max(...arrs.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) { for (const a of arrs) { if (i < a.length) r.push(a[i]); } } return r; }`,
  repeat_value: `function repeat_value(val, n) { return Array(n).fill(val); }`,

  // ── Array Utilities ────────────────────────────────────
  binary_search: `function binary_search(arr, target, keyFn) { let lo = 0, hi = arr.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; const val = keyFn ? keyFn(arr[mid]) : arr[mid]; if (val === target) return mid; if (val < target) lo = mid + 1; else hi = mid - 1; } return -1; }`,
  is_sorted: `function is_sorted(arr, keyFn) { for (let i = 1; i < arr.length; i++) { const a = keyFn ? keyFn(arr[i - 1]) : arr[i - 1]; const b = keyFn ? keyFn(arr[i]) : arr[i]; if (a > b) return false; } return true; }`,
  compact: `function compact(arr) { return arr.filter(v => v != null); }`,
  rotate: `function rotate(arr, n) { if (arr.length === 0) return []; const k = ((n % arr.length) + arr.length) % arr.length; return [...arr.slice(k), ...arr.slice(0, k)]; }`,
  insert_at: `function insert_at(arr, idx, val) { const r = [...arr]; r.splice(idx, 0, val); return r; }`,
  remove_at: `function remove_at(arr, idx) { const r = [...arr]; r.splice(idx, 1); return r; }`,
  update_at: `function update_at(arr, idx, val) { const r = [...arr]; r[idx] = val; return r; }`,

  // ── Functional (extended) ──────────────────────────────
  partial: `function partial(fn, ...bound) { return function(...args) { return fn(...bound, ...args); }; }`,
  curry: `function curry(fn, arity) { const n = arity || fn.length; return function curried(...args) { if (args.length >= n) return fn(...args); return function(...more) { return curried(...args, ...more); }; }; }`,
  flip: `function flip(fn) { return function(a, b, ...rest) { return fn(b, a, ...rest); }; }`,

  // ── Encoding (extended) ────────────────────────────────
  hex_encode: `function hex_encode(s) { let r = ''; for (let i = 0; i < s.length; i++) r += s.charCodeAt(i).toString(16).padStart(2, '0'); return r; }`,
  hex_decode: `function hex_decode(s) { let r = ''; for (let i = 0; i < s.length; i += 2) r += String.fromCharCode(parseInt(s.substr(i, 2), 16)); return r; }`,

  // ── String (extended) ──────────────────────────────────
  fmt: `function fmt(template, ...args) { let i = 0; return template.replace(/\\{\\}/g, () => i < args.length ? String(args[i++]) : '{}'); }`,

  // ── Scripting: Environment & CLI ──────────────────────
  env: `function env(key, fallback) { if (key === undefined) return { ...process.env }; const v = process.env[key]; return v !== undefined ? v : (fallback !== undefined ? fallback : null); }`,
  set_env: `function set_env(key, value) { process.env[key] = String(value); }`,
  args: `function args() { return typeof __tova_args !== 'undefined' ? __tova_args : process.argv.slice(2); }`,
  exit: `function exit(code) { process.exit(code !== undefined ? code : 0); }`,

  // ── Scripting: Filesystem ─────────────────────────────
  exists: `function exists(path) { const fs = require('fs'); return fs.existsSync(path); }`,
  is_dir: `function is_dir(path) { try { return require('fs').statSync(path).isDirectory(); } catch { return false; } }`,
  is_file: `function is_file(path) { try { return require('fs').statSync(path).isFile(); } catch { return false; } }`,
  ls: `function ls(dir, opts) { const fs = require('fs'); const p = require('path'); const d = dir || '.'; const entries = fs.readdirSync(d); if (opts && opts.full) return entries.map(e => p.join(d, e)); return entries; }`,
  glob_files: `function glob_files(pattern, opts) { if (typeof Bun !== 'undefined' && Bun.Glob) { const glob = new Bun.Glob(pattern); const results = [...glob.scanSync(opts && opts.cwd || '.')]; return results; } const fs = require('fs'); if (fs.globSync) return fs.globSync(pattern, opts); return []; }`,
  mkdir: `function mkdir(dir) { try { require('fs').mkdirSync(dir, { recursive: true }); return Ok(dir); } catch (e) { return Err(e.message); } }`,
  rm: `function rm(path, opts) { try { require('fs').rmSync(path, { recursive: !!(opts && opts.recursive), force: !!(opts && opts.force) }); return Ok(path); } catch (e) { return Err(e.message); } }`,
  cp: `function cp(src, dest, opts) { try { const fs = require('fs'); if (opts && opts.recursive) { fs.cpSync(src, dest, { recursive: true }); } else { fs.copyFileSync(src, dest); } return Ok(dest); } catch (e) { return Err(e.message); } }`,
  mv: `function mv(src, dest) { try { require('fs').renameSync(src, dest); return Ok(dest); } catch (e) { return Err(e.message); } }`,
  cwd: `function cwd() { return process.cwd(); }`,
  chdir: `function chdir(dir) { try { process.chdir(dir); return Ok(dir); } catch (e) { return Err(e.message); } }`,
  read_text: `function read_text(path, enc) { try { return Ok(require('fs').readFileSync(path, enc || 'utf-8')); } catch (e) { return Err(e.message); } }`,
  read_bytes: `function read_bytes(path) { try { return Ok(require('fs').readFileSync(path)); } catch (e) { return Err(e.message); } }`,
  write_text: `function write_text(path, content, opts) { try { const fs = require('fs'); if (opts && opts.append) fs.appendFileSync(path, content); else fs.writeFileSync(path, content); return Ok(path); } catch (e) { return Err(e.message); } }`,

  // ── Scripting: Shell ──────────────────────────────────
  // sh() uses shell:true for convenience (pipes, redirects). For trusted commands only.
  // exec() uses shell:false — safe from injection by default (array args).
  sh: `function sh(cmd, opts) { try { const cp = require('child_process'); const o = opts || {}; const result = cp.spawnSync(cmd, { shell: true, cwd: o.cwd, env: o.env ? { ...process.env, ...o.env } : undefined, timeout: o.timeout, stdio: o.inherit ? 'inherit' : 'pipe', encoding: 'utf-8' }); if (result.error) return Err(result.error.message); return Ok({ stdout: (result.stdout || '').trimEnd(), stderr: (result.stderr || '').trimEnd(), exitCode: result.status }); } catch (e) { return Err(e.message); } }`,
  exec: `function exec(cmd, cmdArgs, opts) { try { const cp = require('child_process'); if (cmdArgs && typeof cmdArgs === 'object' && !Array.isArray(cmdArgs)) { opts = cmdArgs; cmdArgs = []; } const o = opts || {}; const a = cmdArgs || []; const result = cp.spawnSync(cmd, a, { shell: false, cwd: o.cwd, env: o.env ? { ...process.env, ...o.env } : undefined, timeout: o.timeout, stdio: o.inherit ? 'inherit' : 'pipe', encoding: 'utf-8' }); if (result.error) return Err(result.error.message); return Ok({ stdout: (result.stdout || '').trimEnd(), stderr: (result.stderr || '').trimEnd(), exitCode: result.status }); } catch (e) { return Err(e.message); } }`,

  // ── Scripting: stdin ─────────────────────────────────
  read_stdin: `function read_stdin() { try { return require('fs').readFileSync(0, 'utf-8'); } catch { return ''; } }`,
  read_lines: `function read_lines() { try { return require('fs').readFileSync(0, 'utf-8').split('\\n').filter(l => l.length > 0); } catch { return []; } }`,

  // ── Scripting: Script path ──────────────────────────
  script_path: `function script_path() { return typeof __tova_filename !== 'undefined' ? __tova_filename : null; }`,
  script_dir: `function script_dir() { return typeof __tova_dirname !== 'undefined' ? __tova_dirname : null; }`,

  // ── Scripting: Argument parsing ──────────────────────
  parse_args: `function parse_args(argv) { const flags = {}; const positional = []; let i = 0; while (i < argv.length) { const arg = argv[i]; if (arg === '--') { positional.push(...argv.slice(i + 1)); break; } if (arg.startsWith('--')) { const eq = arg.indexOf('='); if (eq !== -1) { flags[arg.slice(2, eq)] = arg.slice(eq + 1); } else if (i + 1 < argv.length && !argv[i + 1].startsWith('-')) { flags[arg.slice(2)] = argv[i + 1]; i++; } else { flags[arg.slice(2)] = true; } } else if (arg.startsWith('-') && arg.length > 1) { for (let j = 1; j < arg.length; j++) flags[arg[j]] = true; } else { positional.push(arg); } i++; } return { flags, positional }; }`,

  // ── Lazy Iterators / Sequences ──────────────────────
  iter: `function iter(source) { return new Seq(function*() { for (const x of source) yield x; }); }`,
  Seq: `class Seq {
  constructor(gen) { this._gen = gen; }
  filter(fn) { const g = this._gen; return new Seq(function*() { for (const x of g()) if (fn(x)) yield x; }); }
  map(fn) { const g = this._gen; return new Seq(function*() { for (const x of g()) yield fn(x); }); }
  take(n) { const g = this._gen; return new Seq(function*() { let i = 0; for (const x of g()) { if (i++ >= n) return; yield x; } }); }
  drop(n) { const g = this._gen; return new Seq(function*() { let i = 0; for (const x of g()) { if (i++ < n) continue; yield x; } }); }
  zip(other) { const g1 = this._gen; const g2 = other._gen; return new Seq(function*() { const i1 = g1(), i2 = g2(); while (true) { const a = i1.next(), b = i2.next(); if (a.done || b.done) return; yield [a.value, b.value]; } }); }
  flat_map(fn) { const g = this._gen; return new Seq(function*() { for (const x of g()) { const result = fn(x); if (result && result._gen) { for (const y of result._gen()) yield y; } else if (result && result[Symbol.iterator]) { for (const y of result) yield y; } else { yield result; } } }); }
  enumerate() { const g = this._gen; return new Seq(function*() { let i = 0; for (const x of g()) yield [i++, x]; }); }
  collect() { return [...this._gen()]; }
  toArray() { return this.collect(); }
  reduce(fn, init) { let acc = init; for (const x of this._gen()) acc = fn(acc, x); return acc; }
  first() { for (const x of this._gen()) return Some(x); return None; }
  count() { let n = 0; for (const x of this._gen()) n++; return n; }
  forEach(fn) { for (const x of this._gen()) fn(x); }
  any(fn) { for (const x of this._gen()) if (fn(x)) return true; return false; }
  all(fn) { for (const x of this._gen()) if (!fn(x)) return false; return true; }
  find(fn) { for (const x of this._gen()) if (fn(x)) return Some(x); return None; }
  [Symbol.iterator]() { return this._gen(); }
}`,

  // ── Scripting: Terminal colors ──────────────────────
  color: `function color(text, name) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); const codes = { red: '31', green: '32', yellow: '33', blue: '34', magenta: '35', cyan: '36', white: '37', gray: '90' }; const c = codes[name]; return c ? '\\x1b[' + c + 'm' + text + '\\x1b[0m' : String(text); }`,
  bold: `function bold(text) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); return '\\x1b[1m' + text + '\\x1b[0m'; }`,
  dim: `function dim(text) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); return '\\x1b[2m' + text + '\\x1b[0m'; }`,

  // ── Scripting: Signal handling ────────────────────────
  on_signal: `function on_signal(name, callback) { process.on(name, callback); }`,

  // ── Scripting: File stat ──────────────────────────────
  file_stat: `function file_stat(path) { try { const s = require('fs').statSync(path); return Ok({ size: s.size, mode: s.mode, mtime: s.mtime.toISOString(), atime: s.atime.toISOString(), isDir: s.isDirectory(), isFile: s.isFile(), isSymlink: s.isSymbolicLink() }); } catch (e) { return Err(e.message); } }`,
  file_size: `function file_size(path) { try { return Ok(require('fs').statSync(path).size); } catch (e) { return Err(e.message); } }`,

  // ── Scripting: Path utilities ─────────────────────────
  path_join: `function path_join(...parts) { return require('path').join(...parts); }`,
  path_dirname: `function path_dirname(p) { return require('path').dirname(p); }`,
  path_basename: `function path_basename(p, ext) { return ext ? require('path').basename(p, ext) : require('path').basename(p); }`,
  path_resolve: `function path_resolve(p) { return require('path').resolve(p); }`,
  path_ext: `function path_ext(p) { return require('path').extname(p); }`,
  path_relative: `function path_relative(from, to) { return require('path').relative(from, to); }`,

  // ── Scripting: Symlinks ───────────────────────────────
  symlink: `function symlink(target, path) { try { require('fs').symlinkSync(target, path); return Ok(null); } catch (e) { return Err(e.message); } }`,
  readlink: `function readlink(path) { try { return Ok(require('fs').readlinkSync(path)); } catch (e) { return Err(e.message); } }`,
  is_symlink: `function is_symlink(path) { try { return require('fs').lstatSync(path).isSymbolicLink(); } catch { return false; } }`,

  // ── Scripting: Async shell ────────────────────────────
  spawn: `function spawn(cmd, cmdArgs, opts) { if (cmdArgs && typeof cmdArgs === 'object' && !Array.isArray(cmdArgs)) { opts = cmdArgs; cmdArgs = []; } const o = opts || {}; const a = cmdArgs || []; return new Promise(function(resolve) { try { const cp = require('child_process'); const child = cp.spawn(cmd, a, { shell: !!o.shell, cwd: o.cwd, env: o.env ? Object.assign({}, process.env, o.env) : undefined, stdio: 'pipe' }); let stdout = ''; let stderr = ''; child.stdout.on('data', function(d) { stdout += d; }); child.stderr.on('data', function(d) { stderr += d; }); child.on('error', function(e) { resolve(Err(e.message)); }); child.on('close', function(code) { resolve(Ok({ stdout: stdout.trimEnd(), stderr: stderr.trimEnd(), exitCode: code })); }); } catch (e) { resolve(Err(e.message)); } }); }`,

  // ── Ordering type ─────────────────────────────────────
  Less: `const Less = Object.freeze({ __tag: "Less", value: -1 });`,
  Equal: `const Equal = Object.freeze({ __tag: "Equal", value: 0 });`,
  Greater: `const Greater = Object.freeze({ __tag: "Greater", value: 1 });`,
  compare: `function compare(a, b) { if (a < b) return Less; if (a > b) return Greater; return Equal; }`,
  compare_by: `function compare_by(arr, fn) { return [...arr].sort(function(a, b) { const ord = fn(a, b); return ord.value; }); }`,

  // ── Regex Builder ─────────────────────────────────────
  RegexBuilder: `class RegexBuilder {
  constructor() { this._parts = []; this._flags = ''; }
  literal(s) { this._parts.push(s.replace(/[.*+?^\${}()|[\\]\\\\]/g, '\\\\$&')); return this; }
  digits(n) { this._parts.push(n ? '\\\\d{' + n + '}' : '\\\\d+'); return this; }
  word() { this._parts.push('\\\\w+'); return this; }
  space() { this._parts.push('\\\\s+'); return this; }
  any() { this._parts.push('.'); return this; }
  oneOf(chars) { this._parts.push('[' + chars.replace(/[\\]\\\\]/g, '\\\\$&') + ']'); return this; }
  group(name) { this._parts.push(name ? '(?<' + name + '>' : '('); return this; }
  endGroup() { this._parts.push(')'); return this; }
  optional() { this._parts.push('?'); return this; }
  oneOrMore() { this._parts.push('+'); return this; }
  zeroOrMore() { this._parts.push('*'); return this; }
  startOfLine() { this._parts.push('^'); return this; }
  endOfLine() { this._parts.push('$'); return this; }
  flags(f) { this._flags = f; return this; }
  build() { return new RegExp(this._parts.join(''), this._flags); }
  test(s) { return this.build().test(s); }
  match(s) { return s.match(this.build()); }
}`,
  regex_builder: `function regex_builder() { return new RegexBuilder(); }`,

  // ── Namespace modules ──────────────────────────────────
  math: `const math = Object.freeze({
  sin(n) { return Math.sin(n); },
  cos(n) { return Math.cos(n); },
  tan(n) { return Math.tan(n); },
  asin(n) { return Math.asin(n); },
  acos(n) { return Math.acos(n); },
  atan(n) { return Math.atan(n); },
  atan2(y, x) { return Math.atan2(y, x); },
  log(n) { return Math.log(n); },
  log2(n) { return Math.log2(n); },
  log10(n) { return Math.log10(n); },
  exp(n) { return Math.exp(n); },
  abs(n) { return Math.abs(n); },
  floor(n) { return Math.floor(n); },
  ceil(n) { return Math.ceil(n); },
  round(n) { return Math.round(n); },
  sqrt(n) { return Math.sqrt(n); },
  pow(b, e) { return Math.pow(b, e); },
  clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); },
  random() { return Math.random(); },
  sign(n) { return Math.sign(n); },
  trunc(n) { return Math.trunc(n); },
  hypot(a, b) { return Math.hypot(a, b); },
  lerp(a, b, t) { return a + (b - a) * t; },
  gcd(a, b) { a = Math.abs(a); b = Math.abs(b); while (b) { [a, b] = [b, a % b]; } return a; },
  lcm(a, b) { if (a === 0 && b === 0) return 0; let x = Math.abs(a), y = Math.abs(b); while (y) { const t = y; y = x % y; x = t; } return Math.abs(a * b) / x; },
  factorial(n) { if (n < 0) return null; if (n <= 1) return 1; let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; },
  PI: Math.PI,
  E: Math.E,
  INF: Infinity
});`,

  str: `const str = Object.freeze({
  upper(s) { return s.toUpperCase(); },
  lower(s) { return s.toLowerCase(); },
  trim(s) { return s.trim(); },
  trim_start(s) { return s.trimStart(); },
  trim_end(s) { return s.trimEnd(); },
  split(s, sep) { return s.split(sep); },
  join(arr, sep) { return arr.join(sep); },
  replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); },
  repeat(s, n) { return s.repeat(n); },
  contains(s, sub) { return s.includes(sub); },
  starts_with(s, prefix) { return s.startsWith(prefix); },
  ends_with(s, suffix) { return s.endsWith(suffix); },
  chars(s) { return [...s]; },
  words(s) { return s.split(/\\s+/).filter(Boolean); },
  lines(s) { return s.split('\\n'); },
  capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; },
  title_case(s) { return s.replace(/\\b\\w/g, c => c.toUpperCase()); },
  snake_case(s) { return s.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },
  camel_case(s) { return s.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },
  kebab_case(s) { return s.replace(/[-\\s]+/g, '-').replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase().replace(/^-/, ''); },
  index_of(s, sub) { const i = s.indexOf(sub); return i === -1 ? null : i; },
  last_index_of(s, sub) { const i = s.lastIndexOf(sub); return i === -1 ? null : i; },
  pad_start(s, n, fill) { return s.padStart(n, fill || ' '); },
  pad_end(s, n, fill) { return s.padEnd(n, fill || ' '); },
  center(s, n, fill) { if (s.length >= n) return s; const f = fill || ' '; const total = n - s.length; const left = Math.floor(total / 2); const right = total - left; return f.repeat(Math.ceil(left / f.length)).slice(0, left) + s + f.repeat(Math.ceil(right / f.length)).slice(0, right); },
  slugify(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, ''); },
  escape_html(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); },
  unescape_html(s) { return s.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'"); }
});`,

  arr: `const arr = Object.freeze({
  sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; },
  reversed(a) { return [...a].reverse(); },
  unique(a) { return [...new Set(a)]; },
  chunk(a, n) { const r = []; for (let i = 0; i < a.length; i += n) r.push(a.slice(i, i + n)); return r; },
  flatten(a) { return a.flat(); },
  take(a, n) { return a.slice(0, n); },
  drop(a, n) { return a.slice(n); },
  first(a) { return a.length > 0 ? a[0] : null; },
  last(a) { return a.length > 0 ? a[a.length - 1] : null; },
  count(a, fn) { return a.filter(fn).length; },
  partition(a, fn) { const y = [], n = []; for (const v of a) { (fn(v) ? y : n).push(v); } return [y, n]; },
  group_by(a, fn) { const r = {}; for (const v of a) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; },
  zip_with(a, b, fn) { const m = Math.min(a.length, b.length); const r = []; for (let i = 0; i < m; i++) r.push(fn ? fn(a[i], b[i]) : [a[i], b[i]]); return r; },
  frequencies(a) { const r = {}; for (const v of a) { const k = String(v); r[k] = (r[k] || 0) + 1; } return r; },
  scan(a, fn, init) { const r = []; let acc = init; for (const v of a) { acc = fn(acc, v); r.push(acc); } return r; },
  min_by(a, fn) { if (a.length === 0) return null; let best = a[0], bestK = fn(a[0]); for (let i = 1; i < a.length; i++) { const k = fn(a[i]); if (k < bestK) { best = a[i]; bestK = k; } } return best; },
  max_by(a, fn) { if (a.length === 0) return null; let best = a[0], bestK = fn(a[0]); for (let i = 1; i < a.length; i++) { const k = fn(a[i]); if (k > bestK) { best = a[i]; bestK = k; } } return best; },
  sum_by(a, fn) { let s = 0; for (const v of a) s += fn(v); return s; },
  compact(a) { return a.filter(v => v != null); },
  rotate(a, n) { if (a.length === 0) return []; const k = ((n % a.length) + a.length) % a.length; return [...a.slice(k), ...a.slice(0, k)]; },
  insert_at(a, idx, val) { const r = [...a]; r.splice(idx, 0, val); return r; },
  remove_at(a, idx) { const r = [...a]; r.splice(idx, 1); return r; },
  binary_search(a, target, keyFn) { let lo = 0, hi = a.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; const val = keyFn ? keyFn(a[mid]) : a[mid]; if (val === target) return mid; if (val < target) lo = mid + 1; else hi = mid - 1; } return -1; },
  is_sorted(a, keyFn) { for (let i = 1; i < a.length; i++) { const x = keyFn ? keyFn(a[i - 1]) : a[i - 1]; const y = keyFn ? keyFn(a[i]) : a[i]; if (x > y) return false; } return true; }
});`,

  dt: `const dt = Object.freeze({
  now() { return Date.now(); },
  now_iso() { return new Date().toISOString(); },
  parse(s) { const d = new Date(s); return isNaN(d.getTime()) ? Err('Invalid date: ' + s) : Ok(d); },
  format(d, fmt) { if (typeof d === 'number') d = new Date(d); if (fmt === 'iso') return d.toISOString(); if (fmt === 'date') return d.toISOString().slice(0, 10); if (fmt === 'time') return d.toTimeString().slice(0, 8); if (fmt === 'datetime') return d.toISOString().slice(0, 10) + ' ' + d.toTimeString().slice(0, 8); return fmt.replace('YYYY', String(d.getFullYear())).replace('MM', String(d.getMonth() + 1).padStart(2, '0')).replace('DD', String(d.getDate()).padStart(2, '0')).replace('HH', String(d.getHours()).padStart(2, '0')).replace('mm', String(d.getMinutes()).padStart(2, '0')).replace('ss', String(d.getSeconds()).padStart(2, '0')); },
  add(d, amount, unit) { if (typeof d === 'number') d = new Date(d); const r = new Date(d.getTime()); if (unit === 'years') r.setFullYear(r.getFullYear() + amount); else if (unit === 'months') r.setMonth(r.getMonth() + amount); else if (unit === 'days') r.setDate(r.getDate() + amount); else if (unit === 'hours') r.setHours(r.getHours() + amount); else if (unit === 'minutes') r.setMinutes(r.getMinutes() + amount); else if (unit === 'seconds') r.setSeconds(r.getSeconds() + amount); return r; },
  diff(d1, d2, unit) { if (typeof d1 === 'number') d1 = new Date(d1); if (typeof d2 === 'number') d2 = new Date(d2); const ms = d2.getTime() - d1.getTime(); if (unit === 'seconds') return Math.floor(ms / 1000); if (unit === 'minutes') return Math.floor(ms / 60000); if (unit === 'hours') return Math.floor(ms / 3600000); if (unit === 'days') return Math.floor(ms / 86400000); if (unit === 'months') return (d2.getFullYear() - d1.getFullYear()) * 12 + (d2.getMonth() - d1.getMonth()); if (unit === 'years') return d2.getFullYear() - d1.getFullYear(); return ms; },
  from(parts) { return new Date(parts.year || 0, (parts.month || 1) - 1, parts.day || 1, parts.hour || 0, parts.minute || 0, parts.second || 0); },
  part(d, p) { if (typeof d === 'number') d = new Date(d); if (p === 'year') return d.getFullYear(); if (p === 'month') return d.getMonth() + 1; if (p === 'day') return d.getDate(); if (p === 'hour') return d.getHours(); if (p === 'minute') return d.getMinutes(); if (p === 'second') return d.getSeconds(); if (p === 'weekday') return d.getDay(); return null; },
  time_ago(d) { if (typeof d === 'number') d = new Date(d); const s = Math.floor((Date.now() - d.getTime()) / 1000); if (s < 60) return s + ' seconds ago'; const m = Math.floor(s / 60); if (m < 60) return m + (m === 1 ? ' minute ago' : ' minutes ago'); const h = Math.floor(m / 60); if (h < 24) return h + (h === 1 ? ' hour ago' : ' hours ago'); const dy = Math.floor(h / 24); if (dy < 30) return dy + (dy === 1 ? ' day ago' : ' days ago'); const mo = Math.floor(dy / 30); if (mo < 12) return mo + (mo === 1 ? ' month ago' : ' months ago'); const yr = Math.floor(mo / 12); return yr + (yr === 1 ? ' year ago' : ' years ago'); }
});`,

  re: `const re = Object.freeze({
  test(s, pattern, flags) { return new RegExp(pattern, flags).test(s); },
  match(s, pattern, flags) { const m = s.match(new RegExp(pattern, flags)); if (!m) return Err('No match'); return Ok({ match: m[0], index: m.index, groups: m.slice(1) }); },
  find_all(s, pattern, flags) { const r = new RegExp(pattern, (flags || '') + (flags && flags.includes('g') ? '' : 'g')); const results = []; let m; while ((m = r.exec(s)) !== null) { results.push({ match: m[0], index: m.index, groups: m.slice(1) }); } return results; },
  replace(s, pattern, replacement, flags) { return s.replace(new RegExp(pattern, flags || 'g'), replacement); },
  split(s, pattern, flags) { return s.split(new RegExp(pattern, flags)); },
  capture(s, pattern, flags) { const m = s.match(new RegExp(pattern, flags)); if (!m) return Err('No match'); if (!m.groups) return Err('No named groups'); return Ok(m.groups); }
});`,

  json: `const json = Object.freeze({
  parse(s) { try { return Ok(JSON.parse(s)); } catch (e) { return Err(e.message); } },
  stringify(v) { return JSON.stringify(v); },
  pretty(v) { return JSON.stringify(v, null, 2); }
});`,

  fs: `const fs = Object.freeze({
  read_text(path, enc) { try { return Ok(require('fs').readFileSync(path, enc || 'utf-8')); } catch (e) { return Err(e.message); } },
  write_text(path, content, opts) { try { const f = require('fs'); if (opts && opts.append) f.appendFileSync(path, content); else f.writeFileSync(path, content); return Ok(path); } catch (e) { return Err(e.message); } },
  exists(path) { return require('fs').existsSync(path); },
  is_dir(path) { try { return require('fs').statSync(path).isDirectory(); } catch { return false; } },
  is_file(path) { try { return require('fs').statSync(path).isFile(); } catch { return false; } },
  ls(dir, opts) { const f = require('fs'); const p = require('path'); const d = dir || '.'; const entries = f.readdirSync(d); if (opts && opts.full) return entries.map(e => p.join(d, e)); return entries; },
  mkdir(dir) { try { require('fs').mkdirSync(dir, { recursive: true }); return Ok(dir); } catch (e) { return Err(e.message); } },
  rm(path, opts) { try { require('fs').rmSync(path, { recursive: !!(opts && opts.recursive), force: !!(opts && opts.force) }); return Ok(path); } catch (e) { return Err(e.message); } },
  cp(src, dest, opts) { try { const f = require('fs'); if (opts && opts.recursive) { f.cpSync(src, dest, { recursive: true }); } else { f.copyFileSync(src, dest); } return Ok(dest); } catch (e) { return Err(e.message); } },
  mv(src, dest) { try { require('fs').renameSync(src, dest); return Ok(dest); } catch (e) { return Err(e.message); } },
  glob_files(pattern, opts) { if (typeof Bun !== 'undefined' && Bun.Glob) { const glob = new Bun.Glob(pattern); return [...glob.scanSync(opts && opts.cwd || '.')]; } const f = require('fs'); if (f.globSync) return f.globSync(pattern, opts); return []; }
});`,

  url: `const url = Object.freeze({
  parse(s) { try { const u = new URL(s); return Ok({ protocol: u.protocol.replace(':', ''), host: u.host, pathname: u.pathname, search: u.search, hash: u.hash }); } catch (e) { return Err('Invalid URL: ' + s); } },
  build(parts) { let u = (parts.protocol || 'https') + '://' + (parts.host || ''); u += parts.pathname || '/'; if (parts.search) u += (parts.search.startsWith('?') ? '' : '?') + parts.search; if (parts.hash) u += (parts.hash.startsWith('#') ? '' : '#') + parts.hash; return u; },
  parse_query(s) { const r = {}; const qs = s.startsWith('?') ? s.slice(1) : s; if (!qs) return r; for (const pair of qs.split('&')) { const [k, ...v] = pair.split('='); r[decodeURIComponent(k)] = decodeURIComponent(v.join('=')); } return r; },
  build_query(obj) { return Object.entries(obj).map(([k, v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); }
});`,

  // ── Channel-based async ───────────────────────────────
  Channel: `class Channel {
  constructor(capacity) {
    this._capacity = capacity || 0;
    this._buffer = [];
    this._closed = false;
    this._sendWaiters = [];
    this._recvWaiters = [];
  }
  async send(value) {
    if (this._closed) throw new Error('Cannot send on closed channel');
    if (this._recvWaiters.length > 0) {
      const waiter = this._recvWaiters.shift();
      waiter(Some(value));
      return;
    }
    if (this._capacity > 0 && this._buffer.length < this._capacity) {
      this._buffer.push(value);
      return;
    }
    return new Promise(function(resolve) {
      this._sendWaiters.push({ value: value, resolve: resolve });
    }.bind(this));
  }
  async receive() {
    if (this._buffer.length > 0) {
      const value = this._buffer.shift();
      if (this._sendWaiters.length > 0) {
        const waiter = this._sendWaiters.shift();
        this._buffer.push(waiter.value);
        waiter.resolve();
      }
      return Some(value);
    }
    if (this._closed) return None;
    if (this._sendWaiters.length > 0) {
      const waiter = this._sendWaiters.shift();
      waiter.resolve();
      return Some(waiter.value);
    }
    return new Promise(function(resolve) {
      this._recvWaiters.push(resolve);
    }.bind(this));
  }
  close() {
    this._closed = true;
    for (const waiter of this._recvWaiters) waiter(None);
    this._recvWaiters = [];
  }
  [Symbol.asyncIterator]() {
    const ch = this;
    return {
      async next() {
        const val = await ch.receive();
        if (val.__tag === 'None') return { done: true, value: undefined };
        return { done: false, value: val.value };
      }
    };
  }
}`,

  // ── Snapshot testing ──────────────────────────────────
  assert_snapshot: `function assert_snapshot(value, name) {
  const snap = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
  const updateMode = typeof process !== 'undefined' && process.env.TOVA_UPDATE_SNAPSHOTS === '1';
  if (typeof __tova_snapshots === 'undefined') { globalThis.__tova_snapshots = {}; }
  const key = name || ('snapshot_' + Object.keys(__tova_snapshots).length);
  if (updateMode || !__tova_snapshots[key]) {
    __tova_snapshots[key] = snap;
    return;
  }
  if (__tova_snapshots[key] !== snap) {
    throw new Error('Snapshot mismatch for "' + key + '":\\nExpected:\\n' + __tova_snapshots[key] + '\\nActual:\\n' + snap);
  }
}`,

  // ── Property-based testing ────────────────────────────
  Gen: `const Gen = {
  int: function(min, max) { return function() { const lo = min !== undefined ? min : -1000; const hi = max !== undefined ? max : 1000; return Math.floor(Math.random() * (hi - lo + 1)) + lo; }; },
  float: function(min, max) { return function() { const lo = min !== undefined ? min : -1000; const hi = max !== undefined ? max : 1000; return Math.random() * (hi - lo) + lo; }; },
  bool: function() { return function() { return Math.random() < 0.5; }; },
  string: function(maxLen) { return function() { const len = Math.floor(Math.random() * (maxLen || 20)); const chars = 'abcdefghijklmnopqrstuvwxyz0123456789'; let s = ''; for (let i = 0; i < len; i++) s += chars[Math.floor(Math.random() * chars.length)]; return s; }; },
  array: function(gen, maxLen) { return function() { const len = Math.floor(Math.random() * (maxLen || 10)); const arr = []; for (let i = 0; i < len; i++) arr.push(gen()); return arr; }; },
  oneOf: function(values) { return function() { return values[Math.floor(Math.random() * values.length)]; }; }
};`,
  forAll: `function forAll(generators, property, opts) {
  const runs = (opts && opts.runs) || 100;
  for (let i = 0; i < runs; i++) {
    const args = generators.map(function(g) { return g(); });
    let result;
    try { result = property.apply(null, args); } catch (e) { throw new Error('Property failed on input ' + JSON.stringify(args) + ': ' + e.message); }
    if (result === false) { throw new Error('Property failed on input: ' + JSON.stringify(args)); }
  }
}`,

  // ── Mock / Spy Utilities ────────────────────────────────
  create_spy: `function create_spy(impl) {
  const spy = function(...args) {
    spy.calls.push(args);
    spy.call_count++;
    spy.called = true;
    spy.last_args = args;
    if (spy._impl) return spy._impl(...args);
    return spy._return_value;
  };
  spy.calls = [];
  spy.call_count = 0;
  spy.called = false;
  spy.last_args = null;
  spy._impl = impl || null;
  spy._return_value = undefined;
  spy.returns = function(val) { spy._return_value = val; spy._impl = null; return spy; };
  spy.reset = function() { spy.calls = []; spy.call_count = 0; spy.called = false; spy.last_args = null; };
  spy.called_with = function(...expected) {
    return spy.calls.some(function(call) {
      return expected.length === call.length && expected.every(function(v, i) { return v === call[i]; });
    });
  };
  return spy;
}`,
  create_mock: `function create_mock(return_value) {
  return create_spy(typeof return_value === 'function' ? return_value : function() { return return_value; });
}`,

  // ── Advanced Collections ────────────────────────────────
  OrderedDict: `class OrderedDict {
  constructor(entries) { this._map = new Map(entries || []); }
  get(key) { return this._map.has(key) ? this._map.get(key) : null; }
  set(key, value) { const m = new Map(this._map); m.set(key, value); return new OrderedDict([...m]); }
  delete(key) { const m = new Map(this._map); m.delete(key); return new OrderedDict([...m]); }
  has(key) { return this._map.has(key); }
  keys() { return [...this._map.keys()]; }
  values() { return [...this._map.values()]; }
  entries() { return [...this._map.entries()]; }
  get length() { return this._map.size; }
  [Symbol.iterator]() { return this._map[Symbol.iterator](); }
  toString() { return 'OrderedDict(' + this._map.size + ' entries)'; }
}`,

  DefaultDict: `class DefaultDict {
  constructor(defaultFn) { this._map = new Map(); this._default = defaultFn; }
  get(key) { if (!this._map.has(key)) { this._map.set(key, this._default()); } return this._map.get(key); }
  set(key, value) { this._map.set(key, value); return this; }
  has(key) { return this._map.has(key); }
  delete(key) { this._map.delete(key); return this; }
  keys() { return [...this._map.keys()]; }
  values() { return [...this._map.values()]; }
  entries() { return [...this._map.entries()]; }
  get length() { return this._map.size; }
  [Symbol.iterator]() { return this._map[Symbol.iterator](); }
  toString() { return 'DefaultDict(' + this._map.size + ' entries)'; }
}`,

  Counter: `class Counter {
  constructor(items) { this._counts = new Map(); if (items) { for (const item of items) { this._counts.set(item, (this._counts.get(item) || 0) + 1); } } }
  count(item) { return this._counts.get(item) || 0; }
  total() { let s = 0; for (const v of this._counts.values()) s += v; return s; }
  most_common(n) { const sorted = [...this._counts.entries()].sort((a, b) => b[1] - a[1]); return n !== undefined ? sorted.slice(0, n) : sorted; }
  keys() { return [...this._counts.keys()]; }
  values() { return [...this._counts.values()]; }
  entries() { return [...this._counts.entries()]; }
  has(item) { return this._counts.has(item); }
  get length() { return this._counts.size; }
  [Symbol.iterator]() { return this._counts[Symbol.iterator](); }
  toString() { return 'Counter(' + this._counts.size + ' items)'; }
}`,

  Deque: `class Deque {
  constructor(items) { this._items = items ? [...items] : []; }
  push_back(val) { return new Deque([...this._items, val]); }
  push_front(val) { return new Deque([val, ...this._items]); }
  pop_back() { if (this._items.length === 0) return [null, this]; return [this._items[this._items.length - 1], new Deque(this._items.slice(0, -1))]; }
  pop_front() { if (this._items.length === 0) return [null, this]; return [this._items[0], new Deque(this._items.slice(1))]; }
  peek_front() { return this._items.length > 0 ? this._items[0] : null; }
  peek_back() { return this._items.length > 0 ? this._items[this._items.length - 1] : null; }
  get length() { return this._items.length; }
  toArray() { return [...this._items]; }
  [Symbol.iterator]() { return this._items[Symbol.iterator](); }
  toString() { return 'Deque(' + this._items.length + ' items)'; }
}`,

  collections: `const collections = Object.freeze({
  OrderedDict, DefaultDict, Counter, Deque
});`,

  // ─── Typed numeric array functions for @fast mode ───────────────

  typed_zeros: `function typed_zeros(n, Type) {
  return new (Type || Float64Array)(n);
}`,

  typed_ones: `function typed_ones(n, Type) {
  const out = new (Type || Float64Array)(n);
  out.fill(1);
  return out;
}`,

  typed_fill: `function typed_fill(arr, value) {
  const out = new arr.constructor(arr.length);
  out.fill(value);
  return out;
}`,

  typed_range: `function typed_range(start, end, step) {
  step = step || 1;
  const n = Math.ceil((end - start) / step);
  const arr = new Float64Array(n);
  for (let i = 0; i < n; i++) arr[i] = start + i * step;
  return arr;
}`,

  typed_linspace: `function typed_linspace(start, end, n) {
  const out = new Float64Array(n);
  if (n <= 1) { if (n === 1) out[0] = start; return out; }
  const step = (end - start) / (n - 1);
  for (let i = 0; i < n; i++) out[i] = start + i * step;
  return out;
}`,

  typed_sum: `function typed_sum(arr) {
  let s = 0, c = 0;
  for (let i = 0; i < arr.length; i++) {
    const y = arr[i] - c;
    const t = s + y;
    c = (t - s) - y;
    s = t;
  }
  return s;
}`,

  typed_dot: `function typed_dot(a, b) {
  const n = a.length;
  let s = 0;
  for (let i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}`,

  typed_norm: `function typed_norm(arr) {
  let s = 0;
  for (let i = 0; i < arr.length; i++) s += arr[i] * arr[i];
  return Math.sqrt(s);
}`,

  typed_add: `function typed_add(a, b) {
  const n = a.length;
  const out = new a.constructor(n);
  for (let i = 0; i < n; i++) out[i] = a[i] + b[i];
  return out;
}`,

  typed_scale: `function typed_scale(arr, scalar) {
  const out = new arr.constructor(arr.length);
  for (let i = 0; i < arr.length; i++) out[i] = arr[i] * scalar;
  return out;
}`,

  typed_map: `function typed_map(arr, fn) {
  const out = new arr.constructor(arr.length);
  for (let i = 0; i < arr.length; i++) out[i] = fn(arr[i], i);
  return out;
}`,

  typed_reduce: `function typed_reduce(arr, fn, init) {
  let acc = init;
  for (let i = 0; i < arr.length; i++) acc = fn(acc, arr[i], i);
  return acc;
}`,

  typed_sort: `function typed_sort(arr) {
  if (arr instanceof Float64Array || arr instanceof Int32Array || arr instanceof Uint8Array ||
      arr instanceof Float32Array || arr instanceof Int16Array || arr instanceof Uint16Array ||
      arr instanceof Uint32Array || arr instanceof Int8Array) {
    const out = new arr.constructor(arr);
    out.sort();
    return out;
  }
  const out = [...arr];
  out.sort((a, b) => a - b);
  return out;
}`,
};

// All known builtin names for matching
const BUILTIN_NAMES = new Set(Object.keys(BUILTIN_FUNCTIONS));

// ─── Stdlib Dependency Graph ──────────────────────────────────
// Maps each builtin to the builtins it depends on (must be emitted first).
// This replaces scattered ad-hoc dependency checks throughout the codebase.
const STDLIB_DEPS = {
  // iter() requires the Seq class
  iter: ['Seq'],
  // collections namespace requires all collection classes
  collections: ['OrderedDict', 'DefaultDict', 'Counter', 'Deque'],
  // Table operations may use Table
  describe: ['Table'],
  // Some builtins reference Result/Option types (Ok, Err, Some, None)
  // These are provided by RESULT_OPTION, not the builtin map, so no dep here
  // Namespace modules that use builtins internally
  json: ['Ok', 'Err'],
  re: ['Ok', 'Err'],
  dt: ['Ok', 'Err'],
  fs: ['Ok', 'Err'],
  url: ['Ok', 'Err'],
  parse_url: ['Ok', 'Err'],
  regex_test: ['__regex_cache'],
  regex_match: ['Ok', 'Err', '__regex_cache'],
  regex_find_all: ['__regex_cache'],
  regex_replace: ['__regex_cache'],
  regex_split: ['__regex_cache'],
  regex_capture: ['Ok', 'Err', '__regex_cache'],
  json_parse: ['Ok', 'Err'],
  date_parse: ['Ok', 'Err'],
  read_text: ['Ok', 'Err'],
  try_fn: ['Ok', 'Err'],
  try_async: ['Ok', 'Err'],
  // LazyTable requires Table and table_* functions
  lazy: ['LazyTable', 'Table'],
  collect: ['LazyTable'],
  LazyTable: ['Table', 'table_where', 'table_group_by'],
  // Seq uses Some/None
  Seq: ['Some', 'None'],
  // compare family
  compare: ['Less', 'Equal', 'Greater'],
  compare_by: ['Less', 'Equal', 'Greater'],
  // mock/spy
  create_mock: ['create_spy'],
};

// Resolve all transitive dependencies for a set of used names
function resolveStdlibDeps(usedNames) {
  const resolved = new Set(usedNames);
  const queue = [...usedNames];
  while (queue.length > 0) {
    const name = queue.pop();
    const deps = STDLIB_DEPS[name];
    if (deps) {
      for (const dep of deps) {
        if (!resolved.has(dep)) {
          resolved.add(dep);
          queue.push(dep);
        }
      }
    }
  }
  return resolved;
}

// Topological sort: emit dependencies before dependents
function _topoSort(names) {
  const result = [];
  const visited = new Set();
  const visiting = new Set();

  function visit(name) {
    if (visited.has(name)) return;
    if (visiting.has(name)) return; // circular — break
    visiting.add(name);
    const deps = STDLIB_DEPS[name];
    if (deps) {
      for (const dep of deps) {
        if (names.has(dep)) visit(dep);
      }
    }
    visiting.delete(name);
    visited.add(name);
    result.push(name);
  }

  for (const name of names) visit(name);
  return result;
}

// Legacy compat: full stdlib as a single string (derived from BUILTIN_FUNCTIONS)
// Only includes non-internal, non-table functions for backward compat with tests/playground
const _LEGACY_NAMES = [
  'print', 'len', 'range', 'enumerate', 'sum', 'sorted', 'reversed', 'zip',
  'min', 'max', 'type_of', 'filter', 'map', 'find', 'any', 'all', 'flat_map',
  'reduce', 'unique', 'group_by', 'chunk', 'flatten', 'take', 'drop', 'first',
  'last', 'count', 'partition', 'abs', 'floor', 'ceil', 'round', 'clamp',
  'sqrt', 'pow', 'random', 'trim', 'split', 'join', 'replace', 'repeat',
  'keys', 'values', 'entries', 'merge', 'freeze', 'clone', 'sleep',
  'upper', 'lower', 'contains', 'starts_with', 'ends_with', 'chars', 'words',
  'lines', 'capitalize', 'title_case', 'snake_case', 'camel_case',
  'assert_eq', 'assert_ne', 'assert', 'assert_throws',
  'create_spy', 'create_mock',
  'parallel_map',
];
const BUILTINS = _LEGACY_NAMES.map(n => BUILTIN_FUNCTIONS[n]).join('\n');

// Build stdlib containing only the functions that are actually used
function buildSelectiveStdlib(usedNames) {
  // Resolve transitive dependencies and topologically sort
  const withDeps = resolveStdlibDeps(usedNames);
  const ordered = _topoSort(withDeps);
  const parts = [];
  for (const name of ordered) {
    if (BUILTIN_FUNCTIONS[name]) {
      parts.push(BUILTIN_FUNCTIONS[name]);
    }
  }
  return parts.join('\n');
}

// Native FFI bridge initialization (server-side only, Bun runtime)
// Lazily loads the Rust native library for high-performance stdlib operations
// Async version for tova run (AsyncFunction context supports await)
const NATIVE_INIT = `var __tova_native = null;
try {
  if (typeof Bun !== 'undefined') {
    const { dlopen: __dl, FFIType: __F } = await import('bun:ffi');
    const __path = await import('path');
    const __fs = await import('fs');
    const __searchDirs = [
      __path.join(__path.dirname(typeof __tova_filename !== 'undefined' ? __tova_filename : ''), 'native', 'target', 'release'),
      __path.join(process.cwd(), 'native', 'target', 'release'),
      __path.join(process.env.HOME || '', '.tova', 'lib'),
    ];
    const __libName = process.platform === 'darwin' ? 'libtova_native.dylib' : process.platform === 'win32' ? 'tova_native.dll' : 'libtova_native.so';
    for (const __d of __searchDirs) {
      const __p = __path.join(__d, __libName);
      if (__fs.existsSync(__p)) {
        const __lib = __dl(__p, {
          tova_sort_f64: { args: [__F.ptr, __F.u64], returns: __F.void },
          tova_sort_i64: { args: [__F.ptr, __F.u64], returns: __F.void },
          tova_sum_f64: { args: [__F.ptr, __F.u64], returns: __F.f64 },
          tova_min_f64: { args: [__F.ptr, __F.u64], returns: __F.f64 },
          tova_max_f64: { args: [__F.ptr, __F.u64], returns: __F.f64 },
        });
        __tova_native = __lib.symbols;
        break;
      }
    }
  }
} catch (__e) {}`;

// Sync-safe version without await (for non-async contexts like tests, REPL eval)
const NATIVE_INIT_SYNC = `var __tova_native = null;`;

// Full stdlib for runtime (REPL, run command) — sync-safe (no await)
function getFullStdlib() {
  return `${NATIVE_INIT_SYNC}\n${buildSelectiveStdlib(BUILTIN_NAMES)}\n${RESULT_OPTION}\n${PROPAGATE}`;
}

// Stdlib for client codegen (includes builtins + result/option + propagate)
function getClientStdlib() {
  return `${buildSelectiveStdlib(BUILTIN_NAMES)}\n${RESULT_OPTION}\n${PROPAGATE}`;
}

// ─── src/codegen/wasm-codegen.js ───────────────────────

// WASM binary code generator for @wasm-annotated Tova functions
// Compiles a subset of Tova (numeric types, control flow, recursion) to WebAssembly binary format
// No external dependencies — generates WASM binary directly

// WASM type constants
const I32 = 0x7F;
const I64 = 0x7E;
const F64 = 0x7C;
const VOID = 0x40;
const FUNC_TYPE = 0x60;

// WASM section IDs
const SEC_TYPE = 1;
const SEC_FUNCTION = 3;
const SEC_EXPORT = 7;
const SEC_CODE = 10;

// WASM opcodes
const OP = {
  unreachable: 0x00,
  nop: 0x01,
  block: 0x02,
  loop: 0x03,
  if: 0x04,
  else: 0x05,
  end: 0x0B,
  br: 0x0C,
  br_if: 0x0D,
  return: 0x0F,
  call: 0x10,
  drop: 0x1A,
  select: 0x1B,
  local_get: 0x20,
  local_set: 0x21,
  local_tee: 0x22,
  i32_const: 0x41,
  i64_const: 0x42,
  f64_const: 0x44,
  i32_eqz: 0x45,
  i32_eq: 0x46,
  i32_ne: 0x47,
  i32_lt_s: 0x48,
  i32_gt_s: 0x4A,
  i32_le_s: 0x4C,
  i32_ge_s: 0x4E,
  f64_eq: 0x61,
  f64_ne: 0x62,
  f64_lt: 0x63,
  f64_gt: 0x64,
  f64_le: 0x65,
  f64_ge: 0x66,
  i32_add: 0x6A,
  i32_sub: 0x6B,
  i32_mul: 0x6C,
  i32_div_s: 0x6D,
  i32_rem_s: 0x6F,
  i32_and: 0x71,
  i32_or: 0x72,
  f64_neg: 0x9A,
  f64_add: 0xA0,
  f64_sub: 0xA1,
  f64_mul: 0xA2,
  f64_div: 0xA3,
  f64_convert_i32_s: 0xB7,
  i32_trunc_f64_s: 0xAA,
};

// LEB128 encoding
function uleb128(value) {
  const r = [];
  do {
    let b = value & 0x7F;
    value >>>= 7;
    if (value !== 0) b |= 0x80;
    r.push(b);
  } while (value !== 0);
  return r;
}

function sleb128(value) {
  const r = [];
  let more = true;
  while (more) {
    let b = value & 0x7F;
    value >>= 7;
    if ((value === 0 && (b & 0x40) === 0) || (value === -1 && (b & 0x40) !== 0)) {
      more = false;
    } else {
      b |= 0x80;
    }
    r.push(b);
  }
  return r;
}

function encodeString(s) {
  const bytes = new TextEncoder().encode(s);
  return [...uleb128(bytes.length), ...bytes];
}

function encodeSection(id, contents) {
  return [id, ...uleb128(contents.length), ...contents];
}

function encodeF64(value) {
  const buf = new ArrayBuffer(8);
  new Float64Array(buf)[0] = value;
  return [...new Uint8Array(buf)];
}

// Map Tova type annotations to WASM types
function tovaTypeToWasm(typeStr) {
  if (!typeStr) return I32;
  const t = typeof typeStr === 'string' ? typeStr : (typeStr.name || typeStr.value || String(typeStr));
  switch (t) {
    case 'Int': case 'int': case 'i32': case 'Bool': case 'bool': return I32;
    case 'Float': case 'float': case 'f64': case 'Number': return F64;
    default: return I32;
  }
}

// Compile a single @wasm function to WASM binary
function compileWasmFunction(funcNode) {
  const ctx = new WasmFuncContext(funcNode);
  const bodyBytes = ctx.compile();
  return buildModule(funcNode.name, ctx.paramTypes, ctx.returnType, ctx.localTypes, bodyBytes);
}

// Compile multiple @wasm functions into a single module
function compileWasmModule(funcNodes) {
  if (funcNodes.length === 1) return compileWasmFunction(funcNodes[0]);
  const contexts = funcNodes.map(f => new WasmFuncContext(f));
  const nameMap = {};
  funcNodes.forEach((f, i) => { nameMap[f.name] = i; });
  contexts.forEach(ctx => { ctx.funcNameMap = nameMap; });
  const bodies = contexts.map(ctx => ctx.compile());
  return buildMultiModule(funcNodes.map(f => f.name), contexts, bodies);
}

function buildModule(name, paramTypes, returnType, localTypes, bodyBytes) {
  const typeSection = encodeSection(SEC_TYPE, [
    ...uleb128(1), FUNC_TYPE,
    ...uleb128(paramTypes.length), ...paramTypes,
    ...(returnType !== null ? [1, returnType] : [0])
  ]);
  const funcSection = encodeSection(SEC_FUNCTION, [...uleb128(1), ...uleb128(0)]);
  const exportSection = encodeSection(SEC_EXPORT, [
    ...uleb128(1), ...encodeString(name), 0x00, ...uleb128(0),
  ]);
  const localDecls = encodeLocalDecls(localTypes);
  const funcBody = [...localDecls, ...bodyBytes, OP.end];
  const codeSection = encodeSection(SEC_CODE, [...uleb128(1), ...uleb128(funcBody.length), ...funcBody]);

  return new Uint8Array([
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    ...typeSection, ...funcSection, ...exportSection, ...codeSection,
  ]);
}

function buildMultiModule(names, contexts, bodies) {
  const types = [];
  for (const ctx of contexts) {
    types.push(FUNC_TYPE, ...uleb128(ctx.paramTypes.length), ...ctx.paramTypes,
      ...(ctx.returnType !== null ? [1, ctx.returnType] : [0]));
  }
  const typeSection = encodeSection(SEC_TYPE, [...uleb128(contexts.length), ...types]);
  const funcSection = encodeSection(SEC_FUNCTION, [...uleb128(contexts.length), ...contexts.map((_, i) => uleb128(i)).flat()]);
  const exports = [];
  for (let i = 0; i < names.length; i++) exports.push(...encodeString(names[i]), 0x00, ...uleb128(i));
  const exportSection = encodeSection(SEC_EXPORT, [...uleb128(names.length), ...exports]);
  const funcBodies = [];
  for (let i = 0; i < contexts.length; i++) {
    const fb = [...encodeLocalDecls(contexts[i].localTypes), ...bodies[i], OP.end];
    funcBodies.push(...uleb128(fb.length), ...fb);
  }
  const codeSection = encodeSection(SEC_CODE, [...uleb128(contexts.length), ...funcBodies]);
  return new Uint8Array([
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    ...typeSection, ...funcSection, ...exportSection, ...codeSection,
  ]);
}

function encodeLocalDecls(localTypes) {
  if (localTypes.length === 0) return uleb128(0);
  const groups = [];
  let cur = localTypes[0], count = 1;
  for (let i = 1; i < localTypes.length; i++) {
    if (localTypes[i] === cur) { count++; }
    else { groups.push([count, cur]); cur = localTypes[i]; count = 1; }
  }
  groups.push([count, cur]);
  const r = [...uleb128(groups.length)];
  for (const [cnt, typ] of groups) r.push(...uleb128(cnt), typ);
  return r;
}

// ─── WASM Function Context ─────────────────────────────────

class WasmFuncContext {
  constructor(funcNode) {
    this.funcNode = funcNode;
    this.name = funcNode.name;
    this.locals = new Map();       // name -> local index
    this.localTypes = [];          // types of non-param locals
    this.paramTypes = [];
    this.returnType = null;
    this.funcNameMap = { [funcNode.name]: 0 };
    this.blockDepth = 0;

    // Parse params — Tova AST: param.name, param.typeAnnotation
    for (const p of funcNode.params) {
      const pName = p.name || '_';
      const wt = tovaTypeToWasm(p.typeAnnotation);
      this.locals.set(pName, this.locals.size);
      this.paramTypes.push(wt);
    }

    // Parse return type
    this.returnType = funcNode.returnType ? tovaTypeToWasm(funcNode.returnType) : I32;
  }

  addLocal(name, wasmType) {
    if (this.locals.has(name)) return this.locals.get(name);
    const idx = this.locals.size;
    this.locals.set(name, idx);
    this.localTypes.push(wasmType || I32);
    return idx;
  }

  getLocal(name) { return this.locals.get(name); }

  typeOf(name) {
    const idx = this.locals.get(name);
    if (idx === undefined) return I32;
    if (idx < this.paramTypes.length) return this.paramTypes[idx];
    return this.localTypes[idx - this.paramTypes.length];
  }

  compile() {
    const body = this.funcNode.body;
    if (body.type === 'BlockStatement') return this.compileBlockAsValue(body);
    return this.compileExpr(body);
  }

  // ─── Block compilation (implicit return from last expression) ───

  compileBlockAsValue(block) {
    const stmts = block.body || [];
    if (stmts.length === 0) return this.defaultValue();

    const bytes = [];
    for (let i = 0; i < stmts.length; i++) {
      const stmt = stmts[i];
      const isLast = i === stmts.length - 1;

      if (isLast) {
        if (stmt.type === 'ExpressionStatement') {
          bytes.push(...this.compileExpr(stmt.expression));
        } else if (stmt.type === 'ReturnStatement') {
          if (stmt.value) bytes.push(...this.compileExpr(stmt.value));
          bytes.push(OP.return);
        } else if (stmt.type === 'IfStatement') {
          bytes.push(...this.compileIfExpr(stmt));
        } else {
          bytes.push(...this.compileStatement(stmt));
          bytes.push(...this.defaultValue());
        }
      } else {
        bytes.push(...this.compileStatement(stmt));
      }
    }
    return bytes;
  }

  compileBlockValue(block) {
    if (block.type === 'BlockStatement') {
      const stmts = block.body || [];
      if (stmts.length === 0) return this.defaultValue();
      const bytes = [];
      for (let i = 0; i < stmts.length - 1; i++) bytes.push(...this.compileStatement(stmts[i]));
      const last = stmts[stmts.length - 1];
      if (last.type === 'ExpressionStatement') {
        bytes.push(...this.compileExpr(last.expression));
      } else if (last.type === 'ReturnStatement') {
        if (last.value) bytes.push(...this.compileExpr(last.value));
        bytes.push(OP.return);
      } else if (last.type === 'IfStatement') {
        bytes.push(...this.compileIfExpr(last));
      } else {
        bytes.push(...this.compileStatement(last));
        bytes.push(...this.defaultValue());
      }
      return bytes;
    }
    return this.compileExpr(block);
  }

  defaultValue() {
    return this.returnType === F64 ? [OP.f64_const, ...encodeF64(0)] : [OP.i32_const, ...sleb128(0)];
  }

  // ─── Statement compilation ───

  compileStatement(stmt) {
    switch (stmt.type) {
      case 'VarDeclaration': return this.compileVarDecl(stmt);
      case 'Assignment': return this.compileAssignment(stmt);
      case 'ExpressionStatement': {
        const bytes = this.compileExpr(stmt.expression);
        bytes.push(OP.drop);
        return bytes;
      }
      case 'ReturnStatement': {
        const bytes = [];
        if (stmt.value) bytes.push(...this.compileExpr(stmt.value));
        bytes.push(OP.return);
        return bytes;
      }
      case 'IfStatement': return this.compileIfStmt(stmt);
      case 'WhileStatement': return this.compileWhile(stmt);
      default:
        throw new Error(`@wasm: unsupported statement type '${stmt.type}'`);
    }
  }

  // Tova VarDeclaration: { targets: [identifier], values: [expression] }
  compileVarDecl(node) {
    const bytes = [];
    const targets = node.targets || [];
    const values = node.values || [];
    for (let i = 0; i < targets.length; i++) {
      const name = typeof targets[i] === 'string' ? targets[i] : targets[i].name;
      const init = values[i];
      let wt = I32;
      if (init) wt = this.inferType(init);
      const idx = this.addLocal(name, wt);
      if (init) {
        bytes.push(...this.compileExpr(init));
        bytes.push(OP.local_set, ...uleb128(idx));
      }
    }
    return bytes;
  }

  // Tova Assignment: { targets: [identifier/expr], values: [expression] }
  compileAssignment(node) {
    const bytes = [];
    const targets = node.targets || [];
    const values = node.values || [];
    for (let i = 0; i < targets.length; i++) {
      const target = targets[i];
      const name = typeof target === 'string' ? target : target.name;
      if (!name) throw new Error('@wasm: assignment target must be a simple identifier');
      let idx = this.getLocal(name);
      if (idx === undefined) {
        // Implicit variable declaration (Tova allows `x = 5` without `var`)
        const wt = values[i] ? this.inferType(values[i]) : I32;
        idx = this.addLocal(name, wt);
      }
      bytes.push(...this.compileExpr(values[i]));
      bytes.push(OP.local_set, ...uleb128(idx));
    }
    return bytes;
  }

  // ─── If statement (void) ───

  compileIfStmt(node) {
    const bytes = [];
    bytes.push(...this.compileExpr(node.condition));
    bytes.push(OP.if, VOID);
    if (node.consequent) {
      const stmts = node.consequent.body || [node.consequent];
      for (const s of stmts) bytes.push(...this.compileStatement(s));
    }
    // Handle elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        bytes.push(OP.else);
        bytes.push(...this.compileExpr(alt.condition));
        bytes.push(OP.if, VOID);
        const altStmts = alt.body.body || [alt.body];
        for (const s of altStmts) bytes.push(...this.compileStatement(s));
      }
      // Close all elif if-blocks
      if (node.elseBody) {
        bytes.push(OP.else);
        const elseStmts = node.elseBody.body || [node.elseBody];
        for (const s of elseStmts) bytes.push(...this.compileStatement(s));
      }
      for (let i = 0; i < node.alternates.length; i++) bytes.push(OP.end);
    } else if (node.elseBody) {
      bytes.push(OP.else);
      const elseStmts = node.elseBody.body || [node.elseBody];
      for (const s of elseStmts) bytes.push(...this.compileStatement(s));
    }
    bytes.push(OP.end);
    return bytes;
  }

  // ─── If expression (returns a value) ───

  compileIfExpr(node) {
    const bytes = [];
    bytes.push(...this.compileExpr(node.condition));
    bytes.push(OP.if, this.returnType);

    // Then branch
    if (node.consequent) {
      bytes.push(...this.compileBlockValue(node.consequent));
    } else {
      bytes.push(...this.defaultValue());
    }

    // Handle elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        bytes.push(OP.else);
        bytes.push(...this.compileExpr(alt.condition));
        bytes.push(OP.if, this.returnType);
        bytes.push(...this.compileBlockValue(alt.body));
      }
      // Final else
      bytes.push(OP.else);
      if (node.elseBody) {
        bytes.push(...this.compileBlockValue(node.elseBody));
      } else {
        bytes.push(...this.defaultValue());
      }
      // Close all elif if-blocks
      for (let i = 0; i < node.alternates.length; i++) bytes.push(OP.end);
    } else {
      // Simple if/else
      bytes.push(OP.else);
      if (node.elseBody) {
        bytes.push(...this.compileBlockValue(node.elseBody));
      } else {
        bytes.push(...this.defaultValue());
      }
    }

    bytes.push(OP.end);
    return bytes;
  }

  // ─── While loop ───

  compileWhile(node) {
    const bytes = [];
    bytes.push(OP.block, VOID);
    bytes.push(OP.loop, VOID);
    this.blockDepth += 2;

    bytes.push(...this.compileExpr(node.condition));
    bytes.push(OP.i32_eqz);
    bytes.push(OP.br_if, ...uleb128(1));

    const bodyStmts = node.body.body || [node.body];
    for (const s of bodyStmts) bytes.push(...this.compileStatement(s));

    bytes.push(OP.br, ...uleb128(0));
    bytes.push(OP.end);
    bytes.push(OP.end);
    this.blockDepth -= 2;
    return bytes;
  }

  // ─── Expression compilation ───

  compileExpr(node) {
    switch (node.type) {
      case 'NumberLiteral': return this.compileNumber(node);
      case 'BooleanLiteral': return [OP.i32_const, ...sleb128(node.value ? 1 : 0)];
      case 'Identifier': return this.compileIdentifier(node);
      case 'BinaryExpression': return this.compileBinary(node);
      case 'UnaryExpression': return this.compileUnary(node);
      case 'CallExpression': return this.compileCall(node);
      case 'IfStatement': return this.compileIfExpr(node);
      case 'LogicalExpression': return this.compileLogical(node);
      case 'BlockStatement': return this.compileBlockAsValue(node);
      default:
        throw new Error(`@wasm: unsupported expression type '${node.type}'`);
    }
  }

  compileNumber(node) {
    const val = node.value;
    if (Number.isInteger(val) && val >= -2147483648 && val <= 2147483647) {
      return [OP.i32_const, ...sleb128(val)];
    }
    return [OP.f64_const, ...encodeF64(val)];
  }

  compileIdentifier(node) {
    const name = node.name;
    const idx = this.getLocal(name);
    if (idx === undefined) throw new Error(`@wasm: undefined variable '${name}'`);
    return [OP.local_get, ...uleb128(idx)];
  }

  compileBinary(node) {
    const lt = this.inferType(node.left);
    const rt = this.inferType(node.right);
    const t = (lt === F64 || rt === F64) ? F64 : I32;

    const bytes = [];
    bytes.push(...this.compileExpr(node.left));
    if (t === F64 && lt === I32) bytes.push(OP.f64_convert_i32_s);
    bytes.push(...this.compileExpr(node.right));
    if (t === F64 && rt === I32) bytes.push(OP.f64_convert_i32_s);

    switch (node.operator) {
      case '+': bytes.push(t === F64 ? OP.f64_add : OP.i32_add); break;
      case '-': bytes.push(t === F64 ? OP.f64_sub : OP.i32_sub); break;
      case '*': bytes.push(t === F64 ? OP.f64_mul : OP.i32_mul); break;
      case '/': bytes.push(t === F64 ? OP.f64_div : OP.i32_div_s); break;
      case '%': bytes.push(OP.i32_rem_s); break;
      case '==': bytes.push(t === F64 ? OP.f64_eq : OP.i32_eq); break;
      case '!=': bytes.push(t === F64 ? OP.f64_ne : OP.i32_ne); break;
      case '<': bytes.push(t === F64 ? OP.f64_lt : OP.i32_lt_s); break;
      case '>': bytes.push(t === F64 ? OP.f64_gt : OP.i32_gt_s); break;
      case '<=': bytes.push(t === F64 ? OP.f64_le : OP.i32_le_s); break;
      case '>=': bytes.push(t === F64 ? OP.f64_ge : OP.i32_ge_s); break;
      default:
        throw new Error(`@wasm: unsupported binary operator '${node.operator}'`);
    }
    return bytes;
  }

  compileUnary(node) {
    switch (node.operator) {
      case '-': {
        const t = this.inferType(node.operand);
        if (t === F64) {
          return [...this.compileExpr(node.operand), OP.f64_neg];
        }
        return [OP.i32_const, ...sleb128(0), ...this.compileExpr(node.operand), OP.i32_sub];
      }
      case 'not': case '!':
        return [...this.compileExpr(node.operand), OP.i32_eqz];
      default:
        throw new Error(`@wasm: unsupported unary operator '${node.operator}'`);
    }
  }

  compileCall(node) {
    const name = node.callee.name;
    if (!name) throw new Error('@wasm: only direct function calls are supported');
    const funcIdx = this.funcNameMap[name];
    if (funcIdx === undefined) throw new Error(`@wasm: undefined function '${name}'`);
    const bytes = [];
    for (const arg of node.arguments) bytes.push(...this.compileExpr(arg));
    bytes.push(OP.call, ...uleb128(funcIdx));
    return bytes;
  }

  compileLogical(node) {
    const bytes = [];
    if (node.operator === 'and' || node.operator === '&&') {
      bytes.push(...this.compileExpr(node.left));
      bytes.push(OP.if, I32);
      bytes.push(...this.compileExpr(node.right));
      bytes.push(OP.else, OP.i32_const, ...sleb128(0));
      bytes.push(OP.end);
    } else {
      bytes.push(...this.compileExpr(node.left));
      bytes.push(OP.if, I32);
      bytes.push(OP.i32_const, ...sleb128(1));
      bytes.push(OP.else);
      bytes.push(...this.compileExpr(node.right));
      bytes.push(OP.end);
    }
    return bytes;
  }

  // ─── Type inference ───

  inferType(node) {
    if (!node) return I32;
    switch (node.type) {
      case 'NumberLiteral':
        return (Number.isInteger(node.value) && node.value >= -2147483648 && node.value <= 2147483647) ? I32 : F64;
      case 'BooleanLiteral': return I32;
      case 'Identifier': return this.typeOf(node.name);
      case 'BinaryExpression': {
        if (['==', '!=', '<', '>', '<=', '>='].includes(node.operator)) return I32;
        const lt = this.inferType(node.left);
        const rt = this.inferType(node.right);
        return (lt === F64 || rt === F64) ? F64 : I32;
      }
      case 'UnaryExpression': return this.inferType(node.operand);
      case 'CallExpression': return this.returnType || I32;
      default: return I32;
    }
  }
}

// Generate JS glue code for a @wasm function
function generateWasmGlue(funcNode, wasmBytes) {
  const bytesStr = Array.from(wasmBytes).join(',');
  const name = funcNode.name;
  return `const ${name} = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([${bytesStr}]))).exports.${name};`;
}

// Generate JS glue code for a multi-function WASM module
function generateMultiWasmGlue(funcNodes, wasmBytes) {
  const bytesStr = Array.from(wasmBytes).join(',');
  const names = funcNodes.map(f => f.name);
  return `const { ${names.join(', ')} } = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([${bytesStr}]))).exports;`;
}

// ─── src/codegen/base-codegen.js ───────────────────────

// Base code generation utilities shared across all codegen targets
class BaseCodegen {
  constructor() {
    this.indent = 0;
    this._counter = 0;
    this._scopes = [new Set()]; // scope stack for tracking declared variables
    this._visibleNames = new Set(); // flattened view of all declared names for O(1) lookup
    this._nameRefCount = new Map(); // name -> count of scopes declaring it (for O(1) popScope)
    this._needsContainsHelper = false; // track if __contains helper is needed
    this._needsPropagateHelper = false; // track if __propagate helper is needed
    this._usedBuiltins = new Set(); // track which stdlib builtins are actually used
    this._userDefinedNames = new Set(); // track user-defined top-level names (to avoid stdlib conflicts)
    this._needsResultOption = false; // track if Ok/Err/Some/None are used
    this._variantFields = { 'Ok': ['value'], 'Err': ['error'], 'Some': ['value'] }; // map variant name -> [field names] for pattern destructuring
    this._traitDecls = new Map(); // traitName -> { methods: [...] }
    this._traitImpls = new Map(); // "TraitName:TypeName" -> ImplDeclaration node
    // Source map tracking
    this._sourceMapsEnabled = true; // can be disabled for REPL/check mode
    this._propagateCache = new WeakMap(); // memoize _containsPropagate()
    this._yieldCache = new WeakMap(); // memoize _containsYield()
    this._sourceMappings = []; // {sourceLine, sourceCol, outputLine, outputCol, sourceFile?}
    this._outputLineCount = 0;
    this._sourceFile = null; // current source file for multi-file source maps
    // @fast mode for TypedArray optimization
    this._fastMode = false;
    this._typedArrayParams = new Map(); // paramName -> 'Float64Array' | 'Int32Array' | 'Uint8Array'
    this._typedArrayLocals = new Map(); // varName -> 'Float64Array' | 'Int32Array' | 'Uint8Array'
  }

  static TYPED_ARRAY_MAP = {
    'Int': 'Int32Array',
    'Float': 'Float64Array',
    'Byte': 'Uint8Array',
    'Int8': 'Int8Array',
    'Int16': 'Int16Array',
    'Int32': 'Int32Array',
    'Uint8': 'Uint8Array',
    'Uint16': 'Uint16Array',
    'Uint32': 'Uint32Array',
    'Float32': 'Float32Array',
    'Float64': 'Float64Array',
  };

  _uid() {
    return this._counter++;
  }

  // Returns true for AST nodes with no side effects that are safe to evaluate multiple times
  _isSimpleExpression(node) {
    if (!node) return false;
    switch (node.type) {
      case 'Identifier':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return true;
      case 'MemberExpression':
        return !node.computed && this._isSimpleExpression(node.object);
      default:
        return false;
    }
  }

  // Known void/side-effect-only calls that shouldn't be implicitly returned
  static VOID_FNS = new Set(['print', 'assert', 'assert_eq', 'assert_ne']);
  _isVoidCall(expr) {
    if (expr.type !== 'CallExpression') return false;
    if (expr.callee.type === 'Identifier') {
      return BaseCodegen.VOID_FNS.has(expr.callee.name);
    }
    return false;
  }

  // ─── Scope tracking ─────────────────────────────────────────

  pushScope() {
    this._scopes.push(new Set());
  }

  popScope() {
    const removed = this._scopes.pop();
    // O(n) cleanup using reference counts instead of O(n*m) scope search
    for (const name of removed) {
      const rc = this._nameRefCount.get(name) - 1;
      if (rc <= 0) {
        this._nameRefCount.delete(name);
        this._visibleNames.delete(name);
      } else {
        this._nameRefCount.set(name, rc);
      }
    }
  }

  declareVar(name) {
    this._scopes[this._scopes.length - 1].add(name);
    this._visibleNames.add(name);
    this._nameRefCount.set(name, (this._nameRefCount.get(name) || 0) + 1);
  }

  isDeclared(name) {
    return this._visibleNames.has(name);
  }

  // ─── Helpers ────────────────────────────────────────────────

  i() {
    return '  '.repeat(this.indent);
  }

  // Set current source file for multi-file source map tracking
  setSourceFile(filename) {
    this._sourceFile = filename;
  }

  // Source map: record a mapping from source location to output line
  _addMapping(node, outputLine) {
    if (!this._sourceMapsEnabled) return;
    if (node && node.loc && node.loc.line) {
      const mapping = {
        sourceLine: node.loc.line - 1, // 0-based
        sourceCol: (node.loc.column || 1) - 1, // 0-based
        outputLine,
        outputCol: this.indent * 2, // approximate column from indent
      };
      if (this._sourceFile) mapping.sourceFile = this._sourceFile;
      this._sourceMappings.push(mapping);
    }
  }

  // Count newlines in a generated string to update output line tracking
  _countLines(code) {
    if (!code) return 0;
    let count = 0;
    for (let i = 0; i < code.length; i++) {
      if (code.charCodeAt(i) === 10) count++;
    }
    return count;
  }

  // Get collected source mappings
  getSourceMappings() {
    return this._sourceMappings;
  }

  getUsedBuiltins() {
    // Exclude builtins that the user has redefined at top level
    if (this._userDefinedNames.size > 0) {
      const filtered = new Set(this._usedBuiltins);
      for (const name of this._userDefinedNames) {
        filtered.delete(name);
      }
      return filtered;
    }
    return this._usedBuiltins;
  }

  // Track a builtin and its transitive dependencies from the stdlib dependency graph
  _trackBuiltin(name) {
    this._usedBuiltins.add(name);
    const deps = STDLIB_DEPS[name];
    if (deps) {
      for (const dep of deps) {
        this._usedBuiltins.add(dep);
      }
    }
  }

  getContainsHelper() {
    return [
      'function __contains(col, val) {',
      '  if (Array.isArray(col) || typeof col === \'string\') return col.includes(val);',
      '  if (col instanceof Set || col instanceof Map) return col.has(val);',
      '  if (typeof col === \'object\' && col !== null) return val in col;',
      '  return false;',
      '}',
    ].join('\n');
  }

  genPropagateExpression(node) {
    this._needsPropagateHelper = true;
    return `__propagate(${this.genExpression(node.expression)})`;
  }

  _containsPropagate(node) {
    if (!node) return false;
    if (node.type === 'PropagateExpression') return true;
    if (node.type === 'FunctionDeclaration' || node.type === 'LambdaExpression') return false;
    const cached = this._propagateCache.get(node);
    if (cached !== undefined) return cached;
    let result = false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsPropagate(item)) { result = true; break; }
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsPropagate(val)) { result = true; break; }
      }
      if (result) break;
    }
    this._propagateCache.set(node, result);
    return result;
  }

  getPropagateHelper() {
    return PROPAGATE;
  }

  getResultOptionHelper() {
    return RESULT_OPTION;
  }

  getStringProtoHelper() {
    return '// String methods are now standalone stdlib functions';
  }

  generateStatement(node) {
    if (!node) return '';

    // Record source mapping before generating (skip when source maps disabled)
    if (this._sourceMapsEnabled) this._addMapping(node, this._outputLineCount);

    let result;
    switch (node.type) {
      case 'Assignment': result = this.genAssignment(node); break;
      case 'VarDeclaration': result = this.genVarDeclaration(node); break;
      case 'LetDestructure': result = this.genLetDestructure(node); break;
      case 'FunctionDeclaration': result = this.genFunctionDeclaration(node); break;
      case 'TypeDeclaration': result = this.genTypeDeclaration(node); break;
      case 'ImportDeclaration': result = this.genImport(node); break;
      case 'ImportDefault': result = this.genImportDefault(node); break;
      case 'ImportWildcard': result = this.genImportWildcard(node); break;
      case 'IfStatement': result = this.genIfStatement(node); break;
      case 'ForStatement': result = this.genForStatement(node); break;
      case 'WhileStatement': result = this.genWhileStatement(node); break;
      case 'LoopStatement': result = this.genLoopStatement(node); break;
      case 'TryCatchStatement': result = this.genTryCatchStatement(node); break;
      case 'ReturnStatement': result = this.genReturnStatement(node); break;
      case 'ExpressionStatement': result = `${this.i()}${this.genExpression(node.expression)};`; break;
      case 'BlockStatement': result = this.genBlock(node); break;
      case 'CompoundAssignment': result = this.genCompoundAssignment(node); break;
      case 'BreakStatement': result = node.label ? `${this.i()}break ${node.label};` : `${this.i()}break;`; break;
      case 'ContinueStatement': result = node.label ? `${this.i()}continue ${node.label};` : `${this.i()}continue;`; break;
      case 'GuardStatement': result = this.genGuardStatement(node); break;
      case 'InterfaceDeclaration': result = this.genInterfaceDeclaration(node); break;
      case 'ImplDeclaration': result = this.genImplDeclaration(node); break;
      case 'TraitDeclaration': result = this.genTraitDeclaration(node); break;
      case 'TypeAlias': result = this.genTypeAlias(node); break;
      case 'DeferStatement': result = this.genDeferStatement(node); break;
      case 'WithStatement': result = this.genWithStatement(node); break;
      case 'ExternDeclaration': result = `${this.i()}// extern: ${node.name}`; break;
      // Config declarations handled at block level — emit nothing in statement context
      case 'AiConfigDeclaration': result = ''; break;
      case 'DataBlock': result = ''; break;
      case 'SourceDeclaration': result = ''; break;
      case 'PipelineDeclaration': result = ''; break;
      case 'ValidateBlock': result = ''; break;
      case 'RefreshPolicy': result = ''; break;
      case 'RefinementType': result = this.genRefinementType(node); break;
      default:
        result = `${this.i()}${this.genExpression(node)};`;
    }

    // Track output line count using fast character scan (skip when source maps disabled)
    if (this._sourceMapsEnabled && result) {
      this._outputLineCount += this._countLines(result) + 1; // +1 for the join newline
    }

    return result;
  }

  genExpression(node) {
    if (!node) return 'undefined';

    switch (node.type) {
      case 'Identifier':
        // Track builtin identifier usage (e.g., None used without call)
        if (BUILTIN_NAMES.has(node.name)) {
          this._usedBuiltins.add(node.name);
        }
        if (node.name === 'Ok' || node.name === 'Err' || node.name === 'Some' || node.name === 'None') {
          this._needsResultOption = true;
        }
        return node.name === '_' ? '_' : node.name;
      case 'NumberLiteral': return String(node.value);
      case 'StringLiteral': return JSON.stringify(node.value);
      case 'BooleanLiteral': return String(node.value);
      case 'NilLiteral': return 'null';
      case 'RegexLiteral': return `/${node.pattern}/${node.flags}`;
      case 'TemplateLiteral': return this.genTemplateLiteral(node);
      case 'BinaryExpression': return this.genBinaryExpression(node);
      case 'UnaryExpression': return this.genUnaryExpression(node);
      case 'LogicalExpression': return this.genLogicalExpression(node);
      case 'ChainedComparison': return this.genChainedComparison(node);
      case 'MembershipExpression': return this.genMembershipExpression(node);
      case 'IsExpression': return this.genIsExpression(node);
      case 'CallExpression': return this.genCallExpression(node);
      case 'MemberExpression': return this.genMemberExpression(node);
      case 'OptionalChain': return this.genOptionalChain(node);
      case 'PipeExpression': return this.genPipeExpression(node);
      case 'LambdaExpression': return this.genLambdaExpression(node);
      case 'MatchExpression': return this.genMatchExpression(node);
      case 'IfExpression': return this.genIfExpression(node);
      case 'ArrayLiteral': return this.genArrayLiteral(node);
      case 'ObjectLiteral': return this.genObjectLiteral(node);
      case 'ListComprehension': return this.genListComprehension(node);
      case 'DictComprehension': return this.genDictComprehension(node);
      case 'RangeExpression': return this.genRangeExpression(node);
      case 'SliceExpression': return this.genSliceExpression(node);
      case 'SpreadExpression': return `...${this.genExpression(node.argument)}`;
      case 'PropagateExpression': return this.genPropagateExpression(node);
      case 'NamedArgument': return this.genExpression(node.value);
      case 'AwaitExpression': return `(await ${this.genExpression(node.argument)})`;
      case 'YieldExpression': return node.delegate ? `(yield* ${this.genExpression(node.argument)})` : `(yield ${this.genExpression(node.argument)})`;
      case 'TupleExpression': return `[${node.elements.map(e => this.genExpression(e)).join(', ')}]`;
      // Column expressions (for table operations)
      case 'ColumnExpression': return this.genColumnExpression(node);
      case 'ColumnAssignment': return this.genColumnAssignment(node);
      case 'NegatedColumnExpression': return `{ __exclude: ${JSON.stringify(node.name)} }`;
      default:
        throw new Error(`Codegen: unknown expression type '${node.type}'`);
    }
  }

  // ─── Statements ───────────────────────────────────────────

  genAssignment(node) {
    const exportPrefix = node.isPublic ? 'export ' : '';
    if (node.targets.length === 1 && node.values.length === 1) {
      const target = node.targets[0];
      const value = node.values[0];
      // Member expression target: obj.x = expr, arr[i] = expr
      if (typeof target === 'object' && target.type === 'MemberExpression') {
        // IIFE elimination: match/if on RHS of member assignment
        if (this._needsIIFE(value)) {
          const memberExpr = this.genExpression(target);
          const lines = [];
          if (value.type === 'MatchExpression') {
            lines.push(this._genMatchAssign(value, memberExpr));
          } else {
            lines.push(this._genIfAssign(value, memberExpr));
          }
          return lines.join('\n');
        }
        return `${this.i()}${this.genExpression(target)} = ${this.genExpression(value)};`;
      }
      if (target === '_') {
        return `${this.i()}${this.genExpression(value)};`;
      }
      if (this.isDeclared(target)) {
        // Reassignment to an already-declared variable (must be mutable)
        // IIFE elimination: match/if on RHS of reassignment (skip if binding conflicts)
        if (this._needsIIFE(value) && !this._matchBindingsConflict(value, target)) {
          if (value.type === 'MatchExpression') {
            return this._genMatchAssign(value, target);
          } else {
            return this._genIfAssign(value, target);
          }
        }
        return `${this.i()}${target} = ${this.genExpression(value)};`;
      }
      this.declareVar(target);
      // Track top-level user definitions to avoid stdlib conflicts
      if (this._scopes.length === 1 && BUILTIN_NAMES.has(target)) {
        this._userDefinedNames.add(target);
      }
      // @fast mode: track typed array local variables for loop optimization
      if (this._fastMode && this._typedArrayLocals) {
        const taType = this._detectTypedArrayExpr(value);
        if (taType) this._typedArrayLocals.set(target, taType);
      }
      // IIFE elimination: match/if on RHS of new const declaration (skip if binding conflicts)
      if (this._needsIIFE(value) && !this._matchBindingsConflict(value, target)) {
        const lines = [];
        lines.push(`${this.i()}${exportPrefix}let ${target};`);
        if (value.type === 'MatchExpression') {
          lines.push(this._genMatchAssign(value, target));
        } else {
          lines.push(this._genIfAssign(value, target));
        }
        return lines.join('\n');
      }
      return `${this.i()}${exportPrefix}const ${target} = ${this.genExpression(value)};`;
    }

    // Multiple assignment: a, b = 1, 2 (uses destructuring for atomicity)
    const vals = node.values.map(v => this.genExpression(v));
    const allDeclared = node.targets.every(t => this.isDeclared(t));
    const noneDeclared = node.targets.every(t => !this.isDeclared(t));

    if (allDeclared) {
      // Reassignment (e.g., swap): [a, b] = [v1, v2]
      return `${this.i()}[${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    if (noneDeclared) {
      // New declarations: const [a, b] = [v1, v2]
      for (const t of node.targets) this.declareVar(t);
      return `${this.i()}${exportPrefix}const [${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    // Mixed: some declared, some new — generate individual assignments
    const lines = [];
    const tempArr = `__tmp_${this._uid()}`;
    lines.push(`${this.i()}const ${tempArr} = [${vals.join(', ')}];`);
    for (let idx = 0; idx < node.targets.length; idx++) {
      const t = node.targets[idx];
      if (this.isDeclared(t)) {
        lines.push(`${this.i()}${t} = ${tempArr}[${idx}];`);
      } else {
        this.declareVar(t);
        lines.push(`${this.i()}const ${t} = ${tempArr}[${idx}];`);
      }
    }
    return lines.join('\n');
  }

  genVarDeclaration(node) {
    const exportPrefix = node.isPublic ? 'export ' : '';
    if (node.targets.length === 1 && node.values.length === 1) {
      const target = node.targets[0];
      const value = node.values[0];
      this.declareVar(target);
      // IIFE elimination for var declarations too (skip if binding conflicts)
      if (this._needsIIFE(value) && !this._matchBindingsConflict(value, target)) {
        const lines = [];
        lines.push(`${this.i()}${exportPrefix}let ${target};`);
        if (value.type === 'MatchExpression') {
          lines.push(this._genMatchAssign(value, target));
        } else {
          lines.push(this._genIfAssign(value, target));
        }
        return lines.join('\n');
      }
      return `${this.i()}${exportPrefix}let ${target} = ${this.genExpression(value)};`;
    }
    const lines = [];
    for (let idx = 0; idx < node.targets.length; idx++) {
      this.declareVar(node.targets[idx]);
      const val = idx < node.values.length ? node.values[idx] : node.values[node.values.length - 1];
      lines.push(`${this.i()}${exportPrefix}let ${node.targets[idx]} = ${this.genExpression(val)};`);
    }
    return lines.join('\n');
  }

  genLetDestructure(node) {
    if (node.pattern.type === 'ObjectPattern') {
      for (const p of node.pattern.properties) this.declareVar(p.value);
      const props = node.pattern.properties.map(p => {
        let str = p.key;
        if (p.value !== p.key) str += `: ${p.value}`;
        if (p.defaultValue) str += ` = ${this.genExpression(p.defaultValue)}`;
        return str;
      }).join(', ');
      return `${this.i()}const { ${props} } = ${this.genExpression(node.value)};`;
    }
    if (node.pattern.type === 'ArrayPattern' || node.pattern.type === 'TuplePattern') {
      for (const e of node.pattern.elements) if (e) this.declareVar(e);
      const els = node.pattern.elements.map(e => e || '').join(', ');
      return `${this.i()}const [${els}] = ${this.genExpression(node.value)};`;
    }
    return '';
  }

  genFunctionDeclaration(node) {
    // Check for @wasm decorator — compile to WebAssembly
    if (node.decorators && node.decorators.some(d => d.name === 'wasm')) {
      return this.genWasmFunction(node);
    }
    // Check for @fast decorator — enable TypedArray optimizations
    const isFast = node.decorators && node.decorators.some(d => d.name === 'fast');
    const prevFastMode = this._fastMode;
    const prevTypedParams = this._typedArrayParams;
    const prevTypedLocals = this._typedArrayLocals;
    if (isFast) {
      this._fastMode = true;
      this._typedArrayParams = new Map();
      this._typedArrayLocals = new Map(); // track locally-created typed arrays
      // Scan params for typed array annotations: param: [Int], param: [Float], param: [Byte]
      for (const p of node.params) {
        if (p.typeAnnotation && p.typeAnnotation.type === 'ArrayTypeAnnotation' && p.typeAnnotation.elementType) {
          const elemName = p.typeAnnotation.elementType.name;
          const typedArrayType = BaseCodegen.TYPED_ARRAY_MAP[elemName];
          if (typedArrayType) {
            this._typedArrayParams.set(p.name, typedArrayType);
          }
        }
      }
    }
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const isGenerator = this._containsYield(node.body);
    const exportPrefix = node.isPublic ? 'export ' : '';
    const asyncPrefix = node.isAsync ? 'async ' : '';
    const genStar = isGenerator ? '*' : '';
    this.pushScope();
    for (const p of node.params) {
      if (p.destructure) {
        this._declareDestructureVars(p.destructure);
      } else {
        this.declareVar(p.name);
      }
    }
    const body = this.genBlockBody(node.body);
    this.popScope();
    const lines = [];
    lines.push(`${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {`);
    // In @fast mode, convert typed array params at function entry
    if (isFast && this._typedArrayParams.size > 0) {
      for (const [pName, taType] of this._typedArrayParams) {
        lines.push(`${this.i()}  ${pName} = ${pName} instanceof ${taType} ? ${pName} : new ${taType}(${pName});`);
      }
    }
    if (hasPropagate) {
      lines.push(`${this.i()}  try {`);
      lines.push(body);
      lines.push(`${this.i()}  } catch (__e) {`);
      lines.push(`${this.i()}    if (__e && __e.__tova_propagate) return __e.value;`);
      lines.push(`${this.i()}    throw __e;`);
      lines.push(`${this.i()}  }`);
    } else {
      lines.push(body);
    }
    lines.push(`${this.i()}}`);
    // Restore @fast state
    if (isFast) {
      this._fastMode = prevFastMode;
      this._typedArrayParams = prevTypedParams;
      this._typedArrayLocals = prevTypedLocals;
    }
    return lines.join('\n');
  }

  genWasmFunction(node) {
    try {
      // Track as user-defined to suppress stdlib version
      if (BUILTIN_NAMES.has(node.name)) this._userDefinedNames.add(node.name);
      const wasmBytes = compileWasmFunction(node);
      const glue = generateWasmGlue(node, wasmBytes);
      const exportPrefix = node.isPublic ? 'export ' : '';
      return `${this.i()}${exportPrefix}${glue}`;
    } catch (e) {
      // Fall back to JS if WASM compilation fails
      console.error(`Warning: @wasm compilation failed for '${node.name}': ${e.message}. Falling back to JS.`);
      node.decorators = node.decorators.filter(d => d.name !== 'wasm');
      return this.genFunctionDeclaration(node);
    }
  }

  genParams(params) {
    return params.map(p => {
      if (p.destructure) {
        if (p.destructure.type === 'ObjectPattern') {
          const props = p.destructure.properties.map(prop => {
            let str = prop.key;
            if (prop.value !== prop.key) str += `: ${prop.value}`;
            if (prop.defaultValue) str += ` = ${this.genExpression(prop.defaultValue)}`;
            return str;
          }).join(', ');
          return `{ ${props} }`;
        }
        if (p.destructure.type === 'ArrayPattern' || p.destructure.type === 'TuplePattern') {
          return `[${p.destructure.elements.join(', ')}]`;
        }
      }
      if (p.defaultValue) {
        return `${p.name} = ${this.genExpression(p.defaultValue)}`;
      }
      return p.name;
    }).join(', ');
  }

  genImport(node) {
    for (const s of node.specifiers) this.declareVar(s.local);
    const specs = node.specifiers.map(s => {
      if (s.imported !== s.local) return `${s.imported} as ${s.local}`;
      return s.imported;
    }).join(', ');
    return `${this.i()}import { ${specs} } from ${JSON.stringify(node.source)};`;
  }

  genImportDefault(node) {
    this.declareVar(node.local);
    return `${this.i()}import ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genImportWildcard(node) {
    this.declareVar(node.local);
    return `${this.i()}import * as ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genIfStatement(node) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.consequent));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      this.indent++;
      this.pushScope();
      p.push(this.genBlockStatements(alt.body));
      this.popScope();
      this.indent--;
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      this.indent++;
      this.pushScope();
      p.push(this.genBlockStatements(node.elseBody));
      this.popScope();
      this.indent--;
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  // Check if a for-loop over a range can be emitted as a C-style for loop
  _isRangeForOptimizable(node) {
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    if (vars.length !== 1 || typeof vars[0] !== 'string' || node.isAsync || node.elseBody) return false;
    if (node.iterable.type === 'RangeExpression') return true;
    // Optimize for i in range(n) / range(start, end) / range(start, end, step)
    if (node.iterable.type === 'CallExpression' &&
        node.iterable.callee.type === 'Identifier' &&
        node.iterable.callee.name === 'range' &&
        node.iterable.arguments.length >= 1 && node.iterable.arguments.length <= 3) return true;
    return false;
  }

  // @fast mode: detect if an expression produces a TypedArray
  // Returns the TypedArray type string (e.g. 'Float64Array') or null
  _detectTypedArrayExpr(value) {
    if (!value) return null;
    // Type.new(n) → new Type(n), where Type is a TypedArray
    if (value.type === 'MethodCall' && value.methodName === 'new' &&
        value.object && value.object.type === 'Identifier') {
      const taType = BaseCodegen.TYPED_ARRAY_MAP[value.object.name];
      if (taType) return taType;
      // Direct TypedArray names: Float64Array.new(n)
      if (Object.values(BaseCodegen.TYPED_ARRAY_MAP).includes(value.object.name)) return value.object.name;
    }
    // typed_add/typed_scale/typed_map/typed_sort return same type as input
    if (value.type === 'CallExpression' && value.callee && value.callee.type === 'Identifier') {
      const fname = value.callee.name;
      if (['typed_add', 'typed_scale', 'typed_map', 'typed_sort'].includes(fname)) {
        return 'Float64Array'; // conservative default
      }
      // typed_linspace returns Float64Array
      if (fname === 'typed_linspace') return 'Float64Array';
    }
    return null;
  }

  // @fast mode: check if a for-loop iterates over a known typed array
  // Returns the TypedArray type or null
  _getTypedArrayIterable(node) {
    if (!this._fastMode) return null;
    const iter = node.iterable;
    if (iter.type !== 'Identifier') return null;
    const name = iter.name;
    return this._typedArrayParams.get(name) || (this._typedArrayLocals && this._typedArrayLocals.get(name)) || null;
  }

  genForStatement(node) {
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    const labelPrefix = node.label ? `${node.label}: ` : '';
    const awaitKeyword = node.isAsync ? ' await' : '';

    // Optimization: for i in start..end => C-style for loop (avoids array allocation)
    if (this._isRangeForOptimizable(node)) {
      const varName = vars[0];
      let start, end, step, cmpOp;

      if (node.iterable.type === 'RangeExpression') {
        start = this.genExpression(node.iterable.start);
        end = this.genExpression(node.iterable.end);
        cmpOp = node.iterable.inclusive ? '<=' : '<';
        step = null;
      } else {
        // range(n) / range(start, end) / range(start, end, step)
        const args = node.iterable.arguments;
        if (args.length === 1) {
          start = '0';
          end = this.genExpression(args[0]);
          cmpOp = '<';
        } else if (args.length === 2) {
          start = this.genExpression(args[0]);
          end = this.genExpression(args[1]);
          cmpOp = '<';
        } else {
          start = this.genExpression(args[0]);
          end = this.genExpression(args[1]);
          step = this.genExpression(args[2]);
          cmpOp = '<';
        }
      }

      this.pushScope();
      this.declareVar(varName);
      const p = [];
      if (step) {
        // With explicit step: need to handle positive and negative step
        const stepVar = `__step_${this._uid()}`;
        p.push(`${this.i()}${labelPrefix}{ const ${stepVar} = ${step};\n`);
        p.push(`${this.i()}for (let ${varName} = ${start}; ${stepVar} > 0 ? ${varName} < ${end} : ${varName} > ${end}; ${varName} += ${stepVar}) {\n`);
      } else {
        p.push(`${this.i()}${labelPrefix}for (let ${varName} = ${start}; ${varName} ${cmpOp} ${end}; ${varName}++) {\n`);
      }
      this.indent++;
      if (node.guard) {
        p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
      }
      p.push(this.genBlockStatements(node.body));
      this.indent--;
      p.push(`\n${this.i()}}`);
      if (step) p.push(`\n${this.i()}}`);
      this.popScope();
      return p.join('');
    }

    // @fast mode optimization: for val in typedArray => index-based loop (avoids iterator overhead)
    if (vars.length === 1 && !node.isAsync && !node.elseBody) {
      const taType = this._getTypedArrayIterable(node);
      if (taType) {
        const varName = vars[0];
        const arrName = node.iterable.name;
        const idxVar = `__i_${this._uid()}`;
        this.pushScope();
        this.declareVar(varName);
        const p = [];
        p.push(`${this.i()}${labelPrefix}for (let ${idxVar} = 0; ${idxVar} < ${arrName}.length; ${idxVar}++) {\n`);
        this.indent++;
        p.push(`${this.i()}const ${varName} = ${arrName}[${idxVar}];\n`);
        if (node.guard) {
          p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
        }
        p.push(this.genBlockStatements(node.body));
        this.indent--;
        p.push(`\n${this.i()}}`);
        this.popScope();
        return p.join('');
      }
    }

    const iterExpr = this.genExpression(node.iterable);

    if (node.elseBody) {
      // for-else: run else if iterable was empty
      const tempVar = `__iter_${this._uid()}`;
      const enteredVar = `__entered_${this._uid()}`;
      const p = [];
      p.push(`${this.i()}{\n`);
      this.indent++;
      p.push(`${this.i()}const ${tempVar} = ${iterExpr};\n`);
      p.push(`${this.i()}let ${enteredVar} = false;\n`);
      this.pushScope();
      for (const v of vars) this.declareVar(v);
      if (vars.length === 2) {
        p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const [${vars[0]}, ${vars[1]}] of ${tempVar}) {\n`);
      } else {
        p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const ${vars[0]} of ${tempVar}) {\n`);
      }
      this.indent++;
      p.push(`${this.i()}${enteredVar} = true;\n`);
      if (node.guard) {
        p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
      }
      p.push(this.genBlockStatements(node.body));
      this.indent--;
      p.push(`\n${this.i()}}\n`);
      this.popScope();
      this.pushScope();
      p.push(`${this.i()}if (!${enteredVar}) {\n`);
      this.indent++;
      p.push(this.genBlockStatements(node.elseBody));
      this.indent--;
      p.push(`\n${this.i()}}\n`);
      this.popScope();
      this.indent--;
      p.push(`${this.i()}}`);
      return p.join('');
    }

    this.pushScope();
    for (const v of vars) this.declareVar(v);
    const p = [];
    if (vars.length === 2) {
      p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const [${vars[0]}, ${vars[1]}] of ${iterExpr}) {\n`);
    } else {
      p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const ${vars[0]} of ${iterExpr}) {\n`);
    }
    this.indent++;
    if (node.guard) {
      p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
    }
    p.push(this.genBlockStatements(node.body));
    this.indent--;
    p.push(`\n${this.i()}}`);
    this.popScope();

    return p.join('');
  }

  genWhileStatement(node) {
    const labelPrefix = node.label ? `${node.label}: ` : '';
    const p = [];
    p.push(`${this.i()}${labelPrefix}while (${this.genExpression(node.condition)}) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.body));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genLoopStatement(node) {
    const labelPrefix = node.label ? `${node.label}: ` : '';
    const p = [];
    p.push(`${this.i()}${labelPrefix}while (true) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.body));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genTryCatchStatement(node) {
    const p = [];
    p.push(`${this.i()}try {\n`);
    this.indent++;
    this.pushScope();
    for (const stmt of node.tryBody) {
      p.push(this.generateStatement(stmt) + '\n');
    }
    this.popScope();
    this.indent--;

    if (node.catchBody) {
      const catchVar = node.catchParam || '__err';
      p.push(`${this.i()}} catch (${catchVar}) {\n`);
      this.pushScope();
      this.declareVar(catchVar);
      this.indent++;
      // Re-throw propagation sentinels so ? operator works through user try/catch
      p.push(`${this.i()}if (${catchVar} && ${catchVar}.__tova_propagate) throw ${catchVar};\n`);
      for (const stmt of node.catchBody) {
        p.push(this.generateStatement(stmt) + '\n');
      }
      this.popScope();
      this.indent--;
      p.push(`${this.i()}}`);
    }

    if (node.finallyBody) {
      if (!node.catchBody) {
        // try/finally without catch
        p.push(`${this.i()}}`);
      }
      p.push(` finally {\n`);
      this.indent++;
      this.pushScope();
      for (const stmt of node.finallyBody) {
        p.push(this.generateStatement(stmt) + '\n');
      }
      this.popScope();
      this.indent--;
      p.push(`${this.i()}}`);
    }

    return p.join('');
  }

  genReturnStatement(node) {
    if (node.value) {
      return `${this.i()}return ${this.genExpression(node.value)};`;
    }
    return `${this.i()}return;`;
  }

  genCompoundAssignment(node) {
    return `${this.i()}${this.genExpression(node.target)} ${node.operator} ${this.genExpression(node.value)};`;
  }

  genBlock(node) {
    const p = [];
    p.push(`{\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genBlockBody(block) {
    if (block.type !== 'BlockStatement') {
      this.indent++;
      const code = `${this.i()}return ${this.genExpression(block)};`;
      this.indent--;
      return code;
    }

    this.indent++;
    const stmts = block.body;

    // Collect defer statements and separate them from regular statements
    const regularStmts = [];
    const deferBodies = [];
    for (const stmt of stmts) {
      if (stmt.type === 'DeferStatement') {
        deferBodies.push(stmt.body);
      } else {
        regularStmts.push(stmt);
      }
    }

    const lines = [];

    // If there are defers, wrap in try/finally
    if (deferBodies.length > 0) {
      lines.push(`${this.i()}try {`);
      this.indent++;
    }

    for (let idx = 0; idx < regularStmts.length; idx++) {
      const stmt = regularStmts[idx];
      const isLast = idx === regularStmts.length - 1;
      // Implicit return: last expression in function body
      // Skip implicit return for known void/side-effect-only calls (print, assert, etc.)
      if (isLast && stmt.type === 'ExpressionStatement' && !this._isVoidCall(stmt.expression)) {
        // IIFE elimination: match/if as last expression in function body → direct returns
        const expr = stmt.expression;
        if (expr.type === 'MatchExpression' && !this._isSimpleMatch(expr)) {
          lines.push(this._genMatchReturn(expr));
        } else if (expr.type === 'IfExpression' && this._needsIIFE(expr)) {
          lines.push(this._genIfReturn(expr));
        } else {
          lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
        }
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithReturns(stmt));
      } else if (isLast && stmt.type === 'MatchExpression') {
        lines.push(`${this.i()}return ${this.genExpression(stmt)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }

    if (deferBodies.length > 0) {
      this.indent--;
      lines.push(`${this.i()}} finally {`);
      this.indent++;
      // Execute defers in LIFO order
      for (let i = deferBodies.length - 1; i >= 0; i--) {
        const body = deferBodies[i];
        if (body.type === 'BlockStatement') {
          lines.push(this.genBlockStatements(body));
        } else {
          lines.push(`${this.i()}${this.genExpression(body)};`);
        }
      }
      this.indent--;
      lines.push(`${this.i()}}`);
    }

    this.indent--;
    return lines.join('\n');
  }

  _genIfStatementWithReturns(node) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyReturns(node.consequent));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyReturns(alt.body));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyReturns(node.elseBody));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  _genBlockBodyReturns(block) {
    // Like genBlockBody but always adds return to the last statement
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    this.indent++;
    const lines = [];
    for (let idx = 0; idx < stmts.length; idx++) {
      const stmt = stmts[idx];
      const isLast = idx === stmts.length - 1;
      if (isLast && stmt.type === 'ExpressionStatement') {
        lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithReturns(stmt));
      } else if (isLast && stmt.type === 'MatchExpression') {
        lines.push(`${this.i()}return ${this.genExpression(stmt)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }
    this.indent--;
    return lines.join('\n');
  }

  _genBlockBodyAssign(block, targetVar) {
    // Like _genBlockBodyReturns but emits `targetVar = expr` instead of `return expr`
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    this.indent++;
    const lines = [];
    for (let idx = 0; idx < stmts.length; idx++) {
      const stmt = stmts[idx];
      const isLast = idx === stmts.length - 1;
      if (isLast && stmt.type === 'ExpressionStatement') {
        lines.push(`${this.i()}${targetVar} = ${this.genExpression(stmt.expression)};`);
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithAssigns(stmt, targetVar));
      } else if (isLast && stmt.type === 'MatchExpression') {
        // Nested match inside block — generate as assignment too
        lines.push(this._genMatchAssign(stmt, targetVar));
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }
    this.indent--;
    return lines.join('\n');
  }

  _genIfStatementWithAssigns(node, targetVar) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyAssign(node.consequent, targetVar));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyAssign(alt.body, targetVar));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyAssign(node.elseBody, targetVar));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  genBlockStatements(block) {
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    const lines = [];
    for (const s of stmts) {
      lines.push(this.generateStatement(s));
      // Dead code elimination: stop after unconditional return/break/continue
      if (s.type === 'ReturnStatement' || s.type === 'BreakStatement' || s.type === 'ContinueStatement') break;
    }
    return lines.join('\n');
  }

  // ─── Expressions ──────────────────────────────────────────

  genTemplateLiteral(node) {
    const parts = node.parts.map(p => {
      if (p.type === 'text') {
        return p.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
      }
      return `\${${this.genExpression(p.value)}}`;
    }).join('');
    return `\`${parts}\``;
  }

  genBinaryExpression(node) {
    const op = node.operator;

    // Constant folding: arithmetic on two number literals
    if (node.left.type === 'NumberLiteral' && node.right.type === 'NumberLiteral') {
      const l = node.left.value, r = node.right.value;
      let folded = null;
      switch (op) {
        case '+': folded = l + r; break;
        case '-': folded = l - r; break;
        case '*': folded = l * r; break;
        case '/': if (r !== 0) folded = l / r; break;
        case '%': if (r !== 0) folded = l % r; break;
        case '**': folded = l ** r; break;
      }
      if (folded !== null && Number.isFinite(folded)) {
        return folded < 0 ? `(${folded})` : String(folded);
      }
    }

    // Constant folding: string concatenation with ++
    if (op === '++' && node.left.type === 'StringLiteral' && node.right.type === 'StringLiteral') {
      return JSON.stringify(node.left.value + node.right.value);
    }

    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);

    // String multiply: "ha" * 3 => "ha".repeat(3), also x * 3 when x is string
    if (op === '*' &&
      (node.left.type === 'StringLiteral' || node.left.type === 'TemplateLiteral')) {
      return `${left}.repeat(${right})`;
    }
    if (op === '*' &&
      (node.right.type === 'StringLiteral' || node.right.type === 'TemplateLiteral')) {
      return `${right}.repeat(${left})`;
    }

    // Tova ?? is NaN-safe: catches null, undefined, AND NaN
    if (op === '??') {
      if (this._isSimpleExpression(node.left)) {
        return `((${left} != null && ${left} === ${left}) ? ${left} : ${right})`;
      }
      return `((__tova_v) => (__tova_v != null && __tova_v === __tova_v) ? __tova_v : ${right})(${left})`;
    }

    return `(${left} ${op} ${right})`;
  }

  genUnaryExpression(node) {
    const operand = this.genExpression(node.operand);
    if (node.operator === 'not') return `(!${operand})`;
    return `(${node.operator}${operand})`;
  }

  genLogicalExpression(node) {
    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);
    const op = node.operator === 'and' ? '&&' : node.operator === 'or' ? '||' : node.operator;
    return `(${left} ${op} ${right})`;
  }

  genChainedComparison(node) {
    // a < b < c => ((__t0 = a) < (__t1 = b) && __t1 < c)
    // Use temp vars for intermediate operands to avoid evaluating expressions multiple times
    if (node.operators.length === 1) {
      // Simple case: no duplication needed
      const left = this.genExpression(node.operands[0]);
      const right = this.genExpression(node.operands[1]);
      return `(${left} ${node.operators[0]} ${right})`;
    }
    // Optimization: if all intermediate operands are simple (no side effects),
    // we can inline them without temp vars or IIFE
    const intermediateOperands = node.operands.slice(1, -1);
    const allSimple = intermediateOperands.every(op => this._isSimpleExpression(op));

    if (allSimple) {
      const parts = [];
      for (let idx = 0; idx < node.operators.length; idx++) {
        const left = this.genExpression(node.operands[idx]);
        const right = this.genExpression(node.operands[idx + 1]);
        parts.push(`(${left} ${node.operators[idx]} ${right})`);
      }
      return `(${parts.join(' && ')})`;
    }

    const temps = [];
    const parts = [];
    for (let idx = 0; idx < node.operators.length; idx++) {
      let left, right;
      if (idx === 0) {
        left = this.genExpression(node.operands[idx]);
      } else {
        left = temps[idx - 1];
      }
      if (idx < node.operators.length - 1) {
        // Intermediate operand: assign to temp var so it's not evaluated twice
        const tmp = `__cmp_${this._uid()}`;
        temps.push(tmp);
        right = `(${tmp} = ${this.genExpression(node.operands[idx + 1])})`;
      } else {
        right = this.genExpression(node.operands[idx + 1]);
      }
      parts.push(`(${left} ${node.operators[idx]} ${right})`);
    }
    if (temps.length > 0) {
      return `(() => { let ${temps.join(', ')}; return (${parts.join(' && ')}); })()`;
    }
    return `(${parts.join(' && ')})`;
  }

  // Try to specialize `in` checks based on the collection's AST type
  _specializeContains(collectionNode, colCode, valCode) {
    switch (collectionNode.type) {
      case 'ArrayLiteral':
        return `${colCode}.includes(${valCode})`;
      case 'StringLiteral':
      case 'TemplateLiteral':
        return `${colCode}.includes(${valCode})`;
      case 'CallExpression':
        if (collectionNode.callee.type === 'MemberExpression' &&
            !collectionNode.callee.computed &&
            collectionNode.callee.property === 'new') {
          const objName = collectionNode.callee.object.type === 'Identifier'
            ? collectionNode.callee.object.name : null;
          if (objName === 'Set' || objName === 'Map') {
            return `${colCode}.has(${valCode})`;
          }
        }
        return null;
      case 'ObjectLiteral':
        return `(${valCode} in ${colCode})`;
      default:
        return null;
    }
  }

  genMembershipExpression(node) {
    const val = this.genExpression(node.value);
    const col = this.genExpression(node.collection);

    // Try specialized check based on collection type
    const specialized = this._specializeContains(node.collection, col, val);
    if (specialized) {
      if (node.negated) {
        return `(!${specialized})`;
      }
      return specialized;
    }

    this._needsContainsHelper = true;
    if (node.negated) {
      return `(!__contains(${col}, ${val}))`;
    }
    return `__contains(${col}, ${val})`;
  }

  genIsExpression(node) {
    const val = this.genExpression(node.value);
    const op = node.negated ? '!==' : '===';
    const notOp = node.negated ? '!' : '';

    // Map Tova type names to JS runtime checks
    switch (node.typeName) {
      case 'String':
        return `(typeof ${val} ${op} 'string')`;
      case 'Int':
        return node.negated
          ? `(typeof ${val} !== 'number' || !Number.isInteger(${val}))`
          : `(typeof ${val} === 'number' && Number.isInteger(${val}))`;
      case 'Float':
        return node.negated
          ? `(typeof ${val} !== 'number' || Number.isInteger(${val}))`
          : `(typeof ${val} === 'number' && !Number.isInteger(${val}))`;
      case 'Bool':
        return `(typeof ${val} ${op} 'boolean')`;
      case 'Nil':
        return `(${val} ${op} null)`;
      case 'Array':
        return `(${notOp}Array.isArray(${val}))`;
      case 'Function':
        return `(typeof ${val} ${op} 'function')`;
      case 'Number':
        return `(typeof ${val} ${op} 'number')`;
      default:
        // For ADT variants, check __tag; for classes, use instanceof
        return node.negated
          ? `(!(${val} != null && (${val}.__tag === '${node.typeName}' || ${val} instanceof (typeof ${node.typeName} !== 'undefined' ? ${node.typeName} : function(){}))))`
          : `(${val} != null && (${val}.__tag === '${node.typeName}' || ${val} instanceof (typeof ${node.typeName} !== 'undefined' ? ${node.typeName} : function(){})))`;
    }
  }

  genCallExpression(node) {
    // Transform Foo.new(...) → new Foo(...)
    if (node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property === 'new') {
      const obj = this.genExpression(node.callee.object);
      const args = node.arguments.map(a => this.genExpression(a)).join(', ');
      return `new ${obj}(${args})`;
    }

    // Track builtin usage for tree-shaking (with dependency resolution)
    if (node.callee.type === 'Identifier') {
      if (BUILTIN_NAMES.has(node.callee.name)) {
        this._trackBuiltin(node.callee.name);
      }
      if (node.callee.name === 'Ok' || node.callee.name === 'Err' || node.callee.name === 'Some') {
        this._needsResultOption = true;
      }
      // Seq is a dependency of iter — handled by _trackBuiltin via STDLIB_DEPS
      if (node.callee.name === 'iter') {
        this._needsResultOption = true; // Seq.first()/find() return Option
      }

      // Inline string/collection builtins to direct method calls
      const inlined = this._tryInlineBuiltin(node);
      if (inlined !== null) return inlined;
    }

    // Track namespace builtin usage: math.sin() → include 'math' namespace + deps
    if (node.callee.type === 'MemberExpression' &&
        node.callee.object.type === 'Identifier' &&
        BUILTIN_NAMES.has(node.callee.object.name)) {
      const ns = node.callee.object.name;
      this._trackBuiltin(ns);
      // Namespaces that depend on Ok/Err need Result/Option
      const deps = STDLIB_DEPS[ns];
      if (deps && (deps.includes('Ok') || deps.includes('Err'))) {
        this._needsResultOption = true;
      }
    }

    // Check for table operation calls with column expressions
    const hasColumnExprs = node.arguments.some(a => this._containsColumnExpr(a));
    if (hasColumnExprs || (node.callee.type === 'Identifier' && ['agg', 'table_agg'].includes(node.callee.name))) {
      const tableArgs = this._genTableCallArgs(node);
      if (tableArgs) {
        const callee = this.genExpression(node.callee);
        return `${callee}(${tableArgs.join(', ')})`;
      }
    }

    const callee = this.genExpression(node.callee);
    const hasNamedArgs = node.arguments.some(a => a.type === 'NamedArgument');

    if (hasNamedArgs) {
      const allNamed = node.arguments.every(a => a.type === 'NamedArgument');
      if (allNamed) {
        // All named args → single object argument
        const parts = node.arguments.map(a => `${a.name}: ${this.genExpression(a.value)}`);
        return `${callee}({ ${parts.join(', ')} })`;
      }
      // Mixed: positional first, then named as trailing object
      const positional = [];
      const named = [];
      for (const a of node.arguments) {
        if (a.type === 'NamedArgument') {
          named.push(`${a.name}: ${this.genExpression(a.value)}`);
        } else {
          positional.push(this.genExpression(a));
        }
      }
      return `${callee}(${[...positional, `{ ${named.join(', ')} }`].join(', ')})`;
    }

    const args = node.arguments.map(a => this.genExpression(a)).join(', ');
    return `${callee}(${args})`;
  }

  // Inline known builtins to direct method calls, eliminating wrapper overhead.
  // Returns the inlined code string, or null if not inlineable.
  _tryInlineBuiltin(node) {
    const name = node.callee.name;
    const args = node.arguments;

    switch (name) {
      // String methods: fn(str, ...) → str.method(...)
      case 'split':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.split(${this.genExpression(args[1])})`;
        break;
      case 'join':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.join(${this.genExpression(args[1])})`;
        if (args.length === 1)
          return `${this.genExpression(args[0])}.join('')`;
        break;
      case 'replace':
        if (args.length === 3)
          return `${this.genExpression(args[0])}.replaceAll(${this.genExpression(args[1])}, ${this.genExpression(args[2])})`;
        break;
      case 'contains':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.includes(${this.genExpression(args[1])})`;
        break;
      case 'upper':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.toUpperCase()`;
        break;
      case 'lower':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.toLowerCase()`;
        break;
      case 'trim':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.trim()`;
        break;
      case 'trim_start':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.trimStart()`;
        break;
      case 'trim_end':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.trimEnd()`;
        break;
      case 'repeat':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.repeat(${this.genExpression(args[1])})`;
        break;
      case 'starts_with':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.startsWith(${this.genExpression(args[1])})`;
        break;
      case 'ends_with':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.endsWith(${this.genExpression(args[1])})`;
        break;
      case 'pad_start':
        if (args.length >= 2)
          return `${this.genExpression(args[0])}.padStart(${this.genExpression(args[1])}${args[2] ? ', ' + this.genExpression(args[2]) : ''})`;
        break;
      case 'pad_end':
        if (args.length >= 2)
          return `${this.genExpression(args[0])}.padEnd(${this.genExpression(args[1])}${args[2] ? ', ' + this.genExpression(args[2]) : ''})`;
        break;
      case 'includes':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.includes(${this.genExpression(args[1])})`;
        break;
      case 'char_at':
        if (args.length === 2)
          return `${this.genExpression(args[0])}[${this.genExpression(args[1])}]`;
        break;
    }

    return null;
  }

  genMemberExpression(node) {
    // Track namespace builtin usage: math.PI → include 'math' namespace + deps
    if (node.object.type === 'Identifier' && BUILTIN_NAMES.has(node.object.name)) {
      this._trackBuiltin(node.object.name);
    }
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}[${this.genExpression(node.property)}]`;
    }
    return `${obj}.${node.property}`;
  }

  genOptionalChain(node) {
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}?.[${this.genExpression(node.property)}]`;
    }
    return `${obj}?.${node.property}`;
  }

  genPipeExpression(node) {
    const left = this.genExpression(node.left);
    const right = node.right;

    // Method pipe: x |> .method(args) => x.method(args)
    if (right.type === 'CallExpression' && right.callee.type === 'MemberExpression' &&
        right.callee.object.type === 'Identifier' && right.callee.object.name === PIPE_TARGET) {
      // This is the .method() case - handled through special MemberExpression with empty object
      const method = right.callee.property;
      const args = right.arguments.map(a => this.genExpression(a)).join(', ');
      return `${left}.${method}(${args})`;
    }

    // If right is a call expression, check for placeholder _ or insert as first arg
    if (right.type === 'CallExpression') {
      // Check for table operations with column expressions
      const hasColumnExprs = right.arguments.some(a => this._containsColumnExpr(a));
      if (hasColumnExprs || (right.callee.type === 'Identifier' && ['agg', 'table_agg'].includes(right.callee.name))) {
        const tableArgs = this._genTableCallArgs(right);
        if (tableArgs) {
          const callee = this.genExpression(right.callee);
          // Track builtin usage
          if (right.callee.type === 'Identifier' && BUILTIN_NAMES.has(right.callee.name)) {
            this._usedBuiltins.add(right.callee.name);
          }
          return `${callee}(${[left, ...tableArgs].join(', ')})`;
        }
      }

      const placeholderCount = right.arguments.filter(a => a.type === 'Identifier' && a.name === '_').length;
      if (placeholderCount > 0) {
        const callee = this.genExpression(right.callee);
        if (placeholderCount > 1) {
          // Multiple placeholders: inline if left is simple, otherwise IIFE temp var
          if (this._isSimpleExpression(node.left)) {
            const args = right.arguments.map(a => {
              if (a.type === 'Identifier' && a.name === '_') return left;
              return this.genExpression(a);
            }).join(', ');
            return `${callee}(${args})`;
          }
          const tmp = `__pipe_${this._uid()}`;
          const args = right.arguments.map(a => {
            if (a.type === 'Identifier' && a.name === '_') return tmp;
            return this.genExpression(a);
          }).join(', ');
          return `((${tmp}) => ${callee}(${args}))(${left})`;
        }
        // Single placeholder: inline directly
        const args = right.arguments.map(a => {
          if (a.type === 'Identifier' && a.name === '_') return left;
          return this.genExpression(a);
        }).join(', ');
        return `${callee}(${args})`;
      }
      const callee = this.genExpression(right.callee);
      const args = [left, ...right.arguments.map(a => this.genExpression(a))].join(', ');
      return `${callee}(${args})`;
    }
    // If right is an identifier, call it with left as argument
    if (right.type === 'Identifier') {
      return `${right.name}(${left})`;
    }
    // Method pipe without call: x |> .method => x.method
    if (right.type === 'MemberExpression' && right.object.type === 'Identifier' && right.object.name === PIPE_TARGET) {
      return `${left}.${right.property}`;
    }
    // Fallback
    return `(${this.genExpression(right)})(${left})`;
  }

  // ─── Column expressions ──────────────────────────────────

  // Context flag for whether we're inside a select() call argument list
  _columnAsString = false;

  genColumnExpression(node) {
    // Inside select(), column expressions compile to string names
    if (this._columnAsString) {
      return JSON.stringify(node.name);
    }
    // Default: compile to row lambda
    return `(__row) => __row.${node.name}`;
  }

  genColumnAssignment(node) {
    // Compile to object entry for derive(): { colName: (row) => expr }
    // The expression inside the assignment may reference other columns
    const expr = this._genColumnBody(node.expression);
    return `${JSON.stringify(node.target)}: (__row) => ${expr}`;
  }

  // Generate an expression body that wraps column references as __row.col
  _genColumnBody(node) {
    if (!node) return 'undefined';
    if (node.type === 'ColumnExpression') {
      return `__row.${node.name}`;
    }
    if (node.type === 'BinaryExpression') {
      return `(${this._genColumnBody(node.left)} ${node.operator} ${this._genColumnBody(node.right)})`;
    }
    if (node.type === 'LogicalExpression') {
      const op = node.operator === 'and' ? '&&' : node.operator === 'or' ? '||' : node.operator;
      return `(${this._genColumnBody(node.left)} ${op} ${this._genColumnBody(node.right)})`;
    }
    if (node.type === 'UnaryExpression') {
      return `${node.operator}${this._genColumnBody(node.operand)}`;
    }
    if (node.type === 'CallExpression') {
      // Check if callee is a builtin used as pipe target
      const callee = this.genExpression(node.callee);
      const args = node.arguments.map(a => this._genColumnBody(a)).join(', ');
      return `${callee}(${args})`;
    }
    if (node.type === 'PipeExpression') {
      const left = this._genColumnBody(node.left);
      const right = node.right;
      if (right.type === 'CallExpression') {
        const callee = this.genExpression(right.callee);
        const args = [left, ...right.arguments.map(a => this._genColumnBody(a))].join(', ');
        return `${callee}(${args})`;
      }
      if (right.type === 'Identifier') {
        return `${right.name}(${left})`;
      }
      return `(${this._genColumnBody(right)})(${left})`;
    }
    if (node.type === 'TemplateLiteral') {
      // Template literal with column references
      const parts = node.parts.map(p => {
        if (p.type === 'text') return p.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
        return `\${${this._genColumnBody(p.value)}}`;
      });
      return '`' + parts.join('') + '`';
    }
    if (node.type === 'ConditionalExpression' || node.type === 'IfExpression') {
      const cond = this._genColumnBody(node.condition);
      const cons = this._genColumnBody(node.consequent);
      const alt = node.alternate || node.elseBody;
      const altCode = alt ? this._genColumnBody(alt) : 'undefined';
      return `(${cond} ? ${cons} : ${altCode})`;
    }
    if (node.type === 'MatchExpression') {
      // Match on column value
      const subject = this._genColumnBody(node.subject);
      const tmp = `__match_${this._uid()}`;
      let code = `((__m) => { `;
      for (const arm of node.arms) {
        if (arm.pattern.type === 'WildcardPattern') {
          const body = this._genColumnBody(arm.body);
          code += `return ${body}; `;
        } else if (arm.pattern.type === 'RangePattern') {
          const start = this.genExpression(arm.pattern.start);
          const end = this.genExpression(arm.pattern.end);
          const op = arm.pattern.inclusive ? '<=' : '<';
          code += `if (__m >= ${start} && __m ${op} ${end}) return ${this._genColumnBody(arm.body)}; `;
        } else {
          const pat = this.genExpression(arm.pattern.value || arm.pattern);
          code += `if (__m === ${pat}) return ${this._genColumnBody(arm.body)}; `;
        }
      }
      code += `})(${subject})`;
      return code;
    }
    if (node.type === 'MemberExpression') {
      const obj = this._genColumnBody(node.object);
      if (node.computed) {
        return `${obj}[${this._genColumnBody(node.property)}]`;
      }
      return `${obj}.${node.property}`;
    }
    // Fallback to normal expression generation for constants, strings, etc.
    return this.genExpression(node);
  }

  // Override genCallExpression to handle table operations with column expressions
  _genTableCallArgs(node) {
    const calleeName = node.callee.type === 'Identifier' ? node.callee.name : null;

    // select() — column expressions should compile to strings
    if (calleeName === 'select' || calleeName === 'table_select') {
      this._columnAsString = true;
      const args = node.arguments.map(a => this.genExpression(a));
      this._columnAsString = false;
      return args;
    }

    // where() — column expressions compile to row lambdas
    if (calleeName === 'where' || calleeName === 'table_where') {
      return node.arguments.map(a => {
        if (this._containsColumnExpr(a)) {
          return `(__row) => ${this._genColumnBody(a)}`;
        }
        return this.genExpression(a);
      });
    }

    // sort_by() — column expression compiles to row lambda
    if (calleeName === 'sort_by' || calleeName === 'table_sort_by') {
      return node.arguments.map(a => {
        if (this._containsColumnExpr(a)) {
          return `(__row) => ${this._genColumnBody(a)}`;
        }
        return this.genExpression(a);
      });
    }

    // group_by() — column expression compiles to row lambda
    if (calleeName === 'group_by' || calleeName === 'table_group_by') {
      return node.arguments.map(a => {
        if (this._containsColumnExpr(a)) {
          return `(__row) => ${this._genColumnBody(a)}`;
        }
        return this.genExpression(a);
      });
    }

    // derive() — column assignments compile to { name: (row) => expr }
    if (calleeName === 'derive' || calleeName === 'table_derive') {
      const parts = [];
      for (const a of node.arguments) {
        if (a.type === 'ColumnAssignment') {
          parts.push(this.genColumnAssignment(a));
        } else {
          parts.push(this.genExpression(a));
        }
      }
      // Wrap column assignments in an object
      const hasAssignments = node.arguments.some(a => a.type === 'ColumnAssignment');
      if (hasAssignments) {
        return [`{ ${parts.join(', ')} }`];
      }
      return parts;
    }

    // agg() — named arguments with aggregation functions
    if (calleeName === 'agg' || calleeName === 'table_agg') {
      const parts = [];
      for (const a of node.arguments) {
        if (a.type === 'NamedArgument') {
          // Named agg: total: sum(.amount) → total: agg_sum((__row) => __row.amount)
          const val = a.value;
          if (val.type === 'CallExpression' && val.callee.type === 'Identifier') {
            const aggName = val.callee.name;
            const aggFn = `agg_${aggName}`;
            if (['sum', 'count', 'mean', 'median', 'min', 'max'].includes(aggName)) {
              this._usedBuiltins.add(aggFn);
              if (val.arguments.length === 0) {
                // count() with no args
                parts.push(`${a.name}: ${aggFn}()`);
              } else {
                const inner = val.arguments[0];
                if (this._containsColumnExpr(inner)) {
                  parts.push(`${a.name}: ${aggFn}((__row) => ${this._genColumnBody(inner)})`);
                } else {
                  parts.push(`${a.name}: ${aggFn}(${this.genExpression(inner)})`);
                }
              }
              continue;
            }
          }
          parts.push(`${a.name}: ${this.genExpression(a.value)}`);
        } else {
          parts.push(this.genExpression(a));
        }
      }
      const hasNamed = node.arguments.some(a => a.type === 'NamedArgument');
      if (hasNamed) {
        return [`{ ${parts.join(', ')} }`];
      }
      return parts;
    }

    // drop_nil/fill_nil — column expression compiles to string or lambda
    if (calleeName === 'drop_nil' || calleeName === 'fill_nil') {
      return node.arguments.map(a => {
        if (a.type === 'ColumnExpression') {
          return JSON.stringify(a.name);
        }
        return this.genExpression(a);
      });
    }

    // join() — handle left/right column expressions
    if (calleeName === 'join' || calleeName === 'table_join') {
      return node.arguments.map(a => {
        if (a.type === 'NamedArgument') {
          if ((a.name === 'left' || a.name === 'right') && a.value.type === 'ColumnExpression') {
            return this.genExpression(a); // NamedArgument genExpression handles it
          }
        }
        return this.genExpression(a);
      });
    }

    return null; // No special handling needed
  }

  _containsColumnExpr(node) {
    if (!node) return false;
    if (node.type === 'ColumnExpression' || node.type === 'ColumnAssignment' || node.type === 'NegatedColumnExpression') return true;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsColumnExpr(item)) return true;
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsColumnExpr(val)) return true;
      }
    }
    return false;
  }

  genLambdaExpression(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const asyncPrefix = node.isAsync ? 'async ' : '';

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      const body = this.genBlockBody(node.body);
      this.popScope();
      if (hasPropagate) {
        const p = [];
        p.push(`${asyncPrefix}(${params}) => {`);
        p.push(`${this.i()}  try {`);
        p.push(body);
        p.push(`${this.i()}  } catch (__e) {`);
        p.push(`${this.i()}    if (__e && __e.__tova_propagate) return __e.value;`);
        p.push(`${this.i()}    throw __e;`);
        p.push(`${this.i()}  }`);
        p.push(`${this.i()}}`);
        return p.join('\n');
      }
      return [`${asyncPrefix}(${params}) => {`, body, `${this.i()}}`].join('\n');
    }

    // Statement bodies (compound assignment, assignment in lambda)
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      this.indent++;
      const stmt = this.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `${asyncPrefix}(${params}) => { ${stmt.trim()} }`;
    }

    if (hasPropagate) {
      return `${asyncPrefix}(${params}) => { try { return ${this.genExpression(node.body)}; } catch (__e) { if (__e && __e.__tova_propagate) return __e.value; throw __e; } }`;
    }
    return `${asyncPrefix}(${params}) => ${this.genExpression(node.body)}`;
  }

  // Check if a match can be emitted as a ternary chain instead of IIFE
  _isSimpleMatch(node) {
    if (!this._isSimpleExpression(node.subject)) return false;
    for (const arm of node.arms) {
      // All bodies must be expressions (not block statements)
      if (arm.body.type === 'BlockStatement') return false;
      // No patterns that need variable bindings
      if (this._patternNeedsBindings(arm.pattern)) return false;
      // Guards with BindingPattern need IIFE for binding
      if (arm.guard && arm.pattern.type === 'BindingPattern') return false;
    }
    return true;
  }

  // Check recursively whether a pattern requires const bindings
  _patternNeedsBindings(pattern) {
    switch (pattern.type) {
      case 'LiteralPattern':
      case 'WildcardPattern':
      case 'RangePattern':
        return false;
      case 'BindingPattern':
        return true;
      case 'VariantPattern':
        return pattern.fields.some(f => typeof f === 'string' || (f && this._patternNeedsBindings(f)));
      case 'ArrayPattern':
      case 'TuplePattern':
        return pattern.elements.some(el => el && this._patternNeedsBindings(el));
      default:
        return true; // Conservative: unknown patterns may need bindings
    }
  }

  // Generate a simple match as nested ternary
  _genSimpleMatch(node) {
    const subject = this.genExpression(node.subject);
    let result = '';
    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const body = this.genExpression(arm.body);
      // Last arm with wildcard → else branch
      if ((arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') && !arm.guard) {
        result += body;
        break;
      }
      const condition = this.genPatternCondition(arm.pattern, subject, arm.guard);
      result += `(${condition}) ? ${body} : `;
      // If this is the last arm and not a wildcard, add undefined as fallback
      if (idx === node.arms.length - 1) {
        result += 'undefined';
      }
    }
    return `(${result})`;
  }

  // Check if all arms are literal patterns (string/number/boolean) or wildcard, with no guards
  _isLiteralMatch(node) {
    let hasWildcard = false;
    for (const arm of node.arms) {
      if (arm.guard) return false;
      const pt = arm.pattern.type;
      if (pt === 'LiteralPattern') continue;
      if (pt === 'WildcardPattern' || pt === 'BindingPattern') {
        hasWildcard = true;
        continue;
      }
      return false;
    }
    return true;
  }

  _genSwitchMatch(node) {
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';
    const p = [];
    p.push(`((${tempVar}) => {\n`);
    this.indent++;
    p.push(`${this.i()}switch (${tempVar}) {\n`);
    this.indent++;

    for (const arm of node.arms) {
      if (arm.pattern.type === 'WildcardPattern') {
        p.push(`${this.i()}default:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this.genBlockBody(arm.body) + '\n');
        } else {
          p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
        }
        this.indent--;
      } else if (arm.pattern.type === 'BindingPattern') {
        p.push(`${this.i()}default: {\n`);
        this.indent++;
        p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
        if (arm.body.type === 'BlockStatement') {
          p.push(this.genBlockBody(arm.body) + '\n');
        } else {
          p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
        }
        this.indent--;
        p.push(`${this.i()}}\n`);
      } else {
        // LiteralPattern
        p.push(`${this.i()}case ${JSON.stringify(arm.pattern.value)}:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this.genBlockBody(arm.body) + '\n');
        } else {
          p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
        }
        this.indent--;
      }
    }

    this.indent--;
    p.push(`${this.i()}}\n`);
    this.indent--;
    p.push(`${this.i()}})(${subject})`);
    return p.join('');
  }

  genMatchExpression(node) {
    // Optimization: simple matches emit ternary chain instead of IIFE
    if (this._isSimpleMatch(node)) {
      return this._genSimpleMatch(node);
    }

    // Optimization: literal-only patterns emit switch for V8 jump tables
    if (this._isLiteralMatch(node)) {
      return this._genSwitchMatch(node);
    }

    // Generate as IIFE with if-else chain
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';

    const p = [];
    p.push(`((${tempVar}) => {\n`);
    this.indent++;

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
          }
          if (arm.body.type === 'BlockStatement') {
            p.push(this.genBlockBody(arm.body) + '\n');
          } else {
            p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
          }
          break;
        }
      }

      const keyword = idx === 0 ? 'if' : 'else if';
      p.push(`${this.i()}${keyword} (${condition}) {\n`);
      this.indent++;

      // Bind variables from pattern
      p.push(this.genPatternBindings(arm.pattern, tempVar));

      if (arm.body.type === 'BlockStatement') {
        p.push(this.genBlockBody(arm.body) + '\n');
      } else {
        p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
      }
      this.indent--;
      p.push(`${this.i()}}\n`);
    }

    this.indent--;
    p.push(`${this.i()}})(${subject})`);
    return p.join('');
  }

  genIfExpression(node) {
    // Optimization: if all branches are single expressions, use ternary
    const isSingleExpr = (block) =>
      block.type === 'BlockStatement' && block.body.length === 1 && block.body[0].type === 'ExpressionStatement';

    if (node.alternates.length === 0 && isSingleExpr(node.consequent) && isSingleExpr(node.elseBody)) {
      const cond = this.genExpression(node.condition);
      const thenExpr = this.genExpression(node.consequent.body[0].expression);
      const elseExpr = this.genExpression(node.elseBody.body[0].expression);
      return `((${cond}) ? (${thenExpr}) : (${elseExpr}))`;
    }

    // Extended optimization: if/elif/else where ALL branches are single expressions → nested ternary
    if (node.alternates.length > 0 && node.elseBody &&
        isSingleExpr(node.consequent) && isSingleExpr(node.elseBody) &&
        node.alternates.every(alt => isSingleExpr(alt.body))) {
      let result = `((${this.genExpression(node.condition)}) ? (${this.genExpression(node.consequent.body[0].expression)})`;
      for (const alt of node.alternates) {
        result += ` : (${this.genExpression(alt.condition)}) ? (${this.genExpression(alt.body.body[0].expression)})`;
      }
      result += ` : (${this.genExpression(node.elseBody.body[0].expression)}))`;
      return result;
    }

    // Full IIFE for multi-statement branches
    const p = [];
    p.push(`(() => {\n`);
    this.indent++;

    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this.genBlockBody(node.consequent));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this.genBlockBody(alt.body));
      p.push(`\n${this.i()}}`);
    }

    p.push(` else {\n`);
    p.push(this.genBlockBody(node.elseBody));
    p.push(`\n${this.i()}}`);

    this.indent--;
    p.push(`\n${this.i()}})()`);
    return p.join('');
  }

  // ─── IIFE-free match/if codegen (assign to variable instead of return) ───

  _genMatchAssign(node, targetVar) {
    // Block-scoped match that assigns to targetVar instead of wrapping in IIFE
    // Handles switch optimization and general if-else chain

    // Simple ternary matches don't need this optimization (already no IIFE)
    // Literal-only switch matches benefit from assignment form

    if (this._isLiteralMatch(node)) {
      return this._genSwitchMatchAssign(node, targetVar);
    }

    const subject = this.genExpression(node.subject);
    const tempVar = `__match`;
    const p = [];
    p.push(`${this.i()}{\n`);
    this.indent++;
    p.push(`${this.i()}const ${tempVar} = ${subject};\n`);

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case — wrap in else if preceded by if branches
          if (idx > 0) {
            p.push(` else {\n`);
            this.indent++;
          }
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
          }
          if (arm.body.type === 'BlockStatement') {
            p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
          } else {
            p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
          }
          if (idx > 0) {
            this.indent--;
            p.push(`${this.i()}}\n`);
          }
          break;
        }
      }

      if (idx === 0) {
        p.push(`${this.i()}if (${condition}) {\n`);
      } else {
        p.push(` else if (${condition}) {\n`);
      }
      this.indent++;

      // Bind variables from pattern
      p.push(this.genPatternBindings(arm.pattern, tempVar));

      if (arm.body.type === 'BlockStatement') {
        p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
      } else {
        p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
      }
      this.indent--;
      p.push(`${this.i()}}`);
    }
    p.push('\n');

    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('');
  }

  _genSwitchMatchAssign(node, targetVar) {
    // Switch-based match that assigns to targetVar instead of wrapping in IIFE
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';
    const p = [];
    p.push(`${this.i()}{\n`);
    this.indent++;
    p.push(`${this.i()}const ${tempVar} = ${subject};\n`);
    p.push(`${this.i()}switch (${tempVar}) {\n`);
    this.indent++;

    for (const arm of node.arms) {
      if (arm.pattern.type === 'WildcardPattern') {
        p.push(`${this.i()}default:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
        } else {
          p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
        }
        p.push(`${this.i()}break;\n`);
        this.indent--;
      } else if (arm.pattern.type === 'BindingPattern') {
        p.push(`${this.i()}default: {\n`);
        this.indent++;
        p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
        if (arm.body.type === 'BlockStatement') {
          p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
        } else {
          p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
        }
        p.push(`${this.i()}break;\n`);
        this.indent--;
        p.push(`${this.i()}}\n`);
      } else {
        // LiteralPattern
        p.push(`${this.i()}case ${JSON.stringify(arm.pattern.value)}:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
        } else {
          p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
        }
        p.push(`${this.i()}break;\n`);
        this.indent--;
      }
    }

    this.indent--;
    p.push(`${this.i()}}\n`);
    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('');
  }

  _genIfAssign(node, targetVar) {
    // Block-scoped if expression that assigns to targetVar instead of wrapping in IIFE
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyAssign(node.consequent, targetVar));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyAssign(alt.body, targetVar));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyAssign(node.elseBody, targetVar));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  // IIFE-free match/if that emits direct returns (for function body last expression)
  _genMatchReturn(node) {
    const subject = this.genExpression(node.subject);
    const tempVar = `__match`;
    const p = [];
    p.push(`${this.i()}{\n`);
    this.indent++;
    p.push(`${this.i()}const ${tempVar} = ${subject};\n`);

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          if (idx > 0) {
            p.push(` else {\n`);
            this.indent++;
          }
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
          }
          if (arm.body.type === 'BlockStatement') {
            p.push(this._genBlockBodyReturns(arm.body) + '\n');
          } else {
            p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
          }
          if (idx > 0) {
            this.indent--;
            p.push(`${this.i()}}\n`);
          }
          break;
        }
      }

      if (idx === 0) {
        p.push(`${this.i()}if (${condition}) {\n`);
      } else {
        p.push(` else if (${condition}) {\n`);
      }
      this.indent++;
      p.push(this.genPatternBindings(arm.pattern, tempVar));
      if (arm.body.type === 'BlockStatement') {
        p.push(this._genBlockBodyReturns(arm.body) + '\n');
      } else {
        p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
      }
      this.indent--;
      p.push(`${this.i()}}`);
    }
    p.push('\n');
    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('');
  }

  _genIfReturn(node) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyReturns(node.consequent));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyReturns(alt.body));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyReturns(node.elseBody));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  // Check if a match/if expression would need IIFE (not simple ternary)
  _needsIIFE(node) {
    if (node.type === 'MatchExpression') {
      return !this._isSimpleMatch(node);
    }
    if (node.type === 'IfExpression') {
      const isSingleExpr = (block) =>
        block.type === 'BlockStatement' && block.body.length === 1 && block.body[0].type === 'ExpressionStatement';
      // Simple if/elif → ternary (no IIFE)
      if (node.alternates.length === 0 && isSingleExpr(node.consequent) && isSingleExpr(node.elseBody)) return false;
      if (node.alternates.length > 0 && node.elseBody &&
          isSingleExpr(node.consequent) && isSingleExpr(node.elseBody) &&
          node.alternates.every(alt => isSingleExpr(alt.body))) return false;
      // Otherwise needs IIFE (or our new assign path)
      return true;
    }
    return false;
  }

  // Check if a match has any pattern bindings that would conflict with the target variable
  _matchBindingsConflict(node, targetVar) {
    if (node.type !== 'MatchExpression') return false;
    for (const arm of node.arms) {
      if (this._patternBindsName(arm.pattern, targetVar)) return true;
    }
    return false;
  }

  _patternBindsName(pattern, name) {
    switch (pattern.type) {
      case 'BindingPattern':
        return pattern.name === name;
      case 'VariantPattern':
        return pattern.fields.some(f => {
          if (typeof f === 'string') return f === name;
          if (f && f.type) return this._patternBindsName(f, name);
          return false;
        });
      case 'ArrayPattern':
      case 'TuplePattern':
        return pattern.elements.some(el => el && this._patternBindsName(el, name));
      case 'StringConcatPattern':
        return pattern.rest && pattern.rest.type === 'BindingPattern' && pattern.rest.name === name;
      default:
        return false;
    }
  }

  genPatternCondition(pattern, subject, guard) {
    let cond;

    switch (pattern.type) {
      case 'LiteralPattern':
        cond = `${subject} === ${JSON.stringify(pattern.value)}`;
        break;
      case 'RangePattern':
        if (pattern.inclusive) {
          cond = `${subject} >= ${pattern.start} && ${subject} <= ${pattern.end}`;
        } else {
          cond = `${subject} >= ${pattern.start} && ${subject} < ${pattern.end}`;
        }
        break;
      case 'VariantPattern': {
        const vchecks = [`${subject}?.__tag === "${pattern.name}"`];
        const declFields = this._variantFields[pattern.name] || [];
        for (let i = 0; i < pattern.fields.length; i++) {
          const f = pattern.fields[i];
          if (typeof f === 'object' && f.type && f.type !== 'WildcardPattern' && f.type !== 'BindingPattern') {
            const fieldName = f.type === 'BindingPattern' ? f.name : null;
            const propName = declFields[i] || fieldName || `value`;
            const fCond = this.genPatternCondition(f, `${subject}.${propName}`, null);
            if (fCond !== 'true') vchecks.push(fCond);
          }
        }
        cond = vchecks.join(' && ');
        break;
      }
      case 'ArrayPattern': {
        // Check it's an array with the right length, then check each element pattern
        const checks = [`Array.isArray(${subject})`, `${subject}.length === ${pattern.elements.length}`];
        for (let i = 0; i < pattern.elements.length; i++) {
          const elPat = pattern.elements[i];
          if (elPat.type !== 'WildcardPattern' && elPat.type !== 'BindingPattern') {
            const elCond = this.genPatternCondition(elPat, `${subject}[${i}]`, null);
            if (elCond !== 'true') checks.push(elCond);
          }
        }
        cond = checks.join(' && ');
        break;
      }
      case 'TuplePattern': {
        const checks = [`Array.isArray(${subject})`, `${subject}.length === ${pattern.elements.length}`];
        for (let i = 0; i < pattern.elements.length; i++) {
          const elPat = pattern.elements[i];
          if (elPat.type !== 'WildcardPattern' && elPat.type !== 'BindingPattern') {
            const elCond = this.genPatternCondition(elPat, `${subject}[${i}]`, null);
            if (elCond !== 'true') checks.push(elCond);
          }
        }
        cond = checks.join(' && ');
        break;
      }
      case 'StringConcatPattern':
        cond = `typeof ${subject} === 'string' && ${subject}.startsWith(${JSON.stringify(pattern.prefix)})`;
        break;
      case 'WildcardPattern':
        cond = 'true';
        break;
      case 'BindingPattern':
        cond = 'true';
        break;
      default:
        cond = 'true';
    }

    if (guard) {
      // For binding patterns, we need to bind first for the guard
      if (pattern.type === 'BindingPattern') {
        cond = `((${pattern.name}) => ${this.genExpression(guard)})(${subject})`;
      } else {
        cond = `(${cond}) && (${this.genExpression(guard)})`;
      }
    }

    return cond;
  }

  genPatternBindings(pattern, subject) {
    switch (pattern.type) {
      case 'BindingPattern':
        return `${this.i()}const ${pattern.name} = ${subject};\n`;
      case 'VariantPattern': {
        const declaredFields = this._variantFields[pattern.name] || [];
        return pattern.fields.map((f, idx) => {
          // Determine field name for property access
          const fieldName = typeof f === 'string' ? f : (f.type === 'BindingPattern' ? f.name : null);
          const propName = declaredFields[idx] || fieldName || `value`;
          const accessor = `${subject}.${propName}`;
          // String fields (legacy) — simple binding
          if (typeof f === 'string') {
            return `${this.i()}const ${f} = ${accessor};\n`;
          }
          // Nested pattern — recurse for bindings
          if (f.type === 'BindingPattern') {
            return `${this.i()}const ${f.name} = ${accessor};\n`;
          }
          if (f.type === 'WildcardPattern') return '';
          // Nested variant, array, tuple patterns
          return this.genPatternBindings(f, accessor);
        }).join('');
      }
      case 'ArrayPattern':
        return pattern.elements.map((el, idx) => {
          if (el.type === 'BindingPattern') {
            return `${this.i()}const ${el.name} = ${subject}[${idx}];\n`;
          }
          return this.genPatternBindings(el, `${subject}[${idx}]`);
        }).filter(s => s).join('');
      case 'TuplePattern':
        return pattern.elements.map((el, idx) => {
          if (el.type === 'BindingPattern') {
            return `${this.i()}const ${el.name} = ${subject}[${idx}];\n`;
          }
          return this.genPatternBindings(el, `${subject}[${idx}]`);
        }).filter(s => s).join('');
      case 'StringConcatPattern':
        if (pattern.rest && pattern.rest.type === 'BindingPattern') {
          return `${this.i()}const ${pattern.rest.name} = ${subject}.slice(${pattern.prefix.length});\n`;
        }
        return '';
      default:
        return '';
    }
  }

  genArrayLiteral(node) {
    const elements = node.elements.map(e => this.genExpression(e)).join(', ');
    // In @fast mode, detect all-numeric arrays and emit TypedArrays
    if (this._fastMode && node.elements.length > 0 && node.elements.every(e => e.type === 'NumberLiteral')) {
      const hasFloat = node.elements.some(e => String(e.value).includes('.'));
      const taType = hasFloat ? 'Float64Array' : 'Int32Array';
      return `new ${taType}([${elements}])`;
    }
    return `[${elements}]`;
  }

  genObjectLiteral(node) {
    const props = node.properties.map(p => {
      if (p.spread) {
        return `...${this.genExpression(p.argument)}`;
      }
      if (p.shorthand) {
        return this.genExpression(p.key);
      }
      return `${this.genExpression(p.key)}: ${this.genExpression(p.value)}`;
    }).join(', ');
    return `{ ${props} }`;
  }

  genListComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const varName = node.variable;
    const expr = this.genExpression(node.expression);

    if (node.condition) {
      const cond = this.genExpression(node.condition);
      // Skip redundant .map() when expression is just the loop variable
      if (expr === varName) {
        return `${iter}.filter((${varName}) => ${cond})`;
      }
      // Single-pass loop avoids intermediate array from filter().map()
      return `${iter}.reduce((acc, ${varName}) => { if (${cond}) acc.push(${expr}); return acc; }, [])`;
    }
    return `${iter}.map((${varName}) => ${expr})`;
  }

  genDictComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const vars = node.variables;
    const key = this.genExpression(node.key);
    const value = this.genExpression(node.value);

    const destructure = vars.length === 2 ? `[${vars[0]}, ${vars[1]}]` : vars[0];

    let code = `Object.fromEntries(${iter}`;
    if (node.condition) {
      code += `.filter((${destructure}) => ${this.genExpression(node.condition)})`;
    }
    code += `.map((${destructure}) => [${key}, ${value}]))`;
    return code;
  }

  genRangeExpression(node) {
    const start = this.genExpression(node.start);
    const end = this.genExpression(node.end);
    // Use stdlib range() — handles step and direction, avoids Array.from overhead
    this._trackBuiltin('range');
    if (node.inclusive) {
      return `range(${start}, (${end}) + 1)`;
    }
    return `range(${start}, ${end})`;
  }

  genSliceExpression(node) {
    const obj = this.genExpression(node.object);
    const start = node.start ? this.genExpression(node.start) : '';
    const end = node.end ? this.genExpression(node.end) : '';

    if (node.step) {
      const step = this.genExpression(node.step);
      const s = node.start ? this.genExpression(node.start) : 'null';
      const e = node.end ? this.genExpression(node.end) : 'null';
      // Handles both positive and negative step directions
      return `((a, s, e, st) => { const r = []; if (st > 0) { for (let i = s !== null ? s : 0; i < (e !== null ? e : a.length); i += st) r.push(a[i]); } else { for (let i = s !== null ? s : a.length - 1; i > (e !== null ? e : -1); i += st) r.push(a[i]); } return r; })(${obj}, ${s}, ${e}, ${step})`;
    }

    if (!start && !end) return `${obj}.slice()`;
    if (!start) return `${obj}.slice(0, ${end})`;
    if (!end) return `${obj}.slice(${start})`;
    return `${obj}.slice(${start}, ${end})`;
  }

  _declareDestructureVars(pattern) {
    if (pattern.type === 'ObjectPattern') {
      for (const p of pattern.properties) this.declareVar(p.value);
    } else if (pattern.type === 'ArrayPattern') {
      for (const e of pattern.elements) if (e) this.declareVar(e);
    }
  }

  genGuardStatement(node) {
    const p = [];
    p.push(`${this.i()}if (!(${this.genExpression(node.condition)})) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.elseBody));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genInterfaceDeclaration(node) {
    // Interfaces are compile-time only — generate as a documentation comment
    const exportStr = node.isPublic ? 'export ' : '';
    const methods = node.methods.map(m => {
      const params = m.params.map(p => {
        let s = p.name;
        if (p.typeAnnotation) s += `: ${p.typeAnnotation.name || 'any'}`;
        return s;
      }).join(', ');
      const ret = m.returnType ? ` -> ${m.returnType.name || 'any'}` : '';
      return `${this.i()} *   fn ${m.name}(${params})${ret}`;
    }).join('\n');
    return `${this.i()}/* ${exportStr}interface ${node.name} {\n${methods}\n${this.i()} * } */`;
  }

  genTypeDeclaration(node) {
    const lines = [];
    const exportPrefix = node.isPublic ? 'export ' : '';

    const hasVariants = node.variants.some(v => v.type === 'TypeVariant');

    if (hasVariants) {
      for (const variant of node.variants) {
        if (variant.type === 'TypeVariant') {
          this.declareVar(variant.name);
          const rawFieldNames = variant.fields.map(f => f.name);
          // Deduplicate field names: Add(Expr, Expr) → _0, _1 (prevents property collision)
          const nameCount = {};
          rawFieldNames.forEach(n => nameCount[n] = (nameCount[n] || 0) + 1);
          const hasDupes = Object.values(nameCount).some(c => c > 1);
          const fieldNames = hasDupes ? rawFieldNames.map((_, i) => `_${i}`) : rawFieldNames;
          this._variantFields[variant.name] = fieldNames;
          if (variant.fields.length === 0) {
            lines.push(`${this.i()}${exportPrefix}const ${variant.name} = Object.freeze({ __tag: "${variant.name}" });`);
          } else {
            const params = fieldNames.join(', ');
            const obj = fieldNames.map(f => `${f}`).join(', ');
            lines.push(`${this.i()}${exportPrefix}function ${variant.name}(${params}) { return { __tag: "${variant.name}", ${obj} }; }`);
          }
        }
      }
    } else {
      this.declareVar(node.name);
      const fieldNames = node.variants.map(f => f.name);
      const params = fieldNames.join(', ');
      const obj = fieldNames.map(f => `${f}`).join(', ');
      lines.push(`${this.i()}${exportPrefix}function ${node.name}(${params}) { return Object.assign(Object.create(${node.name}.prototype), { ${obj} }); }`);
    }

    // Derive clause: generate methods
    if (node.derive && node.derive.length > 0) {
      const targetName = hasVariants ? null : node.name;
      const fieldNames = hasVariants ? [] : node.variants.map(f => f.name);

      const builtinTraits = new Set(['Eq', 'Show', 'JSON']);
      for (const trait of node.derive) {
        if (trait === 'Eq' && targetName) {
          // Deep equality: compare all fields
          const checks = fieldNames.map(f => `a.${f} === b.${f}`).join(' && ');
          lines.push(`${this.i()}${targetName}.__eq = function(a, b) { return ${checks || 'true'}; };`);
        }
        if (trait === 'Show' && targetName) {
          const fields = fieldNames.map(f => `${f}: \${JSON.stringify(obj.${f})}`).join(', ');
          lines.push(`${this.i()}${targetName}.__show = function(obj) { return \`${targetName}(${fields})\`; };`);
        }
        if (trait === 'JSON' && targetName) {
          lines.push(`${this.i()}${targetName}.toJSON = function(obj) { return JSON.stringify(obj); };`);
          lines.push(`${this.i()}${targetName}.fromJSON = function(str) { const d = JSON.parse(str); return ${targetName}(${fieldNames.map(f => `d.${f}`).join(', ')}); };`);
        }

        // Extensible derive: user-defined traits
        if (!builtinTraits.has(trait) && targetName) {
          const traitDecl = this._traitDecls.get(trait);
          if (traitDecl) {
            for (const method of traitDecl.methods) {
              if (method.body) {
                // Trait has a default implementation — use it
                lines.push(`${this.i()}${targetName}.prototype.${method.name} = __trait_${trait}_${method.name};`);
              }
            }
          }
        }
      }

      // For variant types with derive
      if (hasVariants) {
        for (const trait of node.derive) {
          if (trait === 'Eq') {
            lines.push(`${this.i()}function __eq_${node.name}(a, b) { if (a === b) return true; if (!a || !b || a.__tag !== b.__tag) return false; for (const k of Object.keys(a)) { if (k === '__tag') continue; if (a[k] !== b[k]) { if (typeof a[k] === 'object' && typeof b[k] === 'object' && a[k]?.__tag && b[k]?.__tag) { if (!__eq_${node.name}(a[k], b[k])) return false; } else return false; } } return true; }`);
          }
          if (trait === 'Show') {
            lines.push(`${this.i()}function __show_${node.name}(obj) { return obj.__tag + "(" + Object.entries(obj).filter(([k]) => k !== "__tag").map(([k, v]) => k + ": " + JSON.stringify(v)).join(", ") + ")"; }`);
          }
          if (trait === 'JSON') {
            lines.push(`${this.i()}function __toJSON_${node.name}(obj) { return JSON.stringify(obj); }`);
          }
        }
      }
    }

    return lines.join('\n');
  }

  genImplDeclaration(node) {
    // Register trait impl for extensible derive
    if (node.traitName) {
      this._traitImpls.set(`${node.traitName}:${node.typeName}`, node);
    }

    const lines = [];
    for (const method of node.methods) {
      const hasSelf = method.params.some(p => p.name === 'self');
      const params = method.params.filter(p => p.name !== 'self');
      const paramStr = this.genParams(params);
      const hasPropagate = this._containsPropagate(method.body);
      const asyncPrefix = method.isAsync ? 'async ' : '';
      this.pushScope();
      if (hasSelf) this.declareVar('self');
      for (const p of params) {
        if (p.destructure) this._declareDestructureVars(p.destructure);
        else this.declareVar(p.name);
      }
      const body = this.genBlockBody(method.body);
      this.popScope();
      const selfBinding = hasSelf ? `\n${this.i()}  const self = this;` : '';
      if (hasPropagate) {
        lines.push(`${this.i()}${node.typeName}.prototype.${method.name} = ${asyncPrefix}function(${paramStr}) {${selfBinding}\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}};`);
      } else {
        lines.push(`${this.i()}${node.typeName}.prototype.${method.name} = ${asyncPrefix}function(${paramStr}) {${selfBinding}\n${body}\n${this.i()}};`);
      }
    }
    return lines.join('\n');
  }

  genTraitDeclaration(node) {
    // Register trait for extensible derive
    this._traitDecls.set(node.name, { methods: node.methods });

    // Traits are mostly compile-time, but generate default implementations as functions
    const lines = [];
    const defaultMethods = node.methods.filter(m => m.body);
    if (defaultMethods.length > 0) {
      lines.push(`${this.i()}/* trait ${node.name} */`);
      for (const method of defaultMethods) {
        const params = this.genParams(method.params);
        this.pushScope();
        for (const p of method.params) {
          if (p.destructure) this._declareDestructureVars(p.destructure);
          else if (p.name) this.declareVar(p.name);
        }
        const body = this.genBlockBody(method.body);
        this.popScope();
        lines.push(`${this.i()}function __trait_${node.name}_${method.name}(${params}) {\n${body}\n${this.i()}}`);
      }
    } else {
      lines.push(`${this.i()}/* trait ${node.name} { ${node.methods.map(m => `fn ${m.name}()`).join(', ')} } */`);
    }
    return lines.join('\n');
  }

  genTypeAlias(node) {
    // Type aliases are compile-time only
    const exportStr = node.isPublic ? 'export ' : '';
    const typeParams = node.typeParams && node.typeParams.length > 0 ? `<${node.typeParams.join(', ')}>` : '';
    const typeStr = this._typeAnnotationToString(node.typeExpr);
    return `${this.i()}/* ${exportStr}type alias: ${node.name}${typeParams} = ${typeStr} */`;
  }

  _typeAnnotationToString(ann) {
    if (!ann) return 'any';
    if (ann.type === 'UnionTypeAnnotation') {
      return ann.members.map(m => this._typeAnnotationToString(m)).join(' | ');
    }
    if (ann.type === 'ArrayTypeAnnotation') {
      return `[${this._typeAnnotationToString(ann.elementType)}]`;
    }
    if (ann.type === 'TupleTypeAnnotation') {
      return `(${ann.elementTypes.map(t => this._typeAnnotationToString(t)).join(', ')})`;
    }
    if (ann.type === 'FunctionTypeAnnotation') {
      const params = ann.paramTypes.map(t => this._typeAnnotationToString(t)).join(', ');
      return `(${params}) -> ${this._typeAnnotationToString(ann.returnType)}`;
    }
    if (ann.typeParams && ann.typeParams.length > 0) {
      const params = ann.typeParams.map(t => this._typeAnnotationToString(t)).join(', ');
      return `${ann.name}<${params}>`;
    }
    return ann.name || 'any';
  }

  genRefinementType(node) {
    // Refinement types compile to validator functions
    // type Email = String where { it |> contains("@") }
    // → function __validate_Email(it) { return it.includes("@"); }
    const predExpr = this.genExpression(node.predicate);
    return `${this.i()}function __validate_${node.name}(it) {\n${this.i()}  if (!(${predExpr})) throw new Error("Refinement type ${node.name} validation failed");\n${this.i()}  return it;\n${this.i()}}`;
  }

  genDeferStatement(node) {
    // Defer is handled by genBlockBody which collects defers and wraps in try/finally.
    // If called outside genBlockBody (e.g., via genBlockStatements), generate a no-op comment.
    // The actual defer logic is emitted correctly when genBlockBody processes the enclosing function.
    return `${this.i()}/* defer */`;
  }

  genWithStatement(node) {
    const expr = this.genExpression(node.expression);
    const name = node.name;
    this.declareVar(name);
    const p = [];
    p.push(`${this.i()}const ${name} = ${expr};`);
    p.push(`${this.i()}try {`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.body));
    this.popScope();
    this.indent--;
    p.push(`${this.i()}} finally {`);
    this.indent++;
    p.push(`${this.i()}if (${name} != null && typeof ${name}.close === 'function') ${name}.close();`);
    p.push(`${this.i()}else if (${name} != null && typeof ${name}.dispose === 'function') ${name}.dispose();`);
    p.push(`${this.i()}else if (${name} != null && typeof ${name}[Symbol.dispose] === 'function') ${name}[Symbol.dispose]();`);
    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('\n');
  }

  // Check if a function body contains yield expressions (for generator detection)
  _containsYield(node) {
    if (!node) return false;
    if (node.type === 'YieldExpression') return true;
    if (node.type === 'FunctionDeclaration' || node.type === 'LambdaExpression') return false;
    const cached = this._yieldCache.get(node);
    if (cached !== undefined) return cached;
    let result = false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsYield(item)) { result = true; break; }
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsYield(val)) { result = true; break; }
      }
      if (result) break;
    }
    this._yieldCache.set(node, result);
    return result;
  }
}

// ─── src/codegen/shared-codegen.js ─────────────────────

class SharedCodegen extends BaseCodegen {
  generate(block) {
    const code = block.body.map(stmt => this.generateStatement(stmt)).join('\n');
    return code;
  }

  // Generate any needed helpers (called after all code is generated)
  generateHelpers() {
    const helpers = [];
    helpers.push(this.getStringProtoHelper());
    // Only include Result/Option if Ok/Err/Some/None are used
    if (this._needsResultOption) {
      helpers.push(this.getResultOptionHelper());
    }
    if (this._needsContainsHelper) {
      helpers.push(this.getContainsHelper());
    }
    if (this._needsPropagateHelper) {
      helpers.push(this.getPropagateHelper());
    }
    // Include only used builtin functions
    const selectiveStdlib = buildSelectiveStdlib(this.getUsedBuiltins());
    if (selectiveStdlib) helpers.push(selectiveStdlib);
    return helpers.join('\n');
  }
}

// ─── src/codegen/server-codegen.js ─────────────────────

class ServerCodegen extends BaseCodegen {
  _astUsesIdentifier(blocks, name) {
    const search = (node) => {
      if (!node || typeof node !== 'object') return false;
      if (node.type === 'Identifier' && node.name === name) return true;
      if (node.type === 'MemberExpression' && node.object && node.object.type === 'Identifier' && node.object.name === name) return true;
      for (const key of Object.keys(node)) {
        if (key === 'loc' || key === 'type') continue;
        const val = node[key];
        if (Array.isArray(val)) {
          for (const item of val) {
            if (search(item)) return true;
          }
        } else if (val && typeof val === 'object' && val.type) {
          if (search(val)) return true;
        }
      }
      return false;
    };
    for (const block of blocks) {
      if (search(block)) return true;
    }
    return false;
  }

  _genValidationCode(params, indent = '  ') {
    const checks = [];
    for (const p of params) {
      const name = p.name;
      const ta = p.typeAnnotation;
      if (!ta) continue;
      const hasRequiredCheck = !p.defaultValue;
      if (hasRequiredCheck) {
        checks.push(`${indent}if (${name} === undefined || ${name} === null) __validationErrors.push("${name} is required");`);
      }
      const typeCheckPrefix = hasRequiredCheck ? 'else if' : 'if';
      if (ta.type === 'TypeAnnotation') {
        switch (ta.name) {
          case 'String':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "string") __validationErrors.push("${name} must be a string");`);
            break;
          case 'Int':
            checks.push(`${indent}${typeCheckPrefix} (!Number.isInteger(${name})) __validationErrors.push("${name} must be an integer");`);
            break;
          case 'Float':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "number") __validationErrors.push("${name} must be a number");`);
            break;
          case 'Bool':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "boolean") __validationErrors.push("${name} must be a boolean");`);
            break;
        }
      } else if (ta.type === 'ArrayTypeAnnotation') {
        checks.push(`${indent}${typeCheckPrefix} (!Array.isArray(${name})) __validationErrors.push("${name} must be an array");`);
      }
    }
    return checks;
  }

  _genAdvancedValidationCode(schemaExpr, indent = '  ') {
    const checks = [];
    if (schemaExpr.type !== 'ObjectLiteral') return checks;
    for (const prop of schemaExpr.properties) {
      const fieldName = prop.key.type === 'Identifier' ? prop.key.name : (prop.key.type === 'StringLiteral' ? prop.key.value : null);
      if (!fieldName) continue;
      const rules = prop.value;
      if (rules.type !== 'ObjectLiteral') continue;
      for (const rule of rules.properties) {
        const ruleKey = rule.key.type === 'Identifier' ? rule.key.name : (rule.key.type === 'StringLiteral' ? rule.key.value : null);
        if (!ruleKey) continue;
        const ruleVal = this.genExpression(rule.value);
        switch (ruleKey) {
          case 'required':
            checks.push(`${indent}if (${ruleVal} && (__body.${fieldName} === undefined || __body.${fieldName} === null || __body.${fieldName} === "")) __validationErrors.push("${fieldName} is required");`);
            break;
          case 'min_length':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && String(__body.${fieldName}).length < ${ruleVal}) __validationErrors.push("${fieldName} must be at least ${ruleVal} characters");`);
            break;
          case 'max_length':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && String(__body.${fieldName}).length > ${ruleVal}) __validationErrors.push("${fieldName} must be at most ${ruleVal} characters");`);
            break;
          case 'min':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && Number(__body.${fieldName}) < ${ruleVal}) __validationErrors.push("${fieldName} must be at least ${ruleVal}");`);
            break;
          case 'max':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && Number(__body.${fieldName}) > ${ruleVal}) __validationErrors.push("${fieldName} must be at most ${ruleVal}");`);
            break;
          case 'pattern':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && !new RegExp(${ruleVal}).test(String(__body.${fieldName}))) __validationErrors.push("${fieldName} does not match required pattern");`);
            break;
          case 'one_of':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && !${ruleVal}.includes(__body.${fieldName})) __validationErrors.push("${fieldName} must be one of: " + ${ruleVal}.join(", "));`);
            break;
        }
      }
    }
    return checks;
  }

  // Emit handler call, optionally wrapped in Promise.race for timeout
  _emitHandlerCall(lines, callExpr, timeoutMs) {
    if (timeoutMs) {
      lines.push(`  let __result;`);
      lines.push(`  try {`);
      lines.push(`    __result = await Promise.race([`);
      lines.push(`      ${callExpr},`);
      lines.push(`      new Promise((_, rej) => setTimeout(() => rej(new Error("__timeout__")), ${timeoutMs}))`);
      lines.push(`    ]);`);
      lines.push(`  } catch (__err) {`);
      lines.push(`    if (__err.message === "__timeout__") return Response.json({ error: "Gateway Timeout" }, { status: 504 });`);
      lines.push(`    throw __err;`);
      lines.push(`  }`);
    } else {
      lines.push(`  const __result = await ${callExpr};`);
    }
  }

  generate(serverBlocks, sharedCode, blockName = null, peerBlocks = null, sharedBlocks = []) {
    const lines = [];

    // Shared code
    if (sharedCode.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedCode);
      lines.push('');
    }

    // Collect all declarations from blocks (including route group flattening)
    const routes = [];
    const functions = [];
    const middlewares = [];
    const otherStatements = [];
    let healthPath = null;
    let corsConfig = null;
    let errorHandler = null;
    let wsDecl = null;
    let staticDecl = null;
    let authConfig = null;
    let maxBodyLimit = null;
    const discoverMap = new Map();
    let rateLimitConfig = null;
    const onStartHooks = [];
    const onStopHooks = [];
    const subscriptions = [];
    const envDecls = [];
    const schedules = [];
    let uploadConfig = null;
    let sessionConfig = null;
    let dbConfig = null;
    let tlsConfig = null;
    let compressionConfig = null;
    const backgroundJobs = [];
    let cacheConfig = null;
    const sseDecls = [];
    const modelDecls = [];
    const aiConfigs = []; // { name: string|null, config: object }

    const collectFromBody = (stmts, groupPrefix = null, groupMiddlewares = [], groupVersion = null) => {
      for (const stmt of stmts) {
        if (stmt.type === 'RouteDeclaration') {
          const route = stmt;
          if (groupPrefix) {
            const prefixedRoute = {
              ...route,
              path: groupPrefix + route.path,
              _groupMiddlewares: groupMiddlewares.length > 0 ? [...groupMiddlewares] : undefined,
              _version: groupVersion || undefined,
            };
            routes.push(prefixedRoute);
          } else {
            routes.push(route);
          }
        } else if (stmt.type === 'FunctionDeclaration') {
          functions.push(stmt);
        } else if (stmt.type === 'MiddlewareDeclaration') {
          if (groupPrefix !== null) {
            groupMiddlewares.push(stmt.name);
          }
          middlewares.push(stmt);
        } else if (stmt.type === 'HealthCheckDeclaration') {
          healthPath = stmt.path;
        } else if (stmt.type === 'CorsDeclaration') {
          corsConfig = stmt.config;
        } else if (stmt.type === 'ErrorHandlerDeclaration') {
          errorHandler = stmt;
        } else if (stmt.type === 'WebSocketDeclaration') {
          wsDecl = stmt;
        } else if (stmt.type === 'StaticDeclaration') {
          staticDecl = stmt;
        } else if (stmt.type === 'AuthDeclaration') {
          authConfig = stmt.config;
        } else if (stmt.type === 'MaxBodyDeclaration') {
          maxBodyLimit = stmt.limit;
        } else if (stmt.type === 'DiscoverDeclaration') {
          discoverMap.set(stmt.peerName, stmt);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          const prefix = groupPrefix ? groupPrefix + stmt.prefix : stmt.prefix;
          const grpMw = [...groupMiddlewares]; // inherit parent group middlewares
          const ver = stmt.version || groupVersion; // inherit or override version
          collectFromBody(stmt.body, prefix, grpMw, ver);
        } else if (stmt.type === 'RateLimitDeclaration') {
          rateLimitConfig = stmt.config;
        } else if (stmt.type === 'LifecycleHookDeclaration') {
          if (stmt.hook === 'start') onStartHooks.push(stmt);
          else if (stmt.hook === 'stop') onStopHooks.push(stmt);
        } else if (stmt.type === 'SubscribeDeclaration') {
          subscriptions.push(stmt);
        } else if (stmt.type === 'EnvDeclaration') {
          envDecls.push(stmt);
        } else if (stmt.type === 'ScheduleDeclaration') {
          schedules.push(stmt);
        } else if (stmt.type === 'UploadDeclaration') {
          uploadConfig = stmt.config;
        } else if (stmt.type === 'SessionDeclaration') {
          sessionConfig = stmt.config;
        } else if (stmt.type === 'DbDeclaration') {
          dbConfig = stmt.config;
        } else if (stmt.type === 'TlsDeclaration') {
          tlsConfig = stmt.config;
        } else if (stmt.type === 'CompressionDeclaration') {
          compressionConfig = stmt.config;
        } else if (stmt.type === 'BackgroundJobDeclaration') {
          backgroundJobs.push(stmt);
        } else if (stmt.type === 'CacheDeclaration') {
          cacheConfig = stmt.config;
        } else if (stmt.type === 'SseDeclaration') {
          sseDecls.push(stmt);
        } else if (stmt.type === 'ModelDeclaration') {
          modelDecls.push(stmt);
        } else if (stmt.type === 'AiConfigDeclaration') {
          aiConfigs.push(stmt);
        } else {
          otherStatements.push(stmt);
        }
      }
    };

    for (const block of serverBlocks) {
      collectFromBody(block.body);
    }

    // Collect type declarations from shared blocks for model/ORM generation
    const sharedTypes = new Map(); // typeName -> { fields: [{ name, type }] }
    const _collectTypes = (stmts) => {
      for (const stmt of stmts) {
        if (stmt.type === 'TypeDeclaration' && stmt.variants) {
          const fields = [];
          for (const v of stmt.variants) {
            if (v.type === 'TypeField' && v.typeAnnotation) {
              fields.push({ name: v.name, type: v.typeAnnotation.name || (v.typeAnnotation.type === 'ArrayTypeAnnotation' ? 'Array' : 'Any') });
            }
          }
          if (fields.length > 0) {
            sharedTypes.set(stmt.name, { fields });
          }
        }
      }
    };
    for (const sb of sharedBlocks) {
      _collectTypes(sb.body);
    }
    // Also collect types from server blocks (for body: Type validation)
    for (const block of serverBlocks) {
      _collectTypes(block.body);
    }

    // Separate group-only middlewares from global middlewares
    const globalMiddlewares = [];
    const allMiddlewareNames = new Set();
    for (const block of serverBlocks) {
      for (const stmt of block.body) {
        if (stmt.type === 'MiddlewareDeclaration') {
          globalMiddlewares.push(stmt);
        }
      }
    }
    for (const mw of middlewares) {
      allMiddlewareNames.add(mw.name);
    }

    // Build function param lookup map
    const fnParamMap = new Map();
    const fnDeclMap = new Map();
    for (const fn of functions) {
      fnParamMap.set(fn.name, fn.params.map(p => p.name));
      fnDeclMap.set(fn.name, fn);
    }

    // Check if 'db' is used
    const usesDb = this._astUsesIdentifier(serverBlocks, 'db');

    // Check if rate limiting is needed
    const needsRateLimitStore = !!rateLimitConfig || routes.some(r => (r.decorators || []).some(d => d.name === 'rate_limit'));

    // Fast mode: emit a minimal request handler when no complex features are used
    const allRoutesStatic = routes.every(r => !r.path.includes(':') && !r.path.includes('*'));
    const hasDynamicRoutes = !allRoutesStatic;
    const isFastMode = !corsConfig && !authConfig && !sessionConfig && !rateLimitConfig &&
      !errorHandler && !wsDecl && !staticDecl && !compressionConfig &&
      middlewares.length === 0 && !dbConfig && subscriptions.length === 0 &&
      backgroundJobs.length === 0 && sseDecls.length === 0 && !cacheConfig &&
      routes.every(r => !(r.decorators || []).length && !r._groupMiddlewares?.length && !r._version);

    // ════════════════════════════════════════════════════════════
    // 1. Distributed Tracing
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
    lines.push('// ── Distributed Tracing ──');
    lines.push('import { AsyncLocalStorage } from "node:async_hooks";');
    lines.push('const __requestContext = new AsyncLocalStorage();');
    lines.push('function __getRequestId() {');
    lines.push('  const store = __requestContext.getStore();');
    lines.push('  return store ? store.rid : null;');
    lines.push('}');
    lines.push('function __getLocals() {');
    lines.push('  const store = __requestContext.getStore();');
    lines.push('  return store ? store.locals : {};');
    lines.push('}');
    lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 2. Env Validation (F6) — fail fast
    // ════════════════════════════════════════════════════════════
    if (envDecls.length > 0) {
      lines.push('// ── Env Validation ──');
      // Collect all required env vars without defaults and validate presence before any exit
      const requiredEnvs = envDecls.filter(d => !d.defaultValue);
      if (requiredEnvs.length > 0) {
        lines.push(`const __envErrors = [];`);
        for (const decl of requiredEnvs) {
          lines.push(`if (process.env.${decl.name} === undefined || process.env.${decl.name} === "") __envErrors.push("${decl.name}");`);
        }
        lines.push(`if (__envErrors.length > 0) { console.error("Missing required env vars: " + __envErrors.join(", ")); process.exit(1); }`);
      }
      for (const decl of envDecls) {
        const envName = decl.name;
        const ta = decl.typeAnnotation;
        const typeName = ta ? ta.name : 'String';
        lines.push(`const ${envName} = (() => {`);
        lines.push(`  const __raw = process.env.${envName};`);
        if (decl.defaultValue) {
          const defaultExpr = this.genExpression(decl.defaultValue);
          lines.push(`  if (__raw === undefined || __raw === "") return ${defaultExpr};`);
        }
        switch (typeName) {
          case 'Int':
            lines.push(`  const __val = parseInt(__raw, 10);`);
            lines.push(`  if (isNaN(__val)) { console.error("env ${envName}: expected Int, got " + __raw); process.exit(1); }`);
            lines.push(`  return __val;`);
            break;
          case 'Float':
            lines.push(`  const __val = parseFloat(__raw);`);
            lines.push(`  if (isNaN(__val)) { console.error("env ${envName}: expected Float, got " + __raw); process.exit(1); }`);
            lines.push(`  return __val;`);
            break;
          case 'Bool':
            lines.push(`  return __raw === "true" || __raw === "1";`);
            break;
          default:
            lines.push(`  return __raw;`);
            break;
        }
        lines.push(`})();`);
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 3. Database (multi-driver: sqlite, postgres, mysql)
    // ════════════════════════════════════════════════════════════
    const dbDriver = dbConfig && dbConfig.driver ? (dbConfig.driver.value || 'sqlite') : 'sqlite';
    if (dbConfig || usesDb) {
      lines.push('// ── Database ──');
      if (dbDriver === 'postgres') {
        lines.push('import postgres from "postgres";');
        const urlExpr = dbConfig && dbConfig.url ? this.genExpression(dbConfig.url) : 'process.env.DATABASE_URL || "postgres://localhost:5432/app"';
        lines.push(`const __pg = postgres(${urlExpr});`);
        lines.push('const db = {');
        lines.push('  async query(sql, ...params) {');
        lines.push('    if (params.length > 0) { return __pg.unsafe(sql, params); }');
        lines.push('    return __pg.unsafe(sql);');
        lines.push('  },');
        lines.push('  async run(sql, ...params) {');
        lines.push('    if (params.length > 0) { return __pg.unsafe(sql, params); }');
        lines.push('    return __pg.unsafe(sql);');
        lines.push('  },');
        lines.push('  async get(sql, ...params) {');
        lines.push('    const rows = params.length > 0 ? await __pg.unsafe(sql, params) : await __pg.unsafe(sql);');
        lines.push('    return rows[0] || null;');
        lines.push('  },');
        lines.push('  async exec(sql) { return __pg.unsafe(sql); },');
        lines.push('  async transaction(fn) {');
        lines.push('    return __pg.begin(sql => fn({ query: (s, ...p) => sql.unsafe(s, p), run: (s, ...p) => sql.unsafe(s, p), get: async (s, ...p) => { const r = await sql.unsafe(s, p); return r[0] || null; }, exec: (s) => sql.unsafe(s) }));');
        lines.push('  },');
        lines.push('  async migrate(migrations) {');
        lines.push('    await __pg.unsafe(`CREATE TABLE IF NOT EXISTS __migrations (id SERIAL PRIMARY KEY, name TEXT NOT NULL UNIQUE, applied_at TIMESTAMPTZ DEFAULT NOW())`);');
        lines.push('    const applied = new Set((await __pg.unsafe("SELECT name FROM __migrations")).map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!applied.has(m.name)) {');
        lines.push('        await __pg.unsafe(m.up);');
        lines.push('        await __pg.unsafe("INSERT INTO __migrations (name) VALUES ($1)", [m.name]);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  async close() { await __pg.end(); },');
        lines.push('};');
      } else if (dbDriver === 'mysql') {
        lines.push('import mysql from "mysql2/promise";');
        const urlExpr = dbConfig && dbConfig.url ? this.genExpression(dbConfig.url) : 'process.env.DATABASE_URL || "mysql://localhost:3306/app"';
        lines.push(`const __mysqlPool = mysql.createPool(${urlExpr});`);
        lines.push('const db = {');
        lines.push('  async query(sql, ...params) {');
        lines.push('    const [rows] = await __mysqlPool.execute(sql, params);');
        lines.push('    return rows;');
        lines.push('  },');
        lines.push('  async run(sql, ...params) {');
        lines.push('    const [result] = await __mysqlPool.execute(sql, params);');
        lines.push('    return result;');
        lines.push('  },');
        lines.push('  async get(sql, ...params) {');
        lines.push('    const [rows] = await __mysqlPool.execute(sql, params);');
        lines.push('    return rows[0] || null;');
        lines.push('  },');
        lines.push('  async exec(sql) { const [r] = await __mysqlPool.query(sql); return r; },');
        lines.push('  async transaction(fn) {');
        lines.push('    const conn = await __mysqlPool.getConnection();');
        lines.push('    await conn.beginTransaction();');
        lines.push('    try {');
        lines.push('      const result = await fn({ query: async (s, ...p) => { const [r] = await conn.execute(s, p); return r; }, run: async (s, ...p) => { const [r] = await conn.execute(s, p); return r; }, get: async (s, ...p) => { const [r] = await conn.execute(s, p); return r[0] || null; }, exec: async (s) => { const [r] = await conn.query(s); return r; } });');
        lines.push('      await conn.commit();');
        lines.push('      return result;');
        lines.push('    } catch (e) { await conn.rollback(); throw e; }');
        lines.push('    finally { conn.release(); }');
        lines.push('  },');
        lines.push('  async migrate(migrations) {');
        lines.push('    await __mysqlPool.query(`CREATE TABLE IF NOT EXISTS __migrations (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL UNIQUE, applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);');
        lines.push('    const [applied] = await __mysqlPool.query("SELECT name FROM __migrations");');
        lines.push('    const appliedSet = new Set(applied.map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!appliedSet.has(m.name)) {');
        lines.push('        await __mysqlPool.query(m.up);');
        lines.push('        await __mysqlPool.execute("INSERT INTO __migrations (name) VALUES (?)", [m.name]);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  async close() { await __mysqlPool.end(); },');
        lines.push('};');
      } else {
        // Default: SQLite
        lines.push('import { Database } from "bun:sqlite";');
        const pathExpr = dbConfig && dbConfig.path ? this.genExpression(dbConfig.path) : '":memory:"';
        lines.push(`const __db = new Database(${pathExpr});`);
        const walEnabled = dbConfig && dbConfig.wal ? this.genExpression(dbConfig.wal) : 'true';
        lines.push(`if (${walEnabled}) __db.exec("PRAGMA journal_mode=WAL");`);
        lines.push('__db.exec("PRAGMA foreign_keys=ON");');
        lines.push('const db = {');
        lines.push('  query(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.all(...params);');
        lines.push('  },');
        lines.push('  run(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.run(...params);');
        lines.push('  },');
        lines.push('  get(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.get(...params);');
        lines.push('  },');
        lines.push('  exec(sql) { return __db.exec(sql); },');
        lines.push('  transaction(fn) {');
        lines.push('    return __db.transaction(fn)();');
        lines.push('  },');
        lines.push('  migrate(migrations) {');
        lines.push('    __db.exec(`CREATE TABLE IF NOT EXISTS __migrations (');
        lines.push('      id INTEGER PRIMARY KEY, name TEXT NOT NULL UNIQUE, applied_at TEXT DEFAULT (datetime(\'now\'))');
        lines.push('    )`);');
        lines.push('    const applied = new Set(__db.prepare("SELECT name FROM __migrations").all().map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!applied.has(m.name)) {');
        lines.push('        __db.exec(m.up);');
        lines.push('        __db.prepare("INSERT INTO __migrations (name) VALUES (?)").run(m.name);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  close() { __db.close(); },');
        lines.push('};');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 3b. AI Client Initialization
    // ════════════════════════════════════════════════════════════
    if (aiConfigs.length > 0) {
      lines.push('// ── AI Clients ──');
      lines.push(this._getAiRuntime());
      lines.push('');

      let hasDefaultAi = false;
      for (const aiConf of aiConfigs) {
        const configParts = [];
        for (const [key, valueNode] of Object.entries(aiConf.config)) {
          configParts.push(`  ${key}: ${this.genExpression(valueNode)}`);
        }
        const configStr = `{\n${configParts.join(',\n')}\n}`;

        if (aiConf.name) {
          // Named provider: ai "claude" { ... } → const claude = __createAI({...})
          lines.push(`const ${aiConf.name} = __createAI(${configStr});`);
        } else {
          // Default provider: ai { ... } → const ai = __createAI({...})
          lines.push(`const ai = __createAI(${configStr});`);
          hasDefaultAi = true;
        }
      }
      // If no default ai config, create a default for one-off calls
      if (!hasDefaultAi) {
        lines.push('const ai = __createAI({});');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 4. Peer Server RPC Proxies (with circuit breaker + retry)
    // ════════════════════════════════════════════════════════════
    if (peerBlocks && peerBlocks.size > 0) {
      lines.push('// ── Circuit Breaker + Retry ──');
      lines.push('class __CircuitBreaker {');
      lines.push('  constructor(name, threshold = 5, resetTimeout = 30000) {');
      lines.push('    this.name = name;');
      lines.push('    this.state = "CLOSED";');
      lines.push('    this.failures = 0;');
      lines.push('    this.threshold = threshold;');
      lines.push('    this.resetTimeout = resetTimeout;');
      lines.push('    this.nextAttempt = 0;');
      lines.push('  }');
      lines.push('  async call(fn) {');
      lines.push('    if (this.state === "OPEN") {');
      lines.push('      if (Date.now() < this.nextAttempt) {');
      lines.push('        throw new Error(`Circuit breaker OPEN for ${this.name}`);');
      lines.push('      }');
      lines.push('      this.state = "HALF_OPEN";');
      lines.push('    }');
      lines.push('    try {');
      lines.push('      const result = await fn();');
      lines.push('      this.failures = 0;');
      lines.push('      this.state = "CLOSED";');
      lines.push('      return result;');
      lines.push('    } catch (err) {');
      lines.push('      this.failures++;');
      lines.push('      if (this.failures >= this.threshold) {');
      lines.push('        this.state = "OPEN";');
      lines.push('        this.nextAttempt = Date.now() + this.resetTimeout;');
      lines.push('      }');
      lines.push('      throw err;');
      lines.push('    }');
      lines.push('  }');
      lines.push('}');
      lines.push('');
      lines.push('async function __retryWithBackoff(fn, retries = 2, baseDelay = 100) {');
      lines.push('  for (let i = 0; i <= retries; i++) {');
      lines.push('    try { return await fn(); } catch (err) {');
      lines.push('      if (i === retries) throw err;');
      lines.push('      await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, i)));');
      lines.push('    }');
      lines.push('  }');
      lines.push('}');
      lines.push('');

      lines.push('// ── Peer Server RPC Proxies ──');
      for (const [peerName, peerFunctions] of peerBlocks) {
        const portVar = `PORT_${peerName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}`;
        const disc = discoverMap.get(peerName);
        const cbThreshold = disc && disc.config && disc.config.threshold ? this.genExpression(disc.config.threshold) : '5';
        const cbReset = disc && disc.config && disc.config.reset_timeout ? this.genExpression(disc.config.reset_timeout) : '30000';
        const rpcTimeout = disc && disc.config && disc.config.timeout ? this.genExpression(disc.config.timeout) : '10000';
        lines.push(`const __cb_${peerName} = new __CircuitBreaker("${peerName}", ${cbThreshold}, ${cbReset});`);

        let baseUrlExpr;
        if (disc) {
          baseUrlExpr = this.genExpression(disc.urlExpression);
        } else {
          baseUrlExpr = `(process.env.${portVar} ? \`http://localhost:\${process.env.${portVar}}\` : "http://localhost:3000")`;
        }

        lines.push(`const ${peerName} = {`);
        lines.push(`  __baseUrl: ${baseUrlExpr},`);
        for (const fnName of peerFunctions) {
          lines.push(`  async ${fnName}(...args) {`);
          lines.push(`    return __cb_${peerName}.call(() => __retryWithBackoff(async () => {`);
          lines.push(`      const __controller = new AbortController();`);
          lines.push(`      const __timeout = setTimeout(() => __controller.abort(), ${rpcTimeout});`);
          lines.push(`      try {`);
          lines.push(`        const __res = await fetch(\`\${${peerName}.__baseUrl}/rpc/${fnName}\`, {`);
          lines.push(`          method: 'POST',`);
          lines.push(`          headers: { 'Content-Type': 'application/json', 'X-Request-Id': __getRequestId() || '' },`);
          lines.push(`          body: JSON.stringify({ __args: args }),`);
          lines.push(`          signal: __controller.signal,`);
          lines.push(`        });`);
          lines.push(`        if (!__res.ok) throw new Error(\`RPC ${peerName}.${fnName} failed: \${__res.status}\`);`);
          lines.push(`        return (await __res.json()).result;`);
          lines.push(`      } catch (__err) {`);
          lines.push(`        if (__err.name === 'AbortError') throw new Error(\`RPC ${peerName}.${fnName} timed out\`);`);
          lines.push(`        throw __err;`);
          lines.push(`      } finally {`);
          lines.push(`        clearTimeout(__timeout);`);
          lines.push(`      }`);
          lines.push(`    }));`);
          lines.push(`  },`);
        }
        lines.push(`};`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 5. Runtime Helpers (respond, cookies)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Runtime Helpers ──');
    lines.push('function respond(status, body, headers = {}) {');
    lines.push('  const __hasContentType = Object.keys(headers).some(k => k.toLowerCase() === "content-type");');
    lines.push('  if (__hasContentType) {');
    lines.push('    const data = typeof body === "string" ? body : JSON.stringify(body);');
    lines.push('    return new Response(data, { status, headers });');
    lines.push('  }');
    lines.push('  return new Response(JSON.stringify(body), {');
    lines.push('    status,');
    lines.push('    headers: { "Content-Type": "application/json", ...headers },');
    lines.push('  });');
    lines.push('}');
    lines.push('');

    lines.push('function __parseQuery(searchParams) {');
    lines.push('  const q = {};');
    lines.push('  for (const [k, v] of searchParams) {');
    lines.push('    if (q[k] !== undefined) {');
    lines.push('      if (!Array.isArray(q[k])) q[k] = [q[k]];');
    lines.push('      q[k].push(v);');
    lines.push('    } else { q[k] = v; }');
    lines.push('  }');
    lines.push('  return q;');
    lines.push('}');
    lines.push('function __parseCookies(str) {');
    lines.push('  const c = {};');
    lines.push('  if (!str) return c;');
    lines.push('  for (const pair of str.split(";")) {');
    lines.push('    const [k, ...v] = pair.trim().split("=");');
    lines.push('    if (k) c[k.trim()] = v.join("=").trim();');
    lines.push('  }');
    lines.push('  return c;');
    lines.push('}');
    lines.push('');
    lines.push('async function __readBodyBytes(req) {');
    lines.push('  if (!req.body) return new Uint8Array(0);');
    lines.push('  const reader = req.body.getReader();');
    lines.push('  const chunks = [];');
    lines.push('  let totalBytes = 0;');
    lines.push('  while (true) {');
    lines.push('    const { done, value } = await reader.read();');
    lines.push('    if (done) break;');
    lines.push('    totalBytes += value.byteLength;');
    lines.push('    if (totalBytes > __maxBodySize) throw new Error("__BODY_TOO_LARGE__");');
    lines.push('    chunks.push(value);');
    lines.push('  }');
    lines.push('  const result = new Uint8Array(totalBytes);');
    lines.push('  let offset = 0;');
    lines.push('  for (const chunk of chunks) { result.set(chunk, offset); offset += chunk.byteLength; }');
    lines.push('  return result;');
    lines.push('}');
    lines.push('async function __parseBody(req) {');
    lines.push('  const ct = (req.headers.get("content-type") || "").toLowerCase();');
    lines.push('  if (ct.includes("multipart/form-data")) {');
    lines.push('    try {');
    lines.push('      const fd = await req.formData();');
    lines.push('      const obj = {};');
    lines.push('      for (const [k, v] of fd) {');
    lines.push('        if (obj[k] !== undefined) {');
    lines.push('          if (!Array.isArray(obj[k])) obj[k] = [obj[k]];');
    lines.push('          obj[k].push(v);');
    lines.push('        } else { obj[k] = v; }');
    lines.push('      }');
    lines.push('      return obj;');
    lines.push('    } catch { return null; }');
    lines.push('  }');
    lines.push('  const raw = await __readBodyBytes(req);');
    lines.push('  const text = new TextDecoder().decode(raw);');
    lines.push('  if (ct.includes("application/x-www-form-urlencoded")) {');
    lines.push('    try {');
    lines.push('      const sp = new URLSearchParams(text);');
    lines.push('      const obj = {};');
    lines.push('      for (const [k, v] of sp) {');
    lines.push('        if (obj[k] !== undefined) {');
    lines.push('          if (!Array.isArray(obj[k])) obj[k] = [obj[k]];');
    lines.push('          obj[k].push(v);');
    lines.push('        } else { obj[k] = v; }');
    lines.push('      }');
    lines.push('      return obj;');
    lines.push('    } catch { return null; }');
    lines.push('  }');
    lines.push('  try { return JSON.parse(text); } catch { return null; }');
    lines.push('}');

    // ════════════════════════════════════════════════════════════
    // 6. Response Helpers (F4) — redirect, set_cookie, stream
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Response Helpers ──');
    lines.push('function redirect(url, status = 302) {');
    lines.push('  return new Response(null, { status, headers: { Location: url } });');
    lines.push('}');
    lines.push('function set_cookie(name, value, options = {}) {');
    lines.push('  let cookie = `${name}=${encodeURIComponent(value)}`;');
    lines.push('  if (options.maxAge) cookie += `; Max-Age=${options.maxAge}`;');
    lines.push('  if (options.path) cookie += `; Path=${options.path}`;');
    lines.push('  if (options.domain) cookie += `; Domain=${options.domain}`;');
    lines.push('  if (options.httpOnly) cookie += "; HttpOnly";');
    lines.push('  if (options.secure) cookie += "; Secure";');
    lines.push('  if (options.sameSite) cookie += `; SameSite=${options.sameSite}`;');
    lines.push('  return cookie;');
    lines.push('}');
    lines.push('function stream(fn) {');
    lines.push('  const readable = new ReadableStream({');
    lines.push('    start(controller) {');
    lines.push('      const send = (data) => controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(data)}\\n\\n`));');
    lines.push('      const close = () => controller.close();');
    lines.push('      fn(send, close);');
    lines.push('    }');
    lines.push('  });');
    lines.push('  return new Response(readable, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });');
    lines.push('}');
    lines.push('function sse(fn) {');
    lines.push('  let cancelled = false;');
    lines.push('  const readable = new ReadableStream({');
    lines.push('    async start(controller) {');
    lines.push('      const send = (data, event) => {');
    lines.push('        if (cancelled) return;');
    lines.push('        let msg = "";');
    lines.push('        if (event) msg += `event: ${event}\\n`;');
    lines.push('        msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
    lines.push('        controller.enqueue(new TextEncoder().encode(msg));');
    lines.push('      };');
    lines.push('      const close = () => { cancelled = true; controller.close(); };');
    lines.push('      await fn(send, close);');
    lines.push('    },');
    lines.push('    cancel() { cancelled = true; }');
    lines.push('  });');
    lines.push('  return new Response(readable, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });');
    lines.push('}');
    lines.push('function html(body, status = 200, headers = {}) {');
    lines.push('  return new Response(body, { status, headers: { "Content-Type": "text/html", ...headers } });');
    lines.push('}');
    lines.push('function text(body, status = 200, headers = {}) {');
    lines.push('  return new Response(body, { status, headers: { "Content-Type": "text/plain", ...headers } });');
    lines.push('}');
    lines.push('function with_headers(response, headers) {');
    lines.push('  const h = new Headers(response.headers);');
    lines.push('  for (const [k, v] of Object.entries(headers)) h.set(k, v);');
    lines.push('  return new Response(response.body, { status: response.status, headers: h });');
    lines.push('}');
    lines.push('');

    // ── Auth Builtins: sign_jwt, hash_password, verify_password ──
    lines.push('// ── Auth Builtins ──');
    lines.push('let __jwtSignKey = null;');
    lines.push('async function sign_jwt(payload, secret, options = {}) {');
    lines.push('  const __secret = secret || (typeof __authSecret !== "undefined" ? __authSecret : "secret");');
    lines.push('  if (!__jwtSignKey || __secret !== (typeof __authSecret !== "undefined" ? __authSecret : "")) {');
    lines.push('    __jwtSignKey = await crypto.subtle.importKey(');
    lines.push('      "raw", new TextEncoder().encode(__secret),');
    lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign"]');
    lines.push('    );');
    lines.push('  }');
    lines.push('  const header = { alg: "HS256", typ: "JWT" };');
    lines.push('  const now = Math.floor(Date.now() / 1000);');
    lines.push('  const claims = { ...payload, iat: now };');
    lines.push('  if (options.expires_in) claims.exp = now + options.expires_in;');
    lines.push('  if (options.exp) claims.exp = options.exp;');
    lines.push('  const __b64url = (obj) => btoa(JSON.stringify(obj)).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
    lines.push('  const __headerB64 = __b64url(header);');
    lines.push('  const __payloadB64 = __b64url(claims);');
    lines.push('  const __sigData = __headerB64 + "." + __payloadB64;');
    lines.push('  const __sig = await crypto.subtle.sign("HMAC", __jwtSignKey, new TextEncoder().encode(__sigData));');
    lines.push('  const __sigB64 = btoa(String.fromCharCode(...new Uint8Array(__sig))).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
    lines.push('  return __sigData + "." + __sigB64;');
    lines.push('}');
    lines.push('');
    lines.push('async function hash_password(password) {');
    lines.push('  const salt = crypto.getRandomValues(new Uint8Array(16));');
    lines.push('  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]);');
    lines.push('  const hash = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, key, 256);');
    lines.push('  const saltHex = [...salt].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  const hashHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  return `pbkdf2:100000:${saltHex}:${hashHex}`;');
    lines.push('}');
    lines.push('');
    lines.push('async function verify_password(password, stored) {');
    lines.push('  const parts = stored.split(":");');
    lines.push('  if (parts[0] !== "pbkdf2" || parts.length !== 4) return false;');
    lines.push('  const iterations = parseInt(parts[1], 10);');
    lines.push('  const salt = new Uint8Array(parts[2].match(/.{2}/g).map(b => parseInt(b, 16)));');
    lines.push('  const expectedHash = parts[3];');
    lines.push('  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]);');
    lines.push('  const hash = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: "SHA-256" }, key, 256);');
    lines.push('  const hashHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  return hashHex === expectedHash;');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 7. Router
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Router ──');
    lines.push('const __routes = [];');
    lines.push('const __staticRoutes = new Map();');  // Fast lookup for static routes
    lines.push('function __addRoute(method, path, handler, version) {');
    lines.push('  const isStatic = !path.includes(":") && !path.includes("*");');
    lines.push('  if (isStatic) {');
    lines.push('    const key = method + " " + path;');
    lines.push('    __staticRoutes.set(key, { method, handler, _path: path, _version: version || null });');
    lines.push('  }');
    lines.push('  let pattern = path');
    lines.push('    .replace(/\\*([a-zA-Z_][a-zA-Z0-9_]*)/g, "(?<$1>.+)")');
    lines.push('    .replace(/\\*$/g, "(.*)")');
    lines.push('    .replace(/:([^/]+)/g, "(?<$1>[^/]+)");');
    lines.push('  __routes.push({ method, regex: new RegExp(`^${pattern}$`), handler, _path: path, _version: version || null, _isStatic: isStatic });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 8. CORS
    // ════════════════════════════════════════════════════════════
    if (corsConfig) {
      const origins = corsConfig.origins ? this.genExpression(corsConfig.origins) : '["*"]';
      const methods = corsConfig.methods ? this.genExpression(corsConfig.methods) : '["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]';
      const headers = corsConfig.headers ? this.genExpression(corsConfig.headers) : '["Content-Type", "Authorization"]';
      const credentials = corsConfig.credentials ? this.genExpression(corsConfig.credentials) : 'false';
      lines.push('// ── CORS ──');
      lines.push(`const __corsOrigins = ${origins};`);
      lines.push(`const __corsCredentials = ${credentials};`);
      lines.push('function __getCorsHeaders(req) {');
      lines.push('  const origin = req.headers.get("Origin") || "*";');
      lines.push('  const allowed = __corsOrigins.includes("*") || __corsOrigins.includes(origin);');
      lines.push('  const h = {');
      lines.push(`    "Access-Control-Allow-Origin": allowed ? (__corsCredentials ? origin : (origin === "*" ? "*" : origin)) : "",`);
      lines.push(`    "Access-Control-Allow-Methods": ${methods}.join(", "),`);
      lines.push(`    "Access-Control-Allow-Headers": ${headers}.join(", "),`);
      lines.push('  };');
      lines.push('  if (__corsCredentials) h["Access-Control-Allow-Credentials"] = "true";');
      lines.push('  return h;');
      lines.push('}');
    } else {
      lines.push('// ── CORS ──');
      lines.push('const __corsHeadersConst = Object.freeze({');
      lines.push('  "Access-Control-Allow-Origin": "*",');
      lines.push('  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",');
      lines.push('  "Access-Control-Allow-Headers": "Content-Type, Authorization",');
      lines.push('});');
      lines.push('function __getCorsHeaders() { return __corsHeadersConst; }');
    }
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 9. Auth (F1) — fixed JWT / API key
    // ════════════════════════════════════════════════════════════
    if (authConfig) {
      lines.push('// ── Auth ──');
      const authType = authConfig.type ? authConfig.type.value : 'jwt';

      if (authType === 'api_key') {
        const keysExpr = authConfig.keys ? this.genExpression(authConfig.keys) : '[]';
        const headerExpr = authConfig.header ? this.genExpression(authConfig.header) : '"X-API-Key"';
        lines.push(`const __validApiKeys = new Set(${keysExpr});`);
        lines.push(`const __apiKeyHeader = ${headerExpr};`);
        lines.push('function __authenticate(req) {');
        lines.push('  const key = req.headers.get(__apiKeyHeader);');
        lines.push('  if (!key || !__validApiKeys.has(key)) return null;');
        lines.push('  return { authenticated: true };');
        lines.push('}');
      } else {
        // JWT auth (default)
        const secretExpr = authConfig.secret ? this.genExpression(authConfig.secret) : '"secret"';
        lines.push(`const __authSecret = ${secretExpr};`);
        lines.push('let __authKey = null;');
        lines.push('async function __authenticate(req) {');
        lines.push('  const authHeader = req.headers.get("Authorization");');
        lines.push('  if (!authHeader || !authHeader.startsWith("Bearer ")) return null;');
        lines.push('  const token = authHeader.slice(7);');
        lines.push('  try {');
        lines.push('    const parts = token.split(".");');
        lines.push('    if (parts.length !== 3) return null;');
        lines.push('    if (!__authKey) {');
        lines.push('      __authKey = await crypto.subtle.importKey(');
        lines.push('        "raw", new TextEncoder().encode(__authSecret),');
        lines.push('        { name: "HMAC", hash: "SHA-256" }, false, ["sign"]');
        lines.push('      );');
        lines.push('    }');
        lines.push('    const __sigData = parts[0] + "." + parts[1];');
        lines.push('    const __sig = await crypto.subtle.sign("HMAC", __authKey, new TextEncoder().encode(__sigData));');
        lines.push('    const __expectedSig = btoa(String.fromCharCode(...new Uint8Array(__sig)))');
        lines.push('      .replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
        lines.push('    const __sigBuf = Buffer.from(__expectedSig);');
        lines.push('    const __tokBuf = Buffer.from(parts[2]);');
        lines.push('    if (__sigBuf.length !== __tokBuf.length || !require("crypto").timingSafeEqual(__sigBuf, __tokBuf)) return null;');
        lines.push('    const __payload = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));');
        lines.push('    if (__payload.exp && __payload.exp < Math.floor(Date.now() / 1000)) return null;');
        lines.push('    return __payload;');
        lines.push('  } catch { return null; }');
        lines.push('}');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 10. Max Body Size
    // ════════════════════════════════════════════════════════════
    if (maxBodyLimit) {
      lines.push('// ── Max Body Size ──');
      lines.push(`const __maxBodySize = ${this.genExpression(maxBodyLimit)};`);
      lines.push('');
    } else {
      lines.push('// ── Max Body Size ──');
      lines.push('const __maxBodySize = 1048576;');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11. Rate Limiting (F2) — store + checker
    // ════════════════════════════════════════════════════════════
    if (needsRateLimitStore) {
      lines.push('// ── Rate Limiting ──');
      if (rateLimitConfig) {
        const maxExpr = rateLimitConfig.max ? this.genExpression(rateLimitConfig.max) : '100';
        const windowExpr = rateLimitConfig.window ? this.genExpression(rateLimitConfig.window) : '60';
        lines.push(`const __rateLimitMax = ${maxExpr};`);
        lines.push(`const __rateLimitWindow = ${windowExpr};`);
      }
      lines.push('const __rateLimitStore = new Map();');
      lines.push('function __checkRateLimit(key, max, windowSec) {');
      lines.push('  const now = Date.now();');
      lines.push('  const windowMs = windowSec * 1000;');
      lines.push('  let entry = __rateLimitStore.get(key);');
      lines.push('  if (!entry) { entry = { timestamps: [] }; __rateLimitStore.set(key, entry); }');
      lines.push('  entry.timestamps = entry.timestamps.filter(t => now - t < windowMs);');
      lines.push('  if (entry.timestamps.length >= max) {');
      lines.push('    const retryAfter = Math.ceil((entry.timestamps[0] + windowMs - now) / 1000);');
      lines.push('    return { limited: true, retryAfter };');
      lines.push('  }');
      lines.push('  entry.timestamps.push(now);');
      lines.push('  return { limited: false };');
      lines.push('}');
      lines.push('setInterval(() => {');
      lines.push('  const now = Date.now();');
      lines.push('  for (const [key, entry] of __rateLimitStore) {');
      lines.push('    entry.timestamps = entry.timestamps.filter(t => now - t < 120000);');
      lines.push('    if (entry.timestamps.length === 0) __rateLimitStore.delete(key);');
      lines.push('  }');
      lines.push('}, 60000);');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11b. File Upload Helpers
    // ════════════════════════════════════════════════════════════
    if (uploadConfig || routes.some(r => (r.decorators || []).some(d => d.name === 'upload'))) {
      lines.push('// ── File Upload Helpers ──');
      const maxSizeExpr = uploadConfig && uploadConfig.max_size ? this.genExpression(uploadConfig.max_size) : '10485760';
      const allowedTypesExpr = uploadConfig && uploadConfig.allowed_types ? this.genExpression(uploadConfig.allowed_types) : '[]';
      lines.push(`const __uploadMaxSize = ${maxSizeExpr};`);
      lines.push(`const __uploadAllowedTypes = ${allowedTypesExpr};`);
      lines.push('function __validateFile(file, fieldName) {');
      lines.push('  if (!file || (typeof file !== "object") || typeof file.size !== "number") {');
      lines.push('    return { valid: false, error: `${fieldName}: not a valid file` };');
      lines.push('  }');
      lines.push('  if (file.size > __uploadMaxSize) {');
      lines.push('    return { valid: false, error: `${fieldName}: file too large (max ${__uploadMaxSize} bytes)` };');
      lines.push('  }');
      lines.push('  if (__uploadAllowedTypes.length > 0 && !__uploadAllowedTypes.includes(file.type)) {');
      lines.push('    return { valid: false, error: `${fieldName}: file type ${file.type} not allowed` };');
      lines.push('  }');
      lines.push('  return { valid: true };');
      lines.push('}');
      lines.push('async function save_file(file, dir) {');
      lines.push('  const fs = await import("node:fs/promises");');
      lines.push('  await fs.mkdir(dir, { recursive: true });');
      lines.push('  const name = file.name || "upload_" + Date.now();');
      lines.push('  const dest = dir + "/" + name;');
      lines.push('  await Bun.write(dest, file);');
      lines.push('  return dest;');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11c. Session Management
    // ════════════════════════════════════════════════════════════
    if (sessionConfig) {
      lines.push('// ── Session Management ──');
      const secretExpr = sessionConfig.secret ? this.genExpression(sessionConfig.secret) : '"tova-session-secret"';
      const maxAgeExpr = sessionConfig.max_age ? this.genExpression(sessionConfig.max_age) : '3600';
      const cookieNameExpr = sessionConfig.cookie_name ? this.genExpression(sessionConfig.cookie_name) : '"__sid"';
      lines.push(`const __sessionSecret = ${secretExpr};`);
      lines.push(`const __sessionMaxAge = ${maxAgeExpr};`);
      lines.push(`const __sessionCookieName = ${cookieNameExpr};`);
      lines.push('let __sessionKey = null;');
      lines.push('async function __getSessionKey() {');
      lines.push('  if (!__sessionKey) {');
      lines.push('    __sessionKey = await crypto.subtle.importKey(');
      lines.push('      "raw", new TextEncoder().encode(__sessionSecret),');
      lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]');
      lines.push('    );');
      lines.push('  }');
      lines.push('  return __sessionKey;');
      lines.push('}');
      lines.push('async function __signSessionId(id) {');
      lines.push('  const key = await __getSessionKey();');
      lines.push('  const sig = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(id));');
      lines.push('  const b64 = btoa(String.fromCharCode(...new Uint8Array(sig))).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
      lines.push('  return id + "." + b64;');
      lines.push('}');
      lines.push('async function __verifySessionId(signed) {');
      lines.push('  const dot = signed.lastIndexOf(".");');
      lines.push('  if (dot === -1) return null;');
      lines.push('  const id = signed.slice(0, dot);');
      lines.push('  const expected = await __signSessionId(id);');
      lines.push('  const __eBuf = new TextEncoder().encode(expected);');
      lines.push('  const __sBuf = new TextEncoder().encode(signed);');
      lines.push('  if (__eBuf.length !== __sBuf.length) return null;');
      lines.push('  let __m = 0;');
      lines.push('  for (let i = 0; i < __eBuf.length; i++) __m |= __eBuf[i] ^ __sBuf[i];');
      lines.push('  return __m === 0 ? id : null;');
      lines.push('}');

      // Use SQLite-backed sessions when db is available
      if (dbConfig || usesDb) {
        lines.push('// SQLite-backed session store');
        lines.push('__db.exec(`CREATE TABLE IF NOT EXISTS __sessions (');
        lines.push("  id TEXT PRIMARY KEY, data TEXT NOT NULL DEFAULT '{}', created_at INTEGER NOT NULL, updated_at INTEGER NOT NULL");
        lines.push(')`);');
        lines.push('const __sessionStmts = {');
        lines.push('  get: __db.prepare("SELECT data, created_at FROM __sessions WHERE id = ? AND created_at > ?"),');
        lines.push('  upsert: __db.prepare("INSERT INTO __sessions (id, data, created_at, updated_at) VALUES (?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET data = excluded.data, updated_at = excluded.updated_at"),');
        lines.push('  del: __db.prepare("DELETE FROM __sessions WHERE id = ?"),');
        lines.push('  cleanup: __db.prepare("DELETE FROM __sessions WHERE created_at <= ?"),');
        lines.push('};');
        lines.push('function __createSession(id) {');
        lines.push('  const cutoff = Date.now() - __sessionMaxAge * 1000;');
        lines.push('  const row = __sessionStmts.get.get(id, cutoff);');
        lines.push('  let __data = row ? JSON.parse(row.data) : {};');
        lines.push('  let __dirty = !row;');
        lines.push('  return {');
        lines.push('    get(key) { return __data[key]; },');
        lines.push('    set(key, value) { __data[key] = value; __dirty = true; },');
        lines.push('    delete(key) { delete __data[key]; __dirty = true; },');
        lines.push('    destroy() { __sessionStmts.del.run(id); __data = {}; },');
        lines.push('    get data() { return { ...__data }; },');
        lines.push('    __flush() { if (__dirty) { const now = Date.now(); __sessionStmts.upsert.run(id, JSON.stringify(__data), now, now); __dirty = false; } },');
        lines.push('  };');
        lines.push('}');
        lines.push('setInterval(() => {');
        lines.push('  const cutoff = Date.now() - __sessionMaxAge * 1000;');
        lines.push('  __sessionStmts.cleanup.run(cutoff);');
        lines.push('}, 60000);');
      } else {
        lines.push('// In-memory session store');
        lines.push('const __sessionStore = new Map();');
        lines.push('function __createSession(id) {');
        lines.push('  if (!__sessionStore.has(id)) {');
        lines.push('    __sessionStore.set(id, { data: {}, createdAt: Date.now() });');
        lines.push('  }');
        lines.push('  const entry = __sessionStore.get(id);');
        lines.push('  return {');
        lines.push('    get(key) { return entry.data[key]; },');
        lines.push('    set(key, value) { entry.data[key] = value; },');
        lines.push('    delete(key) { delete entry.data[key]; },');
        lines.push('    destroy() { __sessionStore.delete(id); },');
        lines.push('    get data() { return { ...entry.data }; },');
        lines.push('    __flush() {},');
        lines.push('  };');
        lines.push('}');
        lines.push('setInterval(() => {');
        lines.push('  const now = Date.now();');
        lines.push('  for (const [id, entry] of __sessionStore) {');
        lines.push('    if (now - entry.createdAt > __sessionMaxAge * 1000) __sessionStore.delete(id);');
        lines.push('  }');
        lines.push('}, 60000);');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12. Event Bus (F5) — if subscriptions exist
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0) {
      lines.push('// ── Event Bus ──');
      lines.push('const __eventBus = new Map();');
      lines.push('function __subscribe(event, handler) {');
      lines.push('  if (!__eventBus.has(event)) __eventBus.set(event, []);');
      lines.push('  __eventBus.get(event).push(handler);');
      lines.push('}');
      lines.push('async function publish(event, data) {');
      lines.push('  const handlers = __eventBus.get(event) || [];');
      lines.push('  await Promise.all(handlers.map(h => h(data)));');
      if (peerBlocks && peerBlocks.size > 0) {
        lines.push('  const __peerUrls = [');
        for (const [peerName] of peerBlocks) {
          lines.push(`    ${peerName}.__baseUrl,`);
        }
        lines.push('  ];');
        lines.push('  for (const __peerUrl of __peerUrls) {');
        lines.push('    try {');
        lines.push('      await fetch(`${__peerUrl}/rpc/__event`, {');
        lines.push('        method: "POST",');
        lines.push('        headers: { "Content-Type": "application/json" },');
        lines.push('        body: JSON.stringify({ event, data }),');
        lines.push('      });');
        lines.push('    } catch {}');
        lines.push('  }');
      }
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12b. Background Jobs
    // ════════════════════════════════════════════════════════════
    if (backgroundJobs.length > 0) {
      lines.push('// ── Background Jobs ──');
      lines.push('const __jobQueue = [];');
      lines.push('let __jobProcessing = false;');
      lines.push('async function __processJobQueue() {');
      lines.push('  if (__jobProcessing) return;');
      lines.push('  __jobProcessing = true;');
      lines.push('  while (__jobQueue.length > 0) {');
      lines.push('    const job = __jobQueue.shift();');
      lines.push('    try { await job.fn(...job.args); } catch (err) {');
      lines.push('      __log("error", `Background job ${job.name} failed`, { error: err.message });');
      lines.push('      if (job.retries > 0) {');
      lines.push('        job.retries--;');
      lines.push('        __jobQueue.push(job);');
      lines.push('      }');
      lines.push('    }');
      lines.push('  }');
      lines.push('  __jobProcessing = false;');
      lines.push('}');
      for (const job of backgroundJobs) {
        const fnName = job.name;
        const params = job.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of job.params) this.declareVar(p.name);
        const body = this.genBlockBody(job.body);
        this.popScope();
        lines.push(`async function __bg_${fnName}(${params}) {`);
        lines.push(body);
        lines.push('}');
      }
      lines.push('function spawn_job(name, ...args) {');
      lines.push('  const __jobFns = {');
      for (const job of backgroundJobs) {
        lines.push(`    "${job.name}": __bg_${job.name},`);
      }
      lines.push('  };');
      lines.push('  const fn = __jobFns[name];');
      lines.push('  if (!fn) throw new Error(`Unknown background job: ${name}`);');
      lines.push('  __jobQueue.push({ name, fn, args, retries: 2 });');
      lines.push('  setTimeout(__processJobQueue, 0);');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12c. Response Compression
    // ════════════════════════════════════════════════════════════
    if (compressionConfig) {
      const minSizeExpr = compressionConfig.min_size ? this.genExpression(compressionConfig.min_size) : '1024';
      lines.push('// ── Compression ──');
      lines.push(`const __compressionMinSize = ${minSizeExpr};`);
      lines.push('async function __compressResponse(req, res) {');
      lines.push('  const accept = req.headers.get("Accept-Encoding") || "";');
      lines.push('  const ct = res.headers.get("Content-Type") || "";');
      lines.push('  if (!ct.match(/text|json|javascript|xml|svg/)) return res;');
      lines.push('  const body = await res.arrayBuffer();');
      lines.push('  if (body.byteLength < __compressionMinSize) {');
      lines.push('    return new Response(body, { status: res.status, headers: res.headers });');
      lines.push('  }');
      lines.push('  const h = new Headers(res.headers);');
      lines.push('  if (accept.includes("gzip")) {');
      lines.push('    const compressed = Bun.gzipSync(new Uint8Array(body));');
      lines.push('    h.set("Content-Encoding", "gzip");');
      lines.push('    h.set("Content-Length", String(compressed.length));');
      lines.push('    return new Response(compressed, { status: res.status, headers: h });');
      lines.push('  }');
      lines.push('  if (accept.includes("deflate")) {');
      lines.push('    const compressed = Bun.deflateSync(new Uint8Array(body));');
      lines.push('    h.set("Content-Encoding", "deflate");');
      lines.push('    h.set("Content-Length", String(compressed.length));');
      lines.push('    return new Response(compressed, { status: res.status, headers: h });');
      lines.push('  }');
      lines.push('  return new Response(body, { status: res.status, headers: res.headers });');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12d. Response Caching Helpers
    // ════════════════════════════════════════════════════════════
    if (cacheConfig) {
      const maxAgeExpr = cacheConfig.max_age ? this.genExpression(cacheConfig.max_age) : '0';
      const staleExpr = cacheConfig.stale_while_revalidate ? this.genExpression(cacheConfig.stale_while_revalidate) : '0';
      lines.push('// ── Cache Helpers ──');
      lines.push(`const __cacheMaxAge = ${maxAgeExpr};`);
      lines.push(`const __cacheStale = ${staleExpr};`);
      lines.push('');
    }
    // Always emit cache helpers
    lines.push('function cache_control(res, maxAge, options = {}) {');
    lines.push('  const h = new Headers(res.headers);');
    lines.push('  let directive = options.private ? "private" : "public";');
    lines.push('  directive += `, max-age=${maxAge}`;');
    lines.push('  if (options.stale_while_revalidate) directive += `, stale-while-revalidate=${options.stale_while_revalidate}`;');
    lines.push('  if (options.no_cache) directive = "no-cache";');
    lines.push('  if (options.no_store) directive = "no-store";');
    lines.push('  h.set("Cache-Control", directive);');
    lines.push('  return new Response(res.body, { status: res.status, headers: h });');
    lines.push('}');
    lines.push('function etag(res, tag) {');
    lines.push('  const h = new Headers(res.headers);');
    lines.push('  h.set("ETag", `"${tag}"`);');
    lines.push('  return new Response(res.body, { status: res.status, headers: h });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12e. Model / ORM Layer — auto-generate CRUD from shared types
    // ════════════════════════════════════════════════════════════
    if (modelDecls.length > 0 && (dbConfig || usesDb)) {
      lines.push('// ── Model / ORM Layer ──');
      const isAsync = dbDriver !== 'sqlite';
      const aw = isAsync ? 'await ' : '';
      for (const modelDecl of modelDecls) {
        const typeName = modelDecl.name;
        let typeInfo = sharedTypes.get(typeName);
        // Fall back to model declaration fields if shared type not in this file (multi-file)
        if (!typeInfo && modelDecl.config) {
          const fields = [{ name: 'id', type: 'Int' }];
          for (const [key, value] of Object.entries(modelDecl.config)) {
            if (key === 'table' || key === 'timestamps' || key === 'belongs_to' || key === 'has_many') continue;
            const fieldType = value.name || (value.type === 'ArrayTypeAnnotation' ? 'Array' : 'Any');
            fields.push({ name: key, type: fieldType });
          }
          if (fields.length > 0) typeInfo = { fields };
        }
        if (!typeInfo) continue;
        const tableName = modelDecl.config && modelDecl.config.table
          ? this.genExpression(modelDecl.config.table).replace(/"/g, '')
          : typeName.toLowerCase() + 's';
        const hasTimestamps = modelDecl.config && modelDecl.config.timestamps;
        const fields = typeInfo.fields;
        const fieldNames = fields.map(f => f.name);
        const hasId = fieldNames.includes('id');

        // Extract relations from config
        const belongsToNames = [];
        const hasManyNames = [];
        if (modelDecl.config) {
          const extractRelNames = (val) => {
            if (!val) return [];
            if (val.type === 'Identifier') return [val.name];
            if (val.type === 'ArrayLiteral') return val.elements.filter(e => e.type === 'Identifier').map(e => e.name);
            return [];
          };
          belongsToNames.push(...extractRelNames(modelDecl.config.belongs_to));
          hasManyNames.push(...extractRelNames(modelDecl.config.has_many));
        }

        // Map Tova types to SQL types
        const sqlType = (tovaType) => {
          if (dbDriver === 'postgres') {
            switch (tovaType) {
              case 'Int': return 'INTEGER';
              case 'Float': return 'DOUBLE PRECISION';
              case 'Bool': return 'BOOLEAN';
              case 'String': return 'TEXT';
              default: return 'TEXT';
            }
          }
          switch (tovaType) {
            case 'Int': return 'INTEGER';
            case 'Float': return 'REAL';
            case 'Bool': return 'INTEGER';
            case 'String': return 'TEXT';
            default: return 'TEXT';
          }
        };

        // Generate CREATE TABLE
        const colDefs = [];
        for (const f of fields) {
          if (f.name === 'id') {
            if (dbDriver === 'postgres') {
              colDefs.push('id SERIAL PRIMARY KEY');
            } else {
              colDefs.push('id INTEGER PRIMARY KEY AUTOINCREMENT');
            }
          } else {
            colDefs.push(`${f.name} ${sqlType(f.type)}`);
          }
        }
        // Add FK columns for belongs_to relations
        for (const parentName of belongsToNames) {
          const fkCol = parentName.toLowerCase() + '_id';
          if (!fieldNames.includes(fkCol)) {
            const parentTable = parentName.toLowerCase() + 's';
            colDefs.push(`${fkCol} INTEGER REFERENCES ${parentTable}(id)`);
          }
        }
        if (hasTimestamps) {
          colDefs.push('created_at TEXT DEFAULT (datetime(\'now\'))');
          colDefs.push('updated_at TEXT DEFAULT (datetime(\'now\'))');
        }

        const placeholder = dbDriver === 'postgres' ? (i) => `$${i}` : () => '?';
        const insertFields = fields.filter(f => f.name !== 'id');
        const insertCols = insertFields.map(f => f.name).join(', ');
        const insertPlaceholders = insertFields.map((_, i) => placeholder(i + 1)).join(', ');
        const updateSets = insertFields.map((f, i) => `${f.name} = ${placeholder(i + 1)}`).join(', ');
        const returningClause = dbDriver === 'postgres' ? ' RETURNING *' : '';

        lines.push(`// Model: ${typeName} -> ${tableName}`);
        lines.push(`${aw}db.exec(\`CREATE TABLE IF NOT EXISTS ${tableName} (${colDefs.join(', ')})\`);`);
        lines.push('');

        // Embed valid column whitelist for SQL injection prevention
        const allColNames = [...fieldNames];
        for (const parentName of belongsToNames) {
          const fkCol = parentName.toLowerCase() + '_id';
          if (!allColNames.includes(fkCol)) allColNames.push(fkCol);
        }
        if (hasTimestamps) {
          allColNames.push('created_at', 'updated_at');
        }
        const colWhitelistJson = JSON.stringify(allColNames);

        // Generate the model object
        lines.push(`const ${typeName}Model = {`);
        lines.push(`  __validCols: new Set(${colWhitelistJson}),`);
        lines.push(`  __assertCols(keys) {`);
        lines.push(`    for (const k of keys) {`);
        lines.push(`      if (!this.__validCols.has(k)) throw new Error(\`Invalid column: \${k}\`);`);
        lines.push(`    }`);
        lines.push(`  },`);

        // find(id)
        lines.push(`  ${isAsync ? 'async ' : ''}find(id) {`);
        lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ${placeholder(1)}", id);`);
        lines.push('  },');

        // all()
        lines.push(`  ${isAsync ? 'async ' : ''}all() {`);
        lines.push(`    return ${aw}db.query("SELECT * FROM ${tableName}");`);
        lines.push('  },');

        // where(conditions)
        lines.push(`  ${isAsync ? 'async ' : ''}where(conditions) {`);
        lines.push('    const keys = Object.keys(conditions);');
        lines.push('    this.__assertCols(keys);');
        lines.push('    const vals = Object.values(conditions);');
        if (dbDriver === 'postgres') {
          lines.push('    const clauses = keys.map((k, i) => `${k} = $${i + 1}`).join(" AND ");');
        } else {
          lines.push('    const clauses = keys.map(k => `${k} = ?`).join(" AND ");');
        }
        lines.push(`    return ${aw}db.query(\`SELECT * FROM ${tableName} WHERE \${clauses}\`, ...vals);`);
        lines.push('  },');

        // create(data)
        lines.push(`  ${isAsync ? 'async ' : ''}create(data) {`);
        lines.push(`    const cols = Object.keys(data).filter(k => k !== 'id');`);
        lines.push('    this.__assertCols(cols);');
        lines.push(`    const vals = cols.map(k => data[k]);`);
        if (dbDriver === 'postgres') {
          lines.push('    const placeholders = cols.map((_, i) => `$${i + 1}`).join(", ");');
          lines.push(`    const rows = ${aw}db.query(\`INSERT INTO ${tableName} (\${cols.join(", ")}) VALUES (\${placeholders}) RETURNING *\`, ...vals);`);
          lines.push('    return rows[0];');
        } else {
          lines.push('    const placeholders = cols.map(() => "?").join(", ");');
          lines.push(`    const result = ${aw}db.run(\`INSERT INTO ${tableName} (\${cols.join(", ")}) VALUES (\${placeholders})\`, ...vals);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", result.lastInsertRowid);`);
        }
        lines.push('  },');

        // update(id, data)
        lines.push(`  ${isAsync ? 'async ' : ''}update(id, data) {`);
        lines.push(`    const cols = Object.keys(data).filter(k => k !== 'id');`);
        lines.push('    this.__assertCols(cols);');
        lines.push(`    const vals = cols.map(k => data[k]);`);
        if (dbDriver === 'postgres') {
          lines.push('    const sets = cols.map((k, i) => `${k} = $${i + 1}`).join(", ");');
          lines.push(`    const rows = ${aw}db.query(\`UPDATE ${tableName} SET \${sets} WHERE id = $\${cols.length + 1} RETURNING *\`, ...vals, id);`);
          lines.push('    return rows[0];');
        } else {
          lines.push('    const sets = cols.map(k => `${k} = ?`).join(", ");');
          lines.push(`    ${aw}db.run(\`UPDATE ${tableName} SET \${sets} WHERE id = ?\`, ...vals, id);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", id);`);
        }
        lines.push('  },');

        // delete(id)
        lines.push(`  ${isAsync ? 'async ' : ''}delete(id) {`);
        lines.push(`    return ${aw}db.run("DELETE FROM ${tableName} WHERE id = ${placeholder(1)}", id);`);
        lines.push('  },');

        // count()
        lines.push(`  ${isAsync ? 'async ' : ''}count(conditions) {`);
        lines.push('    if (!conditions) {');
        lines.push(`      const row = ${aw}db.get("SELECT COUNT(*) as count FROM ${tableName}");`);
        lines.push('      return row ? row.count : 0;');
        lines.push('    }');
        lines.push('    const keys = Object.keys(conditions);');
        lines.push('    this.__assertCols(keys);');
        lines.push('    const vals = Object.values(conditions);');
        if (dbDriver === 'postgres') {
          lines.push('    const clauses = keys.map((k, i) => `${k} = $${i + 1}`).join(" AND ");');
        } else {
          lines.push('    const clauses = keys.map(k => `${k} = ?`).join(" AND ");');
        }
        lines.push(`    const row = ${aw}db.get(\`SELECT COUNT(*) as count FROM ${tableName} WHERE \${clauses}\`, ...vals);`);
        lines.push('    return row ? row.count : 0;');
        lines.push('  },');

        // belongs_to accessors: PostModel.user(user_id) → single parent record
        for (const parentName of belongsToNames) {
          const parentTable = parentName.toLowerCase() + 's';
          const accessorName = parentName.toLowerCase();
          lines.push(`  ${isAsync ? 'async ' : ''}${accessorName}(${accessorName}_id) {`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${parentTable} WHERE id = ${placeholder(1)}", ${accessorName}_id);`);
          lines.push('  },');
        }

        // has_many accessors: UserModel.posts(id) → array of child records
        for (const childName of hasManyNames) {
          const childTable = childName.toLowerCase() + 's';
          const accessorName = childName.toLowerCase() + 's';
          const fkCol = typeName.toLowerCase() + '_id';
          lines.push(`  ${isAsync ? 'async ' : ''}${accessorName}(id) {`);
          lines.push(`    return ${aw}db.query("SELECT * FROM ${childTable} WHERE ${fkCol} = ${placeholder(1)}", id);`);
          lines.push('  },');
        }

        lines.push('};');
        // Alias so server functions can reference the model by its original type name
        // Use var so it works both when Task is already declared (single-file shared block)
        // and when it isn't (multi-file: server in separate file from shared types)
        lines.push(`var ${typeName} = ${typeName}Model;`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 12f. SSE (Server-Sent Events) Support
    // ════════════════════════════════════════════════════════════
    if (sseDecls.length > 0) {
      lines.push('// ── SSE (Server-Sent Events) ──');
      lines.push('class __SSEChannel {');
      lines.push('  constructor() { this.clients = new Set(); }');
      lines.push('  subscribe(controller) { this.clients.add(controller); }');
      lines.push('  unsubscribe(controller) { this.clients.delete(controller); }');
      lines.push('  send(data, event = null) {');
      lines.push('    let msg = "";');
      lines.push('    if (event) msg += `event: ${event}\\n`;');
      lines.push('    msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
      lines.push('    const encoded = new TextEncoder().encode(msg);');
      lines.push('    for (const c of this.clients) { try { c.enqueue(encoded); } catch { this.clients.delete(c); } }');
      lines.push('  }');
      lines.push('  get count() { return this.clients.size; }');
      lines.push('}');
      lines.push('const __sseChannels = new Map();');
      lines.push('function sse_channel(name) {');
      lines.push('  if (!__sseChannels.has(name)) __sseChannels.set(name, new __SSEChannel());');
      lines.push('  return __sseChannels.get(name);');
      lines.push('}');
      lines.push('');

      for (const sse of sseDecls) {
        const params = sse.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sse.params) this.declareVar(p.name);
        const body = this.genBlockBody(sse.body);
        this.popScope();

        lines.push(`__addRoute("GET", ${JSON.stringify(sse.path)}, async (req) => {`);
        lines.push('  const stream = new ReadableStream({');
        lines.push(`    start(controller) {`);
        lines.push('      const send = (data, event) => {');
        lines.push('        let msg = "";');
        lines.push('        if (event) msg += `event: ${event}\\n`;');
        lines.push('        msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
        lines.push('        controller.enqueue(new TextEncoder().encode(msg));');
        lines.push('      };');
        lines.push('      const close = () => controller.close();');
        lines.push(`      (async (${params || 'send, close'}) => {`);
        lines.push(body);
        lines.push(`      })(${params || 'send, close'});`);
        lines.push('    }');
        lines.push('  });');
        lines.push('  return new Response(stream, {');
        lines.push('    headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" }');
        lines.push('  });');
        lines.push('});');
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 12g. Content Negotiation Helper
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Content Negotiation ──');
    lines.push('function negotiate(req, data, options = {}) {');
    lines.push('  const accept = (req.headers.get("Accept") || "application/json").toLowerCase();');
    lines.push('  if (accept.includes("text/html") && options.html) {');
    lines.push('    const body = typeof options.html === "function" ? options.html(data) : options.html;');
    lines.push('    return new Response(body, { status: options.status || 200, headers: { "Content-Type": "text/html" } });');
    lines.push('  }');
    lines.push('  if (accept.includes("text/xml") || accept.includes("application/xml")) {');
    lines.push('    if (options.xml) {');
    lines.push('      const body = typeof options.xml === "function" ? options.xml(data) : options.xml;');
    lines.push('      return new Response(body, { status: options.status || 200, headers: { "Content-Type": "application/xml" } });');
    lines.push('    }');
    lines.push('  }');
    lines.push('  if (accept.includes("text/plain")) {');
    lines.push('    const body = typeof data === "string" ? data : JSON.stringify(data, null, 2);');
    lines.push('    return new Response(body, { status: options.status || 200, headers: { "Content-Type": "text/plain" } });');
    lines.push('  }');
    lines.push('  return Response.json(data, { status: options.status || 200 });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12h. Race Condition Protection — Async Mutex for shared state
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Async Mutex ──');
    lines.push('class __Mutex {');
    lines.push('  constructor() { this._queue = []; this._locked = false; }');
    lines.push('  async acquire() {');
    lines.push('    if (!this._locked) { this._locked = true; return; }');
    lines.push('    return new Promise(resolve => this._queue.push(resolve));');
    lines.push('  }');
    lines.push('  release() {');
    lines.push('    if (this._queue.length > 0) { this._queue.shift()(); }');
    lines.push('    else { this._locked = false; }');
    lines.push('  }');
    lines.push('}');
    lines.push('const __mutex = new __Mutex();');
    lines.push('async function withLock(fn) {');
    lines.push('  await __mutex.acquire();');
    lines.push('  try { return await fn(); } finally { __mutex.release(); }');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 13. Other statements + Server Functions
    // ════════════════════════════════════════════════════════════
    for (const stmt of otherStatements) {
      lines.push(this.generateStatement(stmt));
    }

    if (functions.length > 0) {
      lines.push('// ── Server Functions ──');
      for (const fn of functions) {
        lines.push(this.generateStatement(fn));
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 14. Subscribe registrations (F5)
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0) {
      lines.push('// ── Event Subscriptions ──');
      for (const sub of subscriptions) {
        const params = sub.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sub.params) this.declareVar(p.name);
        const body = this.genBlockBody(sub.body);
        this.popScope();
        lines.push(`__subscribe(${JSON.stringify(sub.event)}, async (${params}) => {`);
        lines.push(body);
        lines.push('});');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 15. Middleware, Error handler, Health check, RPC endpoints
    // ════════════════════════════════════════════════════════════
    if (middlewares.length > 0) {
      lines.push('// ── Middleware ──');
      for (const mw of middlewares) {
        const params = mw.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of mw.params) this.declareVar(p.name);
        const body = this.genBlockBody(mw.body);
        this.popScope();
        lines.push(`async function ${mw.name}(${params}) {`);
        lines.push(body);
        lines.push('}');
        lines.push('');
      }
    }

    if (errorHandler) {
      const params = errorHandler.params.map(p => p.name).join(', ');
      this.pushScope();
      for (const p of errorHandler.params) this.declareVar(p.name);
      const body = this.genBlockBody(errorHandler.body);
      this.popScope();
      lines.push('// ── Error Handler ──');
      lines.push(`async function __errorHandler(${params}) {`);
      lines.push(body);
      lines.push('}');
      lines.push('');
    }

    if (healthPath) {
      lines.push('// ── Health Check ──');
      lines.push(`__addRoute("GET", ${JSON.stringify(healthPath)}, async () => {`);
      lines.push('  return Response.json({ status: "ok", uptime: process.uptime() });');
      lines.push('});');
      lines.push('');
    }

    // RPC Endpoints (auto-wired)
    if (functions.length > 0) {
      lines.push('// ── RPC Endpoints ──');
      for (const fn of functions) {
        const name = fn.name;
        const paramNames = fn.params.map(p => p.name);
        lines.push(`__addRoute("POST", "/rpc/${name}", async (req) => {`);
        lines.push(`  const body = await req.json();`);
        if (paramNames.length > 0) {
          for (let pi = 0; pi < paramNames.length; pi++) {
            lines.push(`  const ${paramNames[pi]} = body.__args ? body.__args[${pi}] : body.${paramNames[pi]};`);
          }
          const validationChecks = this._genValidationCode(fn.params);
          if (validationChecks.length > 0) {
            lines.push(`  const __validationErrors = [];`);
            for (const check of validationChecks) {
              lines.push(check);
            }
            lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
          }
          lines.push(`  const result = await ${name}(${paramNames.join(', ')});`);
        } else {
          lines.push(`  const result = await ${name}();`);
        }
        lines.push(`  return Response.json({ result });`);
        lines.push(`});`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 16. Event RPC endpoint (F5) — if multi-server + subscriptions
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0 && peerBlocks && peerBlocks.size > 0) {
      lines.push('// ── Event RPC Endpoint ──');
      lines.push('__addRoute("POST", "/rpc/__event", async (req) => {');
      lines.push('  const { event, data } = await req.json();');
      lines.push('  const handlers = __eventBus.get(event) || [];');
      lines.push('  await Promise.all(handlers.map(h => h(data)));');
      lines.push('  return Response.json({ ok: true });');
      lines.push('});');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 17. Explicit Routes — with timeout (F7) + per-route rate_limit (F2)
    // ════════════════════════════════════════════════════════════
    if (routes.length > 0) {
      // Sort routes by specificity: static > :param > *wildcard, longer paths first
      const segWeight = (seg) => {
        if (seg.startsWith('*')) return 2; // wildcard — least specific
        if (seg.startsWith(':')) return 1; // param
        return 0; // static — most specific
      };
      routes.sort((a, b) => {
        const segsA = a.path.split('/').filter(Boolean);
        const segsB = b.path.split('/').filter(Boolean);
        // More segments = more specific (but wildcards are inherently less specific)
        const aHasWild = segsA.some(s => s.startsWith('*'));
        const bHasWild = segsB.some(s => s.startsWith('*'));
        if (aHasWild !== bHasWild) return aHasWild ? 1 : -1;
        if (segsA.length !== segsB.length) return segsB.length - segsA.length;
        // Compare segment by segment: static beats dynamic beats wildcard
        for (let i = 0; i < Math.min(segsA.length, segsB.length); i++) {
          const wa = segWeight(segsA[i]);
          const wb = segWeight(segsB[i]);
          if (wa !== wb) return wa - wb;
        }
        // Stable sort: same path, order by method (deterministic)
        const methodOrder = { HEAD: 0, GET: 1, POST: 2, PUT: 3, PATCH: 4, DELETE: 5, OPTIONS: 6 };
        return (methodOrder[a.method.toUpperCase()] || 9) - (methodOrder[b.method.toUpperCase()] || 9);
      });
      lines.push('// ── Routes ──');
      for (const route of routes) {
        const method = route.method.toUpperCase();
        const path = route.path;
        const handlerRaw = this.genExpression(route.handler);
        // Wrap inline lambda handlers in parens so they can be called as IIFEs
        const handlerIsInline = route.handler.type !== 'Identifier';
        const handler = handlerIsInline ? `(${handlerRaw})` : handlerRaw;

        const handlerName = route.handler.type === 'Identifier' ? route.handler.name : null;
        const handlerParams = handlerName ? fnParamMap.get(handlerName) : null;
        const handlerDecl = handlerName ? fnDeclMap.get(handlerName) : null;

        const decorators = route.decorators || [];
        const groupMws = route._groupMiddlewares || [];
        const hasAuth = decorators.some(d => d.name === 'auth');
        const roleDecorator = decorators.find(d => d.name === 'role');
        const rateLimitDec = decorators.find(d => d.name === 'rate_limit');
        const timeoutDec = decorators.find(d => d.name === 'timeout');
        const timeoutMs = timeoutDec && timeoutDec.args[0] ? this.genExpression(timeoutDec.args[0]) : null;
        const validateDec = decorators.find(d => d.name === 'validate');
        const uploadDec = decorators.find(d => d.name === 'upload');

        // T9-5: Version info for route
        const routeVersion = route._version;
        const versionArg = routeVersion ? `, ${JSON.stringify(String(routeVersion.version || ''))}` : '';

        lines.push(`__addRoute(${JSON.stringify(method)}, ${JSON.stringify(path)}, async (req, params) => {`);

        // Auth decorator check
        if (hasAuth && authConfig) {
          lines.push(`  const __user = await __authenticate(req);`);
          lines.push(`  if (!__user) return Response.json({ error: "Unauthorized" }, { status: 401 });`);
          if (roleDecorator && roleDecorator.args.length > 0) {
            const roleExpr = this.genExpression(roleDecorator.args[0]);
            lines.push(`  if (__user.role !== ${roleExpr}) return Response.json({ error: "Forbidden" }, { status: 403 });`);
          }
        }

        // Per-route rate limit check
        if (rateLimitDec && needsRateLimitStore) {
          const rlMax = rateLimitDec.args[0] ? this.genExpression(rateLimitDec.args[0]) : '100';
          const rlWindow = rateLimitDec.args[1] ? this.genExpression(rateLimitDec.args[1]) : '60';
          lines.push(`  const __rlIp = req.headers.get("x-forwarded-for") || "unknown";`);
          lines.push(`  const __rlRoute = __checkRateLimit(\`route:${path}:\${__rlIp}\`, ${rlMax}, ${rlWindow});`);
          lines.push(`  if (__rlRoute.limited) return Response.json({ error: "Too Many Requests" }, { status: 429, headers: { "Retry-After": String(__rlRoute.retryAfter) } });`);
        }

        // Upload decorator — parse multipart body, validate file field
        if (uploadDec) {
          const fieldExpr = uploadDec.args[0] ? this.genExpression(uploadDec.args[0]) : '"file"';
          lines.push(`  const __body = (await __parseBody(req)) || {};`);
          lines.push(`  const __uploadField = ${fieldExpr};`);
          lines.push(`  const __uploadFile = __body[__uploadField];`);
          lines.push(`  const __uploadCheck = __validateFile(__uploadFile, __uploadField);`);
          lines.push(`  if (!__uploadCheck.valid) return Response.json({ error: __uploadCheck.error }, { status: 400 });`);
        }

        // Validate decorator — advanced field validation on body
        if (validateDec && validateDec.args[0]) {
          if (!uploadDec) {
            lines.push(`  const __body = (await __parseBody(req)) || {};`);
          }
          lines.push(`  const __validationErrors = [];`);
          const advChecks = this._genAdvancedValidationCode(validateDec.args[0]);
          for (const check of advChecks) lines.push(check);
          lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
        }

        // T9-1: Route-level body type validation — route POST "/api/users" body: User => handler
        if (route.bodyType && ['POST', 'PUT', 'PATCH'].includes(method)) {
          const typeName = route.bodyType.name || (route.bodyType.elementType && route.bodyType.elementType.name);
          if (typeName && sharedTypes.has(typeName)) {
            const typeInfo = sharedTypes.get(typeName);
            if (!uploadDec && !validateDec) {
              lines.push(`  const __body = (await __parseBody(req)) || {};`);
            }
            const isArray = route.bodyType.type === 'ArrayTypeAnnotation';
            if (isArray) {
              lines.push(`  if (!Array.isArray(__body)) return Response.json({ error: "Request body must be an array of ${typeName}" }, { status: 400 });`);
              lines.push(`  const __bodyTypeErrors = [];`);
              lines.push(`  for (let __i = 0; __i < __body.length; __i++) {`);
              lines.push(`    const __item = __body[__i];`);
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                switch (f.type) {
                  case 'String':
                    lines.push(`    if (__item.${f.name} !== undefined && typeof __item.${f.name} !== "string") __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be a string\`);`);
                    break;
                  case 'Int':
                    lines.push(`    if (__item.${f.name} !== undefined && !Number.isInteger(__item.${f.name})) __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be an integer\`);`);
                    break;
                  case 'Float':
                    lines.push(`    if (__item.${f.name} !== undefined && typeof __item.${f.name} !== "number") __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be a number\`);`);
                    break;
                  case 'Bool':
                    lines.push(`    if (__item.${f.name} !== undefined && typeof __item.${f.name} !== "boolean") __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be a boolean\`);`);
                    break;
                }
              }
              lines.push(`  }`);
              lines.push(`  if (__bodyTypeErrors.length > 0) return Response.json({ error: "Validation failed for ${typeName}[]", details: __bodyTypeErrors }, { status: 400 });`);
            } else {
              lines.push(`  const __bodyTypeErrors = [];`);
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                switch (f.type) {
                  case 'String':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "string") __bodyTypeErrors.push("${f.name} must be a string");`);
                    break;
                  case 'Int':
                    lines.push(`  if (__body.${f.name} !== undefined && !Number.isInteger(__body.${f.name})) __bodyTypeErrors.push("${f.name} must be an integer");`);
                    break;
                  case 'Float':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "number") __bodyTypeErrors.push("${f.name} must be a number");`);
                    break;
                  case 'Bool':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "boolean") __bodyTypeErrors.push("${f.name} must be a boolean");`);
                    break;
                }
              }
              // Check for required fields (non-id fields without defaults)
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                lines.push(`  if (__body.${f.name} === undefined || __body.${f.name} === null) __bodyTypeErrors.push("${f.name} is required");`);
              }
              lines.push(`  if (__bodyTypeErrors.length > 0) return Response.json({ error: "Validation failed for type ${typeName}", details: __bodyTypeErrors }, { status: 400 });`);
            }
          }
        }

        // Type-safe body deserialization: if a param has a shared type annotation, auto-validate
        if (handlerDecl && ['POST', 'PUT', 'PATCH'].includes(method)) {
          for (const p of handlerDecl.params) {
            if (p.typeAnnotation && p.typeAnnotation.type === 'TypeAnnotation' && sharedTypes.has(p.typeAnnotation.name) && p.name !== 'req') {
              const typeInfo = sharedTypes.get(p.typeAnnotation.name);
              if (!uploadDec && !validateDec) {
                lines.push(`  if (!__body) { var __body = (await __parseBody(req)) || {}; }`);
              }
              lines.push(`  // Type-safe validation for ${p.name}: ${p.typeAnnotation.name}`);
              lines.push(`  const __tsErrors_${p.name} = [];`);
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                switch (f.type) {
                  case 'String':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "string") __tsErrors_${p.name}.push("${f.name} must be a string");`);
                    break;
                  case 'Int':
                    lines.push(`  if (__body.${f.name} !== undefined && !Number.isInteger(__body.${f.name})) __tsErrors_${p.name}.push("${f.name} must be an integer");`);
                    break;
                  case 'Float':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "number") __tsErrors_${p.name}.push("${f.name} must be a number");`);
                    break;
                  case 'Bool':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "boolean") __tsErrors_${p.name}.push("${f.name} must be a boolean");`);
                    break;
                }
              }
              lines.push(`  if (__tsErrors_${p.name}.length > 0) return Response.json({ error: "Validation failed", details: __tsErrors_${p.name} }, { status: 400 });`);
            }
          }
        }

        if (handlerParams !== null && handlerParams !== undefined) {
          if (handlerParams.length === 0) {
            if (groupMws.length > 0) {
              this._emitGroupMiddlewareChain(lines, groupMws, handler, '()', timeoutMs);
            } else {
              this._emitHandlerCall(lines, `${handler}()`, timeoutMs);
            }
          } else if (handlerParams[0] === 'req') {
            lines.push(`  const __url = new URL(req.url);`);
            lines.push(`  const __ctx = {`);
            lines.push(`    method: req.method, path: __url.pathname, params,`);
            lines.push(`    query: __parseQuery(__url.searchParams),`);
            lines.push(`    headers: Object.fromEntries(req.headers),`);
            lines.push(`    cookies: __parseCookies(req.headers.get("cookie")),`);
            lines.push(`    body: null, raw: req, locals: __getLocals(),`);
            lines.push(`  };`);
            if (sessionConfig) {
              lines.push(`  if (req.__session) __ctx.session = req.__session;`);
            }
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
              lines.push(`  __ctx.body = await __parseBody(req);`);
            }
            const remainingParams = handlerParams.slice(1);
            if (remainingParams.length > 0) {
              if (['POST', 'PUT', 'PATCH'].includes(method)) {
                lines.push(`  const __body = __ctx.body || {};`);
                for (const pn of remainingParams) {
                  lines.push(`  const ${pn} = params.${pn} ?? __body.${pn};`);
                }
              } else {
                for (const pn of remainingParams) {
                  lines.push(`  const ${pn} = params.${pn} ?? __ctx.query.${pn};`);
                }
              }
              if (handlerDecl) {
                const validationChecks = this._genValidationCode(handlerDecl.params.slice(1));
                if (validationChecks.length > 0) {
                  lines.push(`  const __validationErrors = [];`);
                  for (const check of validationChecks) lines.push(check);
                  lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
                }
              }
              if (groupMws.length > 0) {
                this._emitGroupMiddlewareChain(lines, groupMws, handler, `(__ctx, ${remainingParams.join(', ')})`, timeoutMs);
              } else {
                this._emitHandlerCall(lines, `${handler}(__ctx, ${remainingParams.join(', ')})`, timeoutMs);
              }
            } else {
              if (groupMws.length > 0) {
                this._emitGroupMiddlewareChain(lines, groupMws, handler, '(__ctx)', timeoutMs);
              } else {
                this._emitHandlerCall(lines, `${handler}(__ctx)`, timeoutMs);
              }
            }
          } else {
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
              lines.push(`  const __body = (await __parseBody(req)) || {};`);
              for (const pn of handlerParams) {
                lines.push(`  const ${pn} = params.${pn} ?? __body.${pn};`);
              }
            } else {
              lines.push(`  const __url = new URL(req.url);`);
              for (const pn of handlerParams) {
                lines.push(`  const ${pn} = params.${pn} ?? __url.searchParams.get(${JSON.stringify(pn)});`);
              }
            }
            if (handlerDecl) {
              const validationChecks = this._genValidationCode(handlerDecl.params);
              if (validationChecks.length > 0) {
                lines.push(`  const __validationErrors = [];`);
                for (const check of validationChecks) lines.push(check);
                lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
              }
            }
            if (groupMws.length > 0) {
              this._emitGroupMiddlewareChain(lines, groupMws, handler, `(${handlerParams.join(', ')})`, timeoutMs);
            } else {
              this._emitHandlerCall(lines, `${handler}(${handlerParams.join(', ')})`, timeoutMs);
            }
          }
        } else {
          this._emitHandlerCall(lines, `${handler}(req, params)`, timeoutMs);
        }

        // T9-3: Detect generator-based streaming — if handler uses yield, wrap in streaming response
        const isGeneratorHandler = route.handler.type === 'Identifier'
          ? (handlerDecl && this._containsYield(handlerDecl.body))
          : (route.handler.type === 'FunctionDeclaration' || route.handler.type === 'LambdaExpression')
            ? this._containsYield(route.handler.body || route.handler)
            : false;

        if (isGeneratorHandler) {
          lines.push(`  if (__result && typeof __result[Symbol.asyncIterator] === "function") {`);
          lines.push(`    const __encoder = new TextEncoder();`);
          lines.push(`    const __stream = new ReadableStream({`);
          lines.push(`      async start(controller) {`);
          lines.push(`        try {`);
          lines.push(`          for await (const __chunk of __result) {`);
          lines.push(`            const __data = typeof __chunk === "string" ? __chunk : JSON.stringify(__chunk);`);
          lines.push(`            controller.enqueue(__encoder.encode(\`data: \${__data}\\n\\n\`));`);
          lines.push(`          }`);
          lines.push(`        } finally { controller.close(); }`);
          lines.push(`      }`);
          lines.push(`    });`);
          lines.push(`    return new Response(__stream, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });`);
          lines.push(`  }`);
          lines.push(`  if (__result && typeof __result[Symbol.iterator] === "function" && typeof __result !== "string") {`);
          lines.push(`    const __encoder = new TextEncoder();`);
          lines.push(`    const __chunks = [...__result];`);
          lines.push(`    const __stream = new ReadableStream({`);
          lines.push(`      start(controller) {`);
          lines.push(`        for (const __chunk of __chunks) {`);
          lines.push(`          const __data = typeof __chunk === "string" ? __chunk : JSON.stringify(__chunk);`);
          lines.push(`          controller.enqueue(__encoder.encode(\`data: \${__data}\\n\\n\`));`);
          lines.push(`        }`);
          lines.push(`        controller.close();`);
          lines.push(`      }`);
          lines.push(`    });`);
          lines.push(`    return new Response(__stream, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });`);
          lines.push(`  }`);
        }
        // T9-5: API versioning — add version headers to responses
        if (routeVersion) {
          const ver = JSON.stringify(String(routeVersion.version || ''));
          lines.push(`  const __addVersionHeaders = (res) => {`);
          lines.push(`    const h = new Headers(res.headers);`);
          lines.push(`    h.set("API-Version", ${ver});`);
          if (routeVersion.deprecated) {
            lines.push(`    h.set("Deprecation", "true");`);
            if (routeVersion.sunset) {
              lines.push(`    h.set("Sunset", ${JSON.stringify(String(routeVersion.sunset))});`);
            }
            lines.push(`    h.set("Link", '</api/v' + (parseInt(${ver}) + 1) + req.url.replace(/\\/api\\/v\\d+/, "") + '>; rel="successor-version"');`);
          }
          lines.push(`    return new Response(res.body, { status: res.status, headers: h });`);
          lines.push(`  };`);
          lines.push(`  if (__result instanceof Response) return __addVersionHeaders(__result);`);
          lines.push(`  return __addVersionHeaders(Response.json(__result));`);
        } else {
          lines.push(`  if (__result instanceof Response) return __result;`);
          lines.push(`  return Response.json(__result);`);
        }
        lines.push(`}${versionArg});`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 17b. OpenAPI Spec Generation — auto-generate from routes + types
    // ════════════════════════════════════════════════════════════
    if (routes.length > 0) {
      const tovaTypeToJsonSchema = (typeName) => {
        switch (typeName) {
          case 'Int': return '{ "type": "integer" }';
          case 'Float': return '{ "type": "number" }';
          case 'Bool': return '{ "type": "boolean" }';
          case 'String': return '{ "type": "string" }';
          default: return `{ "$ref": "#/components/schemas/${typeName}" }`;
        }
      };

      lines.push('// ── OpenAPI Spec ──');
      lines.push('const __openApiSpec = {');
      lines.push('  openapi: "3.0.3",');
      lines.push(`  info: { title: ${JSON.stringify(blockName || 'Tova API')}, version: "1.0.0" },`);
      lines.push('  paths: {},');
      lines.push('  components: { schemas: {} },');
      lines.push('};');

      // Generate schemas from shared types
      for (const [typeName, typeInfo] of sharedTypes) {
        const props = typeInfo.fields.map(f => {
          let jsonType;
          switch (f.type) {
            case 'Int': jsonType = '"integer"'; break;
            case 'Float': jsonType = '"number"'; break;
            case 'Bool': jsonType = '"boolean"'; break;
            case 'String': jsonType = '"string"'; break;
            case 'Array': jsonType = '"array"'; break;
            default: jsonType = '"string"'; break;
          }
          return `${f.name}: { type: ${jsonType} }`;
        }).join(', ');
        lines.push(`__openApiSpec.components.schemas[${JSON.stringify(typeName)}] = { type: "object", properties: { ${props} } };`);
      }

      // Generate paths from routes
      for (const route of routes) {
        const method = route.method.toLowerCase();
        const path = route.path.replace(/:([^/]+)/g, '{$1}');
        const handlerName = route.handler.type === 'Identifier' ? route.handler.name : null;
        const handlerDecl = handlerName ? fnDeclMap.get(handlerName) : null;

        lines.push(`if (!__openApiSpec.paths[${JSON.stringify(path)}]) __openApiSpec.paths[${JSON.stringify(path)}] = {};`);
        lines.push(`__openApiSpec.paths[${JSON.stringify(path)}][${JSON.stringify(method)}] = {`);

        // Summary from handler name
        if (handlerName) {
          lines.push(`  summary: ${JSON.stringify(handlerName.replace(/_/g, ' '))},`);
        }

        // Parameters from path params and handler params
        const pathParams = (route.path.match(/:([^/]+)/g) || []).map(p => p.slice(1));
        if (pathParams.length > 0) {
          lines.push('  parameters: [');
          for (const pp of pathParams) {
            lines.push(`    { name: ${JSON.stringify(pp)}, in: "path", required: true, schema: { type: "string" } },`);
          }
          lines.push('  ],');
        }

        // Request body schema for POST/PUT/PATCH — prefer route-level bodyType, fall back to handler params
        if (['post', 'put', 'patch'].includes(method)) {
          if (route.bodyType) {
            // T9-1: Route-level body type annotation
            const bt = route.bodyType;
            if (bt.type === 'ArrayTypeAnnotation' && bt.elementType) {
              const elName = bt.elementType.name;
              if (sharedTypes.has(elName)) {
                lines.push(`  requestBody: { required: true, content: { "application/json": { schema: { type: "array", items: { "$ref": "#/components/schemas/${elName}" } } } } },`);
              } else {
                lines.push(`  requestBody: { required: true, content: { "application/json": { schema: { type: "array", items: ${tovaTypeToJsonSchema(elName)} } } } },`);
              }
            } else if (bt.type === 'TypeAnnotation' && sharedTypes.has(bt.name)) {
              lines.push(`  requestBody: { required: true, content: { "application/json": { schema: { "$ref": "#/components/schemas/${bt.name}" } } } },`);
            } else if (bt.type === 'TypeAnnotation') {
              lines.push(`  requestBody: { required: true, content: { "application/json": { schema: ${tovaTypeToJsonSchema(bt.name)} } } },`);
            }
          } else if (handlerDecl) {
            const bodyParams = handlerDecl.params.filter(p => p.name !== 'req' && !pathParams.includes(p.name));
            if (bodyParams.length > 0) {
              lines.push('  requestBody: {');
              lines.push('    content: { "application/json": { schema: { type: "object", properties: {');
              for (const bp of bodyParams) {
                const ta = bp.typeAnnotation;
                if (ta && ta.name && sharedTypes.has(ta.name)) {
                  lines.push(`      ${bp.name}: { "$ref": "#/components/schemas/${ta.name}" },`);
                } else if (ta) {
                  let jsonType;
                  switch (ta.name) {
                    case 'Int': jsonType = '"integer"'; break;
                    case 'Float': jsonType = '"number"'; break;
                    case 'Bool': jsonType = '"boolean"'; break;
                    default: jsonType = '"string"'; break;
                  }
                  lines.push(`      ${bp.name}: { type: ${jsonType} },`);
                } else {
                  lines.push(`      ${bp.name}: { type: "string" },`);
                }
              }
              lines.push('    } } } },');
              lines.push('  },');
            }
          }
        }

        // Response schema — prefer route-level responseType (T9-2), fall back to handler return type
        const responseType = route.responseType || (handlerDecl && handlerDecl.returnType);
        if (responseType) {
          const rt = responseType;
          if (rt.type === 'ArrayTypeAnnotation' && rt.elementType) {
            const elName = rt.elementType.name;
            if (sharedTypes.has(elName)) {
              lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { type: "array", items: { "$ref": "#/components/schemas/${elName}" } } } } } },`);
            } else {
              lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { type: "array", items: ${tovaTypeToJsonSchema(elName)} } } } } },`);
            }
          } else if (rt.type === 'TypeAnnotation' && sharedTypes.has(rt.name)) {
            lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { "$ref": "#/components/schemas/${rt.name}" } } } } },`);
          } else if (rt.type === 'TypeAnnotation') {
            lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: ${tovaTypeToJsonSchema(rt.name)} } } } },`);
          } else {
            lines.push('  responses: { "200": { description: "Success" } },');
          }
        } else {
          lines.push('  responses: { "200": { description: "Success" } },');
        }

        lines.push('};');
      }

      // Add the /docs endpoint
      lines.push('__addRoute("GET", "/openapi.json", async () => {');
      lines.push('  return Response.json(__openApiSpec);');
      lines.push('});');
      lines.push('__addRoute("GET", "/docs", async () => {');
      lines.push('  const html = `<!DOCTYPE html><html><head><title>API Docs</title>');
      lines.push('    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"></head>');
      lines.push('    <body><div id="swagger-ui"></div>');
      lines.push('    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"><\\/script>');
      lines.push('    <script>SwaggerUIBundle({ url: "/openapi.json", dom_id: "#swagger-ui" });<\\/script>');
      lines.push('    </body></html>`;');
      lines.push('  return new Response(html, { headers: { "Content-Type": "text/html" } });');
      lines.push('});');
      lines.push('');
    }

    // T9-5: API versions endpoint — list available versions
    const versionedRoutes = routes.filter(r => r._version);
    if (versionedRoutes.length > 0) {
      const versionMap = new Map();
      for (const r of versionedRoutes) {
        const v = String(r._version.version || '');
        if (!versionMap.has(v)) {
          versionMap.set(v, { version: v, deprecated: !!r._version.deprecated, sunset: r._version.sunset || null });
        }
      }
      lines.push('// ── API Versions ──');
      lines.push('__addRoute("GET", "/api/versions", async () => {');
      lines.push('  return Response.json({');
      lines.push('    versions: [');
      for (const [, info] of versionMap) {
        const parts = [`version: ${JSON.stringify(info.version)}`];
        if (info.deprecated) parts.push('deprecated: true');
        if (info.sunset) parts.push(`sunset: ${JSON.stringify(info.sunset)}`);
        lines.push(`      { ${parts.join(', ')} },`);
      }
      lines.push('    ]');
      lines.push('  });');
      lines.push('});');
      lines.push('');
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 18. Logging, Static files, WebSocket
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
    lines.push('// ── Structured Logging ──');
    lines.push('let __reqCounter = 0;');
    lines.push('function __genRequestId() {');
    lines.push('  return `${Date.now().toString(36)}-${(++__reqCounter).toString(36)}`;');
    lines.push('}');
    lines.push('const __logLevels = { debug: 0, info: 1, warn: 2, error: 3 };');
    lines.push('const __logMinLevel = __logLevels[process.env.LOG_LEVEL || "info"] || 1;');
    lines.push('let __logFile = null;');
    lines.push('if (process.env.LOG_FILE) {');
    lines.push('  const __fs = await import("node:fs");');
    lines.push('  __logFile = __fs.createWriteStream(process.env.LOG_FILE, { flags: "a" });');
    lines.push('}');
    lines.push('function __log(level, msg, meta = {}) {');
    lines.push('  if ((__logLevels[level] || 0) < __logMinLevel) return;');
    lines.push('  const entry = JSON.stringify({ timestamp: new Date().toISOString(), level, msg, ...meta });');
    lines.push('  console.log(entry);');
    lines.push('  if (__logFile) __logFile.write(entry + "\\n");');
    lines.push('}');
    lines.push('');
    }

    if (staticDecl) {
      lines.push('// ── Static File Serving ──');
      lines.push(`const __staticPrefix = ${JSON.stringify(staticDecl.path)};`);
      lines.push(`const __staticDir = ${JSON.stringify(staticDecl.dir)};`);
      if (staticDecl.fallback) {
        lines.push(`const __staticFallback = ${JSON.stringify(staticDecl.fallback)};`);
      }
      lines.push('async function __serveStatic(pathname, req) {');
      lines.push('  const filePath = __staticDir + pathname.slice(__staticPrefix.length);');
      lines.push('  try {');
      lines.push('    const file = Bun.file(filePath);');
      lines.push('    if (await file.exists()) {');
      lines.push('      const stat = { size: file.size, lastModified: file.lastModified };');
      lines.push('      const etagVal = `"${stat.size.toString(36)}-${stat.lastModified.toString(36)}"`;');
      lines.push('      if (req && req.headers.get("If-None-Match") === etagVal) {');
      lines.push('        return new Response(null, { status: 304 });');
      lines.push('      }');
      const staticCacheAge = cacheConfig && cacheConfig.max_age ? this.genExpression(cacheConfig.max_age) : '3600';
      lines.push(`      return new Response(file, { headers: { ETag: etagVal, "Cache-Control": "public, max-age=${staticCacheAge}" } });`);
      lines.push('    }');
      lines.push('  } catch {}');
      if (staticDecl.fallback) {
        lines.push('  try {');
        lines.push('    const fb = Bun.file(__staticDir + "/" + __staticFallback);');
        lines.push('    if (await fb.exists()) return new Response(fb, { headers: { "Content-Type": "text/html" } });');
        lines.push('  } catch {}');
      }
      lines.push('  return null;');
      lines.push('}');
      lines.push('');
    }

    if (wsDecl) {
      lines.push('// ── WebSocket Handlers ──');
      lines.push('const __wsClients = new Set();');
      lines.push('const __wsRooms = new Map();');
      lines.push('function broadcast(data, exclude = null) {');
      lines.push('  const msg = typeof data === "string" ? data : JSON.stringify(data);');
      lines.push('  for (const c of __wsClients) { if (c !== exclude) c.send(msg); }');
      lines.push('}');
      lines.push('function join(ws, room) {');
      lines.push('  if (!__wsRooms.has(room)) __wsRooms.set(room, new Set());');
      lines.push('  __wsRooms.get(room).add(ws);');
      lines.push('}');
      lines.push('function leave(ws, room) {');
      lines.push('  const r = __wsRooms.get(room);');
      lines.push('  if (r) { r.delete(ws); if (r.size === 0) __wsRooms.delete(room); }');
      lines.push('}');
      lines.push('function broadcast_to(room, data, exclude = null) {');
      lines.push('  const r = __wsRooms.get(room);');
      lines.push('  if (!r) return;');
      lines.push('  const msg = typeof data === "string" ? data : JSON.stringify(data);');
      lines.push('  for (const c of r) { if (c !== exclude) c.send(msg); }');
      lines.push('}');
      lines.push('const __wsHandlers = {};');
      for (const [event, handler] of Object.entries(wsDecl.handlers)) {
        if (!handler) continue;
        const params = handler.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of handler.params) this.declareVar(p.name);
        const body = this.genBlockBody(handler.body);
        this.popScope();
        lines.push(`__wsHandlers.${event} = function(${params}) {`);
        lines.push(body);
        lines.push('};');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 19. Schedule helpers (F8) — interval/cron parser
    // ════════════════════════════════════════════════════════════
    if (schedules.length > 0) {
      lines.push('// ── Schedule Helpers ──');
      lines.push('function __parseInterval(pattern) {');
      lines.push('  const m = pattern.match(/^(\\d+)(s|m|h)$/);');
      lines.push('  if (!m) return null;');
      lines.push('  const val = parseInt(m[1], 10);');
      lines.push('  switch (m[2]) {');
      lines.push('    case "s": return val * 1000;');
      lines.push('    case "m": return val * 60 * 1000;');
      lines.push('    case "h": return val * 60 * 60 * 1000;');
      lines.push('  }');
      lines.push('}');
      lines.push('function __cronFieldMatches(field, value) {');
      lines.push('  if (field === "*") return true;');
      lines.push('  for (const part of field.split(",")) {');
      lines.push('    if (part.includes("/")) {');
      lines.push('      const [range, stepStr] = part.split("/");');
      lines.push('      const step = parseInt(stepStr, 10);');
      lines.push('      if (range === "*") { if (value % step === 0) return true; }');
      lines.push('      else if (range.includes("-")) {');
      lines.push('        const [lo, hi] = range.split("-").map(Number);');
      lines.push('        if (value >= lo && value <= hi && (value - lo) % step === 0) return true;');
      lines.push('      }');
      lines.push('    } else if (part.includes("-")) {');
      lines.push('      const [lo, hi] = part.split("-").map(Number);');
      lines.push('      if (value >= lo && value <= hi) return true;');
      lines.push('    } else { if (parseInt(part, 10) === value) return true; }');
      lines.push('  }');
      lines.push('  return false;');
      lines.push('}');
      lines.push('function __cronMatches(parts, date) {');
      lines.push('  const fields = [date.getMinutes(), date.getHours(), date.getDate(), date.getMonth() + 1, date.getDay()];');
      lines.push('  for (let i = 0; i < 5; i++) {');
      lines.push('    if (!__cronFieldMatches(parts[i], fields[i])) return false;');
      lines.push('  }');
      lines.push('  return true;');
      lines.push('}');
      lines.push('const __scheduleIntervals = [];');

      for (let si = 0; si < schedules.length; si++) {
        const sched = schedules[si];
        const fnName = sched.name || `__scheduled_${si}`;
        const params = sched.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sched.params) this.declareVar(p.name);
        const body = this.genBlockBody(sched.body);
        this.popScope();
        lines.push(`async function ${fnName}(${params}) {`);
        lines.push(body);
        lines.push('}');
        const pattern = sched.pattern;
        // Check if it's a simple interval (no spaces) or cron (has spaces)
        if (pattern.includes(' ')) {
          // Cron expression
          const cronParts = JSON.stringify(pattern.split(/\s+/));
          lines.push(`__scheduleIntervals.push(setInterval(() => {`);
          lines.push(`  if (__cronMatches(${cronParts}, new Date())) ${fnName}();`);
          lines.push(`}, 60000));`);
        } else {
          // Simple interval
          lines.push(`__scheduleIntervals.push(setInterval(${fnName}, __parseInterval(${JSON.stringify(pattern)})));`);
        }
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 20. Middleware chain, Graceful Drain
    // ════════════════════════════════════════════════════════════
    if (globalMiddlewares.length > 0) {
      lines.push('// ── Middleware Chain ──');
      const mwNames = globalMiddlewares.map(m => m.name);
      lines.push(`const __middlewares = [${mwNames.join(', ')}];`);
      lines.push('');
    }

    if (!isFastMode) {
    lines.push('// ── Graceful Drain ──');
    lines.push('let __activeRequests = 0;');
    lines.push('let __shuttingDown = false;');
    lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 21. Request Handler — with global rate limit check (F2)
    // ════════════════════════════════════════════════════════════
    if (isFastMode) {
      // Fast mode: emit direct handler references for static routes
      if (allRoutesStatic && routes.length <= 16) {
        for (let ri = 0; ri < routes.length; ri++) {
          const method = routes[ri].method.toUpperCase();
          const path = routes[ri].path;
          lines.push(`const __fh${ri} = __staticRoutes.get(${JSON.stringify(method + ' ' + path)}).handler;`);
        }
      }
      // Fast mode: minimal handler with no AsyncLocalStorage, no logging, no request IDs
      lines.push('// ── Request Handler (fast mode) ──');
      lines.push('function __handleRequest(req) {');
      lines.push('  const __rawUrl = req.url;');
      lines.push('  const __pStart = __rawUrl.indexOf("/", 12);');
      lines.push('  const __qIdx = __rawUrl.indexOf("?", __pStart);');
      lines.push('  const __pathname = __qIdx === -1 ? __rawUrl.slice(__pStart) : __rawUrl.slice(__pStart, __qIdx);');
      lines.push('  const __method = req.method;');

      // OPTIONS fast path
      lines.push('  if (__method === "OPTIONS") return new Response(null, { status: 204, headers: __corsHeadersConst });');

      // Static route dispatch — emit direct if/else chain using named handler refs
      if (allRoutesStatic && routes.length <= 16) {
        for (let ri = 0; ri < routes.length; ri++) {
          const method = routes[ri].method.toUpperCase();
          const path = routes[ri].path;
          const handlerVar = `__fh${ri}`;
          lines.push(`  if (__method === ${JSON.stringify(method)} && __pathname === ${JSON.stringify(path)}) return ${handlerVar}(req, {});`);
        }
        // HEAD fallback for GET routes
        for (let ri = 0; ri < routes.length; ri++) {
          if (routes[ri].method.toUpperCase() === 'GET') {
            const handlerVar = `__fh${ri}`;
            lines.push(`  if (__method === "HEAD" && __pathname === ${JSON.stringify(routes[ri].path)}) return ${handlerVar}(req, {});`);
          }
        }
      } else {
        // Fallback to Map lookup for larger route sets or dynamic routes
        lines.push('  const __staticKey = __method + " " + __pathname;');
        lines.push('  const __sr = __staticRoutes.get(__staticKey);');
        lines.push('  if (__sr) return __sr.handler(req, {});');
        if (hasDynamicRoutes) {
          lines.push('  for (const route of __routes) {');
          lines.push('    if (route._isStatic) continue;');
          lines.push('    if (__method === route.method || (route.method === "GET" && __method === "HEAD")) {');
          lines.push('      const match = __pathname.match(route.regex);');
          lines.push('      if (match) return route.handler(req, match.groups || {});');
          lines.push('    }');
          lines.push('  }');
        }
      }

      // Client HTML fallback
      lines.push('  if (__pathname === "/" && typeof __clientHTML !== "undefined") {');
      lines.push('    return new Response(__clientHTML, { status: 200, headers: { "Content-Type": "text/html" } });');
      lines.push('  }');
      lines.push('  return new Response("Not Found", { status: 404 });');
      lines.push('}');
      lines.push('');
    } else {
    // Full mode: original handler with all features
    lines.push('// ── Request Handler ──');
    lines.push('async function __handleRequest(req) {');

    lines.push('  if (__shuttingDown) {');
    lines.push('    return new Response("Service Unavailable", { status: 503 });');
    lines.push('  }');
    lines.push('  __activeRequests++;');

    lines.push('  const __rawUrl = req.url;');
    lines.push('  const __pStart = __rawUrl.indexOf("/", 12);');  // skip "http://x:p" or "https://x:p"
    lines.push('  const __qIdx = __rawUrl.indexOf("?", __pStart);');
    lines.push('  const __pathname = __qIdx === -1 ? __rawUrl.slice(__pStart) : __rawUrl.slice(__pStart, __qIdx);');
    lines.push('  const __rid = req.headers.get("X-Request-Id") || __genRequestId();');
    lines.push('  const __startTime = Date.now();');
    lines.push('  const __cors = __getCorsHeaders(req);');

    lines.push('  return __requestContext.run({ rid: __rid, locals: {} }, async () => {');
    lines.push('  try {');

    // WebSocket upgrade
    if (wsDecl) {
      // Determine if WS auth is needed:
      // - If ws has auth: false, skip auth even if authConfig exists
      // - If ws has auth: true or authConfig exists (and ws doesn't disable), require auth
      const wsAuthExplicitlyDisabled = wsDecl.config && wsDecl.config.auth &&
        wsDecl.config.auth.type === 'BooleanLiteral' && wsDecl.config.auth.value === false;
      const wsNeedsAuth = !wsAuthExplicitlyDisabled && (authConfig || (wsDecl.config && wsDecl.config.auth &&
        !(wsDecl.config.auth.type === 'BooleanLiteral' && wsDecl.config.auth.value === false)));

      lines.push('  if (req.headers.get("upgrade") === "websocket") {');
      if (wsNeedsAuth) {
        lines.push('    try {');
        lines.push('      const __wsUser = await __authenticate(req);');
        lines.push('      const upgraded = __server.upgrade(req, { data: { rid: __rid, user: __wsUser } });');
        lines.push('      if (upgraded) return undefined;');
        lines.push('      return new Response("WebSocket upgrade failed", { status: 400 });');
        lines.push('    } catch (__authErr) {');
        lines.push('      return Response.json({ error: "Unauthorized" }, { status: 401 });');
        lines.push('    }');
      } else {
        lines.push('    const upgraded = __server.upgrade(req, { data: { rid: __rid } });');
        lines.push('    if (upgraded) return undefined;');
        lines.push('    return new Response("WebSocket upgrade failed", { status: 400 });');
      }
      lines.push('  }');
    }

    lines.push('  if (req.method === "OPTIONS") {');
    lines.push('    return new Response(null, { status: 204, headers: __cors });');
    lines.push('  }');

    // Max body size check
    lines.push('  const __contentLength = parseInt(req.headers.get("Content-Length") || "0", 10);');
    lines.push('  if (__contentLength > __maxBodySize) {');
    lines.push('    return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
    lines.push('  }');

    // Global rate limit check (F2)
    if (rateLimitConfig) {
      lines.push('  const __clientIp = req.headers.get("x-forwarded-for") || "unknown";');
      lines.push('  const __rl = __checkRateLimit(__clientIp, __rateLimitMax, __rateLimitWindow);');
      lines.push('  if (__rl.limited) {');
      lines.push('    return Response.json({ error: "Too Many Requests" }, { status: 429, headers: { ...__cors, "Retry-After": String(__rl.retryAfter) } });');
      lines.push('  }');
    }

    // Session loading
    if (sessionConfig) {
      lines.push('  let __sessionId = null;');
      lines.push('  let __sessionIsNew = false;');
      lines.push('  const __cookies = __parseCookies(req.headers.get("cookie"));');
      lines.push('  const __signedSid = __cookies[__sessionCookieName];');
      lines.push('  if (__signedSid) {');
      lines.push('    __sessionId = await __verifySessionId(__signedSid);');
      lines.push('  }');
      lines.push('  if (!__sessionId) {');
      lines.push('    __sessionId = crypto.randomUUID();');
      lines.push('    __sessionIsNew = true;');
      lines.push('  }');
      lines.push('  req.__session = __createSession(__sessionId);');
    }

    // Static file serving
    if (staticDecl) {
      lines.push(`  if (__pathname.startsWith(__staticPrefix)) {`);
      lines.push('    const __staticRes = await __serveStatic(__pathname, req);');
      lines.push('    if (__staticRes) return __staticRes;');
      lines.push('  }');
    }

    // Route matching — fast path for static routes (no params/wildcards)
    lines.push('  const __staticKey = req.method + " " + __pathname;');
    lines.push('  const __staticRoute = __staticRoutes.get(__staticKey) || (req.method === "HEAD" && __staticRoutes.get("GET " + __pathname));');
    lines.push('  if (__staticRoute) {');
    lines.push('    const route = __staticRoute;');
    lines.push('    const match = { groups: {} };');

    // Emit static route handler (same structure as dynamic)
    if (globalMiddlewares.length > 0) {
      lines.push('    const __handler = async (__req) => route.handler(__req, {});');
      lines.push('    const __chain = __middlewares.reduceRight(');
      lines.push('      (next, mw) => async (__req) => mw(__req, next),');
      lines.push('      __handler');
      lines.push('    );');
      lines.push('    try {');
      lines.push('      const res = await __chain(req);');
      lines.push('      __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('      const headers = new Headers(res.headers);');
      lines.push('      for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
      lines.push('      return new Response(res.body, { status: res.status, headers });');
      lines.push('    } catch (err) {');
      lines.push('      if (err.message === "__BODY_TOO_LARGE__") return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
      if (errorHandler) {
        lines.push('      try {');
        lines.push('        const errRes = await __errorHandler(err, req);');
        lines.push('        if (errRes instanceof Response) {');
        lines.push('          const headers = new Headers(errRes.headers);');
        lines.push('          for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
        lines.push('          return new Response(errRes.body, { status: errRes.status, headers });');
        lines.push('        }');
        lines.push('        return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('      } catch { /**/ }');
      }
      lines.push('      __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('      return Response.json({ error: "Internal Server Error" }, { status: 500, headers: __cors });');
      lines.push('    }');
    } else {
      lines.push('    try {');
      lines.push('      const res = await route.handler(req, {});');
      lines.push('      __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('      for (const [k, v] of Object.entries(__cors)) res.headers.set(k, v);');
      lines.push('      return res;');
      lines.push('    } catch (err) {');
      lines.push('      if (err.message === "__BODY_TOO_LARGE__") return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
      if (errorHandler) {
        lines.push('      try {');
        lines.push('        const errRes = await __errorHandler(err, req);');
        lines.push('        if (errRes instanceof Response) {');
        lines.push('          for (const [k, v] of Object.entries(__cors)) errRes.headers.set(k, v);');
        lines.push('          return errRes;');
        lines.push('        }');
        lines.push('        return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('      } catch { /**/ }');
      }
      lines.push('      __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('      return Response.json({ error: "Internal Server Error" }, { status: 500, headers: __cors });');
      lines.push('    }');
    }
    lines.push('  }');

    // Fallback: regex-based matching for dynamic routes
    lines.push('  for (const route of __routes) {');
    lines.push('    if (route._isStatic) continue;');  // Skip static routes already handled
    lines.push('    if (req.method === route.method || (route.method === "GET" && req.method === "HEAD" && !__routes.some(r => r.method === "HEAD" && r.regex.source === route.regex.source))) {');
    lines.push('      const match = __pathname.match(route.regex);');
    lines.push('      if (match) {');

    if (globalMiddlewares.length > 0) {
      lines.push('        const __handler = async (__req) => route.handler(__req, match.groups || {});');
      lines.push('        const __chain = __middlewares.reduceRight(');
      lines.push('          (next, mw) => async (__req) => mw(__req, next),');
      lines.push('          __handler');
      lines.push('        );');
      lines.push('        try {');
      lines.push('          const res = await __chain(req);');
      lines.push('          __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('          for (const [k, v] of Object.entries(__cors)) res.headers.set(k, v);');
      lines.push('          return res;');
      lines.push('        } catch (err) {');
      lines.push('          if (err.message === "__BODY_TOO_LARGE__") return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
      if (errorHandler) {
        lines.push('          try {');
        lines.push('            const errRes = await __errorHandler(err, req);');
        lines.push('            if (errRes instanceof Response) {');
        lines.push('              for (const [k, v] of Object.entries(__cors)) errRes.headers.set(k, v);');
        lines.push('              return errRes;');
        lines.push('            }');
        lines.push('            return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('          } catch { /**/ }');
      }
      lines.push('          __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('          return Response.json({ error: "Internal Server Error" }, { status: 500, headers: __cors });');
      lines.push('        }');
    } else {
      lines.push('        try {');
      lines.push('          const res = await route.handler(req, match.groups || {});');
      lines.push('          __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('          for (const [k, v] of Object.entries(__cors)) res.headers.set(k, v);');
      lines.push('          return res;');
      lines.push('        } catch (err) {');
      lines.push('          if (err.message === "__BODY_TOO_LARGE__") return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
      if (errorHandler) {
        lines.push('          try {');
        lines.push('            const errRes = await __errorHandler(err, req);');
        lines.push('            if (errRes instanceof Response) {');
        lines.push('              for (const [k, v] of Object.entries(__cors)) errRes.headers.set(k, v);');
        lines.push('              return errRes;');
        lines.push('            }');
        lines.push('            return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('          } catch { /**/ }');
      }
      lines.push('          __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('          return Response.json({ error: "Internal Server Error" }, { status: 500, headers: __cors });');
      lines.push('        }');
    }

    lines.push('      }');
    lines.push('    }');
    lines.push('  }');

    // Serve client HTML at root
    lines.push('  if (__pathname === "/" && typeof __clientHTML !== "undefined") {');
    lines.push('    return new Response(__clientHTML, { status: 200, headers: { "Content-Type": "text/html", ...(__cors) } });');
    lines.push('  }');
    lines.push('  const __notFound = Response.json({ error: "Not Found" }, { status: 404, headers: __cors });');
    lines.push('  __log("warn", "Not Found", { rid: __rid, method: req.method, path: __pathname, status: 404, ms: Date.now() - __startTime });');
    lines.push('  return __notFound;');

    if (sessionConfig) {
      lines.push('  } catch (__e) { throw __e; }');
      lines.push('  }).then(async (__res) => {');
      lines.push('    if (req.__session && req.__session.__flush) await req.__session.__flush();');
      lines.push('    if (__res && __sessionIsNew) {');
      lines.push('      const __signed = await __signSessionId(__sessionId);');
      lines.push('      const __h = new Headers(__res.headers);');
      lines.push('      __h.set("Set-Cookie", `${__sessionCookieName}=${__signed}; Path=/; HttpOnly; Max-Age=${__sessionMaxAge}`);');
      lines.push('      return new Response(__res.body, { status: __res.status, headers: __h });');
      lines.push('    }');
      lines.push('    return __res;');
      lines.push('  }, async (__e) => {');
      lines.push('    if (req.__session && req.__session.__flush) await req.__session.__flush();');
      lines.push('    throw __e;');
      lines.push('  }).finally(() => { __activeRequests--; });');
    } else {
      lines.push('  } finally {');
      lines.push('    __activeRequests--;');
      lines.push('  }');
      lines.push('  });');
    }
    lines.push('}');
    lines.push('');
    } // end else (full mode)

    // ════════════════════════════════════════════════════════════
    // 22. Bun.serve()
    // ════════════════════════════════════════════════════════════
    const label = blockName ? ` [${blockName}]` : '';
    const portVar = blockName ? `PORT_${blockName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}` : 'PORT';
    lines.push('// ── Start Server ──');
    lines.push(`const __port = process.env.${portVar} || process.env.PORT || 3000;`);
    // Compression wrapper
    if (compressionConfig) {
      lines.push('const __fetchHandler = async (req) => {');
      lines.push('  const res = await __handleRequest(req);');
      lines.push('  if (!res) return res;');
      lines.push('  return __compressResponse(req, res);');
      lines.push('};');
    }
    lines.push(`const __server = Bun.serve({`);
    lines.push(`  port: __port,`);
    lines.push(`  maxRequestBodySize: __maxBodySize,`);
    lines.push(`  fetch: ${compressionConfig ? '__fetchHandler' : '__handleRequest'},`);
    if (tlsConfig) {
      const certExpr = tlsConfig.cert ? this.genExpression(tlsConfig.cert) : 'undefined';
      const keyExpr = tlsConfig.key ? this.genExpression(tlsConfig.key) : 'undefined';
      lines.push(`  tls: {`);
      lines.push(`    cert: Bun.file(${certExpr}),`);
      lines.push(`    key: Bun.file(${keyExpr}),`);
      if (tlsConfig.ca) {
        lines.push(`    ca: Bun.file(${this.genExpression(tlsConfig.ca)}),`);
      }
      lines.push(`  },`);
    }
    if (wsDecl) {
      lines.push(`  websocket: {`);
      if (wsDecl.handlers.on_open) {
        lines.push(`    open(ws) { __wsClients.add(ws); __wsHandlers.on_open(ws); },`);
      } else {
        lines.push(`    open(ws) { __wsClients.add(ws); },`);
      }
      if (wsDecl.handlers.on_message) {
        lines.push(`    message(ws, message) { __wsHandlers.on_message(ws, message); },`);
      }
      if (wsDecl.handlers.on_close) {
        lines.push(`    close(ws, code, reason) { __wsClients.delete(ws); for (const [,r] of __wsRooms) r.delete(ws); __wsHandlers.on_close(ws, code, reason); },`);
      } else {
        lines.push(`    close(ws) { __wsClients.delete(ws); for (const [,r] of __wsRooms) r.delete(ws); },`);
      }
      if (wsDecl.handlers.on_error) {
        lines.push(`    error(ws, error) { __wsHandlers.on_error(ws, error); },`);
      }
      lines.push(`  },`);
    }
    lines.push(`});`);
    lines.push(`console.log(\`Tova server${label} running on \${__server.url}\`);`);
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 23. on_start hooks (F3) + schedule intervals (F8)
    // ════════════════════════════════════════════════════════════
    if (onStartHooks.length > 0) {
      lines.push('// ── Lifecycle: on_start ──');
      for (let hi = 0; hi < onStartHooks.length; hi++) {
        const hook = onStartHooks[hi];
        const params = hook.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of hook.params) this.declareVar(p.name);
        const body = this.genBlockBody(hook.body);
        this.popScope();
        lines.push(`(async (${params}) => {`);
        lines.push(body);
        lines.push('})();');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 24. Graceful Shutdown — on_stop hooks (F3) + clearInterval (F8)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Graceful Shutdown ──');
    if (isFastMode) {
      lines.push('function __shutdown() { __server.stop(); process.exit(0); }');
    } else {
    lines.push('async function __shutdown() {');
    lines.push(`  console.log(\`Tova server${label} shutting down...\`);`);
    lines.push('  __shuttingDown = true;');
    lines.push('  __server.stop();');
    lines.push('  const __drainStart = Date.now();');
    lines.push('  while (__activeRequests > 0 && Date.now() - __drainStart < 10000) {');
    lines.push('    await new Promise(r => setTimeout(r, 50));');
    lines.push('  }');

    // on_stop hooks
    if (onStopHooks.length > 0) {
      for (let hi = 0; hi < onStopHooks.length; hi++) {
        const hook = onStopHooks[hi];
        const params = hook.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of hook.params) this.declareVar(p.name);
        const body = this.genBlockBody(hook.body);
        this.popScope();
        lines.push(`  await (async (${params}) => {`);
        lines.push(body);
        lines.push('  })();');
      }
    }

    // Schedule cleanup
    if (schedules.length > 0) {
      lines.push('  for (const __iv of __scheduleIntervals) clearInterval(__iv);');
    }

    if (dbConfig || usesDb) {
      if (dbDriver !== 'sqlite') {
        lines.push('  await db.close();');
      } else {
        lines.push('  db.close();');
      }
    }
    if (backgroundJobs.length > 0) {
      lines.push('  // Wait for in-flight background jobs');
      lines.push('  const __bgDrainStart = Date.now();');
      lines.push('  while (__jobProcessing && Date.now() - __bgDrainStart < 5000) {');
      lines.push('    await new Promise(r => setTimeout(r, 50));');
      lines.push('  }');
    }
    lines.push('  if (__logFile) __logFile.end();');
    lines.push('  process.exit(0);');
    lines.push('}');
    } // end else (full shutdown)
    lines.push('process.on("SIGINT", __shutdown);');
    lines.push('process.on("SIGTERM", __shutdown);');

    return lines.join('\n');
  }

  // Helper: emit group middleware chain wrapping a handler call
  _emitGroupMiddlewareChain(lines, groupMws, handler, callArgs, timeoutMs) {
    lines.push(`  const __grpHandler = async (__req) => ${handler}${callArgs};`);
    lines.push(`  const __grpChain = [${groupMws.join(', ')}].reduceRight(`);
    lines.push(`    (next, mw) => async (__req) => mw(__req, next),`);
    lines.push(`    __grpHandler`);
    lines.push(`  );`);
    this._emitHandlerCall(lines, `__grpChain(req)`, timeoutMs);
  }

  generateTests(testBlocks, sharedCode) {
    const lines = [];
    lines.push('import { describe, test, expect } from "bun:test";');
    lines.push('');
    lines.push('// ── Test Helpers ──');
    lines.push('async function request(method, path, options = {}) {');
    lines.push('  const url = new URL(path, "http://localhost");');
    lines.push('  const init = { method };');
    lines.push('  if (options.headers) init.headers = new Headers(options.headers);');
    lines.push('  else init.headers = new Headers();');
    lines.push('  if (options.body) {');
    lines.push('    init.headers.set("Content-Type", "application/json");');
    lines.push('    init.body = JSON.stringify(options.body);');
    lines.push('  }');
    lines.push('  const req = new Request(url.toString(), init);');
    lines.push('  const res = await __handleRequest(req);');
    lines.push('  let data = null;');
    lines.push('  try { data = await res.clone().json(); } catch {}');
    lines.push('  return { status: res.status, headers: Object.fromEntries(res.headers), data, raw: res };');
    lines.push('}');
    lines.push('function assert(condition, message) {');
    lines.push('  if (!condition) throw new Error(message || "Assertion failed");');
    lines.push('}');
    lines.push('');
    // Include top-level definitions (functions, variables) so tests can reference them
    if (sharedCode && sharedCode.trim()) {
      lines.push('// ── Module Code ──');
      lines.push(sharedCode);
      lines.push('');
    }

    for (const block of testBlocks) {
      const name = block.name || 'Tests';
      const blockTimeout = block.timeout || null;
      lines.push(`describe(${JSON.stringify(name)}, () => {`);

      // Emit beforeEach if defined
      if (block.beforeEach && block.beforeEach.length > 0) {
        lines.push('  beforeEach(async () => {');
        this.pushScope();
        for (const s of block.beforeEach) {
          lines.push('    ' + this.generateStatement(s));
        }
        this.popScope();
        lines.push('  });');
      }

      // Emit afterEach if defined
      if (block.afterEach && block.afterEach.length > 0) {
        lines.push('  afterEach(async () => {');
        this.pushScope();
        for (const s of block.afterEach) {
          lines.push('    ' + this.generateStatement(s));
        }
        this.popScope();
        lines.push('  });');
      }

      const hasFnTests = block.body.some(s => s.type === 'FunctionDeclaration');

      if (hasFnTests) {
        // Function declarations become individual test cases
        for (const stmt of block.body) {
          if (stmt.type === 'FunctionDeclaration') {
            const fnName = stmt.name;
            const displayName = fnName.replace(/_/g, ' ');
            this.pushScope();
            for (const p of (stmt.params || [])) {
              const pName = typeof p === 'string' ? p : (p.name || p.identifier);
              if (pName) this.declareVar(pName);
            }
            const body = this.genBlockBody(stmt.body);
            this.popScope();
            const timeoutArg = blockTimeout ? `, ${blockTimeout}` : '';
            lines.push(`  test(${JSON.stringify(displayName)}, async () => {`);
            lines.push(body);
            lines.push(`  }${timeoutArg});`);
          } else {
            lines.push('  ' + this.generateStatement(stmt));
          }
        }
      } else {
        // No function declarations — wrap all statements in a single test case
        const timeoutArg = blockTimeout ? `, ${blockTimeout}` : '';
        lines.push(`  test(${JSON.stringify(name)}, async () => {`);
        for (const stmt of block.body) {
          lines.push('    ' + this.generateStatement(stmt));
        }
        lines.push(`  }${timeoutArg});`);
      }
      lines.push('});');
      lines.push('');
    }

    return lines.join('\n');
  }

  generateBench(benchBlocks, sharedCode) {
    const lines = [];
    lines.push('// ── Tova Benchmark Runner ──');
    lines.push('');
    // Include top-level definitions (functions, variables) so benchmarks can reference them
    if (sharedCode && sharedCode.trim()) {
      lines.push('// ── Module Code ──');
      lines.push(sharedCode);
      lines.push('');
    }
    lines.push('async function __runBench(name, fn, runs) {');
    lines.push('  runs = runs || 100;');
    lines.push('  // Warmup');
    lines.push('  for (let i = 0; i < Math.min(10, runs); i++) await fn();');
    lines.push('  const times = [];');
    lines.push('  for (let i = 0; i < runs; i++) {');
    lines.push('    const start = performance.now();');
    lines.push('    await fn();');
    lines.push('    times.push(performance.now() - start);');
    lines.push('  }');
    lines.push('  times.sort((a, b) => a - b);');
    lines.push('  const sum = times.reduce((a, b) => a + b, 0);');
    lines.push('  const mean = sum / times.length;');
    lines.push('  const p50 = times[Math.floor(times.length * 0.5)];');
    lines.push('  const p99 = times[Math.floor(times.length * 0.99)];');
    lines.push('  console.log(`bench ${JSON.stringify(name)}: mean=${mean.toFixed(2)}ms p50=${p50.toFixed(2)}ms p99=${p99.toFixed(2)}ms (${runs} runs)`);');
    lines.push('}');
    lines.push('');
    lines.push('(async () => {');

    for (const block of benchBlocks) {
      const name = block.name || 'Benchmark';
      lines.push(`  console.log("── ${name.replace(/"/g, '\\"')} ──");`);
      for (const stmt of block.body) {
        if (stmt.type === 'FunctionDeclaration') {
          const fnName = stmt.name;
          const displayName = fnName.replace(/_/g, ' ');
          this.pushScope();
          for (const p of (stmt.params || [])) {
            const pName = typeof p === 'string' ? p : (p.name || p.identifier);
            if (pName) this.declareVar(pName);
          }
          const body = this.genBlockBody(stmt.body);
          this.popScope();
          lines.push(`  await __runBench(${JSON.stringify(displayName)}, async () => {`);
          lines.push(body);
          lines.push('  });');
        } else {
          lines.push('  ' + this.generateStatement(stmt));
        }
      }
      lines.push('');
    }

    lines.push('})();');
    return lines.join('\n');
  }

  _getAiRuntime() {
    return `// AI Client Runtime
function __createAI(config) {
  const providerName = config.provider || 'custom';
  async function __aiRequest(method, args, callOpts = {}) {
    const cfg = { ...config, ...callOpts };
    const baseUrl = cfg.base_url || (providerName === 'anthropic' ? 'https://api.anthropic.com' : providerName === 'ollama' ? 'http://localhost:11434' : 'https://api.openai.com');
    const headers = { 'Content-Type': 'application/json', ...(cfg.headers || {}) };
    if (providerName === 'anthropic') {
      headers['x-api-key'] = cfg.api_key;
      headers['anthropic-version'] = '2023-06-01';
    } else if (cfg.api_key) {
      headers['Authorization'] = 'Bearer ' + cfg.api_key;
    }
    const timeout = cfg.timeout || 60000;

    if (method === 'ask') {
      const [prompt, opts] = args;
      let body, url;
      if (providerName === 'anthropic') {
        body = { model: cfg.model, max_tokens: opts?.max_tokens || cfg.max_tokens || 4096, messages: [{ role: 'user', content: prompt }] };
        if (opts?.temperature ?? cfg.temperature) body.temperature = opts?.temperature ?? cfg.temperature;
        if (opts?.tools) body.tools = opts.tools.map(t => ({ name: t.name, description: t.description, input_schema: { type: 'object', properties: t.params ? Object.fromEntries(Object.entries(t.params).map(([k, v]) => [k, { type: typeof v === 'string' ? v.toLowerCase() : 'string' }])) : {} } }));
        url = baseUrl + '/v1/messages';
      } else if (providerName === 'ollama') {
        body = { model: cfg.model, messages: [{ role: 'user', content: prompt }], stream: false };
        url = baseUrl + '/api/chat';
      } else {
        body = { model: cfg.model, messages: [{ role: 'user', content: prompt }] };
        if (opts?.max_tokens || cfg.max_tokens) body.max_tokens = opts?.max_tokens || cfg.max_tokens;
        if (opts?.temperature ?? cfg.temperature) body.temperature = opts?.temperature ?? cfg.temperature;
        if (opts?.tools) body.tools = opts.tools.map(t => ({ type: 'function', function: { name: t.name, description: t.description, parameters: { type: 'object', properties: t.params ? Object.fromEntries(Object.entries(t.params).map(([k, v]) => [k, { type: typeof v === 'string' ? v.toLowerCase() : 'string' }])) : {} } } }));
        url = baseUrl + '/v1/chat/completions';
      }
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: AbortSignal.timeout(timeout) });
      if (!res.ok) throw new Error(providerName + ' API error ' + res.status + ': ' + (await res.text()));
      const data = await res.json();
      if (providerName === 'anthropic') {
        if (opts?.tools && data.content?.some(c => c.type === 'tool_use')) return { text: data.content.filter(c => c.type === 'text').map(c => c.text).join(''), tool_calls: data.content.filter(c => c.type === 'tool_use') };
        return data.content.map(c => c.text).join('');
      }
      if (providerName === 'ollama') return data.message.content;
      const choice = data.choices[0];
      if (opts?.tools && choice.message.tool_calls) return { text: choice.message.content || '', tool_calls: choice.message.tool_calls };
      return choice.message.content;
    }

    if (method === 'chat') {
      const [messages, opts] = args;
      let body, url;
      if (providerName === 'anthropic') {
        const sys = messages.filter(m => m.role === 'system');
        const msgs = messages.filter(m => m.role !== 'system');
        body = { model: cfg.model, max_tokens: opts?.max_tokens || cfg.max_tokens || 4096, messages: msgs };
        if (sys.length > 0) body.system = sys.map(m => m.content).join('\\n');
        url = baseUrl + '/v1/messages';
      } else if (providerName === 'ollama') {
        body = { model: cfg.model, messages, stream: false };
        url = baseUrl + '/api/chat';
      } else {
        body = { model: cfg.model, messages };
        if (opts?.max_tokens || cfg.max_tokens) body.max_tokens = opts?.max_tokens || cfg.max_tokens;
        url = baseUrl + '/v1/chat/completions';
      }
      if (opts?.temperature ?? cfg.temperature) body.temperature = opts?.temperature ?? cfg.temperature;
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: AbortSignal.timeout(timeout) });
      if (!res.ok) throw new Error(providerName + ' API error ' + res.status + ': ' + (await res.text()));
      const data = await res.json();
      if (providerName === 'anthropic') return data.content.map(c => c.text).join('');
      if (providerName === 'ollama') return data.message.content;
      return data.choices[0].message.content;
    }

    if (method === 'embed') {
      const [input, opts] = args;
      let body, url;
      if (providerName === 'ollama') {
        url = baseUrl + '/api/embeddings';
        if (Array.isArray(input)) {
          const results = [];
          for (const text of input) {
            const r = await fetch(url, { method: 'POST', headers, body: JSON.stringify({ model: cfg.model, prompt: text }) });
            results.push((await r.json()).embedding);
          }
          return results;
        }
        body = { model: cfg.model, prompt: input };
      } else {
        body = { model: cfg.model || 'text-embedding-3-small', input };
        url = baseUrl + '/v1/embeddings';
      }
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: AbortSignal.timeout(timeout) });
      if (!res.ok) throw new Error(providerName + ' API error ' + res.status + ': ' + (await res.text()));
      const data = await res.json();
      if (providerName === 'ollama') return data.embedding;
      if (Array.isArray(input)) return data.data.map(d => d.embedding);
      return data.data[0].embedding;
    }

    if (method === 'extract') {
      const [prompt, schema, opts] = args;
      const extractPrompt = prompt + '\\n\\nRespond with a JSON object matching this schema: ' + JSON.stringify(schema);
      const text = await __aiRequest('ask', [extractPrompt, opts]);
      try { return JSON.parse(text); } catch { return JSON.parse(text.match(/\\{[\\s\\S]*\\}/)?.[0] || '{}'); }
    }

    if (method === 'classify') {
      const [text, categories, opts] = args;
      const catList = Array.isArray(categories) ? categories : Object.keys(categories);
      const classifyPrompt = 'Classify into one of: ' + catList.join(', ') + '\\n\\nText: "' + text + '"\\n\\nRespond with only the category name.';
      const result = (await __aiRequest('ask', [classifyPrompt, { ...opts, max_tokens: 100 }])).trim();
      return catList.find(c => c.toLowerCase() === result.toLowerCase()) || result;
    }

    throw new Error('Unknown AI method: ' + method);
  }

  return {
    ask(prompt, opts) { return __aiRequest('ask', [prompt, opts || {}], opts); },
    chat(messages, opts) { return __aiRequest('chat', [messages, opts || {}], opts); },
    embed(input, opts) { return __aiRequest('embed', [input, opts || {}], opts); },
    extract(prompt, schema, opts) { return __aiRequest('extract', [prompt, schema, opts || {}], opts); },
    classify(text, categories, opts) { return __aiRequest('classify', [text, categories, opts || {}], opts); },
  };
}
`;
  }
}

// ─── src/codegen/client-codegen.js ─────────────────────

class ClientCodegen extends BaseCodegen {
  constructor() {
    super();
    this.stateNames = new Set(); // Track state variable names for setter transforms
    this.computedNames = new Set(); // Track computed variable names for getter transforms
    this.componentNames = new Set(); // Track component names for JSX
    this.storeNames = new Set(); // Track store names
    this._asyncContext = false; // When true, server.xxx() calls emit `await`
    this._rpcCache = new WeakMap(); // Memoize _containsRPC() results
    this._signalCache = new WeakMap(); // Memoize _exprReadsSignal() results
  }

  // AST-walk to check if a subtree contains server.xxx() RPC calls (memoized)
  _containsRPC(node) {
    if (!node) return false;
    const cached = this._rpcCache.get(node);
    if (cached !== undefined) return cached;
    const result = this._containsRPCImpl(node);
    this._rpcCache.set(node, result);
    return result;
  }

  _containsRPCImpl(node) {
    if (node.type === 'CallExpression' && this._isRPCCall(node)) return true;
    if (node.type === 'BlockStatement') return node.body.some(s => this._containsRPC(s));
    if (node.type === 'ExpressionStatement') return this._containsRPC(node.expression);
    if (node.type === 'Assignment') return node.values.some(v => this._containsRPC(v));
    if (node.type === 'VarDeclaration') return node.values.some(v => this._containsRPC(v));
    if (node.type === 'ReturnStatement') return this._containsRPC(node.value);
    if (node.type === 'IfStatement') {
      return this._containsRPC(node.condition) || this._containsRPC(node.consequent) ||
        node.alternates.some(a => this._containsRPC(a.body)) ||
        this._containsRPC(node.elseBody);
    }
    if (node.type === 'IfExpression') {
      return this._containsRPC(node.condition) || this._containsRPC(node.consequent) ||
        (node.alternates && node.alternates.some(a => this._containsRPC(a.condition) || this._containsRPC(a.body))) ||
        this._containsRPC(node.elseBody);
    }
    if (node.type === 'ForStatement') return this._containsRPC(node.iterable) || this._containsRPC(node.body);
    if (node.type === 'WhileStatement') return this._containsRPC(node.condition) || this._containsRPC(node.body);
    if (node.type === 'CallExpression') {
      return this._containsRPC(node.callee) || node.arguments.some(a => this._containsRPC(a));
    }
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
      return this._containsRPC(node.left) || this._containsRPC(node.right);
    }
    if (node.type === 'MemberExpression') return this._containsRPC(node.object);
    if (node.type === 'CompoundAssignment') return this._containsRPC(node.value);
    if (node.type === 'LambdaExpression') return this._containsRPC(node.body);
    if (node.type === 'NamedArgument') return this._containsRPC(node.value);
    if (node.type === 'MatchExpression') {
      return this._containsRPC(node.subject) || node.arms.some(a => this._containsRPC(a.body));
    }
    if (node.type === 'TryCatchStatement') {
      return (node.tryBody && node.tryBody.some(s => this._containsRPC(s))) ||
        (node.catchBody && node.catchBody.some(s => this._containsRPC(s))) ||
        (node.finallyBody && node.finallyBody.some(s => this._containsRPC(s)));
    }
    if (node.type === 'PipeExpression') {
      return this._containsRPC(node.left) || this._containsRPC(node.right);
    }
    if (node.type === 'GuardStatement') {
      return this._containsRPC(node.condition) || this._containsRPC(node.elseBody);
    }
    if (node.type === 'LetDestructure') return this._containsRPC(node.value);
    if (node.type === 'ArrayLiteral') return node.elements.some(e => this._containsRPC(e));
    if (node.type === 'ObjectLiteral') return node.properties.some(p => this._containsRPC(p.value));
    if (node.type === 'SpreadExpression') return this._containsRPC(node.argument);
    if (node.type === 'AwaitExpression') return this._containsRPC(node.argument);
    if (node.type === 'PropagateExpression') return this._containsRPC(node.expression);
    if (node.type === 'UnaryExpression') return this._containsRPC(node.operand);
    if (node.type === 'TemplateLiteral') return node.parts.some(p => p.type === 'expr' && this._containsRPC(p.value));
    if (node.type === 'ChainedComparison') return node.operands.some(o => this._containsRPC(o));
    if (node.type === 'RangeExpression') return this._containsRPC(node.start) || this._containsRPC(node.end);
    if (node.type === 'SliceExpression') return this._containsRPC(node.object) || this._containsRPC(node.start) || this._containsRPC(node.end) || this._containsRPC(node.step);
    if (node.type === 'ListComprehension') return this._containsRPC(node.iterable) || this._containsRPC(node.expression) || this._containsRPC(node.condition);
    if (node.type === 'DictComprehension') return this._containsRPC(node.iterable) || this._containsRPC(node.key) || this._containsRPC(node.value) || this._containsRPC(node.condition);
    if (node.type === 'DeferStatement') return this._containsRPC(node.body);
    return false;
  }

  _isRPCCall(node) {
    return node.type === 'CallExpression' &&
      node.callee.type === 'MemberExpression' &&
      node.callee.object.type === 'Identifier' &&
      node.callee.object.name === 'server';
  }

  // Override genCallExpression to add await for server.xxx() in async context
  genCallExpression(node) {
    const isRPC = this._isRPCCall(node);
    const base = super.genCallExpression(node);
    if (isRPC && this._asyncContext) {
      return `await ${base}`;
    }
    return base;
  }

  // Override to add () for signal/computed reads
  genExpression(node) {
    if (node && node.type === 'Identifier' &&
        (this.stateNames.has(node.name) || this.computedNames.has(node.name))) {
      return `${node.name}()`;
    }
    return super.genExpression(node);
  }

  // Override to transform state assignments to setter calls
  generateStatement(node) {
    if (!node) return '';

    // Intercept compound assignments to state variables: count += 1 → setCount(prev => prev + 1)
    if (node.type === 'CompoundAssignment' && node.target.type === 'Identifier' && this.stateNames.has(node.target.name)) {
      const name = node.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.operator[0]; // += → +, -= → -, etc.
      const val = this.genExpression(node.value);
      return `${this.i()}${setter}(__tova_p => __tova_p ${op} ${val});`;
    }

    // Intercept assignments to state variables: count = 0 → setCount(0)
    if (node.type === 'Assignment' && node.targets.length === 1 && this.stateNames.has(node.targets[0])) {
      const name = node.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.values[0]);
      return `${this.i()}${setter}(${val});`;
    }

    return super.generateStatement(node);
  }

  // Override lambda expression to handle state mutations in lambda bodies
  genLambdaExpression(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const asyncPrefix = node.isAsync ? 'async ' : '';

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      const body = this.genBlockBody(node.body);
      this.popScope();
      if (hasPropagate) {
        return `${asyncPrefix}(${params}) => {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
      }
      return `${asyncPrefix}(${params}) => {\n${body}\n${this.i()}}`;
    }

    // Compound assignment in lambda body: fn() count += 1
    if (node.body.type === 'CompoundAssignment' && node.body.target.type === 'Identifier' && this.stateNames.has(node.body.target.name)) {
      const name = node.body.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.body.operator[0];
      const val = this.genExpression(node.body.value);
      return `${asyncPrefix}(${params}) => { ${setter}(__tova_p => __tova_p ${op} ${val}); }`;
    }

    // Assignment in lambda body: fn() count = 0
    if (node.body.type === 'Assignment' && node.body.targets.length === 1 && this.stateNames.has(node.body.targets[0])) {
      const name = node.body.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.body.values[0]);
      return `${asyncPrefix}(${params}) => { ${setter}(${val}); }`;
    }

    // Non-state statement bodies
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      this.indent++;
      const stmt = super.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `${asyncPrefix}(${params}) => { ${stmt.trim()} }`;
    }

    if (hasPropagate) {
      return `${asyncPrefix}(${params}) => { try { return ${this.genExpression(node.body)}; } catch (__e) { if (__e && __e.__tova_propagate) return __e.value; throw __e; } }`;
    }
    return `${asyncPrefix}(${params}) => ${this.genExpression(node.body)}`;
  }

  generate(clientBlocks, sharedCode, sharedBuiltins = null) {
    this._sharedBuiltins = sharedBuiltins || new Set();
    const lines = [];

    // Runtime imports
    lines.push(`import { createSignal, createEffect, createComputed, mount, hydrate, tova_el, tova_fragment, tova_keyed, tova_transition, tova_inject_css, batch, onMount, onUnmount, onCleanup, onBeforeUpdate, createRef, createContext, provide, inject, createErrorBoundary, ErrorBoundary, ErrorInfo, createRoot, watch, untrack, Dynamic, Portal, lazy, Suspense, __tova_action } from './runtime/reactivity.js';`);
    lines.push(`import { rpc } from './runtime/rpc.js';`);

    // Hoist import lines from shared code to the top of the module
    let sharedRest = sharedCode;
    if (sharedCode.trim()) {
      const sharedLines = sharedCode.split('\n');
      const importLines = [];
      const nonImportLines = [];
      for (const line of sharedLines) {
        if (/^\s*import\s+/.test(line)) {
          importLines.push(line);
        } else {
          nonImportLines.push(line);
        }
      }
      if (importLines.length > 0) {
        for (const imp of importLines) {
          lines.push(imp);
        }
      }
      sharedRest = nonImportLines.join('\n');
    }

    lines.push('');

    // Shared code (non-import lines)
    if (sharedRest.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedRest);
      lines.push('');
    }

    // Stdlib placeholder — filled after all client code is generated so tree-shaking sees all usages
    const stdlibPlaceholderIdx = lines.length;
    lines.push('// ── Stdlib ──');
    lines.push('__STDLIB_PLACEHOLDER__');
    lines.push('');

    // Server RPC proxy
    lines.push('// ── Server RPC Proxy ──');
    lines.push('const server = new Proxy({}, {');
    lines.push('  get(_, name) {');
    lines.push('    return (...args) => rpc(name, args);');
    lines.push('  }');
    lines.push('});');
    lines.push('');

    const states = [];
    const computeds = [];
    const effects = [];
    const components = [];
    const stores = [];
    const imports = [];
    const other = [];

    for (const block of clientBlocks) {
      for (const stmt of block.body) {
        switch (stmt.type) {
          case 'StateDeclaration': states.push(stmt); break;
          case 'ComputedDeclaration': computeds.push(stmt); break;
          case 'EffectDeclaration': effects.push(stmt); break;
          case 'ComponentDeclaration': components.push(stmt); break;
          case 'StoreDeclaration': stores.push(stmt); break;
          case 'ImportDeclaration': imports.push(stmt); break;
          case 'ImportDefault': imports.push(stmt); break;
          case 'ImportWildcard': imports.push(stmt); break;
          default: other.push(stmt); break;
        }
      }
    }

    // Generate client block imports (hoisted after runtime imports)
    if (imports.length > 0) {
      lines.push('// ── Client Imports ──');
      for (const stmt of imports) {
        lines.push(this.generateStatement(stmt));
      }
      lines.push('');
    }

    // Register state names for setter transforms
    for (const s of states) {
      this.stateNames.add(s.name);
    }

    // Register computed names for getter transforms
    for (const c of computeds) {
      this.computedNames.add(c.name);
    }

    // Register component names
    for (const comp of components) {
      this.componentNames.add(comp.name);
    }

    // Register store names
    for (const store of stores) {
      this.storeNames.add(store.name);
    }

    // Generate state signals
    if (states.length > 0) {
      lines.push('// ── Reactive State ──');
      for (const s of states) {
        const init = this.genExpression(s.initialValue);
        lines.push(`const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});`);
      }
      lines.push('');
    }

    // Generate computed values
    if (computeds.length > 0) {
      lines.push('// ── Computed Values ──');
      for (const c of computeds) {
        const expr = this.genExpression(c.expression);
        lines.push(`const ${c.name} = createComputed(() => ${expr});`);
      }
      lines.push('');
    }

    // Generate stores
    if (stores.length > 0) {
      lines.push('// ── Stores ──');
      for (const store of stores) {
        lines.push(this.generateStore(store));
        lines.push('');
      }
    }

    // Generate other statements
    for (const stmt of other) {
      lines.push(this.generateStatement(stmt));
    }

    // Generate components
    if (components.length > 0) {
      lines.push('// ── Components ──');
      for (const comp of components) {
        lines.push(this.generateComponent(comp));
        lines.push('');
      }
    }

    // Generate effects
    if (effects.length > 0) {
      lines.push('// ── Effects ──');
      for (const e of effects) {
        lines.push(this._generateEffect(e.body));
        lines.push('');
      }
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push('// ── Runtime Helpers ──');
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // Auto-mount the App component if it exists
    // Auto-detect SSR: if the container already has children, hydrate instead of mount
    const hasApp = components.some(c => c.name === 'App');
    if (hasApp) {
      lines.push('// ── Mount ──');
      lines.push('document.addEventListener("DOMContentLoaded", () => {');
      lines.push('  const container = document.getElementById("app") || document.body;');
      lines.push('  if (container.children.length > 0) {');
      lines.push('    hydrate(App, container);');
      lines.push('  } else {');
      lines.push('    mount(App, container);');
      lines.push('  }');
      lines.push('});');
    }

    // Replace stdlib placeholder now that all client code has been generated
    lines[stdlibPlaceholderIdx + 1] = this.getStdlibCore();

    return lines.join('\n');
  }

  _generateEffect(body) {
    const hasRPC = this._containsRPC(body);
    const p = [];
    if (hasRPC) {
      p.push(`createEffect(() => {\n`);
      p.push(`${this.i()}  (async () => {\n`);
      this.indent += 2;
      const prevAsync = this._asyncContext;
      this._asyncContext = true;
      p.push(this.genBlockStatements(body));
      this._asyncContext = prevAsync;
      this.indent -= 2;
      p.push(`\n${this.i()}  })();\n`);
      p.push(`${this.i()}});`);
    } else {
      p.push(`createEffect(() => {\n`);
      this.indent++;
      p.push(this.genBlockStatements(body));
      this.indent--;
      p.push(`\n${this.i()}});`);
    }
    return p.join('');
  }

  // Generate a short hash from component name + CSS content (for CSS scoping)
  _genScopeId(name, css) {
    const str = name + ':' + (css || '');
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = ((h << 5) - h + str.charCodeAt(i)) | 0;
    }
    return Math.abs(h).toString(36).slice(0, 6);
  }

  // Scope CSS selectors by appending [data-tova-HASH] to each selector
  // Uses a lightweight tokenizer to properly handle:
  // - @media, @keyframes, @layer blocks (don't scope their content selectors)
  // - :is(), :where(), :has() pseudo-functions
  // - :global() escape hatch (strip wrapper, don't scope)
  // - CSS comments /* */
  // - Nested CSS
  // - Multiple rules in sequence
  _scopeCSS(css, scopeAttr) {
    const result = [];
    let i = 0;
    let depth = 0;
    let buf = '';
    const noScopeDepths = new Set(); // Depths where we DON'T scope (property decls, @keyframes, @font-face)

    while (i < css.length) {
      // Skip CSS comments
      if (css[i] === '/' && css[i + 1] === '*') {
        const end = css.indexOf('*/', i + 2);
        if (end === -1) { buf += css.slice(i); break; }
        buf += css.slice(i, end + 2);
        i = end + 2;
        continue;
      }

      // Skip quoted strings
      if (css[i] === '"' || css[i] === "'") {
        const q = css[i];
        buf += css[i++];
        while (i < css.length && css[i] !== q) {
          if (css[i] === '\\') buf += css[i++];
          buf += css[i++];
        }
        if (i < css.length) buf += css[i++];
        continue;
      }

      // Opening brace — process accumulated buf as selector or pass through
      if (css[i] === '{') {
        const trimmed = buf.trim();

        if (noScopeDepths.has(depth)) {
          // Inside a no-scope context (property declarations, @keyframes) — pass through
          result.push(buf + '{');
        } else if (trimmed.startsWith('@')) {
          // @keyframes, @font-face: mark inner as no-scope
          if (/^@keyframes\s/.test(trimmed) || /^@font-face/.test(trimmed)) {
            noScopeDepths.add(depth + 1);
          }
          // @media, @supports, @layer: keep scoping inside (don't mark)
          result.push(buf + '{');
        } else {
          // Regular selector — scope it and mark inner depth as no-scope (property declarations)
          const scopedSelectors = buf.split(',').map(s => {
            s = s.trim();
            if (!s || s === 'from' || s === 'to' || /^\d+%$/.test(s)) return s;
            return this._scopeSelector(s, scopeAttr);
          }).join(', ');
          result.push(scopedSelectors + '{');
          noScopeDepths.add(depth + 1);
        }

        depth++;
        buf = '';
        i++;
        continue;
      }

      // Closing brace
      if (css[i] === '}') {
        result.push(buf + '}');
        buf = '';
        noScopeDepths.delete(depth);
        depth--;
        i++;
        continue;
      }

      // Accumulate character
      buf += css[i];
      i++;
    }

    if (buf) result.push(buf);
    return result.join('');
  }

  // Scope a single CSS selector
  _scopeSelector(selector, scopeAttr) {
    let s = selector.trim();

    // :global() escape hatch — strip wrapper, don't scope
    if (s.startsWith(':global(') && s.endsWith(')')) {
      return s.slice(8, -1);
    }
    // Inline :global() in the middle of a selector
    s = s.replace(/:global\(([^)]+)\)/g, '$1');

    // Handle pseudo-elements (::before, ::after, ::placeholder, etc.)
    const pseudoElMatch = s.match(/(::[\w-]+(?:\([^)]*\))?)$/);
    if (pseudoElMatch) {
      return s.slice(0, -pseudoElMatch[0].length) + scopeAttr + pseudoElMatch[0];
    }
    // Handle pseudo-classes with functions (:is(), :where(), :has(), :not(), :hover, etc.)
    const pseudoClsMatch = s.match(/((?::[\w-]+(?:\([^)]*\))?)+)$/);
    if (pseudoClsMatch) {
      const pseudoPart = pseudoClsMatch[0];
      const basePart = s.slice(0, -pseudoPart.length);
      if (basePart.trim()) {
        return basePart + scopeAttr + pseudoPart;
      }
    }
    return s + scopeAttr;
  }

  generateComponent(comp) {
    const hasParams = comp.params.length > 0;
    const paramStr = hasParams ? '__props' : '';

    // Save state/computed names so component-local names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);

    const p = [];
    p.push(`function ${comp.name}(${paramStr}) {\n`);
    this.indent++;

    // Generate reactive prop accessors — each prop is accessed through __props getter
    // This ensures parent signal changes propagate reactively to the child
    if (hasParams) {
      for (const param of comp.params) {
        this.computedNames.add(param.name);
        const def = param.default || param.defaultValue;
        if (def) {
          const defaultExpr = this.genExpression(def);
          p.push(`${this.i()}const ${param.name} = () => __props.${param.name} !== undefined ? __props.${param.name} : ${defaultExpr};\n`);
        } else {
          p.push(`${this.i()}const ${param.name} = () => __props.${param.name};\n`);
        }
      }
    }

    // Separate JSX elements, style blocks, and statements
    const jsxElements = [];
    const styleBlocks = [];
    const bodyItems = [];

    for (const node of comp.body) {
      if (node.type === 'JSXElement' || node.type === 'JSXFragment' || node.type === 'JSXFor' || node.type === 'JSXIf') {
        jsxElements.push(node);
      } else if (node.type === 'ComponentStyleBlock') {
        styleBlocks.push(node);
      } else {
        bodyItems.push(node);
      }
    }

    // Set up scoped CSS if style blocks exist
    const savedScopeId = this._currentScopeId;
    if (styleBlocks.length > 0) {
      const rawCSS = styleBlocks.map(s => s.css).join('\n');
      const scopeId = this._genScopeId(comp.name, rawCSS);
      this._currentScopeId = scopeId;
      const scopedCSS = this._scopeCSS(rawCSS, `[data-tova-${scopeId}]`);
      p.push(`${this.i()}tova_inject_css(${JSON.stringify(scopeId)}, ${JSON.stringify(scopedCSS)});\n`);
    }

    // Generate body items in order (state, computed, effect, other statements)
    for (const node of bodyItems) {
      if (node.type === 'StateDeclaration') {
        this.stateNames.add(node.name);
        const init = this.genExpression(node.initialValue);
        p.push(`${this.i()}const [${node.name}, set${capitalize(node.name)}] = createSignal(${init});\n`);
      } else if (node.type === 'ComputedDeclaration') {
        this.computedNames.add(node.name);
        const expr = this.genExpression(node.expression);
        p.push(`${this.i()}const ${node.name} = createComputed(() => ${expr});\n`);
      } else if (node.type === 'EffectDeclaration') {
        this.indent++;
        const effectCode = this._generateEffect(node.body);
        this.indent--;
        p.push(`${this.i()}${effectCode}\n`);
      } else {
        p.push(this.generateStatement(node) + '\n');
      }
    }

    // Generate JSX return
    if (jsxElements.length === 1) {
      p.push(`${this.i()}return ${this.genJSX(jsxElements[0])};\n`);
    } else if (jsxElements.length > 1) {
      const children = jsxElements.map(el => this.genJSX(el)).join(', ');
      p.push(`${this.i()}return tova_fragment([${children}]);\n`);
    }

    this.indent--;
    p.push(`}`);

    // Restore scoped names and scope id
    this.stateNames = savedState;
    this.computedNames = savedComputed;
    this._currentScopeId = savedScopeId;

    return p.join('');
  }

  generateStore(store) {
    // Save/restore state and computed names so store-internal names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);

    // Collect store-local state and computed names
    const storeStates = [];
    const storeComputeds = [];
    const storeFunctions = [];

    for (const node of store.body) {
      if (node.type === 'StateDeclaration') {
        storeStates.push(node);
        this.stateNames.add(node.name);
      } else if (node.type === 'ComputedDeclaration') {
        storeComputeds.push(node);
        this.computedNames.add(node.name);
      } else if (node.type === 'FunctionDeclaration') {
        storeFunctions.push(node);
      }
    }

    const p = [];
    p.push(`const ${store.name} = (() => {\n`);
    this.indent++;

    // Generate state signals
    for (const s of storeStates) {
      const init = this.genExpression(s.initialValue);
      p.push(`${this.i()}const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});\n`);
    }

    // Generate computed values
    for (const c of storeComputeds) {
      const expr = this.genExpression(c.expression);
      p.push(`${this.i()}const ${c.name} = createComputed(() => ${expr});\n`);
    }

    // Generate functions
    for (const fn of storeFunctions) {
      p.push(this.genFunctionDeclaration(fn) + '\n');
    }

    // Build return object with getters/setters
    p.push(`${this.i()}return {\n`);
    this.indent++;

    for (const s of storeStates) {
      p.push(`${this.i()}get ${s.name}() { return ${s.name}(); },\n`);
      p.push(`${this.i()}set ${s.name}(v) { set${capitalize(s.name)}(v); },\n`);
    }

    for (const c of storeComputeds) {
      p.push(`${this.i()}get ${c.name}() { return ${c.name}(); },\n`);
    }

    for (const fn of storeFunctions) {
      p.push(`${this.i()}${fn.name},\n`);
    }

    this.indent--;
    p.push(`${this.i()}};\n`);

    this.indent--;
    p.push(`${this.i()}})();`);

    // Restore state/computed names
    this.stateNames = savedState;
    this.computedNames = savedComputed;

    return p.join('');
  }

  // Check if an AST expression references any signal/computed name (memoized)
  _exprReadsSignal(node) {
    if (!node) return false;
    // Cannot cache Identifier lookups — result depends on current stateNames/computedNames
    if (node.type === 'Identifier') return this.stateNames.has(node.name) || this.computedNames.has(node.name);
    const cached = this._signalCache.get(node);
    if (cached !== undefined) return cached;
    const result = this._exprReadsSignalImpl(node);
    this._signalCache.set(node, result);
    return result;
  }

  _exprReadsSignalImpl(node) {
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
      return this._exprReadsSignal(node.left) || this._exprReadsSignal(node.right);
    }
    if (node.type === 'UnaryExpression') return this._exprReadsSignal(node.operand);
    if (node.type === 'CallExpression') {
      return this._exprReadsSignal(node.callee) || node.arguments.some(a => this._exprReadsSignal(a));
    }
    if (node.type === 'MemberExpression') {
      if (node.object.type === 'Identifier' && this.storeNames.has(node.object.name)) {
        return true; // Store property access is reactive (getters call signals)
      }
      return this._exprReadsSignal(node.object) || (node.computed && this._exprReadsSignal(node.property));
    }
    if (node.type === 'OptionalChain') {
      return this._exprReadsSignal(node.object) || (node.computed && this._exprReadsSignal(node.property));
    }
    if (node.type === 'TemplateLiteral') {
      return node.parts.some(p => p.type === 'expr' && this._exprReadsSignal(p.value));
    }
    if (node.type === 'ChainedComparison') return node.operands.some(o => this._exprReadsSignal(o));
    if (node.type === 'PipeExpression') return this._exprReadsSignal(node.left) || this._exprReadsSignal(node.right);
    if (node.type === 'ArrayLiteral') return node.elements.some(e => this._exprReadsSignal(e));
    if (node.type === 'ObjectLiteral') return node.properties.some(p => this._exprReadsSignal(p.value));
    if (node.type === 'IfExpression') {
      return this._exprReadsSignal(node.condition) || this._exprReadsSignal(node.consequent) ||
        (node.alternates && node.alternates.some(a => this._exprReadsSignal(a.condition) || this._exprReadsSignal(a.body))) ||
        this._exprReadsSignal(node.elseBody);
    }
    if (node.type === 'MatchExpression') {
      if (this._exprReadsSignal(node.subject)) return true;
      return node.arms.some(arm => this._exprReadsSignal(arm.body));
    }
    if (node.type === 'SpreadExpression') return this._exprReadsSignal(node.argument);
    if (node.type === 'AwaitExpression') return this._exprReadsSignal(node.argument);
    if (node.type === 'RangeExpression') return this._exprReadsSignal(node.start) || this._exprReadsSignal(node.end);
    if (node.type === 'SliceExpression') return this._exprReadsSignal(node.object) || this._exprReadsSignal(node.start) || this._exprReadsSignal(node.end);
    if (node.type === 'ListComprehension') return this._exprReadsSignal(node.iterable) || this._exprReadsSignal(node.expression);
    if (node.type === 'LambdaExpression') return this._exprReadsSignal(node.body);
    if (node.type === 'PropagateExpression') return this._exprReadsSignal(node.expression);
    return false;
  }

  genJSX(node) {
    if (!node) return 'null';

    switch (node.type) {
      case 'JSXElement': return this.genJSXElement(node);
      case 'JSXFragment': return this.genJSXFragment(node);
      case 'JSXText': return this.genJSXText(node);
      case 'JSXExpression': {
        // If expression reads a signal, wrap as () => expr for fine-grained reactivity
        const expr = this.genExpression(node.expression);
        if (this._exprReadsSignal(node.expression)) {
          return `() => ${expr}`;
        }
        return expr;
      }
      case 'JSXFor': return this.genJSXFor(node);
      case 'JSXIf': return this.genJSXIf(node);
      case 'JSXMatch': return this.genJSXMatch(node);
      default: return this.genExpression(node);
    }
  }

  genJSXElement(node) {
    // <slot /> or <slot name="header" /> — render children passed from parent
    if (node.tag === 'slot') {
      const nameAttr = node.attributes.find(a => a.name === 'name');
      const slotProps = node.attributes.filter(a => a.name !== 'name');

      if (nameAttr && nameAttr.value.type === 'StringLiteral') {
        // Named slot: <slot name="header" />
        const slotName = nameAttr.value.value;
        return `(__props.${slotName} || '')`;
      }

      if (slotProps.length > 0) {
        // Scoped slot: <slot count={count()} /> — pass props to render function
        const propParts = slotProps.map(a => {
          const val = this.genExpression(a.value);
          return `${a.name}: ${val}`;
        });
        return `(typeof __props.children === 'function' ? __props.children({${propParts.join(', ')}}) : (__props.children || ''))`;
      }

      // Default slot: <slot />
      return `(__props.children || '')`;
    }

    const isComponent = node.tag[0] === node.tag[0].toUpperCase() && /^[A-Z]/.test(node.tag);

    // Attributes
    const attrs = {};
    const events = {};
    const classDirectives = [];
    const spreads = []; // collected spread expressions

    for (const attr of node.attributes) {
      if (attr.type === 'JSXSpreadAttribute') {
        spreads.push(this.genExpression(attr.expression));
        continue;
      }
      if (attr.name === 'bind:value') {
        // Two-way binding: bind:value={name} → reactive value + event handler
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs.value = reactive ? `() => ${expr}` : expr;
        const exprName = attr.value.name;
        if (this.stateNames.has(exprName)) {
          // <select> fires 'change', all other inputs fire 'input'
          const eventName = node.tag === 'select' ? 'change' : 'input';
          // For number/range inputs, coerce e.target.value to Number
          const typeAttr = node.attributes.find(a => a.name === 'type');
          const typeStr = typeAttr && typeAttr.value ? (typeAttr.value.value || '') : '';
          const isNumeric = typeStr === 'number' || typeStr === 'range';
          const valueExpr = isNumeric ? 'Number(e.target.value)' : 'e.target.value';
          events[eventName] = `(e) => { set${capitalize(exprName)}(${valueExpr}); }`;
        }
      } else if (attr.name === 'bind:checked') {
        // Two-way binding: bind:checked={flag} → reactive checked + onChange
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs.checked = reactive ? `() => ${expr}` : expr;
        const exprName = attr.value.name;
        if (this.stateNames.has(exprName)) {
          events.change = `(e) => { set${capitalize(exprName)}(e.target.checked); }`;
        }
      } else if (attr.name === 'bind:group') {
        // Radio/checkbox group binding
        // For radio: bind:group={selected} → checked = selected === value, onChange sets selected = value
        // For checkbox: bind:group={items} → checked = items.includes(value), onChange toggles value in array
        const expr = this.genExpression(attr.value);
        const exprName = attr.value.name;
        const reactive = this._exprReadsSignal(attr.value);
        // Determine type from other attributes
        const typeAttr = node.attributes.find(a => a.name === 'type');
        const typeStr = typeAttr ? (typeAttr.value.value || '') : '';
        const valueAttr = node.attributes.find(a => a.name === 'value');
        const valueExpr = valueAttr ? this.genExpression(valueAttr.value) : '""';

        if (typeStr === 'checkbox') {
          // Array-based: checked when array includes value
          attrs.checked = reactive
            ? `() => ${expr}.includes(${valueExpr})`
            : `${expr}.includes(${valueExpr})`;
          if (this.stateNames.has(exprName)) {
            events.change = `(e) => { const v = ${valueExpr}; if (e.target.checked) { set${capitalize(exprName)}(__tova_p => [...__tova_p, v]); } else { set${capitalize(exprName)}(__tova_p => __tova_p.filter(x => x !== v)); } }`;
          }
        } else {
          // Radio: single value
          attrs.checked = reactive
            ? `() => ${expr} === ${valueExpr}`
            : `${expr} === ${valueExpr}`;
          if (this.stateNames.has(exprName)) {
            events.change = `(e) => { set${capitalize(exprName)}(${valueExpr}); }`;
          }
        }
      } else if (attr.name === 'show') {
        // show={condition} → toggles display:none instead of removing from DOM
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        const displayExpr = `(${expr}) ? "" : "none"`;
        // Store show directive to merge with style later
        node._showDirective = { expr: displayExpr, reactive };
      } else if (attr.name.startsWith('class:')) {
        // Conditional class: class:active={cond}
        const className = attr.name.slice(6);
        classDirectives.push({ className, condition: this.genExpression(attr.value), node: attr.value });
      } else if (attr.name.startsWith('use:')) {
        // use:action directive: use:tooltip={params}
        const actionName = attr.name.slice(4);
        const param = attr.value.type === 'BooleanLiteral' ? 'undefined' : this.genExpression(attr.value);
        const reactive = attr.value.type !== 'BooleanLiteral' && this._exprReadsSignal(attr.value);
        if (!node._actions) node._actions = [];
        node._actions.push({ name: actionName, param, reactive });
      } else if (attr.name.startsWith('in:')) {
        // in:fade — enter-only transition
        const transName = attr.name.slice(3);
        const config = attr.value.type === 'BooleanLiteral' ? '{}' : this.genExpression(attr.value);
        node._inTransition = { name: transName, config };
      } else if (attr.name.startsWith('out:')) {
        // out:slide — leave-only transition
        const transName = attr.name.slice(4);
        const config = attr.value.type === 'BooleanLiteral' ? '{}' : this.genExpression(attr.value);
        node._outTransition = { name: transName, config };
      } else if (attr.name.startsWith('transition:')) {
        // transition:fade, transition:slide={duration: 300}, etc.
        const transName = attr.name.slice(11); // 'fade', 'slide', 'scale', 'fly'
        const builtins = new Set(['fade', 'slide', 'scale', 'fly']);
        const config = attr.value.type === 'BooleanLiteral' ? '{}' : this.genExpression(attr.value);
        // Store transition info for element wrapping
        if (!node._transitions) node._transitions = [];
        node._transitions.push({ name: transName, config, custom: !builtins.has(transName) });
      } else if (attr.name === 'bind:this') {
        // bind:this={ref} → ref: refValue (works with both ref objects and functions)
        attrs.ref = this.genExpression(attr.value);
      } else if (attr.name.startsWith('on:')) {
        const fullName = attr.name.slice(3); // e.g. "click.stop.prevent"
        const parts = fullName.split('.');
        const eventName = parts[0];
        const modifiers = parts.slice(1);
        let handler = this.genExpression(attr.value);

        if (modifiers.length > 0) {
          const guards = [];
          let useCapture = false;
          let useOnce = false;

          // Key modifier map for keydown/keyup events
          const keyMap = {
            enter: '"Enter"', escape: '"Escape"', tab: '"Tab"', space: '" "',
            up: '"ArrowUp"', down: '"ArrowDown"', left: '"ArrowLeft"', right: '"ArrowRight"',
            delete: '"Delete"', backspace: '"Backspace"',
          };

          for (const mod of modifiers) {
            if (mod === 'prevent') {
              guards.push('e.preventDefault()');
            } else if (mod === 'stop') {
              guards.push('e.stopPropagation()');
            } else if (mod === 'self') {
              guards.push('if (e.target !== e.currentTarget) return');
            } else if (mod === 'capture') {
              useCapture = true;
            } else if (mod === 'once') {
              useOnce = true;
            } else if (keyMap[mod]) {
              guards.push(`if (e.key !== ${keyMap[mod]}) return`);
            }
          }

          if (guards.length > 0) {
            handler = `(e) => { ${guards.join('; ')}; (${handler})(e); }`;
          }

          if (useCapture || useOnce) {
            const opts = [];
            if (useCapture) opts.push('capture: true');
            if (useOnce) opts.push('once: true');
            handler = `{ handler: ${handler}, options: { ${opts.join(', ')} } }`;
          }
        }

        events[eventName] = handler;
      } else {
        const attrName = attr.name === 'class' ? 'className' : attr.name;
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs[attrName] = reactive ? `() => ${expr}` : expr;
      }
    }

    // Merge class directives with className
    if (classDirectives.length > 0) {
      const parts = [];
      if (attrs.className) {
        parts.push(attrs.className);
      }
      for (const { className, condition } of classDirectives) {
        parts.push(`${condition} && "${className}"`);
      }
      const isReactive = classDirectives.some(d => this._exprReadsSignal(d.node));
      const classExpr = `[${parts.join(', ')}].filter(Boolean).join(" ")`;
      attrs.className = isReactive ? `() => ${classExpr}` : classExpr;
    }

    // Merge show directive with style (show toggles display:none)
    if (node._showDirective) {
      const { expr: displayExpr, reactive } = node._showDirective;
      if (attrs.style) {
        // Merge with existing style object
        const existing = attrs.style;
        if (reactive) {
          attrs.style = `() => Object.assign({}, ${existing}, { display: ${displayExpr} })`;
        } else {
          attrs.style = `Object.assign({}, ${existing}, { display: ${displayExpr} })`;
        }
      } else {
        attrs.style = reactive
          ? `() => ({ display: ${displayExpr} })`
          : `{ display: ${displayExpr} }`;
      }
    }

    // Add scoped CSS attribute to HTML elements (not components)
    if (this._currentScopeId && !isComponent) {
      attrs[`"data-tova-${this._currentScopeId}"`] = '""';
    }

    const propParts = [];
    const memoizedProps = []; // Computed memoization for complex expressions
    for (const [key, val] of Object.entries(attrs)) {
      // For component props, convert reactive () => wrappers to JS getter syntax
      // so the prop stays reactive through the __props access pattern
      if (isComponent && spreads.length === 0 && typeof val === 'string' && val.startsWith('() => ')) {
        const rawExpr = val.slice(6);
        // Simple signal read: just use a getter (no overhead)
        // Complex expressions: memoize with createComputed
        const isSimple = /^[a-zA-Z_$]\w*\(\)$/.test(rawExpr);
        if (isSimple) {
          propParts.push(`get ${key}() { return ${rawExpr}; }`);
        } else {
          const memoName = `__memo_${key}`;
          memoizedProps.push(`const ${memoName} = createComputed(() => ${rawExpr})`);
          propParts.push(`get ${key}() { return ${memoName}(); }`);
        }
      } else {
        propParts.push(`${key}: ${val}`);
      }
    }
    for (const [event, handler] of Object.entries(events)) {
      propParts.push(`on${capitalize(event)}: ${handler}`);
    }

    // Build props object, merging spreads if present
    let propsStr;
    if (spreads.length > 0) {
      const ownProps = `{${propParts.join(', ')}}`;
      propsStr = `Object.assign({}, ${spreads.join(', ')}, ${ownProps})`;
    } else {
      propsStr = `{${propParts.join(', ')}}`;
    }

    // Components: call as function, passing props (with children if any)
    if (isComponent) {
      if (!node.selfClosing && node.children.length > 0) {
        // Named slots: children with slot="name" become named props
        const defaultChildren = [];
        const namedSlots = {};

        for (const child of node.children) {
          if (child.type === 'JSXElement') {
            const slotAttr = child.attributes.find(a => a.name === 'slot');
            if (slotAttr && slotAttr.value.type === 'StringLiteral') {
              const slotName = slotAttr.value.value;
              if (!namedSlots[slotName]) namedSlots[slotName] = [];
              namedSlots[slotName].push(child);
              continue;
            }
          }
          defaultChildren.push(child);
        }

        // Add named slot props
        for (const [slotName, slotChildren] of Object.entries(namedSlots)) {
          const slotContent = slotChildren.map(c => this.genJSX(c)).join(', ');
          propParts.push(`${slotName}: [${slotContent}]`);
        }

        if (defaultChildren.length > 0) {
          const children = defaultChildren.map(c => this.genJSX(c)).join(', ');
          propParts.push(`children: [${children}]`);
        }

        if (spreads.length > 0) {
          propsStr = `Object.assign({}, ${spreads.join(', ')}, {${propParts.join(', ')}})`;
        } else {
          propsStr = `{${propParts.join(', ')}}`;
        }
      }
      if (memoizedProps.length > 0) {
        return `(() => { ${memoizedProps.join('; ')}; const __v = ${node.tag}(${propsStr}); if (__v && __v.__tova) __v._componentName = "${node.tag}"; return __v; })()`;
      }
      return `((__tova_v) => (__tova_v && __tova_v.__tova && (__tova_v._componentName = "${node.tag}"), __tova_v))(${node.tag}(${propsStr}))`;
    }

    const tag = JSON.stringify(node.tag);

    let result;
    if (node.selfClosing || node.children.length === 0) {
      result = `tova_el(${tag}, ${propsStr})`;
    } else {
      const children = node.children.map(c => this.genJSX(c)).join(', ');
      result = `tova_el(${tag}, ${propsStr}, [${children}])`;
    }

    // Wrap with transition directives if present
    if (node._transitions && node._transitions.length > 0) {
      for (const t of node._transitions) {
        if (t.custom) {
          result = `tova_transition(${result}, ${t.name}, ${t.config})`;
        } else {
          result = `tova_transition(${result}, "${t.name}", ${t.config})`;
        }
      }
    }

    // Wrap with directional transitions if present
    if (node._inTransition || node._outTransition) {
      const inPart = node._inTransition ? `in: { name: "${node._inTransition.name}", config: ${node._inTransition.config} }` : '';
      const outPart = node._outTransition ? `out: { name: "${node._outTransition.name}", config: ${node._outTransition.config} }` : '';
      const parts = [inPart, outPart].filter(Boolean).join(', ');
      result = `tova_transition(${result}, { ${parts} })`;
    }

    // Wrap with use: action directives if present
    if (node._actions && node._actions.length > 0) {
      for (const a of node._actions) {
        if (a.reactive) {
          result = `__tova_action(${result}, ${a.name}, () => ${a.param})`;
        } else {
          result = `__tova_action(${result}, ${a.name}, ${a.param})`;
        }
      }
    }

    return result;
  }

  genJSXText(node) {
    if (node.value.type === 'StringLiteral') {
      return JSON.stringify(node.value.value);
    }
    if (node.value.type === 'TemplateLiteral') {
      const code = this.genTemplateLiteral(node.value);
      // Wrap in reactive closure if the template reads signals
      if (this._exprReadsSignal(node.value)) {
        return `() => ${code}`;
      }
      return code;
    }
    return this.genExpression(node.value);
  }

  _genJSXForVar(variable) {
    if (typeof variable === 'string') return variable;
    if (variable.type === 'ArrayPattern') {
      return `[${variable.elements.join(', ')}]`;
    }
    if (variable.type === 'ObjectPattern') {
      return `{${variable.properties.map(p => p.value ? `${p.key}: ${p.value}` : p.key).join(', ')}}`;
    }
    return String(variable);
  }

  genJSXFor(node) {
    const varName = this._genJSXForVar(node.variable);
    const iterable = this.genExpression(node.iterable);
    const children = node.body.map(c => this.genJSX(c));
    const needsReactive = this._exprReadsSignal(node.iterable);
    const wrap = needsReactive ? '() => ' : '';

    if (node.keyExpr) {
      const keyExpr = this.genExpression(node.keyExpr);
      if (children.length === 1) {
        return `${wrap}${iterable}.map((${varName}) => tova_keyed(${keyExpr}, ${children[0]}))`;
      }
      return `${wrap}${iterable}.map((${varName}) => tova_keyed(${keyExpr}, tova_fragment([${children.join(', ')}])))`;
    }

    if (children.length === 1) {
      return `${wrap}${iterable}.map((${varName}) => ${children[0]})`;
    }
    return `${wrap}${iterable}.map((${varName}) => tova_fragment([${children.join(', ')}]))`;
  }

  genJSXIf(node) {
    const cond = this.genExpression(node.condition);
    const consequent = node.consequent.map(c => this.genJSX(c));
    const thenPart = consequent.length === 1 ? consequent[0] : `tova_fragment([${consequent.join(', ')}])`;

    // Build chained ternary: cond1 ? a : cond2 ? b : cond3 ? c : else
    let result = `(${cond}) ? ${thenPart}`;

    // elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        const elifCond = this.genExpression(alt.condition);
        const elifBody = alt.body.map(c => this.genJSX(c));
        const elifPart = elifBody.length === 1 ? elifBody[0] : `tova_fragment([${elifBody.join(', ')}])`;
        result += ` : (${elifCond}) ? ${elifPart}`;
      }
    }

    if (node.alternate) {
      const alt = node.alternate.map(c => this.genJSX(c));
      const elsePart = alt.length === 1 ? alt[0] : `tova_fragment([${alt.join(', ')}])`;
      result += ` : ${elsePart}`;
    } else {
      result += ` : null`;
    }

    // Only wrap in reactive closure if the condition reads signals
    const needsReactive = this._exprReadsSignal(node.condition) ||
      (node.alternates && node.alternates.some(a => this._exprReadsSignal(a.condition)));
    if (needsReactive) {
      return `() => ${result}`;
    }
    return result;
  }

  genJSXMatch(node) {
    const subject = this.genExpression(node.subject);
    const p = [];
    p.push(`((__match) => { `);

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, '__match', arm.guard);
      const body = arm.body.map(c => this.genJSX(c));
      const bodyExpr = body.length === 1 ? body[0] : `tova_fragment([${body.join(', ')}])`;

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`const ${arm.pattern.name} = __match; `);
          }
          p.push(`return ${bodyExpr}; `);
          break;
        }
      }

      const keyword = idx === 0 ? 'if' : 'else if';
      p.push(`${keyword} (${condition}) { `);
      p.push(this.genPatternBindings(arm.pattern, '__match'));
      p.push(`return ${bodyExpr}; } `);
    }

    p.push(`})(${subject})`);
    // Only wrap in reactive closure if the subject reads signals
    if (this._exprReadsSignal(node.subject)) {
      return `() => ${p.join('')}`;
    }
    return p.join('');
  }

  genJSXFragment(node) {
    const children = node.children.map(c => this.genJSX(c)).join(', ');
    return `tova_fragment([${children}])`;
  }

  // Override to add await for piped RPC calls
  genPipeExpression(node) {
    const result = super.genPipeExpression(node);
    // If the pipe target is an RPC call and we're in async context, wrap with await
    if (this._asyncContext && this._containsRPC(node.right)) {
      return `await ${result}`;
    }
    return result;
  }

  // Override function declaration to make async if it contains server.* calls
  genFunctionDeclaration(node) {
    const hasRPC = this._containsRPC(node.body);
    const hasPropagate = this._containsPropagate(node.body);
    const isGenerator = this._containsYield(node.body);
    const exportPrefix = node.isPublic ? 'export ' : '';
    const asyncPrefix = (hasRPC || node.isAsync) ? 'async ' : '';
    const genStar = isGenerator ? '*' : '';
    const params = this.genParams(node.params);
    this.pushScope();
    for (const p of node.params) {
      if (p.destructure) {
        this._declareDestructureVars(p.destructure);
      } else {
        this.declareVar(p.name);
      }
    }
    const prevAsync = this._asyncContext;
    if (hasRPC || node.isAsync) this._asyncContext = true;
    const body = this.genBlockBody(node.body);
    this._asyncContext = prevAsync;
    this.popScope();
    if (hasPropagate) {
      return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
    }
    return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${body}\n${this.i()}}`;
  }

  getStdlibCore() {
    const parts = [];
    // Only include builtins used in client blocks that aren't already in shared code
    const clientOnly = new Set();
    for (const name of this._usedBuiltins) {
      if (!this._sharedBuiltins || !this._sharedBuiltins.has(name)) {
        clientOnly.add(name);
      }
    }
    const selectiveStdlib = buildSelectiveStdlib(clientOnly);
    if (selectiveStdlib) parts.push(selectiveStdlib);
    // Include Result/Option if Ok/Err/Some/None are used
    if (this._needsResultOption) parts.push(RESULT_OPTION);
    // Include propagate if needed
    if (this._needsPropagateHelper) parts.push(PROPAGATE);
    return parts.join('\n');
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ─── src/codegen/codegen.js ────────────────────────────

// Main code generator — orchestrates shared/server/client codegen
// Supports named multi-blocks: server "api" { }, server "ws" { }
// Blocks with the same name are merged; different names produce separate output files.




function getServerCodegen() {
  return ServerCodegen;
}

function getClientCodegen() {
  return ClientCodegen;
}
class CodeGenerator {
  constructor(ast, filename = '<stdin>', options = {}) {
    this.ast = ast;
    this.filename = filename;
    this._sourceMaps = options.sourceMaps !== false; // default true; pass false for REPL/check
  }

  // Group blocks by name (null name = "default")
  _groupByName(blocks) {
    const groups = new Map();
    for (const block of blocks) {
      const key = block.name || null;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key).push(block);
    }
    return groups;
  }

  generate() {
    const sharedBlocks = [];
    const serverBlocks = [];
    const clientBlocks = [];
    const topLevel = [];

    const testBlocks = [];
    const benchBlocks = [];
    const dataBlocks = [];

    for (const node of this.ast.body) {
      switch (node.type) {
        case 'SharedBlock': sharedBlocks.push(node); break;
        case 'ServerBlock': serverBlocks.push(node); break;
        case 'ClientBlock': clientBlocks.push(node); break;
        case 'TestBlock': testBlocks.push(node); break;
        case 'BenchBlock': benchBlocks.push(node); break;
        case 'DataBlock': dataBlocks.push(node); break;
        default: topLevel.push(node); break;
      }
    }

    // Detect module mode: no blocks, only top-level statements
    const isModule = sharedBlocks.length === 0 && serverBlocks.length === 0
      && clientBlocks.length === 0 && testBlocks.length === 0
      && benchBlocks.length === 0 && dataBlocks.length === 0
      && topLevel.length > 0;

    if (isModule) {
      const moduleGen = new SharedCodegen();
      moduleGen._sourceMapsEnabled = this._sourceMaps;
      moduleGen.setSourceFile(this.filename);
      const moduleCode = topLevel.map(s => moduleGen.generateStatement(s)).join('\n');
      const helpers = moduleGen.generateHelpers();
      const combined = [helpers, moduleCode].filter(s => s.trim()).join('\n').trim();
      return {
        shared: combined,
        server: '',
        client: '',
        isModule: true,
        sourceMappings: moduleGen.getSourceMappings(),
        _sourceFile: this.filename,
      };
    }

    const sharedGen = new SharedCodegen();
    sharedGen._sourceMapsEnabled = this._sourceMaps;
    sharedGen.setSourceFile(this.filename);

    // All shared blocks (regardless of name) are merged into one shared output
    const sharedCode = sharedBlocks.map(b => sharedGen.generate(b)).join('\n');
    const topLevelCode = topLevel.map(s => sharedGen.generateStatement(s)).join('\n');

    // Pre-scan server/client blocks for builtin usage so shared stdlib includes them
    this._scanBlocksForBuiltins([...serverBlocks, ...clientBlocks], sharedGen._usedBuiltins);

    const helpers = sharedGen.generateHelpers();

    // Generate data block code (sources, pipelines, validators, refresh)
    const dataCode = dataBlocks.map(b => this._genDataBlock(b, sharedGen)).join('\n');

    const combinedShared = [helpers, sharedCode, topLevelCode, dataCode].filter(s => s.trim()).join('\n').trim();

    // Group server and client blocks by name
    const serverGroups = this._groupByName(serverBlocks);
    const clientGroups = this._groupByName(clientBlocks);

    // Collect function names per named server block for inter-server RPC
    const serverFunctionMap = new Map(); // blockName -> [fnName, ...]
    const collectFns = (stmts) => {
      const fns = [];
      for (const stmt of stmts) {
        if (stmt.type === 'FunctionDeclaration') {
          fns.push(stmt.name);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          fns.push(...collectFns(stmt.body));
        }
      }
      return fns;
    };
    for (const [name, blocks] of serverGroups) {
      if (name) {
        const fns = [];
        for (const block of blocks) {
          fns.push(...collectFns(block.body));
        }
        serverFunctionMap.set(name, fns);
      }
    }

    // Generate server outputs (one per named group)
    const servers = {};
    for (const [name, blocks] of serverGroups) {
      const gen = new (getServerCodegen())();
      gen._sourceMapsEnabled = this._sourceMaps;
      const key = name || 'default';
      // Build peer blocks map (all named blocks except self)
      let peerBlocks = null;
      if (name && serverFunctionMap.size > 1) {
        peerBlocks = new Map();
        for (const [peerName, peerFns] of serverFunctionMap) {
          if (peerName !== name) {
            peerBlocks.set(peerName, peerFns);
          }
        }
      }
      servers[key] = gen.generate(blocks, combinedShared, name, peerBlocks, sharedBlocks);
    }

    // Generate client outputs (one per named group)
    const clients = {};
    for (const [name, blocks] of clientGroups) {
      const gen = new (getClientCodegen())();
      gen._sourceMapsEnabled = this._sourceMaps;
      const key = name || 'default';
      clients[key] = gen.generate(blocks, combinedShared, sharedGen._usedBuiltins);
    }

    // Generate tests if test blocks exist
    let testCode = '';
    if (testBlocks.length > 0) {
      const testGen = new (getServerCodegen())();
      testCode = testGen.generateTests(testBlocks, combinedShared);

      // Add __handleRequest export to server code
      const defaultServer = servers['default'] || '';
      if (defaultServer) {
        servers['default'] = defaultServer + '\nexport { __handleRequest };\n';
      }
    }

    // Generate benchmarks if bench blocks exist
    let benchCode = '';
    if (benchBlocks.length > 0) {
      const benchGen = new (getServerCodegen())();
      benchCode = benchGen.generateBench(benchBlocks, combinedShared);
    }

    // Backward-compatible: if only unnamed blocks, return flat structure
    const hasNamedBlocks = [...serverGroups.keys(), ...clientGroups.keys()].some(k => k !== null);

    // Collect source mappings from all codegens
    const sourceMappings = sharedGen.getSourceMappings();

    if (!hasNamedBlocks) {
      const result = {
        shared: combinedShared,
        server: servers['default'] || '',
        client: clients['default'] || '',
        sourceMappings,
        _sourceFile: this.filename,
      };
      if (testCode) result.test = testCode;
      if (benchCode) result.bench = benchCode;
      return result;
    }

    // Multi-block output: separate files per named block
    const result = {
      shared: combinedShared,
      server: servers['default'] || '',
      client: clients['default'] || '',
      servers,   // { "api": code, "ws": code, ... }
      clients,   // { "admin": code, "dashboard": code, ... }
      multiBlock: true,
      sourceMappings,
      _sourceFile: this.filename,
    };
    if (testCode) result.test = testCode;
    if (benchCode) result.bench = benchCode;
    return result;
  }

  // Walk AST nodes to find builtin function calls/identifiers
  _scanBlocksForBuiltins(blocks, targetSet) {
    const walk = (node) => {
      if (!node || typeof node !== 'object') return;
      if (node.type === 'Identifier' && BUILTIN_NAMES.has(node.name)) {
        targetSet.add(node.name);
      }
      if (node.type === 'CallExpression' && node.callee && node.callee.type === 'Identifier' && BUILTIN_NAMES.has(node.callee.name)) {
        targetSet.add(node.callee.name);
      }
      // Track namespace builtin usage: math.sin() or math.PI
      if (node.type === 'MemberExpression' &&
          node.object.type === 'Identifier' &&
          BUILTIN_NAMES.has(node.object.name)) {
        targetSet.add(node.object.name);
      }
      for (const key of Object.keys(node)) {
        if (key === 'loc' || key === 'type') continue;
        const val = node[key];
        if (Array.isArray(val)) {
          for (const item of val) {
            if (item && typeof item === 'object') walk(item);
          }
        } else if (val && typeof val === 'object' && val.type) {
          walk(val);
        }
      }
    };
    for (const block of blocks) walk(block);
  }

  _genDataBlock(node, gen) {
    const lines = [];
    lines.push('// ── Data Block ──');

    for (const stmt of node.body) {
      switch (stmt.type) {
        case 'SourceDeclaration': {
          // Source: lazy cached getter
          const expr = gen.genExpression(stmt.expression);
          lines.push(`let __data_${stmt.name}_cache = null;`);
          lines.push(`async function __data_${stmt.name}_load() {`);
          lines.push(`  if (__data_${stmt.name}_cache === null) {`);
          lines.push(`    __data_${stmt.name}_cache = await ${expr};`);
          lines.push(`  }`);
          lines.push(`  return __data_${stmt.name}_cache;`);
          lines.push(`}`);
          // Also expose as a simple getter variable via lazy init
          lines.push(`let ${stmt.name} = null;`);
          lines.push(`Object.defineProperty(globalThis, ${JSON.stringify(stmt.name)}, {`);
          lines.push(`  get() { if (${stmt.name} === null) { ${stmt.name} = __data_${stmt.name}_load(); } return ${stmt.name}; },`);
          lines.push(`  configurable: true,`);
          lines.push(`});`);
          break;
        }
        case 'PipelineDeclaration': {
          // Pipeline: function that chains transforms
          const expr = gen.genExpression(stmt.expression);
          lines.push(`async function __pipeline_${stmt.name}() {`);
          lines.push(`  return ${expr};`);
          lines.push(`}`);
          lines.push(`let ${stmt.name} = null;`);
          lines.push(`Object.defineProperty(globalThis, ${JSON.stringify(stmt.name)}, {`);
          lines.push(`  get() { if (${stmt.name} === null) { ${stmt.name} = __pipeline_${stmt.name}(); } return ${stmt.name}; },`);
          lines.push(`  configurable: true,`);
          lines.push(`});`);
          break;
        }
        case 'ValidateBlock': {
          // Validate: validator function
          const rules = stmt.rules.map(r => gen.genExpression(r));
          lines.push(`function __validate_${stmt.typeName}(it) {`);
          lines.push(`  const errors = [];`);
          for (let i = 0; i < rules.length; i++) {
            lines.push(`  if (!(${rules[i]})) errors.push("Validation rule ${i + 1} failed for ${stmt.typeName}");`);
          }
          lines.push(`  return errors.length === 0 ? { valid: true, errors: [] } : { valid: false, errors };`);
          lines.push(`}`);
          break;
        }
        case 'RefreshPolicy': {
          // Refresh: interval cache invalidation
          if (stmt.interval === 'on_demand') {
            lines.push(`function refresh_${stmt.sourceName}() { __data_${stmt.sourceName}_cache = null; ${stmt.sourceName} = null; }`);
          } else {
            const { value, unit } = stmt.interval;
            let ms;
            switch (unit) {
              case 'seconds': case 'second': ms = value * 1000; break;
              case 'minutes': case 'minute': ms = value * 60 * 1000; break;
              case 'hours': case 'hour': ms = value * 60 * 60 * 1000; break;
              case 'days': case 'day': ms = value * 24 * 60 * 60 * 1000; break;
              default: ms = value * 60 * 1000; // default to minutes
            }
            lines.push(`setInterval(() => { __data_${stmt.sourceName}_cache = null; ${stmt.sourceName} = null; }, ${ms});`);
          }
          break;
        }
      }
    }

    return lines.join('\n');
  }
}

window.Lexer = Lexer;

window.Parser = Parser;

window.Analyzer = Analyzer;

window.CodeGenerator = CodeGenerator;

})();
</script>

<!-- ─── CodeMirror shared dependency map ──────────── -->
<script type="importmap">
{
  "imports": {
    "codemirror": "https://esm.sh/*codemirror@6.0.1",
    "@codemirror/state": "https://esm.sh/*@codemirror/state@6.4.1",
    "@codemirror/view": "https://esm.sh/*@codemirror/view@6.26.0",
    "@codemirror/language": "https://esm.sh/*@codemirror/language@6.10.1",
    "@codemirror/commands": "https://esm.sh/*@codemirror/commands@6.3.3",
    "@codemirror/search": "https://esm.sh/*@codemirror/search@6.5.5",
    "@codemirror/autocomplete": "https://esm.sh/*@codemirror/autocomplete@6.12.0",
    "@codemirror/lint": "https://esm.sh/*@codemirror/lint@6.5.0",
    "@codemirror/theme-one-dark": "https://esm.sh/*@codemirror/theme-one-dark@6.1.2",
    "@lezer/common": "https://esm.sh/*@lezer/common@1.2.1",
    "@lezer/highlight": "https://esm.sh/*@lezer/highlight@1.2.0",
    "@lezer/lr": "https://esm.sh/*@lezer/lr@1.4.0",
    "crelt": "https://esm.sh/*crelt@1.0.6",
    "style-mod": "https://esm.sh/*style-mod@4.1.2",
    "w3c-keyname": "https://esm.sh/*w3c-keyname@2.2.8"
  }
}
</script>

<!-- ─── CodeMirror & App ─────────────────────────── -->
<script type="module">
import {basicSetup} from 'codemirror';
import {EditorState, StateField, StateEffect} from '@codemirror/state';
import {EditorView, keymap, Decoration} from '@codemirror/view';
import {StreamLanguage} from '@codemirror/language';
import {oneDark} from '@codemirror/theme-one-dark';
import {autocompletion} from '@codemirror/autocomplete';

// ─── Tova Syntax Highlighting ────────────────────────
const tovaLanguage = StreamLanguage.define({
  startState() { return { inComment: false, commentDepth: 0 }; },
  token(stream, state) {
    // Block comment (nestable)
    if (state.inComment) {
      if (stream.match('/*')) { state.commentDepth++; return 'blockComment'; }
      if (stream.match('*/')) { state.commentDepth--; if (state.commentDepth <= 0) { state.inComment = false; state.commentDepth = 0; } return 'blockComment'; }
      stream.next(); return 'blockComment';
    }
    // Docstring
    if (stream.match('///')) { stream.skipToEnd(); return 'docString'; }
    // Line comment
    if (stream.match('//')) { stream.skipToEnd(); return 'lineComment'; }
    // Block comment start
    if (stream.match('/*')) { state.inComment = true; state.commentDepth = 1; return 'blockComment'; }
    // Strings with interpolation
    if (stream.match('"')) {
      while (!stream.eol()) {
        const ch = stream.next();
        if (ch === '\\') { stream.next(); continue; }
        if (ch === '{') { return 'string'; }
        if (ch === '"') return 'string';
      }
      return 'string';
    }
    // Simple strings
    if (stream.match("'")) {
      while (!stream.eol()) { const ch = stream.next(); if (ch === '\\') { stream.next(); continue; } if (ch === "'") return 'string'; }
      return 'string';
    }
    // Braces (interpolation)
    if (stream.match('{')) return 'brace';
    if (stream.match('}')) return 'brace';
    // Numbers
    if (stream.match(/^0[xX][0-9a-fA-F]+/)) return 'number';
    if (stream.match(/^0[bB][01]+/)) return 'number';
    if (stream.match(/^\d+\.\d+([eE][+-]?\d+)?/)) return 'number';
    if (stream.match(/^\d+([eE][+-]?\d+)?/)) return 'number';
    // Multi-char operators
    if (stream.match('|>')) return 'operator';
    if (stream.match('=>')) return 'operator';
    if (stream.match('->')) return 'operator';
    if (stream.match('..=')) return 'operator';
    if (stream.match('...')) return 'operator';
    if (stream.match('..')) return 'operator';
    if (stream.match('?.')) return 'operator';
    if (stream.match('??')) return 'operator';
    if (stream.match('::')) return 'operator';
    if (stream.match('**')) return 'operator';
    if (stream.match(/^[+\-*\/%]=?/)) return 'operator';
    if (stream.match(/^[<>!=]=?/)) return 'operator';
    if (stream.match(/^&&|\|\|/)) return 'operator';
    if (stream.match('=')) return 'operator';
    // JSX close tag
    if (stream.match(/^<\/[A-Za-z][A-Za-z0-9]*/)) { stream.match('>'); return 'tagName'; }
    // Identifiers and keywords
    if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
      const w = stream.current();
      if (['fn','let','var','if','elif','else','for','while','in','not','and','or','match',
           'return','type','import','from','export','as','true','false','nil',
           'server','client','shared','state','computed','effect','component',
           'route','GET','POST','PUT','DELETE','PATCH'].includes(w)) return 'keyword';
      if (/^[A-Z]/.test(w)) return 'typeName';
      return 'variableName';
    }
    // JSX
    if (stream.match('/>')) return 'angleBracket';
    if (stream.peek() === '<' && /[A-Za-z]/.test(stream.string.charAt(stream.pos + 1) || '')) {
      stream.next(); return 'angleBracket';
    }
    stream.next();
    return null;
  }
});

// ─── Autocompletion ─────────────────────────────────
const tovaKeywords = [
  'fn', 'let', 'var', 'if', 'elif', 'else', 'for', 'while', 'match',
  'type', 'state', 'computed', 'effect', 'component', 'server', 'client',
  'shared', 'route', 'return', 'import', 'from', 'in', 'and', 'or', 'not',
  'true', 'false', 'nil', 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'as', 'export'
];

const tovaStdlib = [
  { label: 'print', detail: '(...args)', info: 'Print values to console' },
  { label: 'len', detail: '(v)', info: 'Length of string, array, or object' },
  { label: 'range', detail: '(start?, end, step?)', info: 'Generate number array' },
  { label: 'sum', detail: '(arr)', info: 'Sum of array elements' },
  { label: 'min', detail: '(arr)', info: 'Minimum value in array' },
  { label: 'max', detail: '(arr)', info: 'Maximum value in array' },
  { label: 'sorted', detail: '(arr, key?)', info: 'Sort array (with optional key fn)' },
  { label: 'reversed', detail: '(arr)', info: 'Reverse array' },
  { label: 'enumerate', detail: '(arr)', info: 'Index-value pairs' },
  { label: 'zip', detail: '(...arrs)', info: 'Combine arrays element-wise' },
  { label: 'type_of', detail: '(v)', info: 'Runtime type name as string' },
  { label: 'filter', detail: '(arr, fn)', info: 'Filter array by predicate' },
  { label: 'map', detail: '(arr, fn)', info: 'Transform each element' },
  { label: 'flat_map', detail: '(arr, fn)', info: 'Map then flatten one level' },
  { label: 'any', detail: '(arr, fn)', info: 'True if any element matches' },
  { label: 'all', detail: '(arr, fn)', info: 'True if all elements match' },
];

const tovaSnippets = [
  { label: 'fn', detail: 'function', apply: 'fn name() {\n  \n}', boost: -1 },
  { label: 'for', detail: 'for-in loop', apply: 'for item in items {\n  \n}', boost: -1 },
  { label: 'match', detail: 'match expression', apply: 'match value {\n  _ => \n}', boost: -1 },
  { label: 'type', detail: 'type definition', apply: 'type Name {\n  \n}', boost: -1 },
  { label: 'client', detail: 'client block', apply: 'client {\n  state count = 0\n\n  component App {\n    <div>\n      \n    </div>\n  }\n}', boost: -1 },
  { label: 'component', detail: 'component', apply: 'component App {\n  <div>\n    \n  </div>\n}', boost: -1 },
  { label: 'server', detail: 'server block', apply: 'server {\n  \n}', boost: -1 },
  { label: 'effect', detail: 'side effect', apply: 'effect {\n  \n}', boost: -1 },
  { label: 'if', detail: 'conditional', apply: 'if condition {\n  \n}', boost: -1 },
  { label: 'while', detail: 'while loop', apply: 'while condition {\n  \n}', boost: -1 },
  { label: 'route', detail: 'HTTP route', apply: 'route GET "/path" => fn(req) {\n  \n}', boost: -1 },
];

function tovaCompletions(context) {
  const word = context.matchBefore(/[a-zA-Z_]\w*/);
  if (!word && !context.explicit) return null;
  const from = word ? word.from : context.pos;
  const text = word ? word.text : '';

  const options = [];

  // Keywords
  for (const kw of tovaKeywords) {
    if (!text || kw.startsWith(text)) {
      // Check if there's a matching snippet
      const snippet = tovaSnippets.find(s => s.label === kw);
      if (snippet) {
        options.push({ label: kw, type: 'keyword', detail: snippet.detail, apply: snippet.apply, boost: 1 });
      } else {
        options.push({ label: kw, type: 'keyword', boost: 0 });
      }
    }
  }

  // Stdlib functions
  for (const fn of tovaStdlib) {
    if (!text || fn.label.startsWith(text)) {
      options.push({ label: fn.label, type: 'function', detail: fn.detail, info: fn.info, boost: 2 });
    }
  }

  return { from, options, filter: true };
}

// ─── Error Decorations ──────────────────────────────
const setErrorEffect = StateEffect.define();
const clearErrorEffect = StateEffect.define();

const errorLineDeco = Decoration.line({ class: 'cm-error-line' });

const errorField = StateField.define({
  create() { return Decoration.none; },
  update(decos, tr) {
    for (const e of tr.effects) {
      if (e.is(clearErrorEffect)) return Decoration.none;
      if (e.is(setErrorEffect)) {
        const lines = e.value;
        const ranges = [];
        for (const lineNum of lines) {
          try {
            const line = tr.state.doc.line(lineNum);
            ranges.push(errorLineDeco.range(line.from));
          } catch(ex) {}
        }
        return ranges.length ? Decoration.set(ranges) : Decoration.none;
      }
    }
    return decos;
  },
  provide: f => EditorView.decorations.from(f)
});

// ─── Data ───────────────────────────────────────────
const EXAMPLES = [
  {
    "category": "Getting Started",
    "name": "Hello World",
    "code": "// Welcome to Tova! A modern language that transpiles to JavaScript.\n// Click \"Run\" or press Cmd/Ctrl+Enter to execute.\n\nname = \"World\"\ngreeting = \"Hello, {name}!\"\nprint(greeting)\n\n// Tova uses string interpolation with {expressions}\nx = 42\npi = 3.14159\nprint(\"x is {x} and pi is {pi}\")\n\n// Variables: immutable by default, use 'var' for mutable\nlanguage = \"Tova\"         // immutable\nvar version = 1          // mutable\nversion += 1\nprint(\"{language} v{version}\")\n"
  },
  {
    "category": "Getting Started",
    "name": "Variables & Types",
    "code": "// Immutable bindings (default)\nname = \"Alice\"\nage = 30\npi = 3.14159\nis_active = true\nnothing = nil\n\n// Mutable bindings\nvar counter = 0\ncounter += 1\ncounter += 1\nprint(\"counter = {counter}\")\n\n// Multiple assignment\na, b, c = 1, 2, 3\nprint(\"a={a}, b={b}, c={c}\")\n\n// Swap\nvar x = 10\nvar y = 20\nx, y = y, x\nprint(\"After swap: x={x}, y={y}\")\n\n// Type checking\nprint(type_of(42))\nprint(type_of(\"hello\"))\nprint(type_of(true))\nprint(type_of([1, 2, 3]))\nprint(type_of(nil))\n"
  },
  {
    "category": "Getting Started",
    "name": "String Operations",
    "code": "// String interpolation with expressions\nname = \"hello world\"\nprint(\"Upper: {name.upper()}\")\nprint(\"Capitalized: {name.capitalize()}\")\nprint(\"Title: {name.title_case()}\")\n\n// String methods\nsentence = \"the quick brown fox jumps\"\nprint(\"Words: {sentence.words()}\")\nprint(\"Starts with 'the': {sentence.starts_with(\"the\")}\")\nprint(\"Contains 'brown': {sentence.contains(\"brown\")}\")\n\n// Useful conversions\nprint(\"snake_case: {\"helloWorld\".snake_case()}\")\nprint(\"camelCase: {\"hello_world\".camel_case()}\")\n\n// String multiply (repeat)\nborder = \"-\" * 30\nprint(border)\nprint(\"  Tova Language\")\nprint(border)\n\n// Characters and lines\ntext = \"Tova\"\nprint(\"Chars: {text.chars()}\")\n"
  },
  {
    "category": "Functions",
    "name": "Functions & Lambdas",
    "code": "// Functions return the last expression (implicit return)\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"friend\") {\n  \"Hey, {name}!\"\n}\n\nprint(add(1, 2))\nprint(greet())\nprint(greet(\"Alice\"))\n\n// Lambda / anonymous functions\ndouble = fn(x) x * 2\nsquare = fn(x) x * x\nprint(\"double(7) = {double(7)}\")\nprint(\"square(5) = {square(5)}\")\n\n// Arrow syntax\nadd3 = fn(a, b, c) a + b + c\nprint(\"add3(1,2,3) = {add3(1, 2, 3)}\")\n\n// Functions are first-class\nfn apply(f, x) { f(x) }\nprint(\"apply(double, 21) = {apply(double, 21)}\")\n\n// Explicit return\nfn first_positive(items) {\n  for item in items {\n    if item > 0 { return item }\n  }\n  nil\n}\nprint(\"First positive: {first_positive([-3, -1, 0, 4, 7])}\")\n"
  },
  {
    "category": "Functions",
    "name": "Higher-Order Functions",
    "code": "// Map, filter, and reduce with lambdas\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndoubled = map(numbers, fn(x) x * 2)\nprint(\"Doubled: {doubled}\")\n\nevens = filter(numbers, fn(x) x % 2 == 0)\nprint(\"Evens: {evens}\")\n\ntotal = sum(numbers)\nprint(\"Sum: {total}\")\n\n// Composition\nfn compose(f, g) {\n  fn(x) f(g(x))\n}\n\ndouble = fn(x) x * 2\nadd_one = fn(x) x + 1\ndouble_then_add = compose(add_one, double)\nprint(\"double_then_add(5) = {double_then_add(5)}\")\n\n// Sorting with key function\nfruit_names = [\"banana\", \"apple\", \"cherry\", \"date\"]\nby_length = sorted(fruit_names, fn(w) len(w))\nprint(\"By length: {by_length}\")\n\n// Checking conditions\nhas_negative = any([-1, 2, 3], fn(x) x < 0)\nall_positive = all([1, 2, 3], fn(x) x > 0)\nprint(\"Has negative: {has_negative}\")\nprint(\"All positive: {all_positive}\")\n"
  },
  {
    "category": "Functions",
    "name": "Pipe Operator",
    "code": "// The pipe operator |> chains function calls beautifully\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Another example\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\", \"Eve\"]\nresult2 = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\n  |> reversed()\nprint(\"Long names (Z-A): {result2}\")\n\n// Simple pipeline\n42 |> fn(x) x * 2 |> fn(x) \"The answer is {x}\" |> print()\n"
  },
  {
    "category": "Data Structures",
    "name": "Lists & Comprehensions",
    "code": "// List literals\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"Fruits: {fruits}\")\nprint(\"Length: {len(fruits)}\")\n\n// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// With filter\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Build pairs with flat_map\npairs = flat_map(range(1, 4), fn(x) [[x, y] for y in range(1, 4) if x != y])\nprint(\"Pairs: {pairs}\")\n\n// Dict comprehension\nsquare_map = {x: x * x for x in range(1, 6)}\nprint(\"Square map: {square_map}\")\n\n// Slice operations\nnums = [10, 20, 30, 40, 50, 60, 70]\nprint(\"nums[1:4] = {nums[1:4]}\")\nprint(\"nums[:3]  = {nums[:3]}\")\nprint(\"nums[4:]  = {nums[4:]}\")\nprint(\"nums[::-1] = {nums[::-1]}\")\n"
  },
  {
    "category": "Data Structures",
    "name": "Spread & Destructuring",
    "code": "// Array spread\nlist_a = [1, 2, 3]\nlist_b = [4, 5, 6]\ncombined = [...list_a, ...list_b]\nprint(\"Combined: {combined}\")\n\n// Object literals\nconfig = {\n  color: \"blue\",\n  size: \"medium\",\n  bold: false,\n  count: 42\n}\nprint(\"Config: {config}\")\n\n// Destructuring objects\nlet {color, size, bold} = config\nprint(\"Color: {color}\")\nprint(\"Size: {size}\")\n\n// Destructuring arrays\nlet [a, b, c] = [10, 20, 30]\nprint(\"a={a}, b={b}, c={c}\")\n\n// Membership testing\nfruits = [\"apple\", \"banana\", \"cherry\"]\nif \"banana\" in fruits {\n  print(\"We have bananas!\")\n}\nif \"grape\" not in fruits {\n  print(\"No grapes available\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "If / Elif / Else",
    "code": "// If expressions (they return values!)\nfn grade(score) {\n  if score >= 90 {\n    \"A\"\n  } elif score >= 80 {\n    \"B\"\n  } elif score >= 70 {\n    \"C\"\n  } elif score >= 60 {\n    \"D\"\n  } else {\n    \"F\"\n  }\n}\n\nfor s in [95, 85, 72, 65, 45] {\n  print(\"Score {s} = Grade {grade(s)}\")\n}\n\n// Chained comparisons (Python-style!)\ny = 5\nif 1 < y < 10 {\n  print(\"{y} is between 1 and 10\")\n}\n\nage = 25\nif 18 <= age < 65 {\n  print(\"Working age\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Loops",
    "code": "// For loops with range\nprint(\"Counting:\")\nfor i in range(1, 6) {\n  print(\"  {i}\")\n}\n\n// For-in with arrays\ncolors = [\"red\", \"green\", \"blue\"]\nfor color in colors {\n  print(\"Color: {color}\")\n}\n\n// Enumerate (get index + value)\nfor pair in enumerate(colors) {\n  print(\"  {pair[0]}: {pair[1]}\")\n}\n\n// While loops\nvar n = 1\nwhile n < 100 {\n  n = n * 2\n}\nprint(\"First power of 2 >= 100: {n}\")\n\n// FizzBuzz\nfn fizzbuzz(n) {\n  if n % 15 == 0 { \"FizzBuzz\" }\n  elif n % 3 == 0 { \"Fizz\" }\n  elif n % 5 == 0 { \"Buzz\" }\n  else { \"{n}\" }\n}\n\nfor i in range(1, 21) {\n  print(fizzbuzz(i))\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Pattern Matching",
    "code": "// Pattern matching — Tova's most powerful feature!\n\n// Simple value matching\nfn describe(value) {\n  match value {\n    0 => \"zero\"\n    1..10 => \"small (1-9)\"\n    n if n > 100 => \"big: {n}\"\n    _ => \"other: {value}\"\n  }\n}\n\nprint(describe(0))\nprint(describe(5))\nprint(describe(200))\nprint(describe(50))\n\n// Pattern matching on algebraic types\ntype Shape {\n  Circle(radius: Float),\n  Rect(w: Float, h: Float),\n  Triangle(base: Float, height: Float),\n  Point\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n    Triangle(b, h) => 0.5 * b * h\n    Point => 0.0\n  }\n}\n\nfn describe_shape(s) {\n  match s {\n    Circle(r) => \"Circle with radius {r}\"\n    Rect(w, h) => \"Rectangle {w}x{h}\"\n    Triangle(b, h) => \"Triangle base={b} height={h}\"\n    Point => \"Just a point\"\n  }\n}\n\nshapes = [Circle(5.0), Rect(3.0, 4.0), Triangle(6.0, 3.0), Point]\nfor shape in shapes {\n  print(\"{describe_shape(shape)} => area = {area(shape)}\")\n}\n"
  },
  {
    "category": "Types",
    "name": "Algebraic Data Types",
    "code": "// Algebraic Data Types (tagged unions / sum types)\ntype Color {\n  Red,\n  Green,\n  Blue,\n  Custom(r: Int, g: Int, b: Int)\n}\n\nfn to_hex(c) {\n  match c {\n    Red => \"#FF0000\"\n    Green => \"#00FF00\"\n    Blue => \"#0000FF\"\n    Custom(r, g, b) => \"rgb({r},{g},{b})\"\n  }\n}\n\nprint(to_hex(Red))\nprint(to_hex(Custom(255, 128, 0)))\n\n// Option type pattern\ntype Option {\n  Some(value: Any),\n  None\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { None }\n  else { Some(a / b) }\n}\n\nfn unwrap(opt, default_val) {\n  match opt {\n    Some(v) => v\n    None => default_val\n  }\n}\n\nprint(unwrap(safe_divide(10, 3), 0))\nprint(unwrap(safe_divide(10, 0), 0))\n\n// Result type\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_age(input) {\n  if input > 0 and input < 150 {\n    Ok(input)\n  } else {\n    Err(\"Invalid age: {input}\")\n  }\n}\n\nprint(parse_age(25))\nprint(parse_age(-5))\n"
  },
  {
    "category": "Types",
    "name": "Struct Types",
    "code": "// Struct-like types with named fields\ntype Point {\n  x: Float\n  y: Float\n}\n\ntype User {\n  name: String\n  age: Int\n}\n\n// Creating instances\np1 = Point(3.0, 4.0)\np2 = Point(1.0, 2.0)\nprint(\"p1 = ({p1.x}, {p1.y})\")\nprint(\"p2 = ({p2.x}, {p2.y})\")\n\n// Distance function\nfn distance(a, b) {\n  dx = a.x - b.x\n  dy = a.y - b.y\n  (dx ** 2 + dy ** 2) ** 0.5\n}\nprint(\"Distance: {distance(p1, p2)}\")\n\n// User records\nusers = [\n  User(\"Alice\", 30),\n  User(\"Bob\", 25),\n  User(\"Charlie\", 35)\n]\n\n// Sort by age\nby_age = sorted(users, fn(u) u.age)\nfor u in by_age {\n  print(\"{u.name}: {u.age}\")\n}\n"
  },
  {
    "category": "Standard Library",
    "name": "Built-in Functions",
    "code": "// Tova comes with useful built-in functions\n\n// range(start?, end, step?)\nprint(\"range(5): {range(5)}\")\nprint(\"range(2,8): {range(2, 8)}\")\nprint(\"range(0,20,3): {range(0, 20, 3)}\")\n\n// len — works on strings, arrays, objects\nprint(\"len('hello'): {len(\"hello\")}\")\nprint(\"len([1,2,3]): {len([1, 2, 3])}\")\n\n// sum, min, max\nnums = [4, 2, 7, 1, 9, 3]\nprint(\"sum: {sum(nums)}\")\nprint(\"min: {min(nums)}\")\nprint(\"max: {max(nums)}\")\n\n// sorted, reversed\nprint(\"sorted: {sorted(nums)}\")\nprint(\"reversed: {reversed(nums)}\")\n\n// enumerate — get index,value pairs\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor pair in enumerate(fruits) {\n  print(\"  [{pair[0]}] {pair[1]}\")\n}\n\n// zip — combine arrays\nlabels = [\"name\", \"age\", \"city\"]\nvals = [\"Alice\", 30, \"NYC\"]\nprint(\"zipped: {zip(labels, vals)}\")\n\n// type_of — runtime type checking\nprint(\"type_of(42): {type_of(42)}\")\nprint(\"type_of(3.14): {type_of(3.14)}\")\nprint(\"type_of('hi'): {type_of(\"hi\")}\")\nprint(\"type_of(true): {type_of(true)}\")\nprint(\"type_of(nil): {type_of(nil)}\")\nprint(\"type_of([1]): {type_of([1, 2])}\")\n"
  },
  {
    "category": "Reactive UI",
    "name": "Counter App",
    "code": "// Counter App in Tova — demonstrates reactive UI\n\nclient {\n  state count = 0\n\n  computed doubled = count * 2\n  computed message = match count {\n    0 => \"Click the button!\"\n    1..5 => \"Keep going...\"\n    n if n >= 10 => \"You're on fire! 🔥\"\n    _ => \"Nice!\"\n  }\n\n  component App {\n    <div class=\"counter-app\">\n      <h1>\"Tova Counter\"</h1>\n      <p class=\"count\">\"{count}\"</p>\n      <p class=\"doubled\">\"Doubled: {doubled}\"</p>\n      <p class=\"message\">\"{message}\"</p>\n      <div class=\"buttons\">\n        <button on:click={fn() count -= 1}>\"-\"</button>\n        <button on:click={fn() count += 1}>\"+\"</button>\n        <button on:click={fn() count = 0}>\"Reset\"</button>\n      </div>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Todo App (Full-Stack)",
    "code": "// Full-Stack Todo App in Tova — demonstrates server/client/shared blocks\n\nshared {\n  type Todo {\n    id: Int\n    title: String\n    completed: Bool\n  }\n}\n\nserver {\n  // In-memory store for demo (use db.query for real apps)\n  var todos = []\n  var next_id = 1\n\n  fn get_todos() -> [Todo] {\n    todos\n  }\n\n  fn add_todo(title: String) -> Todo {\n    todo = Todo(next_id, title, false)\n    next_id += 1\n    todos = [...todos, todo]\n    todo\n  }\n\n  fn toggle_todo(id: Int) -> Todo {\n    for t in todos {\n      if t.id == id {\n        return Todo(t.id, t.title, not t.completed)\n      }\n    }\n    nil\n  }\n\n  fn delete_todo(id: Int) {\n    todos = [t for t in todos if t.id != id]\n  }\n\n  route GET \"/api/todos\" => get_todos\n}\n\nclient {\n  state todos: [Todo] = []\n  state new_title = \"\"\n\n  computed remaining = len([t for t in todos if not t.completed])\n  computed total = len(todos)\n\n  effect {\n    todos = server.get_todos()\n  }\n\n  fn handle_add() {\n    if new_title != \"\" {\n      server.add_todo(new_title)\n      new_title = \"\"\n      todos = server.get_todos()\n    }\n  }\n\n  fn handle_toggle(id) {\n    server.toggle_todo(id)\n    todos = server.get_todos()\n  }\n\n  fn handle_delete(id) {\n    server.delete_todo(id)\n    todos = server.get_todos()\n  }\n\n  component TodoItem(todo) {\n    <li class=\"todo-item\">\n      <input type=\"checkbox\" checked={todo.completed} on:change={fn() handle_toggle(todo.id)} />\n      <span class=\"todo-text\">\"{todo.title}\"</span>\n      <button on:click={fn() handle_delete(todo.id)}>\"×\"</button>\n    </li>\n  }\n\n  component App {\n    <div class=\"todo-app\">\n      <h1>\"Tova Todo\"</h1>\n      <div class=\"input-row\">\n        <input\n          type=\"text\"\n          placeholder=\"What needs to be done?\"\n          value={new_title}\n          on:input={fn(e) new_title = e.target.value}\n        />\n        <button on:click={handle_add}>\"Add\"</button>\n      </div>\n      <ul class=\"todo-list\">\n        for todo in todos {\n          <TodoItem todo={todo} />\n        }\n      </ul>\n      <p class=\"status\">\"{remaining} of {total} remaining\"</p>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Temperature Converter",
    "code": "// Temperature converter — reactive two-way conversion\nclient {\n  state celsius = 20\n  computed fahrenheit = celsius * 9 / 5 + 32\n  computed kelvin = celsius + 273.15\n\n  computed description = match celsius {\n    c if c <= 0 => \"Freezing!\"\n    c if c <= 15 => \"Cold\"\n    c if c <= 25 => \"Comfortable\"\n    c if c <= 35 => \"Warm\"\n    _ => \"Hot!\"\n  }\n\n  component App {\n    <div class=\"converter\">\n      <h1>\"Temperature Converter\"</h1>\n      <div class=\"input-group\">\n        <label>\"Celsius\"</label>\n        <input type=\"range\" min=\"-40\" max=\"60\" value={celsius}\n               on:input={fn(e) celsius = e.target.value * 1} />\n        <span class=\"value\">\"{celsius}C\"</span>\n      </div>\n      <div class=\"results\">\n        <p>\"{celsius}C = {fahrenheit}F = {kelvin}K\"</p>\n        <p class=\"desc\">\"{description}\"</p>\n      </div>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Reactive UI",
    "name": "Stopwatch",
    "code": "// Stopwatch with reactive state\nclient {\n  state elapsed = 0\n  state running = false\n  state timer_id = nil\n\n  fn start_timer() {\n    if not running {\n      running = true\n    }\n  }\n\n  fn stop_timer() {\n    running = false\n  }\n\n  fn reset_timer() {\n    running = false\n    elapsed = 0\n  }\n\n  computed display = match elapsed {\n    t if t < 60 => \"{t}s\"\n    t if t < 3600 => \"{t / 60}m {t % 60}s\"\n    _ => \"{elapsed / 3600}h {(elapsed % 3600) / 60}m\"\n  }\n\n  component App {\n    <div class=\"stopwatch\">\n      <h1>\"Stopwatch\"</h1>\n      <p class=\"time\">\"{display}\"</p>\n      <div class=\"controls\">\n        <button on:click={fn() elapsed += 1}>\"+1s\"</button>\n        <button on:click={fn() elapsed += 10}>\"+10s\"</button>\n        <button on:click={fn() elapsed += 60}>\"+1m\"</button>\n        <button on:click={reset_timer}>\"Reset\"</button>\n      </div>\n      <p class=\"hint\">\"(Click buttons to simulate time passing)\"</p>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Algorithms",
    "name": "Fibonacci",
    "code": "// Fibonacci sequence — multiple approaches\n\n// Recursive (simple but slow)\nfn fib_recursive(n) {\n  if n <= 1 { n }\n  else { fib_recursive(n - 1) + fib_recursive(n - 2) }\n}\n\n// Iterative (fast)\nfn fib(n) {\n  if n <= 1 { return n }\n  var a = 0\n  var b = 1\n  for i in range(2, n + 1) {\n    var temp = b\n    b = a + b\n    a = temp\n  }\n  b\n}\n\n// Print first 15 Fibonacci numbers\nprint(\"Fibonacci sequence:\")\nfor i in range(15) {\n  print(\"  fib({i}) = {fib(i)}\")\n}\n\n// Using list comprehension\nfibs = [fib(i) for i in range(20)]\nprint(\"\\nFirst 20: {fibs}\")\nprint(\"Sum: {sum(fibs)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Binary Search",
    "code": "// Binary search on sorted array\nfn binary_search(arr, target) {\n  var lo = 0\n  var hi = len(arr) - 1\n  while lo <= hi {\n    mid = (lo + hi) / 2\n    if arr[mid] == target {\n      return mid\n    } elif arr[mid] < target {\n      lo = mid + 1\n    } else {\n      hi = mid - 1\n    }\n  }\n  -1\n}\n\n// Test it\nnums = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\nprint(\"Array: {nums}\")\n\nfor target in [23, 72, 15, 2, 91] {\n  idx = binary_search(nums, target)\n  if idx >= 0 {\n    print(\"Found {target} at index {idx}\")\n  } else {\n    print(\"{target} not found\")\n  }\n}\n\n// Sorting + searching\nword_list = [\"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\", \"fig\"]\nsorted_words = sorted(word_list)\nprint(\"\\nSorted: {sorted_words}\")\nprint(\"Index of 'cherry': {binary_search(sorted_words, \"cherry\")}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Linked List with ADTs",
    "code": "// Linked List using algebraic data types\ntype List {\n  Cons(head: Any, tail: Any),\n  Empty\n}\n\n// Constructor helper\nfn list_of(arr) {\n  var result = Empty\n  for i in range(len(arr) - 1, -1, -1) {\n    result = Cons(arr[i], result)\n  }\n  result\n}\n\n// Operations\nfn list_len(lst) {\n  match lst {\n    Empty => 0\n    Cons(_, tail) => 1 + list_len(tail)\n  }\n}\n\nfn list_map(lst, f) {\n  match lst {\n    Empty => Empty\n    Cons(h, t) => Cons(f(h), list_map(t, f))\n  }\n}\n\nfn list_to_array(lst) {\n  var result = []\n  var current = lst\n  while current != Empty {\n    match current {\n      Cons(h, t) => {\n        result = [...result, h]\n        current = t\n      }\n      _ => { current = Empty }\n    }\n  }\n  result\n}\n\n// Test it\nmy_list = list_of([1, 2, 3, 4, 5])\nprint(\"Length: {list_len(my_list)}\")\n\ndoubled = list_map(my_list, fn(x) x * 2)\nprint(\"Doubled: {list_to_array(doubled)}\")\n\nsquared = list_map(my_list, fn(x) x * x)\nprint(\"Squared: {list_to_array(squared)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Game of Life",
    "code": "// Conway's Game of Life — one generation step\n\nfn make_grid(rows, cols) {\n  [[0 for c in range(cols)] for r in range(rows)]\n}\n\nfn count_neighbors(grid, r, c) {\n  rows = len(grid)\n  cols = len(grid[0])\n  var total = 0\n  for dr in [-1, 0, 1] {\n    for dc in [-1, 0, 1] {\n      if dr == 0 and dc == 0 { }\n      else {\n        nr = (r + dr + rows) % rows\n        nc = (c + dc + cols) % cols\n        total = total + grid[nr][nc]\n      }\n    }\n  }\n  total\n}\n\nfn step(grid) {\n  rows = len(grid)\n  cols = len(grid[0])\n  [\n    [\n      match [grid[r][c], count_neighbors(grid, r, c)] {\n        [1, n] if n < 2 => 0\n        [1, n] if n > 3 => 0\n        [1, _] => 1\n        [0, 3] => 3\n        _ => grid[r][c]\n      }\n    for c in range(cols)]\n  for r in range(rows)]\n}\n\nfn display(grid) {\n  for row in grid {\n    line = [match cell { 0 => \".\" _ => \"#\" } for cell in row]\n    print(line)\n  }\n}\n\n// Glider pattern\ngrid = make_grid(8, 8)\ngrid[1][2] = 1\ngrid[2][3] = 1\ngrid[3][1] = 1\ngrid[3][2] = 1\ngrid[3][3] = 1\n\nprint(\"Generation 0:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 1:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 2:\")\ndisplay(grid)\n"
  }
];
const REFERENCE = [
  {
    "title": "Variables",
    "items": [
      {
        "syntax": "name = \"Alice\"",
        "desc": "Immutable binding"
      },
      {
        "syntax": "var count = 0",
        "desc": "Mutable binding"
      },
      {
        "syntax": "a, b = 1, 2",
        "desc": "Multiple assignment"
      },
      {
        "syntax": "x, y = y, x",
        "desc": "Swap values"
      }
    ]
  },
  {
    "title": "Types",
    "items": [
      {
        "syntax": "Int, Float, String, Bool, Nil",
        "desc": "Primitive types"
      },
      {
        "syntax": "type Point { x: Float, y: Float }",
        "desc": "Struct type"
      },
      {
        "syntax": "type Color { Red, Blue, Custom(r: Int) }",
        "desc": "Algebraic type (ADT)"
      }
    ]
  },
  {
    "title": "Functions",
    "items": [
      {
        "syntax": "fn add(a, b) { a + b }",
        "desc": "Function (implicit return)"
      },
      {
        "syntax": "fn greet(name = \"world\") { ... }",
        "desc": "Default parameters"
      },
      {
        "syntax": "double = fn(x) x * 2",
        "desc": "Lambda expression"
      },
      {
        "syntax": "return value",
        "desc": "Early return"
      }
    ]
  },
  {
    "title": "Control Flow",
    "items": [
      {
        "syntax": "if cond { } elif { } else { }",
        "desc": "Conditionals"
      },
      {
        "syntax": "for item in items { }",
        "desc": "For-in loop"
      },
      {
        "syntax": "for i in range(10) { }",
        "desc": "Range loop"
      },
      {
        "syntax": "while cond { }",
        "desc": "While loop"
      }
    ]
  },
  {
    "title": "Pattern Matching",
    "items": [
      {
        "syntax": "match value { 0 => \"zero\", _ => \"other\" }",
        "desc": "Value matching"
      },
      {
        "syntax": "1..10 => \"small\"",
        "desc": "Range pattern"
      },
      {
        "syntax": "n if n > 100 => \"big\"",
        "desc": "Guard clause"
      },
      {
        "syntax": "Circle(r) => 3.14 * r ** 2",
        "desc": "Destructure ADT"
      }
    ]
  },
  {
    "title": "Strings",
    "items": [
      {
        "syntax": "\"Hello, {name}!\"",
        "desc": "Interpolation"
      },
      {
        "syntax": ".upper() .lower() .trim()",
        "desc": "Case methods"
      },
      {
        "syntax": ".contains(s) .starts_with(s)",
        "desc": "Search methods"
      },
      {
        "syntax": ".words() .chars() .lines()",
        "desc": "Split methods"
      },
      {
        "syntax": ".capitalize() .title_case()",
        "desc": "Format methods"
      },
      {
        "syntax": "\"-\" * 20",
        "desc": "String repeat"
      }
    ]
  },
  {
    "title": "Collections",
    "items": [
      {
        "syntax": "[1, 2, 3]",
        "desc": "Array literal"
      },
      {
        "syntax": "{key: value}",
        "desc": "Object literal"
      },
      {
        "syntax": "[x*2 for x in items if x > 0]",
        "desc": "List comprehension"
      },
      {
        "syntax": "{k: v for k in keys}",
        "desc": "Dict comprehension"
      },
      {
        "syntax": "arr[1:3]  arr[::-1]",
        "desc": "Slice syntax"
      },
      {
        "syntax": "[...a, ...b]",
        "desc": "Spread operator"
      }
    ]
  },
  {
    "title": "Operators",
    "items": [
      {
        "syntax": "+ - * / % **",
        "desc": "Arithmetic (** is power)"
      },
      {
        "syntax": "== != < <= > >=",
        "desc": "Comparison"
      },
      {
        "syntax": "and  or  not",
        "desc": "Logical"
      },
      {
        "syntax": "|>",
        "desc": "Pipe operator"
      },
      {
        "syntax": "x in list / x not in list",
        "desc": "Membership"
      },
      {
        "syntax": "1 < x < 10",
        "desc": "Chained comparison"
      },
      {
        "syntax": "a?.b",
        "desc": "Optional chaining"
      }
    ]
  },
  {
    "title": "Stdlib Functions",
    "items": [
      {
        "syntax": "print(...args)",
        "desc": "Print to console"
      },
      {
        "syntax": "len(v)",
        "desc": "Length of string/array/object"
      },
      {
        "syntax": "range(start?, end, step?)",
        "desc": "Generate number array"
      },
      {
        "syntax": "sum(arr) min(arr) max(arr)",
        "desc": "Aggregation"
      },
      {
        "syntax": "sorted(arr, key?) reversed(arr)",
        "desc": "Ordering"
      },
      {
        "syntax": "enumerate(arr)",
        "desc": "Index-value pairs"
      },
      {
        "syntax": "zip(a, b, ...)",
        "desc": "Combine arrays"
      },
      {
        "syntax": "map(arr, fn) filter(arr, fn)",
        "desc": "Transform/filter"
      },
      {
        "syntax": "type_of(value)",
        "desc": "Runtime type name"
      }
    ]
  },
  {
    "title": "Reactive (client)",
    "items": [
      {
        "syntax": "state count = 0",
        "desc": "Reactive variable (signal)"
      },
      {
        "syntax": "computed doubled = count * 2",
        "desc": "Derived value"
      },
      {
        "syntax": "effect { ... }",
        "desc": "Side effect (auto-tracks deps)"
      },
      {
        "syntax": "component App { <div>...</div> }",
        "desc": "UI component"
      },
      {
        "syntax": "on:click={fn() ...}",
        "desc": "Event handler"
      },
      {
        "syntax": "server.method()",
        "desc": "RPC call to server"
      }
    ]
  },
  {
    "title": "Full-Stack Blocks",
    "items": [
      {
        "syntax": "server { ... }",
        "desc": "Server-side code (Bun)"
      },
      {
        "syntax": "client { ... }",
        "desc": "Client-side code (browser)"
      },
      {
        "syntax": "shared { ... }",
        "desc": "Shared code (both)"
      },
      {
        "syntax": "route GET \"/path\" => handler",
        "desc": "HTTP route"
      }
    ]
  }
];
const TUTORIAL = [
  {
    "title": "Welcome to Tova",
    "description": "Tova is a modern language that compiles to JavaScript. It combines Python's readability with ML-style pattern matching and built-in reactivity.",
    "code": "// Try running this! Press Cmd/Ctrl+Enter or click Run.\nprint(\"Welcome to Tova!\")\n\n// Variables are immutable by default\nname = \"Developer\"\nprint(\"Hello, {name}!\")\n\n// Use 'var' for mutable variables\nvar counter = 0\ncounter += 1\nprint(\"Counter: {counter}\")"
  },
  {
    "title": "Functions",
    "description": "Functions use the fn keyword and return their last expression. No \"return\" needed!",
    "code": "// Implicit return — the last expression is returned\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"World\") {\n  \"Hello, {name}!\"\n}\n\nprint(add(3, 4))\nprint(greet())\nprint(greet(\"Tova\"))\n\n// Lambdas for short functions\ndouble = fn(x) x * 2\nprint(double(21))"
  },
  {
    "title": "Collections",
    "description": "Tova has powerful collection features: list comprehensions, slicing, and the pipe operator.",
    "code": "// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// Filter with comprehension\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Pipe operator for readable chains\nresult = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Slicing\narr = [10, 20, 30, 40, 50]\nprint(\"First 3: {arr[:3]}\")\nprint(\"Last 2: {arr[3:]}\")"
  },
  {
    "title": "Pattern Matching",
    "description": "Match expressions are like switch on steroids. They support values, ranges, guards, and destructuring.",
    "code": "// Match on values and ranges\nfn classify(n) {\n  match n {\n    0 => \"zero\"\n    1..10 => \"small\"\n    n if n > 100 => \"huge: {n}\"\n    _ => \"medium: {n}\"\n  }\n}\n\nfor n in [0, 3, 50, 200] {\n  print(\"{n} -> {classify(n)}\")\n}\n\n// Match on algebraic types\ntype Shape {\n  Circle(r: Float),\n  Rect(w: Float, h: Float)\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n  }\n}\n\nprint(\"Circle area: {area(Circle(5.0))}\")\nprint(\"Rect area: {area(Rect(3.0, 4.0))}\")"
  },
  {
    "title": "Types & ADTs",
    "description": "Define struct-like types and algebraic data types (tagged unions) for type-safe data modeling.",
    "code": "// Struct type\ntype User {\n  name: String\n  age: Int\n}\n\n// Algebraic type (sum type)\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn validate_age(age) {\n  if age >= 0 and age <= 150 {\n    Ok(User(\"Valid\", age))\n  } else {\n    Err(\"Age must be 0-150, got {age}\")\n  }\n}\n\nfor age in [25, -5, 200, 42] {\n  result = validate_age(age)\n  match result {\n    Ok(user) => print(\"Valid: age {user.age}\")\n    Err(msg) => print(\"Error: {msg}\")\n  }\n}"
  },
  {
    "title": "Reactive UI",
    "description": "Tova has built-in reactivity for building UIs. State changes automatically update the DOM!",
    "code": "// Switch to the \"Preview\" tab to see this in action!\nclient {\n  state clicks = 0\n  computed doubled = clicks * 2\n  computed emoji = match clicks {\n    0 => \"Start clicking!\"\n    c if c < 5 => \"Getting started...\"\n    c if c < 10 => \"Nice!\"\n    _ => \"On fire!\"\n  }\n\n  component App {\n    <div style=\"text-align: center; padding: 20px;\">\n      <h1>\"Tova Reactive Demo\"</h1>\n      <p style=\"font-size: 48px;\">\"{clicks}\"</p>\n      <p>\"Doubled: {doubled}\"</p>\n      <p>\"{emoji}\"</p>\n      <button on:click={fn() clicks += 1}>\"+ Add\"</button>\n      <button on:click={fn() clicks -= 1}>\"- Sub\"</button>\n      <button on:click={fn() clicks = 0}>\"Reset\"</button>\n    </div>\n  }\n}"
  },
  {
    "title": "Strings & Interpolation",
    "description": "Tova strings support interpolation with {expressions}, plus Python-style methods like .upper(), .contains(), and even string repetition.",
    "code": "// String interpolation with any expression\nname = \"World\"\nprint(\"Hello, {name}!\")\n\n// Expressions inside interpolation\nx = 7\nprint(\"{x} squared is {x * x}\")\n\n// String methods\ngreeting = \"hello world\"\nprint(greeting.upper())\nprint(greeting.capitalize())\nprint(greeting.title_case())\n\n// Useful checks\nprint(\"contains 'world': {greeting.contains(\"world\")}\")\nprint(\"starts with 'hello': {greeting.starts_with(\"hello\")}\")\n\n// String repetition\nborder = \"=\" * 30\nprint(border)\nprint(\"  Tova is great!\")\nprint(border)"
  },
  {
    "title": "Pipe Operator",
    "description": "The pipe operator |> chains function calls, making data transformations read top-to-bottom instead of inside-out.",
    "code": "// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\n\nprint(\"Sum of squares of evens: {result}\")\n\n// Name pipeline\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\"]\nsorted_long = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\nprint(\"Long names sorted: {sorted_long}\")\n\n// Simple value pipeline\n42 |> fn(x) x * 2 |> fn(x) \"Answer: {x}\" |> print()"
  },
  {
    "title": "Full-Stack App",
    "description": "Tova has built-in full-stack blocks: server, client, and shared. In the playground, server features are simulated.",
    "code": "// A full-stack app has server + client blocks.\n// In playground mode, server calls are stubbed.\n\nclient {\n  state name = \"World\"\n  computed greeting = \"Hello, {name}!\"\n\n  component App {\n    <div style=\"padding: 20px;\">\n      <h1>\"Full-Stack Demo\"</h1>\n      <div class=\"input-group\">\n        <label>\"Your name:\"</label>\n        <input type=\"text\" value={name}\n               on:input={fn(e) name = e.target.value} />\n      </div>\n      <p style=\"font-size: 24px; margin-top: 16px;\">\"{greeting}\"</p>\n      <p class=\"hint\">\"(Type to see reactive updates!)\"</p>\n    </div>\n  }\n}"
  },
  {
    "title": "Advanced Patterns",
    "description": "Combine pattern matching with algebraic types, guards, and destructuring for expressive code.",
    "code": "// Result type with pattern matching\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_number(s) {\n  n = s * 1  // coerce to number\n  if n != n { Err(\"Not a number: {s}\") }\n  else { Ok(n) }\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { Err(\"Division by zero\") }\n  else { Ok(a / b) }\n}\n\n// Chain operations with match\ninputs = [[\"10\", \"2\"], [\"42\", \"0\"], [\"abc\", \"5\"], [\"100\", \"4\"]]\nfor pair in inputs {\n  result = match parse_number(pair[0]) {\n    Err(msg) => Err(msg)\n    Ok(a) => match parse_number(pair[1]) {\n      Err(msg) => Err(msg)\n      Ok(b) => safe_divide(a, b)\n    }\n  }\n  match result {\n    Ok(v) => print(\"{pair[0]} / {pair[1]} = {v}\")\n    Err(msg) => print(\"{pair[0]} / {pair[1]} -> Error: {msg}\")\n  }\n}"
  }
];

// ─── State ──────────────────────────────────────────
let autoCompile = true;
let autoRun = true;
let sidebarMode = null; // 'reference' | 'tutorial' | null
let tutorialStep = 0;
let compileTimer = null;

// ─── Early embed mode detection ─────────────────────
const __isEmbed = new URLSearchParams(location.search).get('embed') === 'true';

// ─── Restore settings from localStorage ─────────────
try {
  const saved = JSON.parse(localStorage.getItem('tova-playground-settings') || '{}');
  if (saved.fontSize) document.documentElement.style.setProperty('--editor-font-size', saved.fontSize + 'px');
  if (saved.fontSize) document.getElementById('setting-fontsize').value = saved.fontSize;
  if (saved.autoCompile === false) { autoCompile = false; document.getElementById('setting-autocompile').classList.remove('on'); }
  if (saved.autoRun === false) { autoRun = false; document.getElementById('setting-autorun').classList.remove('on'); }
} catch(e) {}

function saveSettings() {
  try {
    localStorage.setItem('tova-playground-settings', JSON.stringify({
      fontSize: parseInt(document.getElementById('setting-fontsize').value),
      autoCompile,
      autoRun
    }));
  } catch(e) {}
}

// ─── Editor Setup ───────────────────────────────────
const statusCursor = document.getElementById('status-cursor');

// Restore last code or use first example (skip localStorage in embed mode)
let initialCode = EXAMPLES[0].code;
if (!__isEmbed) {
  try {
    const lastCode = localStorage.getItem('tova-playground-code');
    if (lastCode && lastCode.trim()) initialCode = lastCode;
  } catch(e) {}
}

const editor = new EditorView({
  state: EditorState.create({
    doc: initialCode,
    extensions: [
      basicSetup,
      oneDark,
      tovaLanguage,
      errorField,
      autocompletion({
        override: [tovaCompletions],
        icons: true,
        activateOnTyping: true,
      }),
      EditorView.updateListener.of(update => {
        if (update.docChanged) {
          try { localStorage.setItem('tova-playground-code', update.state.doc.toString()); } catch(e) {}
          if (autoCompile) scheduleCompile();
        }
        if (update.selectionSet) {
          const pos = update.state.selection.main.head;
          const line = update.state.doc.lineAt(pos);
          const lines = update.state.doc.lines;
          const chars = update.state.doc.length;
          statusCursor.textContent = 'Ln ' + line.number + ', Col ' + (pos - line.from + 1) + '  |  ' + lines + ' lines, ' + chars + ' chars';
        }
      }),
      keymap.of([
        { key: 'Mod-Enter', run: () => { compile(); return true; } },
        { key: 'Mod-k', run: () => { toggleCommandPalette(); return true; } },
        { key: 'Mod-s', run: () => {
          try { localStorage.setItem('tova-playground-code', editor.state.doc.toString()); } catch(e) {}
          const s = document.getElementById('status-compile');
          s.className = 'success'; s.textContent = 'Saved to browser';
          setTimeout(() => compile(), 1000);
          return true;
        }},
        { key: 'Mod-Shift-r', run: () => { toggleSidebar('reference'); return true; } },
        { key: 'Mod-Shift-s', run: () => { downloadCode(); return true; } },
        { key: 'Mod-/', run: () => { toggleModal('shortcuts-modal'); return true; } },
        { key: 'Mod-j', run: () => { toggleLayout(); return true; } },
      ]),
    ],
  }),
  parent: document.getElementById('editor'),
});

// ─── Populate Examples (with optgroups) ─────────────
const exSelect = document.getElementById('examples-select');
let optgroup = null;
let currentCat = null;
EXAMPLES.forEach((ex, i) => {
  if (ex.category !== currentCat) {
    currentCat = ex.category;
    optgroup = document.createElement('optgroup');
    optgroup.label = currentCat;
    exSelect.appendChild(optgroup);
  }
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = ex.name;
  optgroup.appendChild(opt);
});
exSelect.addEventListener('change', () => {
  const code = EXAMPLES[+exSelect.value].code;
  setEditorCode(code);
  exSelect.value = '';
});

function setEditorCode(code) {
  editor.dispatch({ changes: { from: 0, to: editor.state.doc.length, insert: code } });
  compile();
}

// ─── Output Tabs ────────────────────────────────────
function switchTab(tabName) {
  document.querySelectorAll('#output-tabs .tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.output-panel').forEach(p => p.classList.remove('active'));
  const tab = document.querySelector('#output-tabs .tab[data-tab="' + tabName + '"]');
  if (tab) tab.classList.add('active');
  const panel = document.getElementById('panel-' + tabName);
  if (panel) panel.classList.add('active');
}

document.querySelectorAll('#output-tabs .tab').forEach(tab => {
  tab.addEventListener('click', () => switchTab(tab.dataset.tab));
});

// ─── Drag Handle ────────────────────────────────────
const dragHandle = document.getElementById('drag-handle');
const mainEl = document.querySelector('.main');
const editorPane = document.querySelector('.pane-editor');
const outputPane = document.querySelector('.pane-output');

let dragging = false;
dragHandle.addEventListener('mousedown', e => { dragging = true; dragHandle.classList.add('active'); e.preventDefault(); });
document.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = mainEl.getBoundingClientRect();
  const sidebarW = sidebarMode ? parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w')) : 0;
  const availW = rect.width - sidebarW;
  const pct = ((e.clientX - rect.left) / availW) * 100;
  const clamped = Math.max(20, Math.min(80, pct));
  editorPane.style.flex = 'none';
  editorPane.style.width = clamped + '%';
  outputPane.style.flex = '1';
});
document.addEventListener('mouseup', () => { dragging = false; dragHandle.classList.remove('active'); });

// ─── Share ──────────────────────────────────────────
document.getElementById('btn-share').addEventListener('click', () => {
  const code = editor.state.doc.toString();
  const compressed = LZString.compressToEncodedURIComponent(code);
  const url = location.origin + location.pathname + '#code=' + compressed;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('btn-share');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Share'; }, 2000);
  });
});

// ─── Download ───────────────────────────────────────
function downloadCode() {
  const code = editor.state.doc.toString();
  const blob = new Blob([code], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'playground.tova';
  a.click();
  URL.revokeObjectURL(a.href);
}
document.getElementById('btn-download').addEventListener('click', downloadCode);

// ─── Load from URL hash ─────────────────────────────
function loadFromHash() {
  const hash = location.hash.slice(1);
  if (hash.startsWith('code=')) {
    try {
      const code = LZString.decompressFromEncodedURIComponent(hash.slice(5));
      if (code) { setEditorCode(code); return true; }
    } catch (e) {}
  }
  return false;
}
loadFromHash();

// ─── Run Button ─────────────────────────────────────
document.getElementById('btn-run').addEventListener('click', compile);

// ─── Debounced Compile ──────────────────────────────
function scheduleCompile() {
  clearTimeout(compileTimer);
  compileTimer = setTimeout(compile, 350);
}

// ─── Compiler ───────────────────────────────────────
let lastJsText = '';

function compile() {
  const source = editor.state.doc.toString();
  const statusEl = document.getElementById('status-compile');
  const statusSize = document.getElementById('status-size');
  const errorBanner = document.getElementById('error-banner');
  const errorText = document.getElementById('error-text');
  const errorHint = document.getElementById('error-hint');
  const consoleOutput = document.getElementById('console-output');
  const consoleBadge = document.getElementById('console-badge');
  const consoleTimingEl = document.getElementById('console-timing');
  const astOutput = document.getElementById('ast-output');
  const previewFrame = document.getElementById('preview-frame');

  errorBanner.classList.remove('visible');
  errorText.textContent = '';
  if (errorHint) errorHint.textContent = '';
  consoleOutput.innerHTML = '';
  consoleBadge.style.display = 'none';

  // Clear error decorations
  editor.dispatch({ effects: clearErrorEffect.of(null) });

  const start = performance.now();

  try {
    const lexer = new Lexer(source, 'playground.tova');
    const tokens = lexer.tokenize();

    const parser = new Parser(tokens, 'playground.tova');
    const ast = parser.parse();

    const analyzer = new Analyzer(ast, 'playground.tova');
    const { warnings } = analyzer.analyze();

    const codegen = new CodeGenerator(ast, 'playground.tova');
    const result = codegen.generate();

    const elapsed = (performance.now() - start).toFixed(1);

    // JS Output
    let jsText = '';
    if (result.shared) jsText += '// ── Shared ──\n' + result.shared + '\n\n';
    if (result.server) jsText += '// ── Server ──\n' + result.server + '\n\n';
    if (result.client) jsText += '// ── Client ──\n' + result.client + '\n\n';
    if (!result.shared && !result.server && !result.client && result.code) {
      jsText = result.code;
    }
    lastJsText = jsText || '// No output';

    // Update JS output (use CodeMirror read-only editor if available, else pre tag)
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: lastJsText } });
    } else {
      document.getElementById('js-output').textContent = lastJsText;
    }

    // Status bar output size
    if (statusSize) statusSize.textContent = (lastJsText.length / 1024).toFixed(1) + ' KB output';

    // AST
    astOutput.innerHTML = '';
    astOutput.appendChild(renderAST(ast));

    // Console + Preview
    if (autoRun) {
      executeCode(result, consoleOutput, previewFrame, consoleBadge, consoleTimingEl);
    }

    // Warnings
    const warnCount = warnings ? warnings.length : 0;
    if (warnCount) {
      for (const w of warnings) {
        const div = document.createElement('div');
        div.className = 'log-warn';
        div.innerHTML = '<span class="log-icon">\u26A0</span> Warning: ' + escapeHtml(w.message || String(w));
        consoleOutput.appendChild(div);
      }
    }

    statusEl.className = 'success';
    statusEl.textContent = '\u2713 Compiled in ' + elapsed + 'ms' + (warnCount ? ' (' + warnCount + ' warning' + (warnCount > 1 ? 's' : '') + ')' : '');

  } catch (err) {
    const elapsed = (performance.now() - start).toFixed(1);
    statusEl.className = 'error';
    statusEl.textContent = '\u2717 Error (' + elapsed + 'ms)';
    errorText.textContent = err.message;

    // Error hints for common mistakes
    const hints = getErrorHint(err.message);
    if (errorHint && hints) errorHint.textContent = hints;

    errorBanner.classList.add('visible');
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: '// Compilation error\n// ' + err.message } });
    } else {
      document.getElementById('js-output').textContent = '// Compilation error\n// ' + err.message;
    }
    previewFrame.srcdoc = '';

    // Highlight error line in editor with decorations
    const lineMatch = err.message.match(/:(\d+):/);
    if (lineMatch) {
      const lineNum = parseInt(lineMatch[1]);
      editor.dispatch({ effects: setErrorEffect.of([lineNum]) });
      // Scroll to error line
      try {
        const lineInfo = editor.state.doc.line(lineNum);
        editor.dispatch({ selection: { anchor: lineInfo.from } });
      } catch(e) {}
    }
  }
}

function getErrorHint(msg) {
  if (msg.includes('Unexpected token')) return 'Tip: Check for missing closing brackets or semicolons';
  if (msg.includes('not defined')) return 'Tip: Make sure the variable is declared before use';
  if (msg.includes('Expected')) return 'Tip: The compiler expected a different token here';
  return null;
}

// ─── Execute Code ───────────────────────────────────
function executeCode(result, consoleEl, previewFrame, consoleBadge, consoleTimingEl) {
  const logs = [];
  const fakeConsole = {
    log: (...args) => logs.push({ type: 'log', args }),
    warn: (...args) => logs.push({ type: 'warn', args }),
    error: (...args) => logs.push({ type: 'error', args }),
    info: (...args) => logs.push({ type: 'info', args }),
  };

  const execStart = performance.now();
  const codeToRun = result.code || result.shared || '';
  if (codeToRun.trim()) {
    try {
      const fn = new Function('console', STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n' + ARRAY_PROTO_CODE + '\n' + codeToRun);
      fn(fakeConsole);
    } catch (e) {
      logs.push({ type: 'error', args: ['Runtime Error: ' + e.message] });
    }
  }
  const execTime = (performance.now() - execStart).toFixed(2);

  if (consoleTimingEl) consoleTimingEl.textContent = 'Executed in ' + execTime + 'ms';

  // Render logs with icons and better formatting
  const icons = { log: '\u203A', warn: '\u26A0', error: '\u2717', info: '\u2139' };
  let errorCount = 0;
  for (const log of logs) {
    const div = document.createElement('div');
    div.className = 'log-' + log.type;
    const icon = document.createElement('span');
    icon.className = 'log-icon';
    icon.textContent = icons[log.type] || '';
    div.appendChild(icon);
    const content = document.createElement('span');
    content.className = 'log-content';
    const textParts = log.args.map(a => {
      if (a === null) return 'null';
      if (a === undefined) return 'undefined';
      if (typeof a === 'object') {
        try { return JSON.stringify(a, null, 2); } catch(e) { return String(a); }
      }
      return String(a);
    });
    content.textContent = textParts.join(' ');
    div.appendChild(content);
    consoleEl.appendChild(div);
    if (log.type === 'error') errorCount++;
  }

  // Badge for errors
  if (errorCount > 0) {
    consoleBadge.textContent = errorCount;
    consoleBadge.style.display = 'inline';
    switchTab('console');
  }

  // Auto-switch to console if there are logs and no client code
  if (logs.length > 0 && !result.client) {
    switchTab('console');
  }

  // Live Preview for client code
  if (result.client) {
    const clientCode = result.client
      .replace(/import\s+.*from\s+['"].*['"];?/g, '')
      .replace(/import\s+['"].*['"];?/g, '');

    const previewCSS = '*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }' +
      'body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding: 20px; color: #333; }' +
      'button { cursor: pointer; padding: 8px 16px; margin: 4px; border-radius: 6px; border: 1px solid #ddd; background: #f5f5f5; font-size: 14px; transition: all 0.15s; }' +
      'button:hover { background: #e8e8e8; border-color: #ccc; }' +
      'button:active { transform: scale(0.97); }' +
      'input[type="text"], input[type="number"] { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; margin: 4px; font-size: 14px; outline: none; }' +
      'input[type="text"]:focus, input[type="number"]:focus { border-color: #7c3aed; box-shadow: 0 0 0 3px rgba(124,58,237,0.1); }' +
      'input[type="range"] { width: 200px; margin: 8px 0; }' +
      'input[type="checkbox"] { margin: 4px 8px 4px 0; }' +
      'ul { list-style: none; } li { padding: 6px 0; }' +
      'h1 { margin-bottom: 16px; font-size: 24px; } h2 { margin-bottom: 12px; font-size: 20px; }' +
      'p { margin: 6px 0; line-height: 1.5; }' +
      '.status { color: #666; font-size: 14px; margin-top: 12px; }' +
      '.counter-app, .todo-app, .converter, .stopwatch { max-width: 400px; }' +
      '.count { font-size: 48px; font-weight: 700; color: #7c3aed; }' +
      '.buttons { display: flex; gap: 4px; margin-top: 8px; }' +
      '.input-row { display: flex; gap: 4px; margin-bottom: 12px; }' +
      '.input-row input { flex: 1; }' +
      '.todo-item { display: flex; align-items: center; gap: 8px; }' +
      '.todo-text { flex: 1; }' +
      '.input-group { margin: 12px 0; }' +
      '.input-group label { display: block; font-weight: 600; margin-bottom: 4px; }' +
      '.value { font-size: 18px; font-weight: 600; color: #7c3aed; margin-left: 8px; }' +
      '.desc { font-style: italic; color: #666; }' +
      '.time { font-size: 48px; font-weight: 700; color: #7c3aed; margin: 16px 0; }' +
      '.controls { display: flex; gap: 4px; flex-wrap: wrap; }' +
      '.hint { color: #999; font-size: 12px; margin-top: 12px; }';

    const sharedCode = (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');

    // Build preview HTML using string concatenation — NOT a template literal.
    // Generated client code may contain backticks (JS template strings from
    // string interpolation) which would break a template-literal wrapper.
    const previewHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8">\n<style>' + previewCSS + '</style>\n</head><body>\n' +
      '<div id="app"></div>\n<script>\n' +
      RUNTIME_CODE + '\n' +
      STDLIB_CODE + '\n' +
      STRING_PROTO_CODE + '\n' +
      ARRAY_PROTO_CODE + '\n' +
      'function rpc(name, args) { console.warn("[Playground] server." + name + "() is not available in playground mode"); return Promise.resolve(null); }\n' +
      sharedCode + '\n' +
      clientCode + '\n' +
      'if (typeof App === "function") {' +
      '  if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", function() { mount(App, document.getElementById("app")); }); }' +
      '  else { mount(App, document.getElementById("app")); }' +
      '}\n' +
      '<\/script>\n</body></html>';
    previewFrame.srcdoc = previewHTML;
    // Auto-switch to preview when there's a client block
    switchTab('preview');
  } else {
    previewFrame.srcdoc = '<html><body style="font-family:sans-serif;padding:20px;color:#aaa"><p>Write a <code>client { }</code> block with a <code>component App</code> to see a live preview here.</p></body></html>';
  }
}

// ─── AST Renderer ───────────────────────────────────
function renderAST(node, depth = 0) {
  if (node === null || node === undefined) {
    const span = document.createElement('span');
    span.className = 'ast-null'; span.textContent = 'null'; return span;
  }
  if (typeof node !== 'object') {
    const span = document.createElement('span');
    if (typeof node === 'string') { span.className = 'ast-string'; span.textContent = '"' + node + '"'; }
    else if (typeof node === 'number') { span.className = 'ast-number'; span.textContent = String(node); }
    else if (typeof node === 'boolean') { span.className = 'ast-bool'; span.textContent = String(node); }
    else { span.textContent = String(node); }
    return span;
  }
  if (Array.isArray(node)) {
    if (node.length === 0) { const s = document.createElement('span'); s.className = 'ast-null'; s.textContent = '[]'; return s; }
    const c = document.createElement('div'); c.className = 'ast-node';
    const t = document.createElement('span'); t.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
    t.textContent = 'Array[' + node.length + ']';
    const ch = document.createElement('div'); ch.className = 'ast-children' + (depth < 2 ? ' open' : '');
    t.addEventListener('click', () => { t.classList.toggle('open'); ch.classList.toggle('open'); });
    for (let i = 0; i < node.length; i++) {
      const r = document.createElement('div'); r.className = 'ast-node';
      const k = document.createElement('span'); k.className = 'ast-key'; k.textContent = i + ': ';
      r.appendChild(k); r.appendChild(renderAST(node[i], depth + 1)); ch.appendChild(r);
    }
    c.appendChild(t); c.appendChild(ch); return c;
  }
  const container = document.createElement('div'); container.className = 'ast-node';
  const typeName = node.constructor?.name || 'Object';
  const keys = Object.keys(node).filter(k => k !== 'line' && k !== 'column');
  if (keys.length === 0) { const s = document.createElement('span'); s.className = 'ast-type'; s.textContent = typeName; container.appendChild(s); return container; }
  const toggle = document.createElement('span'); toggle.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
  const typeSpan = document.createElement('span'); typeSpan.className = 'ast-type'; typeSpan.textContent = typeName;
  toggle.appendChild(typeSpan);
  const children = document.createElement('div'); children.className = 'ast-children' + (depth < 2 ? ' open' : '');
  toggle.addEventListener('click', () => { toggle.classList.toggle('open'); children.classList.toggle('open'); });
  for (const key of keys) {
    const row = document.createElement('div'); row.className = 'ast-node';
    const keySpan = document.createElement('span'); keySpan.className = 'ast-key'; keySpan.textContent = key + ': ';
    row.appendChild(keySpan); row.appendChild(renderAST(node[key], depth + 1)); children.appendChild(row);
  }
  container.appendChild(toggle); container.appendChild(children);
  return container;
}

// ─── Sidebar (Reference / Tutorial) ─────────────────
const sidebar = document.getElementById('sidebar');
const sidebarBody = document.getElementById('sidebar-body');
const sidebarTitle = document.getElementById('sidebar-title');
const tutorialNav = document.getElementById('tutorial-nav');

function toggleSidebar(mode) {
  if (sidebarMode === mode) {
    sidebar.classList.remove('open');
    sidebarMode = null;
    document.getElementById('btn-reference').classList.remove('active');
    document.getElementById('btn-tutorial').classList.remove('active');
    return;
  }
  sidebarMode = mode;
  sidebar.classList.add('open');

  document.getElementById('btn-reference').classList.toggle('active', mode === 'reference');
  document.getElementById('btn-tutorial').classList.toggle('active', mode === 'tutorial');

  if (mode === 'reference') {
    sidebarTitle.textContent = 'Tova Reference';
    tutorialNav.style.display = 'none';
    renderReference();
  } else if (mode === 'tutorial') {
    sidebarTitle.textContent = 'Learn Tova';
    tutorialNav.style.display = 'flex';
    renderTutorialStep();
  }
}

function renderTutorialStep() {
  sidebarBody.innerHTML = '';
  const step = TUTORIAL[tutorialStep];
  if (!step) return;

  // Progress dots
  const progress = document.createElement('div');
  progress.className = 'tutorial-progress';
  for (let i = 0; i < TUTORIAL.length; i++) {
    const dot = document.createElement('div');
    dot.className = 'tutorial-dot' + (i === tutorialStep ? ' active' : '') + (i < tutorialStep ? ' completed' : '');
    dot.addEventListener('click', () => { tutorialStep = i; renderTutorialStep(); });
    progress.appendChild(dot);
  }
  sidebarBody.appendChild(progress);

  const div = document.createElement('div');
  div.className = 'tutorial-step';
  div.innerHTML = '<h4>' + (tutorialStep + 1) + '. ' + escapeHtml(step.title) + '</h4>'
    + '<p>' + escapeHtml(step.description) + '</p>';
  const tryBtn = document.createElement('button');
  tryBtn.className = 'try-btn';
  tryBtn.textContent = '\u25B6 Try this code';
  tryBtn.addEventListener('click', () => { setEditorCode(step.code); });
  div.appendChild(tryBtn);
  sidebarBody.appendChild(div);

  // Update nav buttons
  document.getElementById('tut-prev').disabled = tutorialStep === 0;
  document.getElementById('tut-next').textContent = tutorialStep === TUTORIAL.length - 1 ? 'Finish \u2713' : 'Next \u2192';
}

document.getElementById('btn-reference').addEventListener('click', () => toggleSidebar('reference'));
document.getElementById('btn-tutorial').addEventListener('click', () => toggleSidebar('tutorial'));
document.getElementById('sidebar-close').addEventListener('click', () => toggleSidebar(sidebarMode));

document.getElementById('tut-prev').addEventListener('click', () => {
  if (tutorialStep > 0) { tutorialStep--; renderTutorialStep(); }
});
document.getElementById('tut-next').addEventListener('click', () => {
  if (tutorialStep < TUTORIAL.length - 1) { tutorialStep++; renderTutorialStep(); }
  else { toggleSidebar('tutorial'); }
});

// ─── Settings ───────────────────────────────────────
document.getElementById('btn-settings').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('settings-dropdown').classList.toggle('visible');
});
document.addEventListener('click', (e) => {
  if (!e.target.closest('#settings-dropdown') && !e.target.closest('#btn-settings')) {
    document.getElementById('settings-dropdown').classList.remove('visible');
  }
});
document.getElementById('setting-fontsize').addEventListener('change', (e) => {
  document.documentElement.style.setProperty('--editor-font-size', e.target.value + 'px');
  saveSettings();
});
document.getElementById('setting-autocompile').addEventListener('click', function() {
  autoCompile = !autoCompile;
  this.classList.toggle('on', autoCompile);
  saveSettings();
});
document.getElementById('setting-autorun').addEventListener('click', function() {
  autoRun = !autoRun;
  this.classList.toggle('on', autoRun);
  saveSettings();
});

// ─── Keyboard Shortcuts Modal ───────────────────────
function toggleModal(id) {
  document.getElementById(id).classList.toggle('visible');
}
document.getElementById('btn-shortcuts').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-close').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) toggleModal('shortcuts-modal');
});

// ─── Error banner click → jump to error line ────────
document.getElementById('error-banner').addEventListener('click', () => {
  const text = document.getElementById('error-text').textContent;
  const lineMatch = text.match(/:(\d+):/);
  if (lineMatch) {
    const line = parseInt(lineMatch[1]);
    try {
      const lineInfo = editor.state.doc.line(line);
      editor.dispatch({ selection: { anchor: lineInfo.from } });
      editor.focus();
    } catch(e) {}
  }
});

// ─── JS Output Editor (read-only CodeMirror) ────────
try {
  const jsEditorParent = document.getElementById('js-output-editor');
  if (jsEditorParent) {
    window.jsEditor = new EditorView({
      state: EditorState.create({
        doc: '// Compiled JS output will appear here',
        extensions: [
          basicSetup,
          oneDark,
          EditorState.readOnly.of(true),
          EditorView.editable.of(false),
        ],
      }),
      parent: jsEditorParent,
    });
  }
} catch(e) { console.warn('JS output editor init failed:', e); }

// ─── Console Buttons ────────────────────────────────
document.getElementById('btn-clear-console').addEventListener('click', () => {
  document.getElementById('console-output').innerHTML = '';
  document.getElementById('console-timing').textContent = '';
  const badge = document.getElementById('console-badge');
  badge.style.display = 'none';
});

document.getElementById('btn-copy-console').addEventListener('click', () => {
  const text = document.getElementById('console-output').innerText;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btn-copy-console');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
});

// ─── Command Palette ────────────────────────────────
let cmdPaletteOpen = false;
let cmdSelectedIndex = 0;

function getCommandItems(query) {
  const q = query.toLowerCase();
  const items = [];

  // Actions
  const actions = [
    { icon: '\u25B6', label: 'Run Code', category: 'Action', shortcut: '\u2318Enter', action: () => compile() },
    { icon: '\u2197', label: 'Share URL', category: 'Action', action: () => document.getElementById('btn-share').click() },
    { icon: '\u2913', label: 'Download .tova', category: 'Action', shortcut: '\u2318\u21E7S', action: () => downloadCode() },
    { icon: '\uD83D\uDCE4', label: 'Export as HTML', category: 'Action', action: () => exportAsHTML() },
    { icon: '\uD83D\uDCD6', label: 'Toggle Reference', category: 'Action', shortcut: '\u2318\u21E7R', action: () => toggleSidebar('reference') },
    { icon: '\uD83C\uDF93', label: 'Start Tutorial', category: 'Action', action: () => toggleSidebar('tutorial') },
    { icon: '\u2699', label: 'Toggle Light Theme', category: 'Action', action: () => document.getElementById('setting-theme').click() },
    { icon: '\u2B12', label: 'Toggle Layout', category: 'Action', shortcut: '\u2318J', action: () => toggleLayout() },
  ];

  for (const a of actions) {
    if (!q || a.label.toLowerCase().includes(q)) items.push(a);
  }

  // Examples
  for (let i = 0; i < EXAMPLES.length; i++) {
    const ex = EXAMPLES[i];
    if (!q || ex.name.toLowerCase().includes(q) || ex.category.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDCC4',
        label: ex.name,
        category: ex.category,
        action: () => { setEditorCode(ex.code); }
      });
    }
  }

  // Reference sections
  for (const section of REFERENCE) {
    if (!q || section.title.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDD0D',
        label: section.title,
        category: 'Reference',
        action: () => { toggleSidebar('reference'); }
      });
    }
  }

  return items;
}

function renderCommandPalette(query) {
  const results = document.getElementById('cmd-results');
  const items = getCommandItems(query || '');
  results.innerHTML = '';
  cmdSelectedIndex = 0;

  if (items.length === 0) {
    results.innerHTML = '<div class="cmd-palette-empty">No results found</div>';
    return;
  }

  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'cmd-palette-item' + (i === 0 ? ' selected' : '');
    div.innerHTML = '<span class="cmd-icon">' + item.icon + '</span>'
      + '<span class="cmd-label">' + escapeHtml(item.label) + '</span>'
      + '<span class="cmd-category">' + escapeHtml(item.category) + '</span>'
      + (item.shortcut ? '<span class="cmd-shortcut">' + item.shortcut + '</span>' : '');
    div.addEventListener('click', () => { item.action(); closeCommandPalette(); });
    div.addEventListener('mouseenter', () => {
      results.querySelectorAll('.cmd-palette-item').forEach(el => el.classList.remove('selected'));
      div.classList.add('selected');
      cmdSelectedIndex = i;
    });
    results.appendChild(div);
  });

  window._cmdItems = items;
}

function toggleCommandPalette() {
  if (cmdPaletteOpen) { closeCommandPalette(); return; }
  cmdPaletteOpen = true;
  document.getElementById('cmd-palette').classList.add('visible');
  const input = document.getElementById('cmd-input');
  input.value = '';
  renderCommandPalette('');
  input.focus();
}

function closeCommandPalette() {
  cmdPaletteOpen = false;
  document.getElementById('cmd-palette').classList.remove('visible');
  editor.focus();
}

document.getElementById('cmd-input').addEventListener('input', (e) => {
  renderCommandPalette(e.target.value);
});

document.getElementById('cmd-input').addEventListener('keydown', (e) => {
  const results = document.getElementById('cmd-results');
  const items = results.querySelectorAll('.cmd-palette-item');
  if (e.key === 'Escape') { closeCommandPalette(); e.preventDefault(); return; }
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    cmdSelectedIndex = Math.min(cmdSelectedIndex + 1, items.length - 1);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    cmdSelectedIndex = Math.max(cmdSelectedIndex - 1, 0);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'Enter') {
    e.preventDefault();
    if (window._cmdItems && window._cmdItems[cmdSelectedIndex]) {
      window._cmdItems[cmdSelectedIndex].action();
      closeCommandPalette();
    }
  }
});

document.getElementById('cmd-palette').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) closeCommandPalette();
});

// Global Cmd+K for command palette
document.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
    e.preventDefault();
    toggleCommandPalette();
  }
  if (e.key === 'Escape' && cmdPaletteOpen) {
    closeCommandPalette();
  }
});

// ─── Layout Toggle ──────────────────────────────────
let layoutVertical = false;
try {
  layoutVertical = localStorage.getItem('tova-playground-layout') === 'vertical';
} catch(e) {}

function toggleLayout() {
  layoutVertical = !layoutVertical;
  document.querySelector('.main').classList.toggle('vertical', layoutVertical);
  try { localStorage.setItem('tova-playground-layout', layoutVertical ? 'vertical' : 'horizontal'); } catch(e) {}
}

// Apply saved layout
if (layoutVertical) document.querySelector('.main').classList.add('vertical');

document.getElementById('btn-layout').addEventListener('click', toggleLayout);

// ─── Theme Toggle ───────────────────────────────────
let lightTheme = false;
try { lightTheme = localStorage.getItem('tova-playground-theme') === 'light'; } catch(e) {}

function applyTheme() {
  document.body.classList.toggle('light-theme', lightTheme);
  document.getElementById('setting-theme').classList.toggle('on', lightTheme);
}

document.getElementById('setting-theme').addEventListener('click', function() {
  lightTheme = !lightTheme;
  applyTheme();
  try { localStorage.setItem('tova-playground-theme', lightTheme ? 'light' : 'dark'); } catch(e) {}
  saveSettings();
});

applyTheme();

// ─── Export as HTML ─────────────────────────────────
function exportAsHTML() {
  if (!lastJsText || lastJsText.startsWith('// No output') || lastJsText.startsWith('// Compilation')) {
    alert('Nothing to export — compile your code first.');
    return;
  }
  const source = editor.state.doc.toString();
  const hasClient = source.includes('client {') || source.includes('client{');

  let exportHTML;
  if (hasClient) {
    // Export client app as standalone HTML
    try {
      const lexer = new Lexer(source, 'export.tova');
      const tokens = lexer.tokenize();
      const parser = new Parser(tokens, 'export.tova');
      const ast = parser.parse();
      const analyzer = new Analyzer(ast, 'export.tova');
      analyzer.analyze();
      const codegen = new CodeGenerator(ast, 'export.tova');
      const result = codegen.generate();
      const clientCode = (result.client || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');
      exportHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8"><title>Tova App</title>\n'
        + '<style>*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}'
        + 'body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;padding:20px;color:#333}'
        + 'button{cursor:pointer;padding:8px 16px;margin:4px;border-radius:6px;border:1px solid #ddd;background:#f5f5f5;font-size:14px}'
        + 'input[type="text"],input[type="number"]{padding:8px 12px;border:1px solid #ddd;border-radius:6px;margin:4px;font-size:14px}'
        + '</style></head><body><div id="app"></div>\n<script>\n'
        + RUNTIME_CODE + '\n' + STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n' + ARRAY_PROTO_CODE + '\n'
        + (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '') + '\n'
        + clientCode + '\n'
        + 'if(typeof App==="function"){mount(App,document.getElementById("app"));}\n'
        + '<\/script></body></html>';
    } catch(e) {
      exportHTML = '<!-- Export failed: ' + e.message + ' -->';
    }
  } else {
    // Export as Node/Bun script
    exportHTML = '// Generated by Tova Playground\n' + STDLIB_CODE + '\n' + lastJsText;
  }

  const blob = new Blob([exportHTML], { type: hasClient ? 'text/html' : 'text/javascript' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = hasClient ? 'tova-app.html' : 'tova-output.js';
  a.click();
  URL.revokeObjectURL(a.href);
}

document.getElementById('btn-export').addEventListener('click', exportAsHTML);

// ─── Embed Mode ─────────────────────────────────────
if (__isEmbed) {
  document.body.classList.add('embed-mode');
}

// ─── Theme query param override ─────────────────────
const __themeParam = new URLSearchParams(location.search).get('theme');
if (__themeParam === 'light' || __themeParam === 'dark') {
  lightTheme = __themeParam === 'light';
  applyTheme();
}

// ─── postMessage listener for parent integration ────
window.addEventListener('message', function(e) {
  if (!e.data || typeof e.data !== 'object') return;
  if (e.data.type === 'tova-playground-theme') {
    const t = e.data.theme;
    if (t === 'light' || t === 'dark') {
      lightTheme = t === 'light';
      applyTheme();
    }
  } else if (e.data.type === 'tova-playground-set-code') {
    if (typeof e.data.code === 'string') {
      editor.dispatch({
        changes: { from: 0, to: editor.state.doc.length, insert: e.data.code }
      });
    }
  }
});

// ─── Reference Search & Runnable Snippets ───────────
function renderReference() {
  sidebarBody.innerHTML = '';

  // Search box
  const searchBox = document.createElement('input');
  searchBox.type = 'text';
  searchBox.placeholder = 'Search reference...';
  searchBox.style.cssText = 'width:calc(100% - 28px);margin:8px 14px;padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;outline:none;font-family:var(--font-sans);';
  searchBox.addEventListener('input', () => renderRefSections(searchBox.value));
  sidebarBody.appendChild(searchBox);

  const container = document.createElement('div');
  container.id = 'ref-container';
  sidebarBody.appendChild(container);

  renderRefSections('');
}

function renderRefSections(query) {
  const container = document.getElementById('ref-container');
  if (!container) return;
  container.innerHTML = '';
  const q = query.toLowerCase();

  for (const section of REFERENCE) {
    const matchingItems = section.items.filter(item =>
      !q || section.title.toLowerCase().includes(q) || item.syntax.toLowerCase().includes(q) || item.desc.toLowerCase().includes(q)
    );
    if (matchingItems.length === 0) continue;

    const div = document.createElement('div');
    div.className = 'ref-section';
    const title = document.createElement('div');
    title.className = 'ref-title' + (q ? ' open' : '');
    title.textContent = section.title;
    const items = document.createElement('div');
    items.className = 'ref-items' + (q ? ' open' : '');
    for (const item of matchingItems) {
      const row = document.createElement('div');
      row.className = 'ref-item';
      row.style.cursor = 'pointer';
      row.innerHTML = '<code>' + escapeHtml(item.syntax) + '</code><span class="ref-desc"> \u2014 ' + escapeHtml(item.desc) + '</span>';
      row.title = 'Click to insert into editor';
      row.addEventListener('click', () => {
        // Insert the syntax at cursor position
        const pos = editor.state.selection.main.head;
        editor.dispatch({ changes: { from: pos, insert: item.syntax } });
        editor.focus();
      });
      items.appendChild(row);
    }
    title.addEventListener('click', () => { title.classList.toggle('open'); items.classList.toggle('open'); });
    div.appendChild(title);
    div.appendChild(items);
    container.appendChild(div);
  }

  // Open first two sections by default when no search
  if (!q) {
    const titles = container.querySelectorAll('.ref-title');
    const itemSections = container.querySelectorAll('.ref-items');
    if (titles[0]) { titles[0].classList.add('open'); itemSections[0].classList.add('open'); }
    if (titles[1]) { titles[1].classList.add('open'); itemSections[1].classList.add('open'); }
  }
}

// ─── Welcome Toast ──────────────────────────────────
if (!localStorage.getItem('tova-playground-welcomed')) {
  const toast = document.createElement('div');
  toast.className = 'welcome-toast';
  toast.innerHTML = 'Welcome! Try the <strong style="color:var(--accent);margin:0 2px">Learn</strong> button, or press <span class="kbd-hint">Cmd+Enter</span> to run code. <button class="close-toast" aria-label="Close">\u2715</button>';
  document.querySelector('.pane-editor').appendChild(toast);
  toast.querySelector('.close-toast').addEventListener('click', () => { toast.remove(); localStorage.setItem('tova-playground-welcomed', '1'); });
  setTimeout(() => { if (toast.parentNode) toast.remove(); }, 15000);
  localStorage.setItem('tova-playground-welcomed', '1');
}

// ─── Utility ────────────────────────────────────────
function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ─── Initial Compile ────────────────────────────────
compile();
</script>
</body>
</html>