<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tova Playground</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
/* ─── Reset & Base ─────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #1e1e2e; --bg-surface: #181825; --bg-overlay: #11111b;
  --bg-hover: #1e1e2e;
  --text: #cdd6f4; --text-dim: #6c7086; --text-bright: #f5f5f5;
  --accent: #cba6f7; --accent-dim: #9370db; --accent-bg: rgba(203,166,247,0.1);
  --green: #a6e3a1; --red: #f38ba8; --yellow: #f9e2af; --blue: #89b4fa;
  --teal: #94e2d5; --peach: #fab387;
  --border: #313244; --border-active: #45475a;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --header-h: 48px; --status-h: 28px;
  --tab-h: 36px; --sidebar-w: 340px;
  --editor-font-size: 14px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: var(--font-sans); background: var(--bg); color: var(--text);
  display: flex; flex-direction: column;
}

/* ─── Header ───────────────────────────────────────── */
.header {
  height: var(--header-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.header .logo {
  font-weight: 700; font-size: 15px; color: var(--accent);
  display: flex; align-items: center; gap: 6px; white-space: nowrap;
}
.header .logo span { color: var(--text-dim); font-weight: 400; font-size: 12px; }
.header .sep { width: 1px; height: 24px; background: var(--border); }
.header .spacer { flex: 1; }

.btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; transition: all 0.15s; font-family: var(--font-sans);
  white-space: nowrap;
}
.btn:hover { border-color: var(--border-active); background: var(--bg-surface); }
.btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
.btn-primary { background: var(--accent); color: var(--bg-overlay); border-color: var(--accent); font-weight: 600; }
.btn-primary:hover { background: var(--accent-dim); border-color: var(--accent-dim); }
.btn-icon { padding: 5px 8px; font-size: 14px; }
.btn .kbd { font-size: 10px; opacity: 0.6; font-family: var(--font-mono); }

select.examples-select {
  padding: 5px 24px 5px 8px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; font-family: var(--font-sans); max-width: 200px;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236c7086' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 6px center;
}
select.examples-select:hover { border-color: var(--border-active); }
select.examples-select optgroup { background: var(--bg-surface); color: var(--accent); font-style: normal; }
select.examples-select option { background: var(--bg); color: var(--text); }

/* ─── Main Layout ──────────────────────────────────── */
.main {
  flex: 1; display: flex; overflow: hidden;
  height: calc(100% - var(--header-h) - var(--status-h));
}
.pane { display: flex; flex-direction: column; overflow: hidden; min-width: 200px; }
.pane-editor { flex: 1; position: relative; }
.pane-output { flex: 1; }

/* ─── Drag Handle ──────────────────────────────────── */
.drag-handle {
  width: 4px; cursor: col-resize; background: var(--border);
  transition: background 0.15s; flex-shrink: 0;
}
.drag-handle:hover, .drag-handle.active { background: var(--accent); }

/* ─── Output Tabs ──────────────────────────────────── */
.tabs {
  display: flex; height: var(--tab-h); background: var(--bg-surface);
  border-bottom: 1px solid var(--border); flex-shrink: 0; align-items: flex-end;
}
.tab {
  padding: 0 14px; height: 100%; font-size: 12px; cursor: pointer; display: flex; align-items: center;
  color: var(--text-dim); border-bottom: 2px solid transparent;
  transition: all 0.15s; user-select: none; gap: 6px;
}
.tab:hover { color: var(--text); background: rgba(255,255,255,0.02); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab .badge {
  font-size: 10px; padding: 1px 6px; border-radius: 8px;
  background: var(--red); color: var(--bg); font-weight: 600; min-width: 18px; text-align: center;
}

/* ─── Output Panels ────────────────────────────────── */
.output-content { flex: 1; overflow: auto; position: relative; }
.output-panel { display: none; height: 100%; overflow: auto; }
.output-panel.active { display: block; }
#panel-console.active { display: flex; flex-direction: column; }
#panel-js { position: relative; }

#js-output, #console-output, #ast-output {
  padding: 12px 16px; font-family: var(--font-mono); font-size: 13px;
  line-height: 1.6; white-space: pre-wrap; word-break: break-word;
}
#js-output { color: var(--text); }
#console-output .log-line { color: var(--text); padding: 1px 0; }
#console-output .log-error { color: var(--red); padding: 1px 0; }
#console-output .log-warn { color: var(--yellow); padding: 1px 0; }
#console-output .log-info { color: var(--blue); padding: 1px 0; }
#console-output .log-return { color: var(--text-dim); font-style: italic; padding: 1px 0; }

#preview-frame {
  width: 100%; height: 100%; border: none; background: #fff;
}

/* ─── AST Tree ─────────────────────────────────────── */
.ast-node { margin-left: 16px; font-family: var(--font-mono); font-size: 12px; line-height: 1.5; }
.ast-toggle { cursor: pointer; user-select: none; display: inline-flex; align-items: center; gap: 4px; }
.ast-toggle:hover { color: var(--accent); }
.ast-toggle::before { content: '\25B6'; font-size: 8px; display: inline-block; transition: transform 0.15s; }
.ast-toggle.open::before { transform: rotate(90deg); }
.ast-key { color: var(--blue); }
.ast-string { color: var(--green); }
.ast-number { color: var(--yellow); }
.ast-bool { color: var(--accent); }
.ast-null { color: var(--text-dim); }
.ast-type { color: var(--accent); font-weight: 600; }
.ast-children { display: none; }
.ast-children.open { display: block; }

/* ─── Status Bar ───────────────────────────────────── */
.status-bar {
  height: var(--status-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-top: 1px solid var(--border); font-size: 11px;
  color: var(--text-dim); gap: 16px; flex-shrink: 0;
}
.status-bar .success { color: var(--green); }
.status-bar .error { color: var(--red); }
.status-bar .spacer { flex: 1; }

/* ─── Error Display ────────────────────────────────── */
.error-banner {
  padding: 8px 16px; background: rgba(243,139,168,0.08);
  border-bottom: 1px solid rgba(243,139,168,0.3); color: var(--red);
  font-family: var(--font-mono); font-size: 12px; display: none;
  cursor: pointer; position: relative;
}
.error-banner:hover { background: rgba(243,139,168,0.12); }
.error-banner.visible { display: flex; align-items: center; gap: 8px; }
.error-banner .error-icon { font-weight: bold; flex-shrink: 0; }
.error-banner .error-text { flex: 1; }

/* ─── Sidebar / Reference Panel ───────────────────── */
.sidebar {
  width: 0; overflow: hidden; background: var(--bg-surface);
  border-left: 1px solid var(--border); transition: width 0.2s ease;
  flex-shrink: 0; display: flex; flex-direction: column;
}
.sidebar.open { width: var(--sidebar-w); }
.sidebar-header {
  display: flex; align-items: center; padding: 10px 14px;
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.sidebar-header h3 { font-size: 14px; font-weight: 600; color: var(--text-bright); flex: 1; }
.sidebar-close {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 18px; padding: 2px 6px; border-radius: 4px;
}
.sidebar-close:hover { color: var(--text); background: var(--bg); }
.sidebar-body { flex: 1; overflow-y: auto; padding: 8px 0; }

/* Reference styles */
.ref-section { margin-bottom: 4px; }
.ref-title {
  padding: 6px 14px; font-size: 12px; font-weight: 600;
  color: var(--accent); cursor: pointer; display: flex; align-items: center; gap: 6px;
  user-select: none;
}
.ref-title:hover { background: var(--bg); }
.ref-title::before { content: '\25B6'; font-size: 8px; transition: transform 0.15s; }
.ref-title.open::before { transform: rotate(90deg); }
.ref-items { display: none; padding: 0 14px 8px; }
.ref-items.open { display: block; }
.ref-item { margin: 3px 0; }
.ref-item code {
  font-family: var(--font-mono); font-size: 11px; color: var(--green);
  background: rgba(166,227,161,0.08); padding: 1px 4px; border-radius: 3px;
}
.ref-item .ref-desc { font-size: 11px; color: var(--text-dim); margin-left: 4px; }

/* Tutorial styles */
.tutorial-nav { display: flex; gap: 4px; padding: 8px 14px; flex-shrink: 0; border-top: 1px solid var(--border); }
.tutorial-nav .btn { flex: 1; justify-content: center; font-size: 12px; }
.tutorial-step { padding: 14px; }
.tutorial-step h4 { color: var(--accent); font-size: 14px; margin-bottom: 8px; }
.tutorial-step p { font-size: 13px; color: var(--text); line-height: 1.5; margin-bottom: 10px; }
.tutorial-step .try-btn {
  display: inline-flex; align-items: center; gap: 4px;
  padding: 6px 14px; border-radius: 6px; border: 1px solid var(--accent);
  background: var(--accent-bg); color: var(--accent); font-size: 12px;
  cursor: pointer; font-weight: 500;
}
.tutorial-step .try-btn:hover { background: rgba(203,166,247,0.2); }
.tutorial-progress {
  display: flex; gap: 4px; padding: 0 14px 8px; flex-shrink: 0;
}
.tutorial-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--border); cursor: pointer;
}
.tutorial-dot.active { background: var(--accent); }
.tutorial-dot.completed { background: var(--green); }

/* ─── Keyboard Shortcuts Modal ────────────────────── */
.modal-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: none; align-items: center; justify-content: center; z-index: 100;
}
.modal-backdrop.visible { display: flex; }
.modal {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 24px; max-width: 480px; width: 90%;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.modal h3 { color: var(--accent); margin-bottom: 16px; font-size: 16px; }
.modal-close {
  float: right; background: none; border: none; color: var(--text-dim);
  cursor: pointer; font-size: 20px; padding: 0 4px;
}
.modal-close:hover { color: var(--text); }
.shortcut-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 0; border-bottom: 1px solid rgba(49,50,68,0.5);
}
.shortcut-row:last-child { border-bottom: none; }
.shortcut-keys {
  display: flex; gap: 4px;
}
.shortcut-key {
  background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  padding: 2px 8px; font-family: var(--font-mono); font-size: 11px; color: var(--text-bright);
}
.shortcut-desc { font-size: 13px; color: var(--text-dim); }

/* ─── Settings Dropdown ──────────────────────────── */
.settings-dropdown {
  position: absolute; top: calc(var(--header-h) + 4px); right: 12px;
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 12px; min-width: 220px; z-index: 50;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
}
.settings-dropdown.visible { display: block; }
.settings-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 0; font-size: 13px;
}
.settings-row label { color: var(--text); }
.settings-row select, .settings-row input[type="range"] {
  background: var(--bg); border: 1px solid var(--border); color: var(--text);
  border-radius: 4px; padding: 3px 6px; font-size: 12px;
}
.toggle {
  width: 36px; height: 20px; border-radius: 10px; background: var(--border);
  position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle.on { background: var(--accent); }
.toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 16px; height: 16px; border-radius: 50%; background: white;
  transition: transform 0.2s;
}
.toggle.on::after { transform: translateX(16px); }

/* ─── Welcome Overlay ─────────────────────────────── */
.welcome-toast {
  position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 16px; font-size: 12px;
  color: var(--text-dim); z-index: 10; display: flex; align-items: center; gap: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3); white-space: nowrap;
  animation: fadeIn 0.3s ease;
}
.welcome-toast .kbd-hint {
  font-family: var(--font-mono); font-size: 10px;
  background: var(--bg); border: 1px solid var(--border); padding: 2px 6px;
  border-radius: 3px; color: var(--text);
}
.welcome-toast .close-toast {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 14px; padding: 0 2px;
}
@keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(8px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
@keyframes spin { to { transform: rotate(360deg); } }

/* ─── Console Enhancements ────────────────────────── */
.console-toolbar {
  display: flex; align-items: center; gap: 8px;
  padding: 4px 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); font-size: 11px; flex-shrink: 0;
}
.console-toolbar .spacer { flex: 1; }
.console-toolbar .console-timing { color: var(--text-dim); font-family: var(--font-mono); }
.log-icon { margin-right: 6px; opacity: 0.7; font-size: 11px; }
.log-content { white-space: pre-wrap; word-break: break-word; }
#console-output .log-line, #console-output .log-error,
#console-output .log-warn, #console-output .log-info {
  display: flex; align-items: flex-start; padding: 3px 16px; border-bottom: 1px solid rgba(49,50,68,0.3);
}
#console-output .log-line:hover, #console-output .log-error:hover,
#console-output .log-warn:hover, #console-output .log-info:hover {
  background: rgba(255,255,255,0.02);
}

/* ─── Error Banner Enhanced ───────────────────────── */
.error-banner .error-hint {
  color: var(--yellow); font-size: 11px; margin-left: 12px; opacity: 0.8;
}

/* ─── Command Palette ─────────────────────────────── */
.cmd-palette-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: flex-start; justify-content: center;
  padding-top: 20vh; z-index: 200;
}
.cmd-palette-backdrop.visible { display: flex; }
.cmd-palette {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; width: 520px; max-width: 90vw;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5); overflow: hidden;
}
.cmd-palette input {
  width: 100%; padding: 14px 16px; background: transparent;
  border: none; border-bottom: 1px solid var(--border);
  color: var(--text); font-size: 15px; font-family: var(--font-sans);
  outline: none;
}
.cmd-palette input::placeholder { color: var(--text-dim); }
.cmd-palette-results {
  max-height: 320px; overflow-y: auto; padding: 4px 0;
}
.cmd-palette-item {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 16px; cursor: pointer; font-size: 13px;
  color: var(--text); transition: background 0.1s;
}
.cmd-palette-item:hover, .cmd-palette-item.selected {
  background: var(--accent-bg); color: var(--accent);
}
.cmd-palette-item .cmd-icon { width: 20px; text-align: center; opacity: 0.6; font-size: 14px; }
.cmd-palette-item .cmd-label { flex: 1; }
.cmd-palette-item .cmd-category { font-size: 11px; color: var(--text-dim); }
.cmd-palette-item .cmd-shortcut {
  font-family: var(--font-mono); font-size: 10px; color: var(--text-dim);
  background: var(--bg); border: 1px solid var(--border); border-radius: 3px;
  padding: 1px 5px;
}
.cmd-palette-empty {
  padding: 24px 16px; text-align: center; color: var(--text-dim); font-size: 13px;
}

/* ─── Layout Toggle ───────────────────────────────── */
.main.vertical { flex-direction: column; }
.main.vertical .drag-handle { width: auto; height: 4px; cursor: row-resize; }
.main.vertical .pane { min-width: unset; min-height: 150px; }

/* ─── Light Theme ─────────────────────────────────── */
.light-theme {
  --bg: #f8f9fa; --bg-surface: #ffffff; --bg-overlay: #e9ecef;
  --bg-hover: #f1f3f5;
  --text: #212529; --text-dim: #868e96; --text-bright: #000000;
  --accent: #7c3aed; --accent-dim: #6d28d9; --accent-bg: rgba(124,58,237,0.08);
  --green: #2b8a3e; --red: #e03131; --yellow: #e67700; --blue: #1971c2;
  --teal: #0ca678; --peach: #e8590c;
  --border: #dee2e6; --border-active: #ced4da;
}
.light-theme .cm-editor .cm-gutters { background: #f1f3f5; }
.light-theme #preview-frame { background: #fff; }

/* ─── Embed Mode ──────────────────────────────────── */
.embed-mode .header { display: none; }
.embed-mode .status-bar { display: none; }
.embed-mode .sidebar { display: none; }

/* ─── JS Output Editor ────────────────────────────── */
#js-output-editor { height: 100%; }
#panel-js .cm-editor { height: 100%; }
#panel-js .cm-editor .cm-gutters { background: var(--bg-surface); }

/* ─── CodeMirror Overrides ─────────────────────────── */
.cm-editor { height: 100%; font-size: var(--editor-font-size); }
.cm-editor .cm-scroller { font-family: var(--font-mono) !important; }
.cm-editor .cm-content { padding: 8px 0; }
.cm-editor .cm-gutters {
  background: var(--bg-surface); border-right: 1px solid var(--border);
  color: var(--text-dim);
}
.cm-editor .cm-activeLineGutter { background: rgba(203,166,247,0.08); }
.cm-editor .cm-activeLine { background: rgba(203,166,247,0.04); }
.cm-editor .cm-selectionBackground { background: rgba(203,166,247,0.2) !important; }
.cm-editor.cm-focused .cm-selectionBackground { background: rgba(203,166,247,0.25) !important; }
.cm-editor .cm-cursor { border-left-color: var(--accent); }
.cm-error-line { background: rgba(243,139,168,0.1) !important; }
.cm-error-gutter .cm-gutterElement { padding: 0 2px; }

/* ─── Autocomplete Styling ────────────────────────── */
.cm-tooltip-autocomplete { background: var(--bg-surface) !important; border: 1px solid var(--border) !important; border-radius: 8px !important; }
.cm-tooltip-autocomplete ul li { padding: 4px 8px !important; }
.cm-tooltip-autocomplete ul li[aria-selected] { background: var(--accent-bg) !important; color: var(--accent) !important; }
.cm-completionLabel { font-family: var(--font-mono); }
.cm-completionDetail { font-size: 11px; opacity: 0.7; margin-left: 8px; }
.cm-completionInfo { padding: 8px; font-size: 12px; }

/* ─── Scrollbar ───────────────────────────────────── */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--border-active); }

/* ─── Responsive ───────────────────────────────────── */
@media (max-width: 768px) {
  .main { flex-direction: column; }
  .drag-handle { width: auto; height: 4px; cursor: row-resize; }
  .pane { min-width: unset; min-height: 150px; }
  .sidebar { position: fixed; right: 0; top: var(--header-h); bottom: var(--status-h); z-index: 50; }
  .header .hide-mobile { display: none; }
  .header .sep { display: none; }
}
</style>
</head>
<body>

<!-- ─── Header ────────────────────────────────────── -->
<div class="header">
  <div class="logo">&#9670; Tova <span>Playground</span></div>
  <div class="sep"></div>
  <select class="examples-select" id="examples-select">
    <option value="" disabled selected>Load Example...</option>
  </select>
  <div class="spacer"></div>
  <button class="btn hide-mobile" id="btn-tutorial" title="Interactive tutorial">Learn</button>
  <button class="btn hide-mobile" id="btn-reference" title="Language reference">Reference</button>
  <div class="sep hide-mobile"></div>
  <button class="btn btn-icon hide-mobile" id="btn-layout" title="Toggle layout (Cmd+J)">&#9707;</button>
  <button class="btn btn-icon hide-mobile" id="btn-shortcuts" title="Keyboard shortcuts">&#9000;</button>
  <button class="btn btn-icon hide-mobile" id="btn-settings" title="Settings">&#9881;</button>
  <button class="btn btn-icon hide-mobile" id="btn-reset" title="Reset to default code">&#8634;</button>
  <div class="sep hide-mobile"></div>
  <button class="btn" id="btn-export" title="Export as standalone HTML">Export</button>
  <button class="btn" id="btn-download" title="Download .tova file">&#8615;</button>
  <button class="btn" id="btn-share" title="Copy shareable URL">Share</button>
  <button class="btn btn-primary" id="btn-run" title="Cmd/Ctrl+Enter">Run &#9654;</button>
</div>

<!-- ─── Settings Dropdown ─────────────────────────── -->
<div class="settings-dropdown" id="settings-dropdown">
  <div class="settings-row">
    <label>Font Size</label>
    <select id="setting-fontsize">
      <option value="12">12px</option>
      <option value="13">13px</option>
      <option value="14" selected>14px</option>
      <option value="15">15px</option>
      <option value="16">16px</option>
      <option value="18">18px</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Auto-Compile</label>
    <div class="toggle on" id="setting-autocompile"></div>
  </div>
  <div class="settings-row">
    <label>Auto-Run</label>
    <div class="toggle on" id="setting-autorun"></div>
  </div>
  <div class="settings-row">
    <label>Light Theme</label>
    <div class="toggle" id="setting-theme"></div>
  </div>
</div>

<!-- ─── Main ──────────────────────────────────────── -->
<div class="main">
  <div class="pane pane-editor">
    <div id="editor"><div id="editor-loading" style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--text-dim);font-size:14px;gap:10px;"><svg width="20" height="20" viewBox="0 0 20 20" style="animation:spin 1s linear infinite"><circle cx="10" cy="10" r="8" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="40" stroke-dashoffset="10" stroke-linecap="round"/></svg> Loading editor...</div></div>
  </div>
  <div class="drag-handle" id="drag-handle"></div>
  <div class="pane pane-output">
    <div class="tabs" id="output-tabs">
      <div class="tab active" data-tab="js">JS Output</div>
      <div class="tab" data-tab="console">Console <span class="badge" id="console-badge" style="display:none">0</span></div>
      <div class="tab" data-tab="preview">Preview</div>
      <div class="tab" data-tab="ast">AST</div>
    </div>
    <div class="error-banner" id="error-banner">
      <span class="error-icon">&#10006;</span>
      <span class="error-text" id="error-text"></span>
      <span class="error-hint" id="error-hint"></span>
    </div>
    <div class="output-content">
      <div class="output-panel active" id="panel-js"><button class="btn" id="btn-copy-js" style="position:absolute;top:8px;right:12px;z-index:5;padding:2px 8px;font-size:11px;opacity:0.7;" title="Copy JS output">Copy</button><div id="js-output-editor"></div><pre id="js-output" style="display:none"></pre></div>
      <div class="output-panel" id="panel-console">
        <div class="console-toolbar">
          <span class="console-timing" id="console-timing"></span>
          <div class="spacer"></div>
          <button class="btn" id="btn-copy-console" style="padding:2px 8px;font-size:11px;">Copy</button>
          <button class="btn" id="btn-clear-console" style="padding:2px 8px;font-size:11px;">Clear</button>
        </div>
        <div id="console-output" style="padding:12px 0;font-family:var(--font-mono);font-size:13px;line-height:1.6;overflow:auto;flex:1;"></div>
      </div>
      <div class="output-panel" id="panel-preview"><iframe id="preview-frame" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe></div>
      <div class="output-panel" id="panel-ast"><div id="ast-output"></div></div>
    </div>
  </div>

  <!-- ─── Sidebar ─────────────────────────────────── -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h3 id="sidebar-title">Reference</h3>
      <button class="sidebar-close" id="sidebar-close">&#10005;</button>
    </div>
    <div class="sidebar-body" id="sidebar-body"></div>
    <div class="tutorial-nav" id="tutorial-nav" style="display:none;">
      <button class="btn" id="tut-prev">&#8592; Prev</button>
      <button class="btn btn-primary" id="tut-next">Next &#8594;</button>
    </div>
  </div>
</div>

<!-- ─── Status Bar ────────────────────────────────── -->
<div class="status-bar">
  <span id="status-compile"></span>
  <span id="status-size" style="color:var(--text-dim)"></span>
  <div class="spacer"></div>
  <span id="status-cursor">Ln 1, Col 1</span>
</div>

<!-- ─── Keyboard Shortcuts Modal ──────────────────── -->
<div class="modal-backdrop" id="shortcuts-modal">
  <div class="modal">
    <button class="modal-close" id="shortcuts-close">&#10005;</button>
    <h3>Keyboard Shortcuts</h3>
    <div class="shortcut-row"><span class="shortcut-desc">Run code</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Enter</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Command palette</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">K</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Save to browser</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">S</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle reference</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">R</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle layout</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">J</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Show shortcuts</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">?</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Download .tova file</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">S</span></div></div>
    <p style="margin-top:12px;font-size:11px;color:var(--text-dim)">On Windows/Linux, use Ctrl instead of Cmd</p>
  </div>
</div>

<!-- ─── Command Palette ──────────────────────────── -->
<div class="cmd-palette-backdrop" id="cmd-palette">
  <div class="cmd-palette">
    <input type="text" id="cmd-input" placeholder="Search examples, actions, reference..." autocomplete="off" />
    <div class="cmd-palette-results" id="cmd-results"></div>
  </div>
</div>

<!-- ─── LZString for sharing ─────────────────────── -->
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

<!-- ─── Inlined Tova Compiler & Runtime ───────────── -->
<script>
var RUNTIME_CODE = "// Fine-grained reactivity system for Tova (signals-based)\n\nconst __DEV__ = typeof process !== 'undefined' && process.env?.NODE_ENV !== 'production';\n\n// ─── DevTools hooks (zero-cost when disabled) ────────────\nlet __devtools_hooks = null;\nfunction __enableDevTools(hooks) {\n  __devtools_hooks = hooks;\n}\n\nlet currentEffect = null;\nconst effectStack = [];\n\n// ─── Ownership System ─────────────────────────────────────\nlet currentOwner = null;\nconst ownerStack = [];\n\n// ─── Batching ────────────────────────────────────────────\n// Default: synchronous flush after each setter (backward compatible).\n// Inside batch(): effects are deferred and flushed once when batch ends.\n// This means setA(1); setB(2) causes 2 runs by default, but\n// batch(() => { setA(1); setB(2); }) causes only 1 run.\n\nlet pendingEffects = new Set();\nlet batchDepth = 0;\nlet flushing = false;\n\n// Reusable array for flush cycle — avoids allocation on every flush\nlet _flushBuf = [];\n\nfunction flush() {\n  if (flushing) return; // prevent re-entrant flush\n  flushing = true;\n  let iterations = 0;\n  try {\n    while (pendingEffects.size > 0) {\n      if (++iterations > 100) {\n        console.error('Tova: Possible infinite loop in reactive updates (>100 flush iterations). Aborting.');\n        pendingEffects.clear();\n        break;\n      }\n\n      // Invoke onBeforeUpdate callbacks for owners that have pending effects\n      const ownersNotified = new Set();\n      for (const effect of pendingEffects) {\n        const owner = effect._owner;\n        if (owner && owner._beforeUpdate && !ownersNotified.has(owner)) {\n          ownersNotified.add(owner);\n          for (const cb of owner._beforeUpdate) {\n            try { cb(); } catch (e) { console.error('Tova: onBeforeUpdate error:', e); }\n          }\n        }\n      }\n\n      const toRun = pendingEffects;\n      pendingEffects = new Set();\n      // Sort by depth (parents first) to avoid redundant child re-runs\n      // Reuse buffer to reduce GC pressure\n      if (toRun.size > 1) {\n        _flushBuf.length = 0;\n        for (const effect of toRun) _flushBuf.push(effect);\n        _flushBuf.sort((a, b) => (a._depth || 0) - (b._depth || 0));\n        for (let i = 0; i < _flushBuf.length; i++) {\n          if (!_flushBuf[i]._disposed) {\n            _flushBuf[i]();\n          }\n        }\n        _flushBuf.length = 0;\n      } else {\n        for (const effect of toRun) {\n          if (!effect._disposed) {\n            effect();\n          }\n        }\n      }\n    }\n  } finally {\n    flushing = false;\n  }\n}\nfunction batch(fn) {\n  batchDepth++;\n  try {\n    fn();\n  } finally {\n    batchDepth--;\n    if (batchDepth === 0) {\n      flush();\n    }\n  }\n}\n\n// ─── Ownership Root ──────────────────────────────────────\nfunction createRoot(fn) {\n  const root = {\n    _children: [],\n    _disposed: false,\n    _cleanups: [],\n    _contexts: null,\n    _owner: currentOwner,\n    dispose() {\n      if (root._disposed) return;\n      root._disposed = true;\n      // Dispose children in reverse order (skip already-disposed)\n      for (let i = root._children.length - 1; i >= 0; i--) {\n        const child = root._children[i];\n        if (!child._disposed && typeof child.dispose === 'function') child.dispose();\n      }\n      root._children.length = 0;\n      // Run cleanups in reverse order\n      for (let i = root._cleanups.length - 1; i >= 0; i--) {\n        try { root._cleanups[i](); } catch (e) { console.error('Tova: root cleanup error:', e); }\n      }\n      root._cleanups.length = 0;\n    }\n  };\n  ownerStack.push(currentOwner);\n  currentOwner = root;\n  try {\n    return fn(root.dispose.bind(root));\n  } finally {\n    currentOwner = ownerStack.pop();\n  }\n}\n\n// ─── Dependency Cleanup ──────────────────────────────────\n\nfunction cleanupDeps(subscriber) {\n  if (subscriber._deps) {\n    for (const depSet of subscriber._deps) {\n      depSet.delete(subscriber);\n    }\n    subscriber._deps.clear();\n  }\n}\n\nfunction trackDep(subscriber, subscriberSet) {\n  subscriberSet.add(subscriber);\n  if (!subscriber._deps) subscriber._deps = new Set();\n  subscriber._deps.add(subscriberSet);\n}\n\n// ─── Signals ─────────────────────────────────────────────\nfunction createSignal(initialValue, name) {\n  let value = initialValue;\n  const subscribers = new Set();\n  let signalId = null;\n\n  if (__devtools_hooks) {\n    signalId = __devtools_hooks.onSignalCreate(\n      () => value,\n      (v) => setter(v),\n      name,\n    );\n  }\n\n  function getter() {\n    if (currentEffect) {\n      trackDep(currentEffect, subscribers);\n    }\n    return value;\n  }\n\n  function setter(newValue) {\n    if (typeof newValue === 'function') {\n      newValue = newValue(value);\n    }\n    if (value !== newValue) {\n      const oldValue = value;\n      value = newValue;\n      if (__devtools_hooks && signalId != null) {\n        __devtools_hooks.onSignalUpdate(signalId, oldValue, newValue);\n      }\n      for (const sub of subscribers) {\n        if (sub._isComputed) {\n          sub(); // propagate dirty flags synchronously through computed graph\n        } else {\n          pendingEffects.add(sub);\n        }\n      }\n      if (batchDepth === 0) {\n        flush();\n      }\n    }\n  }\n\n  return [getter, setter];\n}\n\n// ─── Effects ─────────────────────────────────────────────\n\nfunction runCleanups(effect) {\n  if (effect._cleanup) {\n    try { effect._cleanup(); } catch (e) { console.error('Tova: cleanup error:', e); }\n    effect._cleanup = null;\n  }\n  if (effect._cleanups && effect._cleanups.length > 0) {\n    for (const cb of effect._cleanups) {\n      try { cb(); } catch (e) { console.error('Tova: cleanup error:', e); }\n    }\n    effect._cleanups = [];\n  }\n}\nfunction createEffect(fn) {\n  function effect() {\n    if (effect._running) return;\n    if (effect._disposed) return;\n    effect._running = true;\n\n    // Run cleanups from previous execution\n    runCleanups(effect);\n\n    // Remove from all previous dependency subscriber sets\n    cleanupDeps(effect);\n\n    effectStack.push(effect);\n    currentEffect = effect;\n    const startTime = __devtools_hooks && typeof performance !== 'undefined' ? performance.now() : 0;\n    try {\n      const result = fn();\n      // If effect returns a function, use as cleanup\n      if (typeof result === 'function') {\n        effect._cleanup = result;\n      }\n    } catch (e) {\n      console.error('Tova: Error in effect:', e);\n      if (currentErrorHandler) {\n        currentErrorHandler(e);\n      }\n    } finally {\n      if (__devtools_hooks) {\n        const duration = typeof performance !== 'undefined' ? performance.now() - startTime : 0;\n        __devtools_hooks.onEffectRun(effect, duration);\n      }\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n      effect._running = false;\n    }\n  }\n\n  effect._deps = new Set();\n  effect._running = false;\n  effect._disposed = false;\n  effect._cleanup = null;\n  effect._cleanups = [];\n  effect._owner = currentOwner;\n  // Compute depth for priority scheduling (parents flush before children)\n  effect._depth = currentOwner ? (currentOwner._depth || 0) + 1 : 0;\n\n  if (__devtools_hooks) {\n    __devtools_hooks.onEffectCreate(effect);\n  }\n\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._children.push(effect);\n  }\n\n  effect.dispose = function () {\n    effect._disposed = true;\n    runCleanups(effect);\n    cleanupDeps(effect);\n    pendingEffects.delete(effect);\n  };\n\n  // Run immediately (synchronous first run)\n  effect();\n  return effect;\n}\n\n// ─── Computed (lazy/pull-based for glitch-free reads) ────\nfunction createComputed(fn) {\n  let value;\n  let dirty = true;\n  const subscribers = new Set();\n\n  // notify is called synchronously when a source signal changes.\n  // It marks the computed dirty and propagates to downstream subscribers.\n  function notify() {\n    if (!dirty) {\n      dirty = true;\n      notify._dirty = true;\n      for (const sub of subscribers) {\n        if (sub._isComputed) {\n          if (!sub._dirty) sub(); // skip already-dirty computeds\n        } else {\n          pendingEffects.add(sub);\n        }\n      }\n    }\n  }\n\n  notify._deps = new Set();\n  notify._disposed = false;\n  notify._isComputed = true;\n  notify._owner = currentOwner;\n\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._children.push(notify);\n  }\n\n  notify.dispose = function () {\n    notify._disposed = true;\n    cleanupDeps(notify);\n  };\n\n  function recompute() {\n    cleanupDeps(notify);\n\n    effectStack.push(notify);\n    currentEffect = notify;\n    try {\n      value = fn();\n      dirty = false;\n      notify._dirty = false;\n    } finally {\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n    }\n  }\n\n  // Initial computation\n  recompute();\n\n  function getter() {\n    if (currentEffect) {\n      trackDep(currentEffect, subscribers);\n    }\n    if (dirty) {\n      recompute();\n    }\n    return value;\n  }\n\n  return getter;\n}\n\n// ─── Lifecycle Hooks ─────────────────────────────────────\nfunction onMount(fn) {\n  const owner = currentOwner;\n  queueMicrotask(() => {\n    const result = fn();\n    if (typeof result === 'function' && owner && !owner._disposed) {\n      owner._cleanups.push(result);\n    }\n  });\n}\nfunction onUnmount(fn) {\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._cleanups.push(fn);\n  }\n}\nfunction onCleanup(fn) {\n  if (currentEffect) {\n    if (!currentEffect._cleanups) currentEffect._cleanups = [];\n    currentEffect._cleanups.push(fn);\n  }\n}\nfunction onBeforeUpdate(fn) {\n  if (currentOwner && !currentOwner._disposed) {\n    if (!currentOwner._beforeUpdate) currentOwner._beforeUpdate = [];\n    currentOwner._beforeUpdate.push(fn);\n  }\n}\n\n// ─── Untrack ─────────────────────────────────────────────\n// Run a function without tracking any signal reads (opt out of reactivity)\nfunction untrack(fn) {\n  const prev = currentEffect;\n  currentEffect = null;\n  try {\n    return fn();\n  } finally {\n    currentEffect = prev;\n  }\n}\n\n// ─── Watch ───────────────────────────────────────────────\n// Watch a reactive expression, calling callback with (newValue, oldValue)\n// Returns a dispose function to stop watching.\nfunction watch(getter, callback, options = {}) {\n  let oldValue = undefined;\n  let initialized = false;\n\n  const effect = createEffect(() => {\n    const newValue = getter();\n    if (initialized) {\n      untrack(() => callback(newValue, oldValue));\n    } else if (options.immediate) {\n      untrack(() => callback(newValue, undefined));\n    }\n    oldValue = newValue;\n    initialized = true;\n  });\n\n  return effect.dispose ? effect.dispose.bind(effect) : () => {\n    effect._disposed = true;\n    runCleanups(effect);\n    cleanupDeps(effect);\n    pendingEffects.delete(effect);\n  };\n}\n\n// ─── Refs ────────────────────────────────────────────────\nfunction createRef(initialValue) {\n  return { current: initialValue !== undefined ? initialValue : null };\n}\n\n// ─── Error Boundaries ────────────────────────────────────\n\n// Stack-based error handler for correct nested boundary propagation\nconst errorHandlerStack = [];\nlet currentErrorHandler = null;\n\nfunction pushErrorHandler(handler) {\n  errorHandlerStack.push(currentErrorHandler);\n  currentErrorHandler = handler;\n}\n\nfunction popErrorHandler() {\n  currentErrorHandler = errorHandlerStack.pop() || null;\n}\n\n// Component name tracking for stack traces\nconst componentNameStack = [];\nfunction pushComponentName(name) {\n  componentNameStack.push(name);\n}\nfunction popComponentName() {\n  componentNameStack.pop();\n}\n\nfunction buildComponentStack() {\n  return [...componentNameStack].reverse();\n}\nfunction createErrorBoundary(options = {}) {\n  const { onError, onReset } = options;\n  const [error, setError] = createSignal(null);\n\n  function run(fn) {\n    pushErrorHandler((e) => {\n      const stack = buildComponentStack();\n      if (e && typeof e === 'object') e.__tovaComponentStack = stack;\n      setError(e);\n      if (onError) onError({ error: e, componentStack: stack });\n    });\n    try {\n      return fn();\n    } catch (e) {\n      const stack = buildComponentStack();\n      if (e && typeof e === 'object') e.__tovaComponentStack = stack;\n      setError(e);\n      if (onError) onError({ error: e, componentStack: stack });\n      return null;\n    } finally {\n      popErrorHandler();\n    }\n  }\n\n  function reset() {\n    setError(null);\n    if (onReset) onReset();\n  }\n\n  return { error, run, reset };\n}\n\nlet __errorBoundaryIdCounter = 0;\nfunction ErrorBoundary({ fallback, children, onError, onReset, onErrorCleared, retry = 0 }) {\n  const [error, setError] = createSignal(null);\n  const [retryCount, setRetryCount] = createSignal(0);\n  const boundaryId = ++__errorBoundaryIdCounter;\n  let lastErrorId = 0;\n\n  function handleError(e) {\n    const stack = buildComponentStack();\n    const errorId = `EB${boundaryId}-${++lastErrorId}`;\n\n    if (e && typeof e === 'object') {\n      e.__tovaComponentStack = stack;\n      e.__tovaErrorId = errorId;\n    }\n\n    if (retryCount() < retry) {\n      setRetryCount(c => c + 1);\n      setError(null); // clear to re-trigger render\n      return;\n    }\n    setError(e);\n    if (onError) onError({ error: e, componentStack: stack, errorId, retryCount: retryCount() });\n  }\n\n  function resetBoundary() {\n    setRetryCount(0);\n    setError(null);\n    if (onReset) onReset();\n  }\n\n  // Return a reactive wrapper that switches between children and fallback\n  const childContent = children && children.length === 1 ? children[0] : tova_fragment(children || []);\n\n  const vnode = {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    _fallback: fallback,\n    _componentName: 'ErrorBoundary',\n    _errorHandler: handleError, // Active during __dynamic effect render cycle\n    compute: () => {\n      const err = error();\n      if (err) {\n        // Render fallback — if fallback itself throws, propagate to parent boundary\n        try {\n          const errorId = err && typeof err === 'object' ? err.__tovaErrorId : null;\n          return typeof fallback === 'function'\n            ? fallback({\n                error: err,\n                errorId,\n                retryCount: retryCount(),\n                componentStack: err && typeof err === 'object' ? err.__tovaComponentStack : [],\n                reset: resetBoundary,\n              })\n            : fallback;\n        } catch (fallbackError) {\n          // Fallback threw — propagate to parent error boundary\n          if (currentErrorHandler) {\n            currentErrorHandler(fallbackError);\n          }\n          return null;\n        }\n      }\n      // Children rendered successfully — fire onErrorCleared if we recovered from an error\n      if (onErrorCleared && lastErrorId > 0 && retryCount() === 0) {\n        queueMicrotask(() => onErrorCleared());\n      }\n      return childContent;\n    },\n  };\n\n  return vnode;\n}\n\n// Built-in ErrorInfo component — renders a formatted error display\n// Usage: <ErrorBoundary fallback={fn(props) ErrorInfo(props)} />\nfunction ErrorInfo({ error, errorId, componentStack, reset, retryCount }) {\n  const message = error instanceof Error ? error.message : String(error);\n  const stackTrace = error instanceof Error && error.stack ? error.stack : '';\n  const compStack = (componentStack || []).join(' > ');\n\n  const children = [\n    tova_el('h3', { style: { margin: '0 0 8px 0', color: '#e53e3e' } }, ['Something went wrong']),\n    tova_el('p', { style: { margin: '4px 0', fontFamily: 'monospace', fontSize: '14px' } }, [message]),\n  ];\n\n  if (compStack) {\n    children.push(\n      tova_el('p', { style: { margin: '4px 0', fontSize: '12px', color: '#718096' } }, [\n        'Component: ', compStack\n      ])\n    );\n  }\n\n  if (errorId) {\n    children.push(\n      tova_el('p', { style: { margin: '4px 0', fontSize: '11px', color: '#a0aec0' } }, [\n        'Error ID: ', errorId\n      ])\n    );\n  }\n\n  if (stackTrace) {\n    children.push(\n      tova_el('details', { style: { marginTop: '8px', fontSize: '12px' } }, [\n        tova_el('summary', { style: { cursor: 'pointer', color: '#4a5568' } }, ['Stack trace']),\n        tova_el('pre', { style: { margin: '4px 0', padding: '8px', background: '#1a202c', color: '#e2e8f0', borderRadius: '4px', overflow: 'auto', fontSize: '11px', maxHeight: '200px' } }, [stackTrace]),\n      ])\n    );\n  }\n\n  if (reset) {\n    children.push(\n      tova_el('button', {\n        style: { marginTop: '8px', padding: '6px 16px', background: '#3182ce', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '13px' },\n        onClick: reset,\n      }, [retryCount > 0 ? 'Retry again' : 'Try again'])\n    );\n  }\n\n  return tova_el('div', {\n    style: { padding: '16px', border: '1px solid #fed7d7', borderRadius: '8px', background: '#fff5f5', color: '#2d3748', fontFamily: 'system-ui, -apple-system, sans-serif' },\n    role: 'alert',\n  }, children);\n}\n\n// ─── Dynamic Component ──────────────────────────────────\n// Renders a component dynamically based on a reactive signal.\n// Usage: Dynamic({ component: mySignal, ...props })\nfunction Dynamic({ component, ...rest }) {\n  return {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    compute: () => {\n      const comp = typeof component === 'function' && !component.__tova ? component() : component;\n      if (!comp) return null;\n      if (typeof comp === 'function') {\n        return comp(rest);\n      }\n      return comp;\n    },\n  };\n}\n\n// ─── Portal ─────────────────────────────────────────────\n// Renders children into a different DOM target.\n// Usage: Portal({ target: \"#modal-root\", children })\n// Cleans up children from the target when the component unmounts.\nfunction Portal({ target, children }) {\n  return {\n    __tova: true,\n    tag: '__portal',\n    props: { target },\n    children: children || [],\n    _portalCleanup: true, // Signal to render() to register cleanup\n  };\n}\n\n// ─── Suspense ────────────────────────────────────────────\n// Renders fallback while any child lazy() component is loading.\n// Usage: Suspense({ fallback: loadingEl, children: [LazyComp(props)] })\n\nconst SuspenseContext = createContext(null);\nfunction Suspense({ fallback, children }) {\n  const [pending, setPending] = createSignal(0);\n  const childContent = children && children.length === 1 ? children[0] : tova_fragment(children || []);\n\n  const boundary = {\n    register() {\n      setPending(p => p + 1);\n    },\n    resolve() {\n      setPending(p => Math.max(0, p - 1));\n    },\n  };\n\n  return {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    compute: () => {\n      provide(SuspenseContext, boundary);\n      if (pending() > 0) {\n        return typeof fallback === 'function' ? fallback() : fallback;\n      }\n      return childContent;\n    },\n  };\n}\n\n// ─── Lazy ───────────────────────────────────────────────\n// Async component loading with optional fallback.\n// Usage: const LazyComp = lazy(() => import('./HeavyComponent.js'))\nfunction lazy(loader) {\n  let resolved = null;\n  let loadError = null;\n  let promise = null;\n  // Signal is shared across all renders of this lazy component (not per-call)\n  const [tick, setTick] = createSignal(0);\n\n  return function LazyWrapper(props) {\n    if (resolved) {\n      return resolved(props);\n    }\n\n    // Check for Suspense boundary\n    const suspense = inject(SuspenseContext);\n\n    if (!promise) {\n      if (suspense) suspense.register();\n      promise = loader()\n        .then(mod => {\n          resolved = mod.default || mod;\n          if (suspense) suspense.resolve();\n          setTick(1);\n        })\n        .catch(e => {\n          loadError = e;\n          if (suspense) suspense.resolve();\n          setTick(1);\n        });\n    }\n\n    return {\n      __tova: true,\n      tag: '__dynamic',\n      props: {},\n      children: [],\n      compute: () => {\n        tick(); // Track for reactivity\n        if (loadError) return tova_el('span', { className: 'tova-error' }, [String(loadError)]);\n        if (resolved) return resolved(props);\n        // Fallback while loading (individual or Suspense-level)\n        return props && props.fallback ? props.fallback : null;\n      },\n    };\n  };\n}\n\n// ─── Context (Provide/Inject) ────────────────────────────\n// Tree-based: values are stored on the ownership tree, inject walks up.\nfunction createContext(defaultValue) {\n  const id = Symbol('context');\n  return { _id: id, _default: defaultValue };\n}\nfunction provide(context, value) {\n  const owner = currentOwner;\n  if (owner) {\n    if (!owner._contexts) owner._contexts = new Map();\n    owner._contexts.set(context._id, value);\n  }\n}\nfunction inject(context) {\n  let owner = currentOwner;\n  while (owner) {\n    if (owner._contexts && owner._contexts.has(context._id)) {\n      return owner._contexts.get(context._id);\n    }\n    owner = owner._owner;\n  }\n  return context._default;\n}\n\n// ─── Head Component ──────────────────────────────────────\n// Declarative document head management.\n// Usage: Head({ children: [tova_el('title', {}, ['My Page']), tova_el('meta', {name: 'description', content: '...'})] })\n// Components can render <Head> to set title, meta, link, and script tags in <head>.\n// When the component unmounts, its head contributions are removed.\n\nconst __tovaHeadTags = [];\nfunction Head({ children }) {\n  if (typeof document === 'undefined') return null;\n\n  const addedElements = [];\n  const childList = Array.isArray(children) ? children : [children];\n\n  for (const child of childList) {\n    if (!child || !child.__tova) continue;\n    const tag = child.tag;\n    const props = child.props || {};\n    const text = child.children && child.children.length > 0 ? child.children.join('') : null;\n\n    if (tag === 'title') {\n      // Special case: update document.title directly\n      const prevTitle = document.title;\n      document.title = text || '';\n      addedElements.push({ type: 'title', prev: prevTitle });\n    } else {\n      const el = document.createElement(tag);\n      for (const [key, val] of Object.entries(props)) {\n        if (key.startsWith('on') || key === 'key' || key === 'ref') continue;\n        const attrName = key === 'className' ? 'class' : key;\n        const attrVal = typeof val === 'function' ? val() : val;\n        if (attrVal !== false && attrVal != null) {\n          el.setAttribute(attrName, String(attrVal));\n        }\n      }\n      if (text) el.textContent = text;\n      document.head.appendChild(el);\n      addedElements.push({ type: 'element', el });\n    }\n  }\n\n  // Register cleanup: remove added elements when component unmounts\n  if (currentOwner) {\n    const cleanup = () => {\n      for (const item of addedElements) {\n        if (item.type === 'element') {\n          if (typeof item.el.remove === 'function') {\n            item.el.remove();\n          } else if (item.el.parentNode && typeof item.el.parentNode.removeChild === 'function') {\n            item.el.parentNode.removeChild(item.el);\n          }\n        } else if (item.type === 'title') {\n          document.title = item.prev;\n        }\n      }\n    };\n    if (!currentOwner._cleanups) currentOwner._cleanups = [];\n    currentOwner._cleanups.push(cleanup);\n  }\n\n  return null; // Head renders nothing in the component tree\n}\n\n// ─── createResource ──────────────────────────────────────\n// Async data fetching primitive integrated with signals.\n// Usage: const [data, { loading, error, refetch }] = createResource(fetcher)\n// Usage with source: const [data, { loading, error, refetch }] = createResource(sourceSignal, fetcher)\n// When source changes, fetcher is re-invoked automatically.\nfunction createResource(sourceOrFetcher, maybeFetcher) {\n  let source, fetcher;\n  if (typeof maybeFetcher === 'function') {\n    source = sourceOrFetcher;\n    fetcher = maybeFetcher;\n  } else {\n    source = null;\n    fetcher = sourceOrFetcher;\n  }\n\n  const [data, setData] = createSignal(undefined);\n  const [loading, setLoading] = createSignal(false);\n  const [error, setError] = createSignal(undefined);\n  let version = 0; // Guards against stale responses\n\n  function doFetch(sourceVal) {\n    const currentVersion = ++version;\n    setLoading(true);\n    setError(undefined);\n    try {\n      const result = source ? fetcher(sourceVal) : fetcher();\n      if (result && typeof result.then === 'function') {\n        result.then(\n          (val) => {\n            if (currentVersion === version) {\n              setData(() => val);\n              setLoading(false);\n            }\n          },\n          (err) => {\n            if (currentVersion === version) {\n              setError(() => err);\n              setLoading(false);\n            }\n          },\n        );\n      } else {\n        // Synchronous fetcher\n        if (currentVersion === version) {\n          setData(() => result);\n          setLoading(false);\n        }\n      }\n    } catch (err) {\n      if (currentVersion === version) {\n        setError(() => err);\n        setLoading(false);\n      }\n    }\n  }\n\n  function refetch() {\n    const sourceVal = source ? (typeof source === 'function' ? source() : source) : undefined;\n    doFetch(sourceVal);\n  }\n\n  // If source is provided, track it reactively\n  if (source) {\n    createEffect(() => {\n      const sourceVal = typeof source === 'function' ? source() : source;\n      if (sourceVal !== undefined && sourceVal !== null && sourceVal !== false) {\n        doFetch(sourceVal);\n      }\n    });\n  } else {\n    // Fetch immediately\n    doFetch();\n  }\n\n  return [data, { loading, error, refetch, mutate: setData }];\n}\n\n// ─── DOM Rendering ────────────────────────────────────────\n\n// CSP nonce — set via configureCSP({ nonce: '...' }) or auto-detected from\n// <meta name=\"csp-nonce\" content=\"...\">. Used for style tags to comply with\n// Content-Security-Policy headers.\nlet __cspNonce = null;\nfunction configureCSP(options) {\n  if (options && options.nonce) __cspNonce = options.nonce;\n}\n\nfunction getCSPNonce() {\n  if (__cspNonce) return __cspNonce;\n  if (typeof document !== 'undefined' && typeof document.querySelector === 'function') {\n    const meta = document.querySelector('meta[name=\"csp-nonce\"]');\n    if (meta) {\n      __cspNonce = meta.getAttribute('content');\n      return __cspNonce;\n    }\n  }\n  return null;\n}\n\n// Inject scoped CSS into the page with reference counting.\n// Style tags are created on first use and removed when no component instances reference them.\n// Supports CSP nonce for Content-Security-Policy compliance.\nconst __tovaStyleRefs = new Map(); // id → { el, count }\nfunction tova_inject_css(id, css) {\n  const ref = __tovaStyleRefs.get(id);\n  if (ref) {\n    ref.count++;\n  } else {\n    const style = document.createElement('style');\n    style.setAttribute('data-tova-style', id);\n    const nonce = getCSPNonce();\n    if (nonce) style.setAttribute('nonce', nonce);\n    style.textContent = css;\n    document.head.appendChild(style);\n    __tovaStyleRefs.set(id, { el: style, count: 1 });\n  }\n  // Register cleanup on the current owner so unmount decrements the ref count\n  if (currentOwner) {\n    let cleaned = false;\n    const cleanup = () => {\n      if (cleaned) return;\n      cleaned = true;\n      const r = __tovaStyleRefs.get(id);\n      if (r) {\n        r.count--;\n        if (r.count <= 0) {\n          if (typeof r.el.remove === 'function') {\n            r.el.remove();\n          } else if (r.el.parentNode && typeof r.el.parentNode.removeChild === 'function') {\n            r.el.parentNode.removeChild(r.el);\n          }\n          __tovaStyleRefs.delete(id);\n        }\n      }\n    };\n    if (!currentOwner._cleanups) currentOwner._cleanups = [];\n    currentOwner._cleanups.push(cleanup);\n  }\n}\nfunction tova_el(tag, props = {}, children = []) {\n  return { __tova: true, tag, props, children };\n}\nfunction tova_fragment(children) {\n  return { __tova: true, tag: '__fragment', props: {}, children };\n}\n\n// ─── Transitions ──────────────────────────────────────────\n// CSS transition directives for mount/unmount animations.\n// Usage: tova_transition(vnode, \"fade\", { duration: 300 })\n\nconst TRANSITION_DEFAULTS = {\n  fade: { duration: 200, easing: 'ease' },\n  slide: { duration: 300, easing: 'ease-out', axis: 'y' },\n  scale: { duration: 200, easing: 'ease' },\n  fly: { duration: 300, easing: 'ease-out', x: 0, y: -20 },\n};\n\nfunction getTransitionCSS(name, config, phase) {\n  const opts = { ...TRANSITION_DEFAULTS[name], ...config };\n  const dur = opts.duration + 'ms';\n  const ease = opts.easing;\n\n  switch (name) {\n    case 'fade':\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { opacity: '0', transition: `opacity ${dur} ${ease}` };\n      }\n      return { opacity: '1', transition: `opacity ${dur} ${ease}` };\n\n    case 'slide': {\n      const axis = opts.axis || 'y';\n      const prop = axis === 'x' ? 'translateX' : 'translateY';\n      const dist = (opts.distance || 20) + 'px';\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { transform: `${prop}(${dist})`, opacity: '0', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n      }\n      return { transform: `${prop}(0)`, opacity: '1', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n    }\n\n    case 'scale':\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { transform: 'scale(0)', opacity: '0', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n      }\n      return { transform: 'scale(1)', opacity: '1', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n\n    case 'fly': {\n      const x = (opts.x || 0) + 'px';\n      const y = (opts.y || -20) + 'px';\n      if (phase === 'enter-from' || phase === 'leave-to') {\n        return { transform: `translate(${x}, ${y})`, opacity: '0', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n      }\n      return { transform: 'translate(0, 0)', opacity: '1', transition: `transform ${dur} ${ease}, opacity ${dur} ${ease}` };\n    }\n\n    default:\n      return {};\n  }\n}\nfunction tova_transition(vnode, nameOrConfig, config = {}) {\n  if (!vnode || !vnode.__tova) return vnode;\n\n  // Directional transitions: tova_transition(vnode, { in: {...}, out: {...} })\n  if (typeof nameOrConfig === 'object' && nameOrConfig !== null && !nameOrConfig.__tova && (nameOrConfig.in || nameOrConfig.out)) {\n    vnode._transition = { directional: true, in: nameOrConfig.in, out: nameOrConfig.out };\n    return vnode;\n  }\n\n  // Custom transition function: tova_transition(vnode, myTransitionFn, config)\n  if (typeof nameOrConfig === 'function') {\n    vnode._transition = { custom: nameOrConfig, config };\n    return vnode;\n  }\n\n  // Built-in transition: tova_transition(vnode, \"fade\", config)\n  vnode._transition = { name: nameOrConfig, config };\n  return vnode;\n}\n\n// ─── TransitionGroup ──────────────────────────────────────\n// Animates enter, leave, and move for keyed list items.\n// Usage: TransitionGroup({ name: \"fade\", tag: \"ul\", children: items.map(i => ...) })\n// Each child MUST have a `key` prop.\n// Supports FLIP-based move animations when items reorder.\nfunction TransitionGroup({ name = 'fade', tag = 'div', config = {}, children, ...rest }) {\n  const transName = name;\n  const transConfig = config;\n  const childList = Array.isArray(children) ? children : (children ? [children] : []);\n\n  // Annotate each child vnode with the transition\n  const annotated = childList.map(child => {\n    if (child && child.__tova && !child._transition) {\n      child._transition = { name: transName, config: transConfig };\n    }\n    return child;\n  });\n\n  // Wrap in a container element (default <div>)\n  const wrapper = tova_el(tag, { ...rest, 'data-tova-transition-group': '' }, annotated);\n  wrapper._transitionGroup = { name: transName, config: transConfig };\n  return wrapper;\n}\n\n// ─── Actions ──────────────────────────────────────────────\n// use: directive support. Calls actionFn(el, param) after render.\n// Returns the wrapped vnode. The action lifecycle (update/destroy) is managed.\nfunction __tova_action(vnode, actionFn, param) {\n  if (!vnode || !vnode.__tova) return vnode;\n  if (!vnode._actions) vnode._actions = [];\n  vnode._actions.push({ fn: actionFn, param });\n  return vnode;\n}\n\n// Apply enter transition to a DOM element after render\nfunction applyEnterTransition(el, trans) {\n  if (!trans) return;\n\n  // Custom transition function\n  if (trans.custom) {\n    const result = trans.custom(el, trans.config || {}, 'enter');\n    if (result && typeof result === 'object' && !result.then) {\n      Object.assign(el.style, result);\n    }\n    return;\n  }\n\n  // Directional: use 'in' config for enter\n  const name = trans.directional ? (trans.in ? trans.in.name : null) : trans.name;\n  const config = trans.directional ? (trans.in ? trans.in.config : {}) : trans.config;\n  if (!name) return;\n\n  const fromStyles = getTransitionCSS(name, config, 'enter-from');\n  const toStyles = getTransitionCSS(name, config, 'enter-to');\n\n  // Set initial state\n  Object.assign(el.style, fromStyles);\n\n  // Force reflow, then apply target state\n  void el.offsetHeight;\n  Object.assign(el.style, toStyles);\n}\n\n// Apply leave transition and return a Promise that resolves when done\nfunction applyLeaveTransition(el, trans) {\n  if (!trans) return Promise.resolve();\n\n  // Custom transition function\n  if (trans.custom) {\n    const result = trans.custom(el, trans.config || {}, 'leave');\n    if (result && typeof result.then === 'function') {\n      // Race with timeout to prevent leaked promises from custom transitions\n      const dur = (trans.config && trans.config.duration) || 5000;\n      return Promise.race([result, new Promise(r => setTimeout(r, dur + 100))]);\n    }\n    if (result && typeof result === 'object') {\n      Object.assign(el.style, result);\n    }\n    const dur = (trans.config && trans.config.duration) || 200;\n    return new Promise(resolve => setTimeout(resolve, dur));\n  }\n\n  // Directional: use 'out' config for leave\n  const name = trans.directional ? (trans.out ? trans.out.name : null) : trans.name;\n  const config = trans.directional ? (trans.out ? trans.out.config : {}) : trans.config;\n  if (!name) return Promise.resolve();\n\n  const duration = (config && config.duration) || TRANSITION_DEFAULTS[name]?.duration || 200;\n  const toStyles = getTransitionCSS(name, config, 'leave-to');\n  Object.assign(el.style, toStyles);\n\n  return new Promise(resolve => {\n    const handler = () => {\n      el.removeEventListener('transitionend', handler);\n      resolve();\n    };\n    el.addEventListener('transitionend', handler);\n    // Fallback timeout in case transitionend doesn't fire\n    setTimeout(resolve, duration + 50);\n  });\n}\n\n// Inject a key prop into a vnode for keyed reconciliation\nfunction tova_keyed(key, vnode) {\n  if (vnode && vnode.__tova) {\n    vnode.props = { ...vnode.props, key };\n  }\n  return vnode;\n}\n\n// Flatten nested arrays and vnodes into a flat list of vnodes\nfunction flattenVNodes(children) {\n  const result = [];\n  for (const child of children) {\n    if (child === null || child === undefined) {\n      continue;\n    } else if (Array.isArray(child)) {\n      result.push(...flattenVNodes(child));\n    } else {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\n// ─── Marker-based DOM helpers ─────────────────────────────\n// Instead of wrapping dynamic blocks/fragments in <span style=\"display:contents\">,\n// we use comment node markers. A marker's __tovaNodes tracks its content nodes.\n// Content nodes have __tovaOwner pointing to their owning marker.\n\n// Recursively dispose ownership roots attached to a DOM subtree\nfunction disposeNode(node) {\n  if (!node) return;\n  if (node.__tovaRoot) {\n    node.__tovaRoot();\n    node.__tovaRoot = null;\n  }\n  // If this is a marker, dispose and remove its content nodes\n  if (node.__tovaNodes) {\n    for (const cn of node.__tovaNodes) {\n      disposeNode(cn);\n      if (cn.parentNode) cn.parentNode.removeChild(cn);\n    }\n    node.__tovaNodes = [];\n  }\n  if (node.childNodes) {\n    for (const child of Array.from(node.childNodes)) {\n      disposeNode(child);\n    }\n  }\n}\n\n// Check if a node is transitively owned by a marker (walks __tovaOwner chain)\nfunction isOwnedBy(node, marker) {\n  let owner = node.__tovaOwner;\n  while (owner) {\n    if (owner === marker) return true;\n    owner = owner.__tovaOwner;\n  }\n  return false;\n}\n\n// Get logical children of a parent element (skips marker content nodes)\nfunction getLogicalChildren(parent) {\n  const logical = [];\n  for (let i = 0; i < parent.childNodes.length; i++) {\n    const node = parent.childNodes[i];\n    if (!node.__tovaOwner) {\n      logical.push(node);\n    }\n  }\n  return logical;\n}\n\n// Find the first DOM sibling after all of a marker's content\nfunction nextSiblingAfterMarker(marker) {\n  if (!marker.__tovaNodes || marker.__tovaNodes.length === 0) {\n    return marker.nextSibling;\n  }\n  let last = marker.__tovaNodes[marker.__tovaNodes.length - 1];\n  // If last content is itself a marker, recurse to find physical end\n  while (last && last.__tovaNodes && last.__tovaNodes.length > 0) {\n    last = last.__tovaNodes[last.__tovaNodes.length - 1];\n  }\n  return last ? last.nextSibling : marker.nextSibling;\n}\n\n// Remove a logical node (marker + its content, or a regular node) from the DOM\nfunction removeLogicalNode(parent, node) {\n  disposeNode(node);\n  if (node.parentNode === parent) parent.removeChild(node);\n}\n\n// Insert rendered result (could be single node or DocumentFragment) before ref,\n// setting __tovaOwner on top-level inserted nodes. Returns array of inserted nodes.\nfunction insertRendered(parent, rendered, ref, owner) {\n  if (rendered.nodeType === 11) {\n    const nodes = Array.from(rendered.childNodes);\n    for (const n of nodes) {\n      if (!n.__tovaOwner) n.__tovaOwner = owner;\n    }\n    parent.insertBefore(rendered, ref);\n    return nodes;\n  }\n  if (!rendered.__tovaOwner) rendered.__tovaOwner = owner;\n  parent.insertBefore(rendered, ref);\n  return [rendered];\n}\n\n// Clear a marker's content from the DOM and reset __tovaNodes\nfunction clearMarkerContent(marker) {\n  for (const node of marker.__tovaNodes) {\n    // If element has a leave transition, animate out before removing\n    if (node.__tovaTransition && node.nodeType === 1) {\n      const el = node;\n      applyLeaveTransition(el, el.__tovaTransition).then(() => {\n        disposeNode(el);\n        if (el.parentNode) el.parentNode.removeChild(el);\n      }).catch(() => {\n        disposeNode(el);\n        if (el.parentNode) el.parentNode.removeChild(el);\n      });\n    } else {\n      disposeNode(node);\n      if (node.parentNode) node.parentNode.removeChild(node);\n    }\n  }\n  marker.__tovaNodes = [];\n}\n\n// ─── Render ───────────────────────────────────────────────\n\n// Create real DOM nodes from a vnode (with fine-grained reactive bindings).\n// Returns a single DOM node for elements/text, or a DocumentFragment for\n// markers (dynamic blocks, fragments) containing [marker, ...content].\nfunction render(vnode) {\n  if (vnode === null || vnode === undefined) {\n    return document.createTextNode('');\n  }\n\n  // Reactive dynamic block (JSXIf, JSXFor, reactive text, etc.)\n  if (typeof vnode === 'function') {\n    const marker = document.createComment('');\n    marker.__tovaDynamic = true;\n    marker.__tovaNodes = [];\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    createEffect(() => {\n      const val = vnode();\n      const parent = marker.parentNode;\n      const ref = nextSiblingAfterMarker(marker);\n\n      // Array: keyed or positional reconciliation within marker range\n      if (Array.isArray(val)) {\n        const flat = flattenVNodes(val);\n        const hasKeys = flat.some(c => getKey(c) != null);\n        if (hasKeys) {\n          patchKeyedInMarker(marker, flat);\n        } else {\n          patchPositionalInMarker(marker, flat);\n        }\n        return;\n      }\n\n      // Text: optimize single text node update in place\n      if (val == null || typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {\n        const text = val == null ? '' : String(val);\n        if (marker.__tovaNodes.length === 1 && marker.__tovaNodes[0].nodeType === 3) {\n          if (marker.__tovaNodes[0].textContent !== text) {\n            marker.__tovaNodes[0].textContent = text;\n          }\n          return;\n        }\n        clearMarkerContent(marker);\n        const textNode = document.createTextNode(text);\n        textNode.__tovaOwner = marker;\n        parent.insertBefore(textNode, ref);\n        marker.__tovaNodes = [textNode];\n        return;\n      }\n\n      // Vnode or other: clear and re-render\n      clearMarkerContent(marker);\n      if (val && val.__tova) {\n        const rendered = render(val);\n        marker.__tovaNodes = insertRendered(parent, rendered, ref, marker);\n      } else {\n        const textNode = document.createTextNode(String(val));\n        textNode.__tovaOwner = marker;\n        parent.insertBefore(textNode, ref);\n        marker.__tovaNodes = [textNode];\n      }\n    });\n\n    return frag;\n  }\n\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    return document.createTextNode(String(vnode));\n  }\n\n  if (Array.isArray(vnode)) {\n    const fragment = document.createDocumentFragment();\n    for (const child of vnode) {\n      fragment.appendChild(render(child));\n    }\n    return fragment;\n  }\n\n  if (!vnode.__tova) {\n    return document.createTextNode(String(vnode));\n  }\n\n  // Fragment — marker + children (no wrapper element)\n  if (vnode.tag === '__fragment') {\n    const marker = document.createComment('');\n    marker.__tovaFragment = true;\n    marker.__tovaNodes = [];\n    marker.__vnode = vnode;\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    for (const child of flattenVNodes(vnode.children)) {\n      const rendered = render(child);\n      const inserted = insertRendered(frag, rendered, null, marker);\n      marker.__tovaNodes.push(...inserted);\n    }\n\n    return frag;\n  }\n\n  // Dynamic reactive node (ErrorBoundary, Dynamic component, etc.)\n  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {\n    const marker = document.createComment('');\n    marker.__tovaDynamic = true;\n    marker.__tovaNodes = [];\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    let prevDispose = null;\n    const errHandler = vnode._errorHandler || null;\n    createEffect(() => {\n      if (errHandler) pushErrorHandler(errHandler);\n      try {\n        const inner = vnode.compute();\n        const parent = marker.parentNode;\n        const ref = nextSiblingAfterMarker(marker);\n\n        if (prevDispose) {\n          prevDispose();\n          prevDispose = null;\n        }\n        clearMarkerContent(marker);\n\n        createRoot((dispose) => {\n          prevDispose = dispose;\n          const rendered = render(inner);\n          marker.__tovaNodes = insertRendered(parent, rendered, ref, marker);\n        });\n      } catch (e) {\n        if (errHandler) {\n          errHandler(e);\n        } else if (currentErrorHandler) {\n          currentErrorHandler(e);\n        } else {\n          console.error('Uncaught error during render:', e);\n        }\n      } finally {\n        if (errHandler) popErrorHandler();\n      }\n    });\n\n    return frag;\n  }\n\n  // Portal — render children into a different DOM target\n  if (vnode.tag === '__portal') {\n    const placeholder = document.createComment('portal');\n    const targetSelector = vnode.props.target;\n    const portalNodes = [];\n    queueMicrotask(() => {\n      const targetEl = typeof targetSelector === 'string'\n        ? document.querySelector(targetSelector)\n        : targetSelector;\n      if (targetEl) {\n        for (const child of flattenVNodes(vnode.children)) {\n          const rendered = render(child);\n          targetEl.appendChild(rendered);\n          portalNodes.push(rendered);\n        }\n      }\n    });\n    // Register cleanup: remove portal children when component unmounts\n    if (currentOwner && !currentOwner._disposed) {\n      if (!currentOwner._cleanups) currentOwner._cleanups = [];\n      currentOwner._cleanups.push(() => {\n        for (const node of portalNodes) {\n          disposeNode(node);\n          if (node.parentNode) node.parentNode.removeChild(node);\n        }\n        portalNodes.length = 0;\n      });\n    }\n    return placeholder;\n  }\n\n  // Element\n  const el = document.createElement(vnode.tag);\n  applyReactiveProps(el, vnode.props);\n\n  // Set data-tova-component attribute for DevTools\n  if (vnode._componentName) {\n    el.setAttribute('data-tova-component', vnode._componentName);\n    if (__devtools_hooks && __devtools_hooks.onComponentRender) {\n      __devtools_hooks.onComponentRender(vnode._componentName, el, 0);\n    }\n  }\n\n  // Render children\n  for (const child of flattenVNodes(vnode.children)) {\n    el.appendChild(render(child));\n  }\n\n  // Store vnode reference for patching\n  el.__vnode = vnode;\n\n  // Apply enter transition if present\n  if (vnode._transition) {\n    el.__tovaTransition = vnode._transition;\n    applyEnterTransition(el, vnode._transition);\n  }\n\n  // Apply use: actions if present\n  if (vnode._actions && vnode._actions.length > 0) {\n    for (const action of vnode._actions) {\n      const paramValue = typeof action.param === 'function' ? action.param() : action.param;\n      const result = action.fn(el, paramValue);\n      if (result) {\n        // If param is reactive, set up effect for updates\n        if (typeof action.param === 'function') {\n          createEffect(() => {\n            const newVal = action.param();\n            if (result.update) result.update(newVal);\n          });\n        }\n        // Register destroy on cleanup\n        if (result.destroy) {\n          if (currentOwner && !currentOwner._disposed) {\n            currentOwner._cleanups.push(result.destroy);\n          }\n        }\n      }\n    }\n  }\n\n  return el;\n}\n\n// Apply reactive props — function-valued props get their own effect\nfunction applyReactiveProps(el, props) {\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      if (typeof value === 'object' && value !== null && value.handler) {\n        el.addEventListener(eventName, value.handler, value.options);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value.handler;\n        el.__handlerOptions = el.__handlerOptions || {};\n        el.__handlerOptions[eventName] = value.options;\n      } else {\n        el.addEventListener(eventName, value);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value;\n      }\n    } else if (key === 'key') {\n      // Skip\n    } else if (typeof value === 'function' && !key.startsWith('on')) {\n      // Reactive prop — create effect for fine-grained updates\n      createEffect(() => {\n        const val = value();\n        applyPropValue(el, key, val);\n      });\n    } else {\n      applyPropValue(el, key, value);\n    }\n  }\n}\n\nfunction applyPropValue(el, key, val) {\n  if (key === 'className') {\n    if (el.className !== val) el.className = val || '';\n  } else if (key === 'dangerouslySetInnerHTML') {\n    // Explicit unsafe HTML injection — requires {__html: \"...\"} format\n    const html = typeof val === 'object' && val !== null ? val.__html || '' : '';\n    if (__DEV__ && html) {\n      console.warn('Tova: dangerouslySetInnerHTML bypasses XSS protection. Ensure content is sanitized.');\n    }\n    if (el.innerHTML !== html) el.innerHTML = html;\n  } else if (key === 'innerHTML') {\n    // Blocked: use dangerouslySetInnerHTML instead\n    if (__DEV__) {\n      console.error('Tova: innerHTML is not allowed. Use dangerouslySetInnerHTML={{__html: value}} to acknowledge XSS risk.');\n    }\n  } else if (key === 'value') {\n    if (el !== document.activeElement && el.value !== val) {\n      el.value = val;\n    }\n  } else if (key === 'checked') {\n    el.checked = !!val;\n  } else if (key === 'disabled' || key === 'readOnly' || key === 'hidden') {\n    el[key] = !!val;\n  } else if (key === 'style' && typeof val === 'object') {\n    // Delta update: only remove properties that were in previous style but not in new\n    if (el.__prevStyle) {\n      for (const prop of Object.keys(el.__prevStyle)) {\n        if (!(prop in val)) el.style.removeProperty(prop);\n      }\n    }\n    el.__prevStyle = { ...val };\n    Object.assign(el.style, val);\n  } else {\n    const s = val == null ? '' : String(val);\n    if (el.getAttribute(key) !== s) {\n      el.setAttribute(key, s);\n    }\n  }\n}\n\n// Apply/update props on a DOM element (used by patcher for full-tree mode)\nfunction applyProps(el, newProps, oldProps) {\n  // Remove old props that are no longer present\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in newProps)) {\n      if (key.startsWith('on')) {\n        const eventName = key.slice(2).toLowerCase();\n        if (el.__handlers && el.__handlers[eventName]) {\n          el.removeEventListener(eventName, el.__handlers[eventName]);\n          delete el.__handlers[eventName];\n        }\n      } else if (key === 'className') {\n        el.className = '';\n      } else if (key === 'style') {\n        el.removeAttribute('style');\n      } else {\n        el.removeAttribute(key);\n      }\n    }\n  }\n\n  // Apply new props\n  for (const [key, value] of Object.entries(newProps)) {\n    if (key === 'className') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.className !== val) el.className = val;\n    } else if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      if (typeof value === 'object' && value !== null && value.handler) {\n        const oldHandler = el.__handlers && el.__handlers[eventName];\n        if (oldHandler !== value.handler) {\n          const oldOpts = el.__handlerOptions && el.__handlerOptions[eventName];\n          if (oldHandler) el.removeEventListener(eventName, oldHandler, oldOpts);\n          el.addEventListener(eventName, value.handler, value.options);\n          if (!el.__handlers) el.__handlers = {};\n          el.__handlers[eventName] = value.handler;\n          el.__handlerOptions = el.__handlerOptions || {};\n          el.__handlerOptions[eventName] = value.options;\n        }\n      } else {\n        const oldHandler = el.__handlers && el.__handlers[eventName];\n        if (oldHandler !== value) {\n          if (oldHandler) el.removeEventListener(eventName, oldHandler);\n          el.addEventListener(eventName, value);\n          if (!el.__handlers) el.__handlers = {};\n          el.__handlers[eventName] = value;\n        }\n      }\n    } else if (key === 'style' && typeof value === 'object') {\n      Object.assign(el.style, value);\n    } else if (key === 'key') {\n      // Skip\n    } else if (key === 'value') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el !== document.activeElement && el.value !== val) {\n        el.value = val;\n      }\n    } else if (key === 'checked') {\n      el.checked = !!value;\n    } else {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.getAttribute(key) !== String(val)) {\n        el.setAttribute(key, val);\n      }\n    }\n  }\n}\n\n// ─── Longest Increasing Subsequence (O(n log n)) ────────\n// Used by keyed reconciliation to minimize DOM moves.\n\nfunction longestIncreasingSubsequence(arr) {\n  const n = arr.length;\n  if (n === 0) return [];\n\n  // tails[i] = index in arr of smallest tail element for IS of length i+1\n  const tails = [];\n  // parent[i] = index in arr of predecessor of arr[i] in the LIS\n  const parent = new Array(n).fill(-1);\n  // indices[i] = index in arr of tails[i]\n  const indices = [];\n\n  for (let i = 0; i < n; i++) {\n    const val = arr[i];\n    if (val < 0) continue; // skip removed items (marker -1)\n\n    // Binary search for the insertion point\n    let lo = 0, hi = tails.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >> 1;\n      if (tails[mid] < val) lo = mid + 1;\n      else hi = mid;\n    }\n\n    tails[lo] = val;\n    indices[lo] = i;\n\n    if (lo > 0) {\n      parent[i] = indices[lo - 1];\n    }\n  }\n\n  // Reconstruct\n  const result = new Array(tails.length);\n  let k = indices[tails.length - 1];\n  for (let i = tails.length - 1; i >= 0; i--) {\n    result[i] = k;\n    k = parent[k];\n  }\n\n  return result;\n}\n\n// ─── Keyed Reconciliation ────────────────────────────────\n\nfunction getKey(vnode) {\n  if (vnode && vnode.__tova && vnode.props) return vnode.props.key;\n  return undefined;\n}\n\nfunction getNodeKey(node) {\n  if (node && node.__vnode && node.__vnode.props) return node.__vnode.props.key;\n  return undefined;\n}\n\n// Keyed reconciliation within a marker's content range\nfunction patchKeyedInMarker(marker, newVNodes) {\n  const parent = marker.parentNode;\n  const oldNodes = [...marker.__tovaNodes];\n  const oldKeyMap = new Map();\n\n  for (const node of oldNodes) {\n    const key = getNodeKey(node);\n    if (key != null) oldKeyMap.set(key, node);\n  }\n\n  const newNodes = [];\n  const usedOld = new Set();\n\n  for (const newChild of newVNodes) {\n    const key = getKey(newChild);\n\n    if (key != null && oldKeyMap.has(key)) {\n      const oldNode = oldKeyMap.get(key);\n      usedOld.add(oldNode);\n\n      if (oldNode.nodeType === 1 && newChild.__tova &&\n          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {\n        const oldVNode = oldNode.__vnode || { props: {}, children: [] };\n        applyProps(oldNode, newChild.props, oldVNode.props);\n        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));\n        oldNode.__vnode = newChild;\n        newNodes.push(oldNode);\n      } else {\n        const node = render(newChild);\n        // render may return Fragment — collect nodes\n        if (node.nodeType === 11) {\n          const nodes = Array.from(node.childNodes);\n          for (const n of nodes) { if (!n.__tovaOwner) n.__tovaOwner = marker; }\n          parent.insertBefore(node, nextSiblingAfterMarker(marker));\n          newNodes.push(...nodes);\n        } else {\n          if (!node.__tovaOwner) node.__tovaOwner = marker;\n          newNodes.push(node);\n        }\n      }\n    } else {\n      const node = render(newChild);\n      if (node.nodeType === 11) {\n        const nodes = Array.from(node.childNodes);\n        for (const n of nodes) { if (!n.__tovaOwner) n.__tovaOwner = marker; }\n        parent.insertBefore(node, nextSiblingAfterMarker(marker));\n        newNodes.push(...nodes);\n      } else {\n        if (!node.__tovaOwner) node.__tovaOwner = marker;\n        newNodes.push(node);\n      }\n    }\n  }\n\n  // Remove unused old nodes\n  for (const node of oldNodes) {\n    if (!usedOld.has(node)) {\n      disposeNode(node);\n      if (node.parentNode === parent) parent.removeChild(node);\n    }\n  }\n\n  // LIS-based reorder: compute old positions, find LIS, only move non-LIS nodes\n  const oldPosMap = new Map();\n  for (let i = 0; i < oldNodes.length; i++) {\n    oldPosMap.set(oldNodes[i], i);\n  }\n  const positions = newNodes.map(n => oldPosMap.has(n) ? oldPosMap.get(n) : -1);\n  const lisIndices = new Set(longestIncreasingSubsequence(positions));\n\n  // Insert nodes: only move nodes not in the LIS\n  let cursor = marker.nextSibling;\n  for (let i = 0; i < newNodes.length; i++) {\n    const node = newNodes[i];\n    if (lisIndices.has(i) && node === cursor) {\n      cursor = node.nextSibling;\n    } else {\n      parent.insertBefore(node, cursor);\n    }\n  }\n\n  marker.__tovaNodes = newNodes;\n}\n\n// Positional reconciliation within a marker's content range\nfunction patchPositionalInMarker(marker, newChildren) {\n  const parent = marker.parentNode;\n  const oldNodes = [...marker.__tovaNodes];\n  const oldCount = oldNodes.length;\n  const newCount = newChildren.length;\n\n  // Patch in place (skip identical vnodes)\n  const patchCount = Math.min(oldCount, newCount);\n  for (let i = 0; i < patchCount; i++) {\n    if (oldNodes[i] === newChildren[i]) continue;\n    patchSingle(parent, oldNodes[i], newChildren[i]);\n  }\n\n  // Append new children\n  const ref = nextSiblingAfterMarker(marker);\n  for (let i = oldCount; i < newCount; i++) {\n    const rendered = render(newChildren[i]);\n    const inserted = insertRendered(parent, rendered, ref, marker);\n    oldNodes.push(...inserted);\n  }\n\n  // Remove excess children\n  for (let i = newCount; i < oldCount; i++) {\n    disposeNode(oldNodes[i]);\n    if (oldNodes[i].parentNode === parent) parent.removeChild(oldNodes[i]);\n  }\n\n  marker.__tovaNodes = oldNodes.slice(0, newCount);\n}\n\n// Keyed reconciliation for children of an element (not marker-based)\nfunction patchKeyedChildren(parent, newVNodes) {\n  const logical = getLogicalChildren(parent);\n  const oldKeyMap = new Map();\n\n  for (const node of logical) {\n    const key = getNodeKey(node);\n    if (key != null) oldKeyMap.set(key, node);\n  }\n\n  const newNodes = [];\n  const usedOld = new Set();\n\n  for (const newChild of newVNodes) {\n    const key = getKey(newChild);\n\n    if (key != null && oldKeyMap.has(key)) {\n      const oldNode = oldKeyMap.get(key);\n      usedOld.add(oldNode);\n\n      if (oldNode.nodeType === 1 && newChild.__tova &&\n          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {\n        const oldVNode = oldNode.__vnode || { props: {}, children: [] };\n        applyProps(oldNode, newChild.props, oldVNode.props);\n        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));\n        oldNode.__vnode = newChild;\n        newNodes.push(oldNode);\n      } else {\n        newNodes.push(render(newChild));\n      }\n    } else {\n      newNodes.push(render(newChild));\n    }\n  }\n\n  // Remove unused old logical nodes\n  for (const node of logical) {\n    if (!usedOld.has(node) && node.parentNode === parent) {\n      removeLogicalNode(parent, node);\n    }\n  }\n\n  // LIS-based reorder for element children\n  const logicalAfterRemove = getLogicalChildren(parent);\n  const oldPosMap = new Map();\n  for (let i = 0; i < logicalAfterRemove.length; i++) {\n    oldPosMap.set(logicalAfterRemove[i], i);\n  }\n  const positions = newNodes.map(n => oldPosMap.has(n) ? oldPosMap.get(n) : -1);\n  const lisIndices = new Set(longestIncreasingSubsequence(positions));\n\n  for (let i = 0; i < newNodes.length; i++) {\n    const expected = newNodes[i];\n    if (!lisIndices.has(i)) {\n      const logicalNow = getLogicalChildren(parent);\n      const current = logicalNow[i];\n      if (current !== expected) {\n        parent.insertBefore(expected, current || null);\n      }\n    }\n  }\n}\n\n// Positional reconciliation for children of an element\nfunction patchPositionalChildren(parent, newChildren) {\n  const logical = getLogicalChildren(parent);\n  const oldCount = logical.length;\n  const newCount = newChildren.length;\n\n  for (let i = 0; i < Math.min(oldCount, newCount); i++) {\n    patchSingle(parent, logical[i], newChildren[i]);\n  }\n\n  for (let i = oldCount; i < newCount; i++) {\n    parent.appendChild(render(newChildren[i]));\n  }\n\n  // Remove excess logical children\n  const currentLogical = getLogicalChildren(parent);\n  while (currentLogical.length > newCount) {\n    const node = currentLogical.pop();\n    removeLogicalNode(parent, node);\n  }\n}\n\n// Patch children of a regular element\nfunction patchChildrenOfElement(el, newChildren) {\n  const hasKeys = newChildren.some(c => getKey(c) != null);\n  if (hasKeys) {\n    patchKeyedChildren(el, newChildren);\n  } else {\n    patchPositionalChildren(el, newChildren);\n  }\n}\n\n// Patch a single logical node in place\nfunction patchSingle(parent, existing, newVNode) {\n  if (!existing) {\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  if (newVNode === null || newVNode === undefined) {\n    removeLogicalNode(parent, existing);\n    return;\n  }\n\n  // Function vnode — replace with new dynamic block\n  if (typeof newVNode === 'function') {\n    const rendered = render(newVNode);\n    if (existing.__tovaNodes) {\n      // Existing is a marker — clear its content and replace\n      clearMarkerContent(existing);\n      parent.replaceChild(rendered, existing);\n    } else {\n      disposeNode(existing);\n      parent.replaceChild(rendered, existing);\n    }\n    return;\n  }\n\n  // Text\n  if (typeof newVNode === 'string' || typeof newVNode === 'number' || typeof newVNode === 'boolean') {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      removeLogicalNode(parent, existing);\n      parent.insertBefore(document.createTextNode(text), null);\n    }\n    return;\n  }\n\n  if (!newVNode.__tova) {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      removeLogicalNode(parent, existing);\n      parent.insertBefore(document.createTextNode(text), null);\n    }\n    return;\n  }\n\n  // Fragment — patch marker content\n  if (newVNode.tag === '__fragment') {\n    if (existing.__tovaFragment) {\n      // Patch children within the marker range\n      const oldNodes = [...existing.__tovaNodes];\n      const newChildren = flattenVNodes(newVNode.children);\n      // Simple approach: clear and re-render fragment content\n      clearMarkerContent(existing);\n      const ref = nextSiblingAfterMarker(existing);\n      for (const child of newChildren) {\n        const rendered = render(child);\n        const inserted = insertRendered(parent, rendered, ref, existing);\n        existing.__tovaNodes.push(...inserted);\n      }\n      existing.__vnode = newVNode;\n      return;\n    }\n    removeLogicalNode(parent, existing);\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  // Element — patch in place\n  if (existing.nodeType === 1 && newVNode.tag &&\n      existing.tagName.toLowerCase() === newVNode.tag.toLowerCase()) {\n    const oldVNode = existing.__vnode || { props: {}, children: [] };\n    applyProps(existing, newVNode.props, oldVNode.props);\n    patchChildrenOfElement(existing, flattenVNodes(newVNode.children));\n    existing.__vnode = newVNode;\n    return;\n  }\n\n  // Different type — full replace\n  removeLogicalNode(parent, existing);\n  parent.appendChild(render(newVNode));\n}\n\n// ─── Hydration (SSR) ─────────────────────────────────────\n// SSR renders flat HTML without markers. Hydration attaches reactivity\n// to existing DOM nodes and inserts markers for dynamic blocks.\n\n// Dev-mode hydration mismatch detection\nfunction checkHydrationMismatch(domNode, vnode) {\n  if (!__DEV__) return;\n  if (!domNode || !vnode || !vnode.__tova) return;\n\n  const props = vnode.props || {};\n\n  // Check className\n  if (props.className !== undefined) {\n    const expected = typeof props.className === 'function' ? props.className() : props.className;\n    const actual = domNode.className || '';\n    if (expected && actual !== expected) {\n      console.warn(`Tova hydration mismatch: <${vnode.tag}> class expected \"${expected}\" but got \"${actual}\"`);\n    }\n  }\n\n  // Check attributes\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'key' || key === 'ref' || key === 'className' || key.startsWith('on')) continue;\n    if (typeof value === 'function') continue; // reactive props — skip static check\n\n    if (domNode.getAttribute) {\n      const attrName = key === 'className' ? 'class' : key;\n      const actual = domNode.getAttribute(attrName);\n      const expected = String(value);\n      if (actual !== null && actual !== expected) {\n        console.warn(`Tova hydration mismatch: <${vnode.tag}> attribute \"${key}\" expected \"${expected}\" but got \"${actual}\"`);\n      }\n    }\n  }\n}\n\n// Check if a DOM node is an SSR marker comment (<!--tova-s:ID-->)\nfunction isSSRMarker(node) {\n  return node && node.nodeType === 8 && typeof node.data === 'string' && node.data.startsWith('tova-s:');\n}\n\n// Find the closing SSR marker and collect content nodes between them\nfunction collectSSRMarkerContent(startMarker) {\n  const id = startMarker.data.replace('tova-s:', '');\n  const closingText = `/tova-s:${id}`;\n  const content = [];\n  let cursor = startMarker.nextSibling;\n  while (cursor) {\n    if (cursor.nodeType === 8 && cursor.data === closingText) {\n      return { content, endMarker: cursor };\n    }\n    content.push(cursor);\n    cursor = cursor.nextSibling;\n  }\n  return { content, endMarker: null };\n}\n\nfunction hydrateVNode(domNode, vnode) {\n  if (!domNode) return null;\n  if (vnode === null || vnode === undefined) return domNode;\n\n  // Function vnode (reactive text, JSXIf, JSXFor)\n  if (typeof vnode === 'function') {\n    if (domNode.nodeType === 3) {\n      // Dev-mode: warn if text content differs\n      if (__DEV__) {\n        const val = vnode();\n        const expected = val == null ? '' : String(val);\n        if (domNode.textContent !== expected) {\n          console.warn(`Tova hydration mismatch: text expected \"${expected}\" but got \"${domNode.textContent}\"`);\n        }\n      }\n      // Reactive text: attach effect to existing text node\n      domNode.__tovaReactive = true;\n      createEffect(() => {\n        const val = vnode();\n        const text = val == null ? '' : String(val);\n        if (domNode.textContent !== text) domNode.textContent = text;\n      });\n      return domNode.nextSibling;\n    }\n    // Complex dynamic block: insert marker-based render, replace SSR node\n    const parent = domNode.parentNode;\n    const next = domNode.nextSibling;\n    const rendered = render(vnode);\n    parent.replaceChild(rendered, domNode);\n    return next;\n  }\n\n  // Primitive text — already correct from SSR\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    if (__DEV__ && domNode.nodeType === 3) {\n      const expected = String(vnode);\n      if (domNode.textContent !== expected) {\n        console.warn(`Tova hydration mismatch: text expected \"${expected}\" but got \"${domNode.textContent}\"`);\n      }\n    }\n    return domNode.nextSibling;\n  }\n\n  // Array\n  if (Array.isArray(vnode)) {\n    let cursor = domNode;\n    for (const child of flattenVNodes(vnode)) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return cursor;\n  }\n\n  if (!vnode.__tova) return domNode.nextSibling;\n\n  // Fragment — children rendered inline in SSR (no wrapper)\n  if (vnode.tag === '__fragment') {\n    const children = flattenVNodes(vnode.children);\n    let cursor = domNode;\n    for (const child of children) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return cursor;\n  }\n\n  // Dynamic node — SSR marker-aware hydration\n  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {\n    // Check if current domNode is an SSR marker (<!--tova-s:ID-->)\n    if (isSSRMarker(domNode)) {\n      const { content, endMarker } = collectSSRMarkerContent(domNode);\n      const parent = domNode.parentNode;\n\n      // Remove SSR markers and content, replace with reactive marker\n      const afterEnd = endMarker ? endMarker.nextSibling : null;\n      for (const node of content) {\n        if (node.parentNode === parent) parent.removeChild(node);\n      }\n      if (endMarker && endMarker.parentNode === parent) parent.removeChild(endMarker);\n\n      const rendered = render(vnode);\n      parent.replaceChild(rendered, domNode);\n      return afterEnd;\n    }\n\n    // No SSR marker — fall back to standard behavior\n    const parent = domNode.parentNode;\n    const next = domNode.nextSibling;\n    const rendered = render(vnode);\n    parent.replaceChild(rendered, domNode);\n    return next;\n  }\n\n  // Element — attach event handlers, reactive props, refs\n  if (domNode.nodeType === 1 && domNode.tagName.toLowerCase() === vnode.tag.toLowerCase()) {\n    if (__DEV__) checkHydrationMismatch(domNode, vnode);\n    hydrateProps(domNode, vnode.props);\n    domNode.__vnode = vnode;\n\n    const children = flattenVNodes(vnode.children || []);\n    let cursor = domNode.firstChild;\n    for (const child of children) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return domNode.nextSibling;\n  }\n\n  // Tag mismatch — fall back to full render\n  if (__DEV__) {\n    const expectedTag = vnode.tag || '(unknown)';\n    const actualTag = domNode.tagName ? domNode.tagName.toLowerCase() : `nodeType:${domNode.nodeType}`;\n    console.warn(`Tova hydration mismatch: expected <${expectedTag}> but got <${actualTag}>, falling back to full render`);\n  }\n  const parent = domNode.parentNode;\n  const next = domNode.nextSibling;\n  const rendered = render(vnode);\n  parent.replaceChild(rendered, domNode);\n  return next;\n}\n\nfunction hydrateProps(el, props) {\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      if (typeof value === 'object' && value !== null && value.handler) {\n        el.addEventListener(eventName, value.handler, value.options);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value.handler;\n        el.__handlerOptions = el.__handlerOptions || {};\n        el.__handlerOptions[eventName] = value.options;\n      } else {\n        el.addEventListener(eventName, value);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value;\n      }\n    } else if (key === 'key') {\n      // Skip\n    } else if (typeof value === 'function' && !key.startsWith('on')) {\n      createEffect(() => {\n        const val = value();\n        applyPropValue(el, key, val);\n      });\n    }\n  }\n}\nfunction hydrate(component, container) {\n  if (!container) {\n    console.error('Tova: Hydration target not found');\n    return;\n  }\n\n  const startTime = typeof performance !== 'undefined' ? performance.now() : 0;\n\n  const result = createRoot(() => {\n    const vnode = typeof component === 'function' ? component() : component;\n    if (container.firstChild) {\n      hydrateVNode(container.firstChild, vnode);\n    }\n  });\n\n  // Dispatch hydration completion event\n  const duration = typeof performance !== 'undefined' ? performance.now() - startTime : 0;\n  if (typeof CustomEvent !== 'undefined' && typeof container.dispatchEvent === 'function') {\n    container.dispatchEvent(new CustomEvent('tova:hydrated', { detail: { duration }, bubbles: true }));\n  }\n\n  if (__devtools_hooks && __devtools_hooks.onHydrate) {\n    __devtools_hooks.onHydrate({ duration });\n  }\n\n  return result;\n}\nfunction mount(component, container) {\n  if (!container) {\n    console.error('Tova: Mount target not found');\n    return;\n  }\n\n  const result = createRoot((dispose) => {\n    const vnode = typeof component === 'function' ? component() : component;\n    if (typeof container.replaceChildren === 'function') {\n      container.replaceChildren();\n    } else {\n      while (container.firstChild) container.removeChild(container.firstChild);\n    }\n    container.appendChild(render(vnode));\n    return dispose;\n  });\n\n  if (__devtools_hooks && __devtools_hooks.onMount) {\n    __devtools_hooks.onMount();\n  }\n\n  return result;\n}\n\n// ─── Progressive Hydration ──────────────────────────────────\n// Hydrate a component only when it becomes visible in the viewport.\nfunction hydrateWhenVisible(component, domNode, options = {}) {\n  if (typeof IntersectionObserver === 'undefined') {\n    // Fallback: hydrate immediately\n    return hydrate(component, domNode);\n  }\n\n  const { rootMargin = '200px' } = options;\n  let hydrated = false;\n\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting && !hydrated) {\n          hydrated = true;\n          observer.disconnect();\n          hydrate(component, domNode);\n        }\n      }\n    },\n    { rootMargin },\n  );\n\n  observer.observe(domNode);\n\n  return () => {\n    observer.disconnect();\n  };\n}\n\n// ─── Form Handling ──────────────────────────────────────────\n// Reactive form primitives with field-level validation.\n// Usage:\n//   const form = createForm({\n//     fields: { email: { initial: '', validate: (v) => v.includes('@') ? null : 'Invalid email' } },\n//     onSubmit: async (values) => { await server.register(values); }\n//   });\n//   <input bind:value={form.field('email').value} />\n//   {form.field('email').error()}\n//   <button on:click={form.submit} disabled={form.submitting()}>Submit</button>\nfunction createForm({ fields = {}, onSubmit, validateOnChange = true, validateOnBlur = true }) {\n  const fieldSignals = {};\n  const errorSignals = {};\n  const touchedSignals = {};\n  const [submitting, setSubmitting] = createSignal(false);\n  const [submitError, setSubmitError] = createSignal(null);\n  const [submitCount, setSubmitCount] = createSignal(0);\n\n  // Initialize field signals\n  for (const [name, config] of Object.entries(fields)) {\n    const initial = config.initial !== undefined ? config.initial : '';\n    const [value, setValue] = createSignal(initial);\n    const [error, setError] = createSignal(null);\n    const [touched, setTouched] = createSignal(false);\n    fieldSignals[name] = { value, setValue, validate: config.validate || null, initial };\n    errorSignals[name] = { error, setError };\n    touchedSignals[name] = { touched, setTouched };\n  }\n\n  function validateField(name) {\n    const f = fieldSignals[name];\n    const e = errorSignals[name];\n    if (!f || !e || !f.validate) return null;\n    const err = f.validate(f.value());\n    e.setError(err);\n    return err;\n  }\n\n  function validateAll() {\n    let hasErrors = false;\n    for (const name of Object.keys(fieldSignals)) {\n      const err = validateField(name);\n      if (err) hasErrors = true;\n    }\n    return !hasErrors;\n  }\n\n  function field(name) {\n    const f = fieldSignals[name];\n    const e = errorSignals[name];\n    const t = touchedSignals[name];\n    if (!f) throw new Error(`Tova form: unknown field \"${name}\"`);\n    return {\n      value: f.value,\n      error: e.error,\n      touched: t.touched,\n      set(val) {\n        f.setValue(val);\n        if (validateOnChange && t.touched()) validateField(name);\n      },\n      blur() {\n        t.setTouched(true);\n        if (validateOnBlur) validateField(name);\n      },\n      validate() { return validateField(name); },\n    };\n  }\n\n  function values() {\n    const result = {};\n    for (const [name, f] of Object.entries(fieldSignals)) {\n      result[name] = f.value();\n    }\n    return result;\n  }\n\n  function reset() {\n    for (const [name, f] of Object.entries(fieldSignals)) {\n      f.setValue(f.initial);\n      errorSignals[name].setError(null);\n      touchedSignals[name].setTouched(false);\n    }\n    setSubmitError(null);\n  }\n\n  async function submit(e) {\n    if (e && typeof e.preventDefault === 'function') e.preventDefault();\n    // Touch all fields\n    for (const name of Object.keys(touchedSignals)) {\n      touchedSignals[name].setTouched(true);\n    }\n    if (!validateAll()) return;\n    if (!onSubmit) return;\n    setSubmitting(true);\n    setSubmitError(null);\n    setSubmitCount(c => c + 1);\n    try {\n      await onSubmit(values());\n    } catch (err) {\n      setSubmitError(err);\n    } finally {\n      setSubmitting(false);\n    }\n  }\n\n  const isValid = createComputed(() => {\n    for (const name of Object.keys(errorSignals)) {\n      if (errorSignals[name].error()) return false;\n    }\n    return true;\n  });\n\n  const isDirty = createComputed(() => {\n    for (const [name, f] of Object.entries(fieldSignals)) {\n      if (f.value() !== f.initial) return true;\n    }\n    return false;\n  });\n\n  return {\n    field,\n    values,\n    reset,\n    submit,\n    submitting,\n    submitError,\n    submitCount,\n    isValid,\n    isDirty,\n    validate: validateAll,\n  };\n}";
var STRING_PROTO_CODE = "{\n// Tova string method extensions — bridges Tova method syntax to JavaScript\n// Allows: \"hello\".upper() instead of requiring upper(\"hello\")\n\nconst methods = {\n  upper()       { return this.toUpperCase(); },\n  lower()       { return this.toLowerCase(); },\n  contains(s)   { return this.includes(s); },\n  starts_with(s){ return this.startsWith(s); },\n  ends_with(s)  { return this.endsWith(s); },\n  chars()       { return [...this]; },\n  words()       { return this.split(/\\s+/).filter(Boolean); },\n  lines()       { return this.split('\\n'); },\n  capitalize()  { return this.length ? this.charAt(0).toUpperCase() + this.slice(1) : this; },\n  title_case()  { return this.replace(/\\b\\w/g, c => c.toUpperCase()); },\n  snake_case()  { return this.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },\n  camel_case()  { return this.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },\n};\n\nfor (const [name, fn] of Object.entries(methods)) {\n  if (!String.prototype[name]) {\n    Object.defineProperty(String.prototype, name, {\n      value: fn,\n      writable: true,\n      configurable: true,\n    });\n  }\n}\n}";
var ARRAY_PROTO_CODE = "{\n// Tova array method extensions — bridges Tova method syntax to JavaScript\n// Allows: [1,2,3].sorted() instead of requiring sorted([1,2,3])\n\nconst methods = {\n  sorted(key)     { const c = [...this]; if (key) c.sort((x, y) => { const kx = key(x), ky = key(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; },\n  reversed()      { return [...this].reverse(); },\n  unique()        { return [...new Set(this)]; },\n  chunk(n)        { const r = []; for (let i = 0; i < this.length; i += n) r.push(this.slice(i, i + n)); return r; },\n  flatten()       { return this.flat(); },\n  first()         { return this[0] ?? null; },\n  last()          { return this[this.length - 1] ?? null; },\n  take(n)         { return this.slice(0, n); },\n  drop(n)         { return this.slice(n); },\n  compact()       { return this.filter(v => v != null); },\n  sum()           { return this.reduce((a, b) => a + b, 0); },\n  min_val()       { if (this.length === 0) return null; let m = this[0]; for (let i = 1; i < this.length; i++) if (this[i] < m) m = this[i]; return m; },\n  max_val()       { if (this.length === 0) return null; let m = this[0]; for (let i = 1; i < this.length; i++) if (this[i] > m) m = this[i]; return m; },\n  group_by(fn)    { const r = {}; for (const v of this) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; },\n  partition(fn)   { const y = [], n = []; for (const v of this) { (fn(v) ? y : n).push(v); } return [y, n]; },\n  zip_with(other) { const m = Math.min(this.length, other.length); const r = []; for (let i = 0; i < m; i++) r.push([this[i], other[i]]); return r; },\n  frequencies()   { const r = {}; for (const v of this) { const k = String(v); r[k] = (r[k] || 0) + 1; } return r; },\n};\n\nfor (const [name, fn] of Object.entries(methods)) {\n  if (!Array.prototype[name]) {\n    Object.defineProperty(Array.prototype, name, {\n      value: fn,\n      writable: true,\n      configurable: true,\n    });\n  }\n}\n}";
var STDLIB_CODE = "function print(...args) { console.log(...args); }\nfunction len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v) || ArrayBuffer.isView(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }\nfunction range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; if (st === 0) return []; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }\nfunction enumerate(a) { return a.map((v, i) => [i, v]); }\nfunction sum(a) { return a.reduce((x, y) => x + y, 0); }\nfunction sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else if (c.length > 0 && typeof c[0] === 'number') { if (typeof __tova_native !== 'undefined' && __tova_native && c.length > 128) { const f = new Float64Array(c); __tova_native.tova_sort_f64(f, f.length); for (let i = 0; i < c.length; i++) c[i] = f[i]; } else if (c.length > 128) { const f = new Float64Array(c); f.sort(); for (let i = 0; i < c.length; i++) c[i] = f[i]; } else { c.sort((a, b) => a - b); } } else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }\nfunction reversed(a) { return [...a].reverse(); }\nfunction zip(...as) { if (as.length === 0) return []; const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }\nfunction min(a) { if (a.length === 0) return null; let m = a[0]; for (let i = 1; i < a.length; i++) if (a[i] < m) m = a[i]; return m; }\nfunction max(a) { if (a.length === 0) return null; let m = a[0]; for (let i = 1; i < a.length; i++) if (a[i] > m) m = a[i]; return m; }\nfunction type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }\nfunction filter(arr, fn) { return arr.filter(fn); }\nfunction map(arr, fn) { return arr.map(fn); }\nfunction flat_map(arr, fn) { return arr.flatMap(fn); }\nfunction any(arr, fn) { return arr.some(fn); }\nfunction all(arr, fn) { return arr.every(fn); }\nfunction find(arr, fn) { return arr.find(fn) ?? null; }\nfunction reduce(arr, fn, init) { return init === undefined ? arr.reduce(fn) : arr.reduce(fn, init); }\nfunction unique(arr) { return [...new Set(arr)]; }\nfunction group_by(arr, fn) { const r = {}; for (const v of arr) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; }\nfunction chunk(arr, n) { const r = []; for (let i = 0; i < arr.length; i += n) r.push(arr.slice(i, i + n)); return r; }\nfunction flatten(arr) { return arr.flat(); }\nfunction take(arr, n) { return arr.slice(0, n); }\nfunction drop(arr, n) { return arr.slice(n); }\nfunction first(arr) { return arr.length > 0 ? arr[0] : null; }\nfunction last(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }\nfunction count(arr, fn) { return arr.filter(fn).length; }\nfunction partition(arr, fn) { const y = [], n = []; for (const v of arr) { (fn(v) ? y : n).push(v); } return [y, n]; }\nfunction filled(n, val) { return new Array(n).fill(val); }\nfunction abs(n) { return Math.abs(n); }\nfunction floor(n) { return Math.floor(n); }\nfunction ceil(n) { return Math.ceil(n); }\nfunction round(n) { return Math.round(n); }\nfunction clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); }\nfunction sqrt(n) { return Math.sqrt(n); }\nfunction pow(b, e) { return Math.pow(b, e); }\nfunction random() { return Math.random(); }\nfunction trim(s) { return s.trim(); }\nfunction split(s, sep) { return s.split(sep); }\nfunction join(arr, sep) { return arr.join(sep); }\nfunction replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); }\nfunction repeat(s, n) { return s.repeat(n); }\nfunction keys(obj) { return Object.keys(obj); }\nfunction values(obj) { return Object.values(obj); }\nfunction entries(obj) { return Object.entries(obj); }\nfunction merge(...objs) { return Object.assign({}, ...objs); }\nfunction upper(s) { return s.toUpperCase(); }\nfunction lower(s) { return s.toLowerCase(); }\nfunction contains(s, sub) { return s.includes(sub); }\nfunction starts_with(s, prefix) { return s.startsWith(prefix); }\nfunction ends_with(s, suffix) { return s.endsWith(suffix); }\nfunction chars(s) { return [...s]; }\nfunction words(s) { return s.split(/\\\\s+/).filter(Boolean); }\nfunction lines(s) { return s.split('\\\\n'); }\nfunction capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; }\nfunction title_case(s) { return s.replace(/\\\\b\\\\w/g, c => c.toUpperCase()); }";

// ─── Tova Compiler Bundle ────────────────────────────
(function() {

// ─── src/lexer/tokens.js ───────────────────────────────

// Token type definitions for the Tova language
const TokenType = {
  // Literals
  NUMBER: 'NUMBER',
  STRING: 'STRING',
  STRING_TEMPLATE: 'STRING_TEMPLATE',
  BOOLEAN: 'BOOLEAN',
  NIL: 'NIL',
  IDENTIFIER: 'IDENTIFIER',

  // Keywords
  VAR: 'VAR',
  LET: 'LET',
  FN: 'FN',
  RETURN: 'RETURN',
  IF: 'IF',
  ELIF: 'ELIF',
  ELSE: 'ELSE',
  FOR: 'FOR',
  WHILE: 'WHILE',
  MATCH: 'MATCH',
  TYPE: 'TYPE',
  IMPORT: 'IMPORT',
  FROM: 'FROM',
  EXPORT: 'EXPORT',
  AS: 'AS',

  // Boolean / logic keywords
  AND: 'AND',
  OR: 'OR',
  NOT: 'NOT',
  IN: 'IN',
  TRUE: 'TRUE',
  FALSE: 'FALSE',

  // Control flow
  BREAK: 'BREAK',
  CONTINUE: 'CONTINUE',

  // Error handling
  TRY: 'TRY',
  CATCH: 'CATCH',
  FINALLY: 'FINALLY',

  // Async
  ASYNC: 'ASYNC',
  AWAIT: 'AWAIT',

  // Guard
  GUARD: 'GUARD',

  // Interface
  INTERFACE: 'INTERFACE',
  DERIVE: 'DERIVE',

  // Visibility
  PUB: 'PUB',

  // Impl blocks / traits
  IMPL: 'IMPL',
  TRAIT: 'TRAIT',

  // Defer
  DEFER: 'DEFER',

  // Mutable (alias for var)
  MUT: 'MUT',

  // Loop
  LOOP: 'LOOP',
  WHEN: 'WHEN',

  // Generators
  YIELD: 'YIELD',

  // Extern
  EXTERN: 'EXTERN',

  // Type checking
  IS: 'IS',

  // Resource management
  WITH: 'WITH',

  // Full-stack keywords
  SERVER: 'SERVER',
  BROWSER: 'BROWSER',
  CLIENT: 'BROWSER',  // deprecated alias — both map to BROWSER
  SHARED: 'SHARED',
  ROUTE: 'ROUTE',
  STATE: 'STATE',
  COMPUTED: 'COMPUTED',
  EFFECT: 'EFFECT',
  COMPONENT: 'COMPONENT',
  STORE: 'STORE',
  FORM: 'FORM',
  FIELD: 'FIELD',
  GROUP: 'GROUP',
  STEPS: 'STEPS',
  STYLE_BLOCK: 'STYLE_BLOCK',

  // HTTP methods (used in route declarations)
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',

  // Operators
  PLUS: 'PLUS',               // +
  MINUS: 'MINUS',             // -
  STAR: 'STAR',               // *
  SLASH: 'SLASH',             // /
  PERCENT: 'PERCENT',         // %
  POWER: 'POWER',             // **
  ASSIGN: 'ASSIGN',           // =
  EQUAL: 'EQUAL',             // ==
  NOT_EQUAL: 'NOT_EQUAL',     // !=
  LESS: 'LESS',               // <
  LESS_EQUAL: 'LESS_EQUAL',   // <=
  GREATER: 'GREATER',         // >
  GREATER_EQUAL: 'GREATER_EQUAL', // >=
  AND_AND: 'AND_AND',         // &&
  OR_OR: 'OR_OR',             // ||
  BANG: 'BANG',                // !
  PIPE: 'PIPE',               // |>
  BAR: 'BAR',                 // |
  ARROW: 'ARROW',             // =>
  THIN_ARROW: 'THIN_ARROW',   // ->
  DOT: 'DOT',                 // .
  DOT_DOT: 'DOT_DOT',        // ..
  DOT_DOT_EQUAL: 'DOT_DOT_EQUAL', // ..=
  SPREAD: 'SPREAD',           // ...
  COLON: 'COLON',             // :
  DOUBLE_COLON: 'DOUBLE_COLON', // ::
  QUESTION: 'QUESTION',       // ?
  QUESTION_DOT: 'QUESTION_DOT', // ?.
  QUESTION_QUESTION: 'QUESTION_QUESTION', // ??
  PLUS_ASSIGN: 'PLUS_ASSIGN', // +=
  MINUS_ASSIGN: 'MINUS_ASSIGN', // -=
  STAR_ASSIGN: 'STAR_ASSIGN', // *=
  SLASH_ASSIGN: 'SLASH_ASSIGN', // /=

  // Delimiters
  LPAREN: 'LPAREN',           // (
  RPAREN: 'RPAREN',           // )
  LBRACE: 'LBRACE',           // {
  RBRACE: 'RBRACE',           // }
  LBRACKET: 'LBRACKET',       // [
  RBRACKET: 'RBRACKET',       // ]
  COMMA: 'COMMA',             // ,
  SEMICOLON: 'SEMICOLON',     // ;
  NEWLINE: 'NEWLINE',         // \n (significant in some contexts)

  // JSX
  JSX_OPEN: 'JSX_OPEN',       // <tag
  JSX_CLOSE: 'JSX_CLOSE',     // </tag>
  JSX_SELF_CLOSE: 'JSX_SELF_CLOSE', // />
  JSX_TEXT: 'JSX_TEXT',

  // Regex
  REGEX: 'REGEX',             // /pattern/flags

  // Decorators
  AT: 'AT',                    // @

  // Special
  EOF: 'EOF',
  DOCSTRING: 'DOCSTRING',     // /// comment
};

// Keywords map for quick lookup during lexing
const Keywords = {
  'var': TokenType.VAR,
  'let': TokenType.LET,
  'fn': TokenType.FN,
  'return': TokenType.RETURN,
  'if': TokenType.IF,
  'elif': TokenType.ELIF,
  'else': TokenType.ELSE,
  'for': TokenType.FOR,
  'while': TokenType.WHILE,
  'match': TokenType.MATCH,
  'type': TokenType.TYPE,
  'import': TokenType.IMPORT,
  'from': TokenType.FROM,
  'export': TokenType.EXPORT,
  'as': TokenType.AS,
  'and': TokenType.AND,
  'or': TokenType.OR,
  'not': TokenType.NOT,
  'in': TokenType.IN,
  'true': TokenType.TRUE,
  'false': TokenType.FALSE,
  'nil': TokenType.NIL,
  'break': TokenType.BREAK,
  'continue': TokenType.CONTINUE,
  'try': TokenType.TRY,
  'catch': TokenType.CATCH,
  'finally': TokenType.FINALLY,
  'async': TokenType.ASYNC,
  'await': TokenType.AWAIT,
  'guard': TokenType.GUARD,
  'interface': TokenType.INTERFACE,
  'derive': TokenType.DERIVE,
  'pub': TokenType.PUB,
  'impl': TokenType.IMPL,
  'trait': TokenType.TRAIT,
  'defer': TokenType.DEFER,
  'mut': TokenType.MUT,
  'yield': TokenType.YIELD,
  'loop': TokenType.LOOP,
  'when': TokenType.WHEN,
  'extern': TokenType.EXTERN,
  'is': TokenType.IS,
  'with': TokenType.WITH,
  'server': TokenType.SERVER,
  'browser': TokenType.BROWSER,
  'client': TokenType.BROWSER,  // deprecated alias
  'shared': TokenType.SHARED,
  'route': TokenType.ROUTE,
  'state': TokenType.STATE,
  'computed': TokenType.COMPUTED,
  'effect': TokenType.EFFECT,
  'component': TokenType.COMPONENT,
  'store': TokenType.STORE,
  'form': TokenType.FORM,
  'field': TokenType.FIELD,
  'group': TokenType.GROUP,
  'steps': TokenType.STEPS,
};

// Token class
class Token {
  constructor(type, value, line, column) {
    this.type = type;
    this.value = value;
    this.line = line;
    this.column = column;
  }

  toString() {
    return `Token(${this.type}, ${JSON.stringify(this.value)}, ${this.line}:${this.column})`;
  }
}

// ─── src/lexer/lexer.js ────────────────────────────────

class Lexer {
  static MAX_INTERPOLATION_DEPTH = 64;

  // Pre-compiled regex constants (avoid re-compilation in hot loops)
  static UNICODE_LETTER_RE = /\p{Letter}/u;
  static UNICODE_ALPHANUM_RE = /[\p{Letter}\p{Number}\p{Mark}]/u;
  static HEX_DIGIT_RE = /[0-9a-fA-F_]/;
  static BINARY_DIGIT_RE = /[01_]/;
  static OCTAL_DIGIT_RE = /[0-7_]/;
  static REGEX_FLAG_RE = /[gimsuydv]/;
  static REGEX_START_RE = /[\s\/*=]/;
  static JSX_CF_KEYWORDS = new Set(['if', 'for', 'elif', 'else', 'match']);

  constructor(source, filename = '<stdin>', lineOffset = 0, columnOffset = 0, _depth = 0) {
    this.source = source;
    this.filename = filename;
    this.tokens = [];
    this.pos = 0;
    this.line = 1 + lineOffset;
    this.column = 1 + columnOffset;
    this.length = source.length;
    this._depth = _depth;

    // JSX context tracking (consolidated state machine)
    this._jsxStack = [];          // stack of 'tag' or 'cfblock' entries
    this._jsxTagMode = null;      // null | 'open' | 'close' — current tag parsing state
    this._jsxSelfClosing = false; // true when / seen in opening tag (before >)
    this._jsxExprDepth = 0;       // brace depth for {expr} inside JSX
    this._jsxCF = null;           // null | { paren: 0, brace: 0, keyword? } — control flow state
    this._matchBlockDepth = 0;    // brace depth for match body inside JSX
    this._subLexer = null;        // reusable sub-lexer for string interpolation
  }

  reset(source, lineOffset, columnOffset) {
    this.source = source;
    this.tokens = [];
    this.pos = 0;
    this.line = 1 + lineOffset;
    this.column = 1 + columnOffset;
    this.length = source.length;
    this._jsxStack = [];
    this._jsxTagMode = null;
    this._jsxSelfClosing = false;
    this._jsxExprDepth = 0;
    this._jsxCF = null;
    this._matchBlockDepth = 0;
  }

  error(message) {
    throw new Error(`${this.filename}:${this.line}:${this.column} — ${message}`);
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.length ? this.source[idx] : '\0';
  }

  advance() {
    const ch = this.source[this.pos];
    this.pos++;
    if (ch === '\n') {
      this.line++;
      this.column = 1;
    } else {
      this.column++;
    }
    return ch;
  }

  match(expected) {
    if (this.pos < this.length && this.source[this.pos] === expected) {
      this.advance();
      return true;
    }
    return false;
  }

  addToken(type, value) {
    this.tokens.push(new Token(type, value, this.line, this.column));
  }

  isDigit(ch) {
    return ch >= '0' && ch <= '9';
  }

  isAlpha(ch) {
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_') return true;
    // Unicode letter support
    if (ch > '\x7f') return Lexer.UNICODE_LETTER_RE.test(ch);
    return false;
  }

  isAlphaNumeric(ch) {
    if (this.isAlpha(ch) || this.isDigit(ch)) return true;
    // Unicode continue characters (combining marks, etc.)
    if (ch > '\x7f') return Lexer.UNICODE_ALPHANUM_RE.test(ch);
    return false;
  }

  isWhitespace(ch) {
    return ch === ' ' || ch === '\t' || ch === '\r';
  }

  _processEscape(esc) {
    switch (esc) {
      case 'n': return '\n';
      case 't': return '\t';
      case 'r': return '\r';
      case '\\': return '\\';
      case '"': return '"';
      case "'": return "'";
      case '{': return '{';
      case '}': return '}';
      default: return '\\' + esc;
    }
  }

  _isJSXStart() {
    const nextCh = this.peek();
    if (!this.isAlpha(nextCh)) return false;
    // Check the token BEFORE < (LESS was already pushed, so it's at length-2)
    const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
    if (!prev) return true;
    return !Lexer.VALUE_TOKEN_TYPES.has(prev.type);
  }

  tokenize() {
    // Strip shebang line if present (e.g. #!/usr/bin/env tova)
    if (this.pos === 0 && this.source[0] === '#' && this.source[1] === '!') {
      while (this.pos < this.length && this.source[this.pos] !== '\n') this.advance();
      if (this.pos < this.length) this.advance();
    }

    while (this.pos < this.length) {
      this.scanToken();
    }
    this.tokens.push(new Token(TokenType.EOF, null, this.line, this.column));
    return this.tokens;
  }

  scanToken() {
    // In JSX children mode, scan raw text instead of normal tokens
    // (but not inside matchblock — match bodies need normal scanning for patterns/arrows)
    if (this._jsxStack.length > 0 && this._jsxExprDepth === 0 &&
        !this._jsxTagMode && !this._jsxCF && this._matchBlockDepth === 0) {
      return this._scanInJSXChildren();
    }

    const ch = this.peek();

    // Skip whitespace (not newlines) — batch skip for consecutive whitespace
    if (this.isWhitespace(ch)) {
      this.advance();
      while (this.pos < this.length && this.isWhitespace(this.source[this.pos])) {
        this.advance();
      }
      return;
    }

    // Newlines
    if (ch === '\n') {
      this.tokens.push(new Token(TokenType.NEWLINE, '\n', this.line, this.column));
      this.advance();
      return;
    }

    // Comments
    if (ch === '/' && this.peek(1) === '/') {
      this.scanComment();
      return;
    }
    if (ch === '/' && this.peek(1) === '*') {
      this.scanBlockComment();
      return;
    }

    // Regex literals: /pattern/flags
    // Must not be /=, //, /*, and must be in a context where regex makes sense
    if (ch === '/' && this.peek(1) !== '/' && this.peek(1) !== '*' && this.peek(1) !== '='
        && this._jsxStack.length === 0) {
      let prev = null;
      for (let i = this.tokens.length - 1; i >= 0; i--) {
        if (this.tokens[i].type !== TokenType.NEWLINE) {
          prev = this.tokens[i];
          break;
        }
      }
      // Negative list: if previous token ends an expression (produces a value),
      // then / is division. Otherwise, / starts a regex.
      // This is simpler and more robust — new token types default to regex context.
      if (prev && !Lexer.VALUE_TOKEN_TYPES.has(prev.type)) {
        this.scanRegex();
        return;
      }
      // At start of file (no prev token), treat / as regex if followed by a non-space, non-special char
      if (!prev && this.pos + 1 < this.length && !Lexer.REGEX_START_RE.test(this.peek(1))) {
        this.scanRegex();
        return;
      }
    }

    // Numbers
    if (this.isDigit(ch)) {
      this.scanNumber();
      return;
    }

    // Strings
    if (ch === '"') {
      // Triple-quote multiline strings: """..."""
      if (this.peek(1) === '"' && this.peek(2) === '"') {
        this.scanTripleQuoteString();
        return;
      }
      this.scanString();
      return;
    }
    if (ch === "'") {
      this.scanSimpleString();
      return;
    }

    // Identifiers and keywords
    if (this.isAlpha(ch)) {
      this.scanIdentifier();
      return;
    }

    // Operators and delimiters
    this.scanOperator();
  }

  _scanInJSXChildren() {
    const ch = this.peek();

    // Close control flow block: } when top of stack is 'cfblock'
    if (ch === '}' && this._jsxStack.length > 0 && this._jsxStack[this._jsxStack.length - 1] === 'cfblock') {
      this._jsxStack.pop();
      this.scanOperator(); // emits RBRACE
      return;
    }

    // Skip whitespace/newlines silently when followed by structural chars
    if (this.isWhitespace(ch) || ch === '\n') {
      let pp = this.pos;
      while (pp < this.length && (this.source[pp] === ' ' || this.source[pp] === '\t' || this.source[pp] === '\r' || this.source[pp] === '\n')) {
        pp++;
      }
      const nextNonWs = pp < this.length ? this.source[pp] : '\0';
      // Skip whitespace if next meaningful char is structural
      if (nextNonWs === '<' || nextNonWs === '{' || nextNonWs === '}' || nextNonWs === '"' || nextNonWs === "'" || pp >= this.length) {
        while (this.pos < pp) this.advance();
        return;
      }
      // Check if next non-ws starts a keyword (if/for/elif/else)
      if (this.isAlpha(nextNonWs)) {
        let wp = pp;
        while (wp < this.length && this.isAlphaNumeric(this.source[wp])) wp++;
        const word = this.source.substring(pp, wp);
        if (Lexer.JSX_CF_KEYWORDS.has(word)) {
          while (this.pos < pp) this.advance();
          return;
        }
      }
      // Otherwise, fall through to collect as JSX text
    }

    if (ch === '{') {
      this.scanOperator();
      this._jsxExprDepth = 1;
      return;
    }
    if (ch === '<') {
      // In JSX children, set tag mode directly (heuristic may fail after STRING tokens)
      const nextCh = this.peek(1);
      if (nextCh === '/') {
        this._jsxTagMode = 'close';
      } else if (nextCh === '>' || this.isAlpha(nextCh)) {
        // <tag or <> (fragment)
        this._jsxTagMode = 'open';
      }
      this.scanOperator();
      return;
    }
    if (ch === '"') { this.scanString(); return; }
    if (ch === "'") { this.scanSimpleString(); return; }

    // Check for JSX control flow keywords: if, for, elif, else, match
    if (this.isAlpha(ch)) {
      let peekPos = this.pos;
      while (peekPos < this.length && this.isAlphaNumeric(this.source[peekPos])) peekPos++;
      const word = this.source.substring(this.pos, peekPos);
      if (Lexer.JSX_CF_KEYWORDS.has(word)) {
        this.scanIdentifier();
        // After keyword, enter control flow mode for normal scanning
        this._jsxCF = { paren: 0, brace: 0, keyword: word };
        return;
      }
    }

    // Everything else: scan as raw JSX text
    this._scanJSXText();
  }

  _scanJSXText() {
    const startLine = this.line, startCol = this.column;
    let text = '';
    while (this.pos < this.length) {
      const ch = this.peek();
      if (ch === '<' || ch === '{' || ch === '"' || ch === "'") break;
      // Stop at keywords if, for, elif, else preceded by whitespace
      if (this.isAlpha(ch) && text.length > 0) {
        const lastCh = text[text.length - 1];
        if (lastCh === ' ' || lastCh === '\t' || lastCh === '\n' || lastCh === '\r') {
          let pp = this.pos;
          while (pp < this.length && this.isAlphaNumeric(this.source[pp])) pp++;
          const word = this.source.substring(this.pos, pp);
          if (Lexer.JSX_CF_KEYWORDS.has(word)) break;
        }
      }
      text += this.advance();
    }
    if (text.length > 0) {
      this.tokens.push(new Token(TokenType.JSX_TEXT, text, startLine, startCol));
    }
  }

  scanComment() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // /
    this.advance(); // /

    // Check for docstring ///
    const isDocstring = this.peek() === '/';
    if (isDocstring) this.advance();

    let value = '';
    while (this.pos < this.length && this.peek() !== '\n') {
      value += this.advance();
    }

    if (isDocstring) {
      this.tokens.push(new Token(TokenType.DOCSTRING, value.trim(), startLine, startCol));
    }
    // Regular comments are discarded
  }

  scanBlockComment() {
    this.advance(); // /
    this.advance(); // *
    let depth = 1;

    while (this.pos < this.length && depth > 0) {
      if (this.peek() === '/' && this.peek(1) === '*') {
        depth++;
        this.advance();
        this.advance();
      } else if (this.peek() === '*' && this.peek(1) === '/') {
        depth--;
        this.advance();
        this.advance();
      } else {
        this.advance();
      }
    }

    if (depth !== 0) {
      this.error('Unterminated block comment');
    }
  }

  scanNumber() {
    const startLine = this.line;
    const startCol = this.column;
    let value = '';

    // Handle hex, octal, binary
    if (this.peek() === '0') {
      const next = this.peek(1);
      if (next === 'x' || next === 'X') {
        this.advance(); // 0
        this.advance(); // x
        while (this.pos < this.length && Lexer.HEX_DIGIT_RE.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected hex digits after 0x');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 16), startLine, startCol));
        return;
      }
      if (next === 'b' || next === 'B') {
        this.advance(); // 0
        this.advance(); // b
        while (this.pos < this.length && Lexer.BINARY_DIGIT_RE.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected binary digits after 0b');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 2), startLine, startCol));
        return;
      }
      if (next === 'o' || next === 'O') {
        this.advance(); // 0
        this.advance(); // o
        while (this.pos < this.length && Lexer.OCTAL_DIGIT_RE.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected octal digits after 0o');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 8), startLine, startCol));
        return;
      }
    }

    // Fast path: scan decimal number using index advancement (no string concat)
    // Handles digits, underscores, decimal point, and exponent
    const numStart = this.pos;
    let hasUnderscore = false;
    while (this.pos < this.length) {
      const ch = this.source[this.pos];
      if (ch >= '0' && ch <= '9') { this.pos++; this.column++; }
      else if (ch === '_') { hasUnderscore = true; this.pos++; this.column++; }
      else break;
    }

    // Decimal point — only consume if followed by a digit or underscore (not e.g. 15.minutes)
    if (this.pos < this.length && this.source[this.pos] === '.') {
      const next = this.pos + 1 < this.length ? this.source[this.pos + 1] : '';
      if (next !== '.' && ((next >= '0' && next <= '9') || next === '_')) {
        this.pos++; this.column++; // .
        while (this.pos < this.length) {
          const ch = this.source[this.pos];
          if (ch >= '0' && ch <= '9') { this.pos++; this.column++; }
          else if (ch === '_') { hasUnderscore = true; this.pos++; this.column++; }
          else break;
        }
      }
    }

    // Exponent
    if (this.pos < this.length) {
      const ech = this.source[this.pos];
      if (ech === 'e' || ech === 'E') {
        const savedPos = this.pos;
        const savedCol = this.column;
        this.pos++; this.column++;
        if (this.pos < this.length && (this.source[this.pos] === '+' || this.source[this.pos] === '-')) {
          this.pos++; this.column++;
        }
        if (this.pos < this.length && this.source[this.pos] >= '0' && this.source[this.pos] <= '9') {
          while (this.pos < this.length && this.source[this.pos] >= '0' && this.source[this.pos] <= '9') {
            this.pos++; this.column++;
          }
        } else {
          // No digits after exponent — backtrack
          this.pos = savedPos;
          this.column = savedCol;
        }
      }
    }

    let numStr = this.source.substring(numStart, this.pos);
    if (hasUnderscore) numStr = numStr.replace(/_/g, '');
    value = numStr;
    this.tokens.push(new Token(TokenType.NUMBER, parseFloat(value), startLine, startCol));
  }

  scanString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening "

    const parts = [];
    let current = '';

    while (this.pos < this.length && this.peek() !== '"') {
      // Escape sequences
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated string');
        }
        current += this._processEscape(this.advance());
        continue;
      }

      // String interpolation: {expr}
      if (this.peek() === '{') {
        this.advance(); // {
        if (current.length > 0) {
          parts.push({ type: 'text', value: current });
          current = '';
        }

        // Lex the interpolation expression, respecting nested strings
        const exprStartLine = this.line - 1; // 0-based offset for sub-lexer
        const exprStartCol = this.column - 1;
        let depth = 1;
        // Use array-based building to avoid O(n^2) string concatenation
        const exprParts = [];
        while (this.pos < this.length && depth > 0) {
          const ch = this.peek();
          // Skip over string literals so braces inside them don't affect depth
          if (ch === '"' || ch === "'" || ch === '`') {
            const quote = ch;
            exprParts.push(this.advance()); // opening quote
            let strDepth = 0; // track interpolation depth inside nested strings
            while (this.pos < this.length) {
              if (this.peek() === '\\') {
                exprParts.push(this.advance()); // backslash
                if (this.pos < this.length) exprParts.push(this.advance()); // escaped char
              } else if (quote === '"' && this.peek() === '{') {
                strDepth++;
                exprParts.push(this.advance());
              } else if (quote === '"' && this.peek() === '}' && strDepth > 0) {
                strDepth--;
                exprParts.push(this.advance());
              } else if (this.peek() === quote && strDepth === 0) {
                break;
              } else {
                exprParts.push(this.advance());
              }
            }
            if (this.pos < this.length) exprParts.push(this.advance()); // closing quote
            continue;
          }
          if (ch === '{') depth++;
          if (ch === '}') {
            depth--;
            if (depth === 0) break;
          }
          exprParts.push(this.advance());
        }
        const exprSource = exprParts.join('');

        if (this.peek() !== '}') {
          this.error('Unterminated string interpolation');
        }
        this.advance(); // }

        // Sub-lex the expression with correct file position offsets
        if (this._depth + 1 > Lexer.MAX_INTERPOLATION_DEPTH) {
          this.error('String interpolation nested too deeply (max ' + Lexer.MAX_INTERPOLATION_DEPTH + ' levels)');
        }
        if (!this._subLexer) {
          this._subLexer = new Lexer(exprSource, this.filename, exprStartLine, exprStartCol, this._depth + 1);
        } else {
          this._subLexer.reset(exprSource, exprStartLine, exprStartCol);
        }
        const exprTokens = this._subLexer.tokenize();
        // Remove the EOF token
        exprTokens.pop();

        parts.push({ type: 'expr', tokens: exprTokens, source: exprSource });
        continue;
      }

      current += this.advance();
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing "

    // If there are no interpolation parts, emit a simple string
    if (parts.length === 0) {
      this.tokens.push(new Token(TokenType.STRING, current, startLine, startCol));
    } else {
      if (current.length > 0) {
        parts.push({ type: 'text', value: current });
      }
      this.tokens.push(new Token(TokenType.STRING_TEMPLATE, parts, startLine, startCol));
    }
  }

  scanTripleQuoteString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // first "
    this.advance(); // second "
    this.advance(); // third "

    // Skip a leading newline immediately after opening """
    if (this.pos < this.length && this.peek() === '\n') {
      this.advance();
    } else if (this.pos < this.length && this.peek() === '\r' && this.peek(1) === '\n') {
      this.advance();
      this.advance();
    }

    const parts = [];
    let current = '';

    while (this.pos < this.length) {
      // Check for closing """
      if (this.peek() === '"' && this.peek(1) === '"' && this.peek(2) === '"') {
        break;
      }

      // Escape sequences (same as regular strings)
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated multiline string');
        }
        current += this._processEscape(this.advance());
        continue;
      }

      // String interpolation: {expr}
      if (this.peek() === '{') {
        this.advance(); // {
        if (current.length > 0) {
          parts.push({ type: 'text', value: current });
          current = '';
        }

        const exprStartLine = this.line - 1;
        const exprStartCol = this.column - 1;
        let depth = 1;
        const exprParts = [];
        while (this.pos < this.length && depth > 0) {
          const ch = this.peek();
          if (ch === '"' || ch === "'" || ch === '`') {
            const quote = ch;
            exprParts.push(this.advance());
            let strDepth = 0;
            while (this.pos < this.length) {
              if (this.peek() === '\\') {
                exprParts.push(this.advance());
                if (this.pos < this.length) exprParts.push(this.advance());
              } else if (quote === '"' && this.peek() === '{') {
                strDepth++;
                exprParts.push(this.advance());
              } else if (quote === '"' && this.peek() === '}' && strDepth > 0) {
                strDepth--;
                exprParts.push(this.advance());
              } else if (this.peek() === quote && strDepth === 0) {
                break;
              } else {
                exprParts.push(this.advance());
              }
            }
            if (this.pos < this.length) exprParts.push(this.advance());
            continue;
          }
          if (ch === '{') depth++;
          if (ch === '}') {
            depth--;
            if (depth === 0) break;
          }
          exprParts.push(this.advance());
        }
        const exprSource = exprParts.join('');

        if (this.peek() !== '}') {
          this.error('Unterminated string interpolation in multiline string');
        }
        this.advance(); // }

        if (this._depth + 1 > Lexer.MAX_INTERPOLATION_DEPTH) {
          this.error('String interpolation nested too deeply (max ' + Lexer.MAX_INTERPOLATION_DEPTH + ' levels)');
        }
        if (!this._subLexer) {
          this._subLexer = new Lexer(exprSource, this.filename, exprStartLine, exprStartCol, this._depth + 1);
        } else {
          this._subLexer.reset(exprSource, exprStartLine, exprStartCol);
        }
        const exprTokens = this._subLexer.tokenize();
        exprTokens.pop();

        parts.push({ type: 'expr', tokens: exprTokens, source: exprSource });
        continue;
      }

      current += this.advance();
    }

    if (this.pos >= this.length || this.peek() !== '"') {
      this.error('Unterminated multiline string (expected closing \"\"\")')
    }
    this.advance(); // first closing "
    this.advance(); // second closing "
    this.advance(); // third closing "

    // Auto-dedent: find the indentation of the closing """ line
    // Look back in `current` for the last newline to get the indentation
    let rawContent = current;
    if (parts.length === 0) {
      // Simple string, no interpolation — auto-dedent
      const dedented = this._dedentTripleQuote(rawContent);
      this.tokens.push(new Token(TokenType.STRING, dedented, startLine, startCol));
    } else {
      // Template string — dedent text parts
      if (current.length > 0) {
        parts.push({ type: 'text', value: current });
      }
      const dedentedParts = this._dedentTripleQuoteParts(parts);
      if (dedentedParts.length === 1 && dedentedParts[0].type === 'text') {
        this.tokens.push(new Token(TokenType.STRING, dedentedParts[0].value, startLine, startCol));
      } else {
        this.tokens.push(new Token(TokenType.STRING_TEMPLATE, dedentedParts, startLine, startCol));
      }
    }
  }

  _dedentTripleQuote(text) {
    // Remove trailing whitespace-only line (the line before closing """)
    if (text.endsWith('\n')) {
      text = text.slice(0, -1);
    } else {
      // Check for trailing whitespace-only content after last newline
      const lastNl = text.lastIndexOf('\n');
      if (lastNl !== -1) {
        const lastLine = text.slice(lastNl + 1);
        if (lastLine.trim() === '') {
          text = text.slice(0, lastNl);
        }
      }
    }

    const lines = text.split('\n');
    // Find minimum indentation of non-empty lines
    let minIndent = Infinity;
    for (const line of lines) {
      if (line.trim().length === 0) continue;
      const indent = line.match(/^[ \t]*/)[0].length;
      if (indent < minIndent) minIndent = indent;
    }
    if (minIndent === Infinity) minIndent = 0;

    // Strip the common indentation
    return lines.map(line => {
      if (line.trim().length === 0) return '';
      return line.slice(minIndent);
    }).join('\n');
  }

  _dedentTripleQuoteParts(parts) {
    // Collect all text to determine minimum indent
    let allText = '';
    for (const p of parts) {
      if (p.type === 'text') allText += p.value;
      else allText += 'X'; // placeholder for expressions
    }

    // Remove trailing whitespace-only line
    if (allText.endsWith('\n')) {
      // Trim trailing newline from last text part
      for (let i = parts.length - 1; i >= 0; i--) {
        if (parts[i].type === 'text' && parts[i].value.endsWith('\n')) {
          parts[i] = { type: 'text', value: parts[i].value.slice(0, -1) };
          break;
        }
      }
    }

    // Find minimum indentation from text parts
    let minIndent = Infinity;
    for (const p of parts) {
      if (p.type !== 'text') continue;
      const lines = p.value.split('\n');
      for (const line of lines) {
        if (line.trim().length === 0) continue;
        const indent = line.match(/^[ \t]*/)[0].length;
        if (indent < minIndent) minIndent = indent;
      }
    }
    if (minIndent === Infinity || minIndent === 0) return parts;

    // Dedent text parts
    return parts.map(p => {
      if (p.type !== 'text') return p;
      const lines = p.value.split('\n');
      const dedented = lines.map(line => {
        if (line.trim().length === 0) return '';
        return line.slice(Math.min(minIndent, line.match(/^[ \t]*/)[0].length));
      }).join('\n');
      return { type: 'text', value: dedented };
    });
  }

  scanSimpleString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening '

    let value = '';
    while (this.pos < this.length && this.peek() !== "'") {
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated string');
        }
        value += this._processEscape(this.advance());
      } else {
        value += this.advance();
      }
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing '

    this.tokens.push(new Token(TokenType.STRING, value, startLine, startCol));
  }

  scanRegex() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening /

    let pattern = '';
    let escaped = false;
    let inCharClass = false;

    while (this.pos < this.length) {
      const ch = this.peek();
      if (ch === '\n') {
        this.error('Unterminated regex literal');
      }
      if (escaped) {
        pattern += ch;
        this.advance();
        escaped = false;
        continue;
      }
      if (ch === '\\') {
        pattern += ch;
        this.advance();
        escaped = true;
        continue;
      }
      if (ch === '[') inCharClass = true;
      if (ch === ']') inCharClass = false;
      if (ch === '/' && !inCharClass) break;
      pattern += this.advance();
    }

    if (this.pos >= this.length || this.peek() !== '/') {
      this.error('Unterminated regex literal');
    }
    this.advance(); // closing /

    // Read flags
    let flags = '';
    while (this.pos < this.length && Lexer.REGEX_FLAG_RE.test(this.peek())) {
      flags += this.advance();
    }

    this.tokens.push(new Token(TokenType.REGEX, { pattern, flags }, startLine, startCol));
  }

  scanIdentifier() {
    const startLine = this.line;
    const startCol = this.column;
    const startPos = this.pos;

    // Fast path: scan ASCII identifier using index advancement (no string concat)
    while (this.pos < this.length) {
      const ch = this.source[this.pos];
      if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_' || (ch >= '0' && ch <= '9')) {
        this.pos++;
        this.column++;
      } else if (ch > '\x7f' && Lexer.UNICODE_ALPHANUM_RE.test(ch)) {
        this.pos++;
        this.column++;
      } else {
        break;
      }
    }
    const value = this.source.substring(startPos, this.pos);

    // Raw string: r"no\escapes"
    if (value === 'r' && this.pos < this.length && this.peek() === '"') {
      this.advance(); // opening "
      const rawParts = [];
      while (this.pos < this.length && this.peek() !== '"') {
        rawParts.push(this.advance());
      }
      const raw = rawParts.join('');
      if (this.pos >= this.length) {
        this.error('Unterminated raw string');
      }
      this.advance(); // closing "
      this.tokens.push(new Token(TokenType.STRING, raw, startLine, startCol));
      return;
    }

    // f-string: f"Hello, {name}!" — explicit interpolation sigil
    // Delegates to scanString() which already handles interpolation
    if (value === 'f' && this.pos < this.length && this.peek() === '"') {
      this.scanString();
      return;
    }

    // Special case: "style {" → read raw CSS block
    if (value === 'style') {
      const savedPos = this.pos;
      const savedLine = this.line;
      const savedCol = this.column;
      // Skip whitespace (including newlines) to check for {
      while (this.pos < this.length && (this.isWhitespace(this.peek()) || this.peek() === '\n')) {
        this.advance();
      }
      if (this.peek() === '{') {
        this.advance(); // skip {
        let depth = 1;
        let css = '';
        while (depth > 0 && this.pos < this.length) {
          const ch = this.peek();
          if (ch === '{') depth++;
          else if (ch === '}') {
            depth--;
            if (depth === 0) { this.advance(); break; }
          }
          css += this.advance();
        }
        if (depth > 0) {
          this.error('Unterminated style block');
        }
        this.tokens.push(new Token(TokenType.STYLE_BLOCK, css.trim(), startLine, startCol));
        return;
      }
      // Not a style block — restore position
      this.pos = savedPos;
      this.line = savedLine;
      this.column = savedCol;
    }

    // Check if it's a keyword
    const type = Keywords[value] || TokenType.IDENTIFIER;
    this.tokens.push(new Token(type, value, startLine, startCol));
  }

  scanOperator() {
    const startLine = this.line;
    const startCol = this.column;
    const ch = this.advance();

    switch (ch) {
      case '(':
        this.tokens.push(new Token(TokenType.LPAREN, '(', startLine, startCol));
        if (this._jsxCF) this._jsxCF.paren++;
        break;
      case ')':
        this.tokens.push(new Token(TokenType.RPAREN, ')', startLine, startCol));
        if (this._jsxCF && this._jsxCF.paren > 0) this._jsxCF.paren--;
        break;
      case '{':
        this.tokens.push(new Token(TokenType.LBRACE, '{', startLine, startCol));
        if (this._jsxCF) {
          if (this._jsxCF.brace > 0) {
            // Nested brace inside expression (e.g., key={obj.field})
            this._jsxCF.brace++;
          } else if (this._jsxCF.paren > 0) {
            // Inside parens, this is an expression brace
            this._jsxCF.brace++;
          } else {
            // Check if prev token is ASSIGN (key={...}) or FOR (destructuring: for {a,b} in ...)
            const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
            if (prev && (prev.type === TokenType.ASSIGN || prev.type === TokenType.FOR)) {
              this._jsxCF.brace++;
            } else if (this._jsxCF.keyword === 'match') {
              // Match body: scan normally (patterns, =>, etc.) — not JSX children mode
              this._jsxCF = null;
              this._jsxStack.push('matchblock');
              this._matchBlockDepth = 1;
            } else {
              // This is the block opener for the control flow body
              this._jsxCF = null;
              this._jsxStack.push('cfblock');
            }
          }
        } else if (this._jsxExprDepth > 0) {
          this._jsxExprDepth++;
        } else if (this._matchBlockDepth > 0) {
          this._matchBlockDepth++;
        }
        break;
      case '}':
        this.tokens.push(new Token(TokenType.RBRACE, '}', startLine, startCol));
        if (this._jsxCF && this._jsxCF.brace > 0) {
          this._jsxCF.brace--;
        } else if (this._matchBlockDepth > 0) {
          this._matchBlockDepth--;
          if (this._matchBlockDepth === 0) {
            // Match body closed — pop matchblock from JSX stack
            if (this._jsxStack.length > 0 && this._jsxStack[this._jsxStack.length - 1] === 'matchblock') {
              this._jsxStack.pop();
            }
          }
        } else if (this._jsxExprDepth > 0) {
          this._jsxExprDepth--;
        }
        break;
      case '[':
        this.tokens.push(new Token(TokenType.LBRACKET, '[', startLine, startCol));
        if (this._jsxCF) this._jsxCF.paren++;
        break;
      case ']':
        this.tokens.push(new Token(TokenType.RBRACKET, ']', startLine, startCol));
        if (this._jsxCF && this._jsxCF.paren > 0) this._jsxCF.paren--;
        break;
      case ',':
        this.tokens.push(new Token(TokenType.COMMA, ',', startLine, startCol));
        break;
      case ';':
        this.tokens.push(new Token(TokenType.SEMICOLON, ';', startLine, startCol));
        break;

      case '+':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.PLUS_ASSIGN, '+=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.PLUS, '+', startLine, startCol));
        }
        break;

      case '-':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.THIN_ARROW, '->', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.MINUS_ASSIGN, '-=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.MINUS, '-', startLine, startCol));
        }
        break;

      case '*':
        if (this.match('*')) {
          this.tokens.push(new Token(TokenType.POWER, '**', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.STAR_ASSIGN, '*=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.STAR, '*', startLine, startCol));
        }
        break;

      case '/':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.SLASH_ASSIGN, '/=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.SLASH, '/', startLine, startCol));
          if (this._jsxTagMode === 'open') this._jsxSelfClosing = true;
        }
        break;

      case '%':
        this.tokens.push(new Token(TokenType.PERCENT, '%', startLine, startCol));
        break;

      case '=':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.EQUAL, '==', startLine, startCol));
        } else if (this.match('>')) {
          this.tokens.push(new Token(TokenType.ARROW, '=>', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.ASSIGN, '=', startLine, startCol));
        }
        break;

      case '!':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.NOT_EQUAL, '!=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.BANG, '!', startLine, startCol));
        }
        break;

      case '<':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.LESS_EQUAL, '<=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.LESS, '<', startLine, startCol));
          // Don't override tag mode already set by _scanInJSXChildren
          if (!this._jsxTagMode) {
            if (this.peek() === '/') {
              this._jsxTagMode = 'close';
            } else if (this.peek() === '>') {
              // Fragment: <> — use same heuristic as _isJSXStart
              // to avoid false positives in expressions
              if (this._jsxStack.length > 0) {
                this._jsxTagMode = 'open';
              } else {
                const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
                if (!prev || !Lexer.VALUE_TOKEN_TYPES.has(prev.type)) {
                  this._jsxTagMode = 'open';
                }
              }
            } else if (this._isJSXStart()) {
              this._jsxTagMode = 'open';
            }
          }
        }
        break;

      case '>':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.GREATER_EQUAL, '>=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.GREATER, '>', startLine, startCol));
          // JSX state transitions on >
          if (this._jsxSelfClosing) {
            // Self-closing tag: <br/> — don't push to stack
            this._jsxTagMode = null;
            this._jsxSelfClosing = false;
          } else if (this._jsxTagMode === 'close') {
            // Closing tag: </div> or </> — pop 'tag' from stack
            this._jsxTagMode = null;
            if (this._jsxStack.length > 0) this._jsxStack.pop();
          } else if (this._jsxTagMode === 'open') {
            // Opening tag: <div> or <> — push 'tag' to stack (entering children mode)
            this._jsxTagMode = null;
            this._jsxStack.push('tag');
          }
        }
        break;

      case '&':
        if (this.match('&')) {
          this.tokens.push(new Token(TokenType.AND_AND, '&&', startLine, startCol));
        } else if (this._jsxStack.length > 0) {
          // Inside JSX, & is valid text - should not reach here normally
          // but handle gracefully by treating as text
          this.tokens.push(new Token(TokenType.JSX_TEXT, '&', startLine, startCol));
        } else {
          this.error(`Unexpected character: '&'. Did you mean '&&'?`);
        }
        break;

      case '|':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.PIPE, '|>', startLine, startCol));
        } else if (this.match('|')) {
          this.tokens.push(new Token(TokenType.OR_OR, '||', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.BAR, '|', startLine, startCol));
        }
        break;

      case '.':
        if (this.match('.')) {
          if (this.match('=')) {
            this.tokens.push(new Token(TokenType.DOT_DOT_EQUAL, '..=', startLine, startCol));
          } else if (this.match('.')) {
            this.tokens.push(new Token(TokenType.SPREAD, '...', startLine, startCol));
          } else {
            this.tokens.push(new Token(TokenType.DOT_DOT, '..', startLine, startCol));
          }
        } else {
          this.tokens.push(new Token(TokenType.DOT, '.', startLine, startCol));
        }
        break;

      case ':':
        if (this.match(':')) {
          this.tokens.push(new Token(TokenType.DOUBLE_COLON, '::', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.COLON, ':', startLine, startCol));
        }
        break;

      case '?':
        if (this.match('.')) {
          this.tokens.push(new Token(TokenType.QUESTION_DOT, '?.', startLine, startCol));
        } else if (this.match('?')) {
          this.tokens.push(new Token(TokenType.QUESTION_QUESTION, '??', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.QUESTION, '?', startLine, startCol));
        }
        break;

      case '@':
        this.tokens.push(new Token(TokenType.AT, '@', startLine, startCol));
        break;

      default:
        this.error(`Unexpected character: '${ch}'`);
    }
  }
}

// Initialize static Set after class definition (depends on TokenType)
Lexer.VALUE_TOKEN_TYPES = new Set([
  TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.STRING,
  TokenType.STRING_TEMPLATE, TokenType.RPAREN, TokenType.RBRACKET, TokenType.RBRACE,
  TokenType.TRUE, TokenType.FALSE, TokenType.NIL
]);

// ─── src/parser/browser-ast.js ─────────────────────────

// Browser-specific AST Node definitions for the Tova language
// Extracted from ast.js for lazy loading — only loaded when browser { } blocks are used.

// ============================================================
// Browser-specific nodes
// ============================================================
class StateDeclaration {
  constructor(name, typeAnnotation, initialValue, loc) {
    this.type = 'StateDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.initialValue = initialValue;
    this.loc = loc;
  }
}
class ComputedDeclaration {
  constructor(name, expression, loc) {
    this.type = 'ComputedDeclaration';
    this.name = name;
    this.expression = expression;
    this.loc = loc;
  }
}
class EffectDeclaration {
  constructor(body, loc) {
    this.type = 'EffectDeclaration';
    this.body = body;
    this.loc = loc;
  }
}
class ComponentDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'ComponentDeclaration';
    this.name = name;
    this.params = params;
    this.body = body; // Array of JSX elements and statements
    this.loc = loc;
  }
}
class ComponentStyleBlock {
  constructor(css, loc) {
    this.type = 'ComponentStyleBlock';
    this.css = css; // raw CSS string
    this.loc = loc;
  }
}
class StoreDeclaration {
  constructor(name, body, loc) {
    this.type = 'StoreDeclaration';
    this.name = name;   // e.g. "TodoStore"
    this.body = body;   // Array of StateDeclaration, ComputedDeclaration, FunctionDeclaration
    this.loc = loc;
  }
}

// ============================================================
// JSX-like nodes
// ============================================================
class JSXElement {
  constructor(tag, attributes, children, selfClosing, loc) {
    this.type = 'JSXElement';
    this.tag = tag;
    this.attributes = attributes; // Array of JSXAttribute
    this.children = children;     // Array of JSXElement, JSXText, JSXExpression
    this.selfClosing = selfClosing;
    this.loc = loc;
  }
}
class JSXAttribute {
  constructor(name, value, loc) {
    this.type = 'JSXAttribute';
    this.name = name;   // string (e.g., "class", "on:click")
    this.value = value;  // Expression or string
    this.loc = loc;
  }
}
class JSXSpreadAttribute {
  constructor(expression, loc) {
    this.type = 'JSXSpreadAttribute';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXFragment {
  constructor(children, loc) {
    this.type = 'JSXFragment';
    this.children = children;     // Array of JSXElement, JSXText, JSXExpression, etc.
    this.loc = loc;
  }
}
class JSXText {
  constructor(value, loc) {
    this.type = 'JSXText';
    this.value = value;
    this.loc = loc;
  }
}
class JSXExpression {
  constructor(expression, loc) {
    this.type = 'JSXExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXFor {
  constructor(variable, iterable, body, loc, keyExpr = null) {
    this.type = 'JSXFor';
    this.variable = variable;
    this.iterable = iterable;
    this.body = body;
    this.keyExpr = keyExpr; // optional key expression for keyed reconciliation
    this.loc = loc;
  }
}
class JSXIf {
  constructor(condition, consequent, alternate, loc, alternates = []) {
    this.type = 'JSXIf';
    this.condition = condition;
    this.consequent = consequent;
    this.alternates = alternates; // Array of { condition, body } for elif chains
    this.alternate = alternate;   // else body (or null)
    this.loc = loc;
  }
}
class JSXMatch {
  constructor(subject, arms, loc) {
    this.type = 'JSXMatch';
    this.subject = subject;     // expression being matched
    this.arms = arms;           // Array of { pattern, guard, body: [JSXChild] }
    this.loc = loc;
  }
}

// ─── src/parser/server-ast.js ──────────────────────────

// Server-specific AST Node definitions for the Tova language
// Extracted from ast.js for lazy loading — only loaded when server { } blocks are used.
class RouteDeclaration {
  constructor(method, path, handler, loc, decorators = [], bodyType = null, responseType = null) {
    this.type = 'RouteDeclaration';
    this.method = method;   // GET, POST, PUT, DELETE, PATCH
    this.path = path;       // string literal
    this.handler = handler; // Identifier or FunctionDeclaration
    this.decorators = decorators; // Array of { name, args } for "with auth, role("admin")"
    this.bodyType = bodyType;       // TypeAnnotation — request body type (e.g., body: User)
    this.responseType = responseType; // TypeAnnotation — response type (e.g., -> [User])
    this.loc = loc;
  }
}
class MiddlewareDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'MiddlewareDeclaration';
    this.name = name;
    this.params = params;   // Array of Parameter nodes (req, next)
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class HealthCheckDeclaration {
  constructor(path, loc, checks = []) {
    this.type = 'HealthCheckDeclaration';
    this.path = path;       // string literal, e.g. "/health"
    this.checks = checks;   // optional array of check names, e.g. ["check_memory", "check_db"]
    this.loc = loc;
  }
}
class CorsDeclaration {
  constructor(config, loc) {
    this.type = 'CorsDeclaration';
    this.config = config;   // { origins: ArrayLiteral, methods: ArrayLiteral, headers: ArrayLiteral }
    this.loc = loc;
  }
}
class ErrorHandlerDeclaration {
  constructor(params, body, loc) {
    this.type = 'ErrorHandlerDeclaration';
    this.params = params;   // Array of Parameter nodes (err, req)
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class WebSocketDeclaration {
  constructor(handlers, loc, config = null) {
    this.type = 'WebSocketDeclaration';
    this.handlers = handlers; // { on_open, on_message, on_close, on_error } — each is { params, body } or null
    this.config = config;     // { auth: expression } or null
    this.loc = loc;
  }
}
class StaticDeclaration {
  constructor(path, dir, loc, fallback = null) {
    this.type = 'StaticDeclaration';
    this.path = path;       // URL prefix, e.g. "/public"
    this.dir = dir;         // directory path, e.g. "./public"
    this.fallback = fallback; // fallback file, e.g. "index.html"
    this.loc = loc;
  }
}
class DiscoverDeclaration {
  constructor(peerName, urlExpression, loc, config = null) {
    this.type = 'DiscoverDeclaration';
    this.peerName = peerName;         // string — the peer server name
    this.urlExpression = urlExpression; // Expression — the URL
    this.config = config;             // { threshold, timeout } or null
    this.loc = loc;
  }
}
class AuthDeclaration {
  constructor(config, loc) {
    this.type = 'AuthDeclaration';
    this.config = config; // { type, secret, ... } object config
    this.loc = loc;
  }
}
class MaxBodyDeclaration {
  constructor(limit, loc) {
    this.type = 'MaxBodyDeclaration';
    this.limit = limit; // Expression — max body size in bytes
    this.loc = loc;
  }
}
class RouteGroupDeclaration {
  constructor(prefix, body, loc, version = null) {
    this.type = 'RouteGroupDeclaration';
    this.prefix = prefix; // string — URL prefix, e.g. "/api/v1"
    this.body = body;     // Array of server statements
    this.version = version; // version config: { version, deprecated, sunset } or null
    this.loc = loc;
  }
}
class RateLimitDeclaration {
  constructor(config, loc) {
    this.type = 'RateLimitDeclaration';
    this.config = config;
    this.loc = loc;
  }
}
class LifecycleHookDeclaration {
  constructor(hook, params, body, loc) {
    this.type = 'LifecycleHookDeclaration';
    this.hook = hook;       // "start" or "stop"
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class SubscribeDeclaration {
  constructor(event, params, body, loc) {
    this.type = 'SubscribeDeclaration';
    this.event = event;     // string — event name
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class EnvDeclaration {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'EnvDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.defaultValue = defaultValue;
    this.loc = loc;
  }
}
class ScheduleDeclaration {
  constructor(pattern, name, params, body, loc) {
    this.type = 'ScheduleDeclaration';
    this.pattern = pattern;   // string — interval or cron pattern
    this.name = name;         // optional function name
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class UploadDeclaration {
  constructor(config, loc) {
    this.type = 'UploadDeclaration';
    this.config = config;   // { max_size, allowed_types, ... }
    this.loc = loc;
  }
}
class SessionDeclaration {
  constructor(config, loc) {
    this.type = 'SessionDeclaration';
    this.config = config;   // { secret, max_age, cookie_name, ... }
    this.loc = loc;
  }
}
class DbDeclaration {
  constructor(config, loc) {
    this.type = 'DbDeclaration';
    this.config = config;   // { path, wal, ... }
    this.loc = loc;
  }
}
class TlsDeclaration {
  constructor(config, loc) {
    this.type = 'TlsDeclaration';
    this.config = config;   // { cert, key, ... }
    this.loc = loc;
  }
}
class CompressionDeclaration {
  constructor(config, loc) {
    this.type = 'CompressionDeclaration';
    this.config = config;   // { enabled, min_size, ... }
    this.loc = loc;
  }
}
class BackgroundJobDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'BackgroundJobDeclaration';
    this.name = name;
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class CacheDeclaration {
  constructor(config, loc) {
    this.type = 'CacheDeclaration';
    this.config = config;   // { max_age, stale_while_revalidate, ... }
    this.loc = loc;
  }
}
class SseDeclaration {
  constructor(path, params, body, loc) {
    this.type = 'SseDeclaration';
    this.path = path;       // string — SSE endpoint path
    this.params = params;   // Array of Parameter nodes
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class ModelDeclaration {
  constructor(name, config, loc) {
    this.type = 'ModelDeclaration';
    this.name = name;       // string — type name to generate CRUD for
    this.config = config;   // { table, timestamps, ... } or null
    this.loc = loc;
  }
}
class AiConfigDeclaration {
  constructor(name, config, loc) {
    this.type = 'AiConfigDeclaration';
    this.name = name;    // optional string name (null for default)
    this.config = config; // key-value config object
    this.loc = loc;
  }
}

// ─── src/parser/ast.js ─────────────────────────────────

// AST Node definitions for the Tova language

// Sentinel value for pipe target placeholder (used in method pipe |> .method())
const PIPE_TARGET = '__pipe_target__';

// ============================================================
// Program (root node)
// ============================================================
class Program {
  constructor(body) {
    this.type = 'Program';
    this.body = body; // Array of top-level statements/blocks
  }
}

// ============================================================
// Full-stack blocks
// ============================================================
class ServerBlock {
  constructor(body, loc, name = null) {
    this.type = 'ServerBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class BrowserBlock {
  constructor(body, loc, name = null) {
    this.type = 'BrowserBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
// Deprecated alias for backward compatibility
class SharedBlock {
  constructor(body, loc, name = null) {
    this.type = 'SharedBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class SecurityBlock {
  constructor(body, loc) {
    this.type = 'SecurityBlock';
    this.body = body;
    this.loc = loc;
  }
}
class CliBlock {
  constructor(config, commands, loc) {
    this.type = 'CliBlock';
    this.config = config;     // Array of CliConfigField
    this.commands = commands;  // Array of CliCommandDeclaration
    this.loc = loc;
  }
}
class EdgeBlock {
  constructor(body, loc, name = null) {
    this.type = 'EdgeBlock';
    this.name = name;       // optional string name for named edge blocks
    this.body = body;       // Array of edge statements (config, bindings, routes, functions, etc.)
    this.loc = loc;
  }
}
class ConcurrentBlock {
  constructor(mode, timeout, body, loc) {
    this.type = 'ConcurrentBlock';
    this.mode = mode;           // "all" | "cancel_on_error" | "first"
    this.timeout = timeout;     // Expression | null
    this.body = body;           // Array of statements
    this.loc = loc;
  }
}

// ============================================================
// Declarations
// ============================================================
class Assignment {
  constructor(targets, values, loc) {
    this.type = 'Assignment';
    this.targets = targets;   // Array of identifiers (supports multiple: a, b = 1, 2)
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class VarDeclaration {
  constructor(targets, values, loc) {
    this.type = 'VarDeclaration';
    this.targets = targets;   // Array of identifiers
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class LetDestructure {
  constructor(pattern, value, loc) {
    this.type = 'LetDestructure';
    this.pattern = pattern;   // ObjectPattern or ArrayPattern
    this.value = value;       // Expression
    this.loc = loc;
  }
}
class FunctionDeclaration {
  constructor(name, params, body, returnType, loc, isAsync = false, typeParams = [], decorators = []) {
    this.type = 'FunctionDeclaration';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (generics)
    this.params = params;     // Array of Parameter nodes
    this.body = body;         // BlockStatement or Expression (implicit return)
    this.returnType = returnType; // optional type annotation
    this.isAsync = isAsync;
    this.decorators = decorators; // Array of { name, args } for @decorator syntax
    this.loc = loc;
  }
}
class Parameter {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'Parameter';
    this.name = name;
    this.typeAnnotation = typeAnnotation; // optional
    this.defaultValue = defaultValue;     // optional
    this.loc = loc;
  }
}
class TypeDeclaration {
  constructor(name, typeParams, variants, loc) {
    this.type = 'TypeDeclaration';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (generics)
    this.variants = variants;     // Array of TypeVariant or TypeField
    this.loc = loc;
  }
}
class TypeVariant {
  constructor(name, fields, loc) {
    this.type = 'TypeVariant';
    this.name = name;
    this.fields = fields; // Array of { name, typeAnnotation }
    this.loc = loc;
  }
}
class TypeField {
  constructor(name, typeAnnotation, loc, validators) {
    this.type = 'TypeField';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.loc = loc;
    this.validators = validators || [];
  }
}

// ============================================================
// Import / Export
// ============================================================
class ImportDeclaration {
  constructor(specifiers, source, loc) {
    this.type = 'ImportDeclaration';
    this.specifiers = specifiers; // Array of { imported, local }
    this.source = source;         // string literal
    this.loc = loc;
  }
}
class ImportSpecifier {
  constructor(imported, local, loc) {
    this.type = 'ImportSpecifier';
    this.imported = imported;
    this.local = local || imported;
    this.loc = loc;
  }
}
class ImportDefault {
  constructor(local, source, loc) {
    this.type = 'ImportDefault';
    this.local = local;
    this.source = source;
    this.loc = loc;
  }
}
class ImportWildcard {
  constructor(local, source, loc) {
    this.type = 'ImportWildcard';
    this.local = local;    // namespace binding name
    this.source = source;
    this.loc = loc;
  }
}

// ============================================================
// Statements
// ============================================================
class BlockStatement {
  constructor(body, loc) {
    this.type = 'BlockStatement';
    this.body = body;
    this.loc = loc;
  }
}
class ReturnStatement {
  constructor(value, loc) {
    this.type = 'ReturnStatement';
    this.value = value;
    this.loc = loc;
  }
}
class IfStatement {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfStatement';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement or null
    this.loc = loc;
  }
}
class ForStatement {
  constructor(variable, iterable, body, elseBody, loc, guard = null, label = null, isAsync = false) {
    this.type = 'ForStatement';
    this.variable = variable;   // Identifier or destructure pattern
    this.iterable = iterable;   // Expression
    this.body = body;           // BlockStatement
    this.elseBody = elseBody;   // BlockStatement or null (for-else)
    this.guard = guard;         // Expression or null (when guard)
    this.label = label;         // string or null (for named loops)
    this.isAsync = isAsync;     // true for `async for x in stream`
    this.loc = loc;
  }
}
class WhileStatement {
  constructor(condition, body, loc, label = null) {
    this.type = 'WhileStatement';
    this.condition = condition;
    this.body = body;
    this.label = label;         // string or null (for named loops)
    this.loc = loc;
  }
}
class LoopStatement {
  constructor(body, label, loc) {
    this.type = 'LoopStatement';
    this.body = body;           // BlockStatement
    this.label = label;         // string or null (for named loops)
    this.loc = loc;
  }
}
class IfExpression {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfExpression';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement (required)
    this.loc = loc;
  }
}
class TryCatchStatement {
  constructor(tryBody, catchParam, catchBody, loc, finallyBody = null) {
    this.type = 'TryCatchStatement';
    this.tryBody = tryBody;         // Array of statements
    this.catchParam = catchParam;   // string (error variable name) or null
    this.catchBody = catchBody;     // Array of statements (or null if try/finally only)
    this.finallyBody = finallyBody; // Array of statements or null
    this.loc = loc;
  }
}
class BreakStatement {
  constructor(loc, label = null) {
    this.type = 'BreakStatement';
    this.label = label;         // string or null (for named break)
    this.loc = loc;
  }
}
class ContinueStatement {
  constructor(loc, label = null) {
    this.type = 'ContinueStatement';
    this.label = label;         // string or null (for named continue)
    this.loc = loc;
  }
}
class GuardStatement {
  constructor(condition, elseBody, loc) {
    this.type = 'GuardStatement';
    this.condition = condition;
    this.elseBody = elseBody; // BlockStatement
    this.loc = loc;
  }
}
class ExpressionStatement {
  constructor(expression, loc) {
    this.type = 'ExpressionStatement';
    this.expression = expression;
    this.loc = loc;
  }
}

// ============================================================
// Expressions
// ============================================================
class Identifier {
  constructor(name, loc) {
    this.type = 'Identifier';
    this.name = name;
    this.loc = loc;
  }
}
class NumberLiteral {
  constructor(value, loc) {
    this.type = 'NumberLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class StringLiteral {
  constructor(value, loc) {
    this.type = 'StringLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class TemplateLiteral {
  constructor(parts, loc) {
    this.type = 'TemplateLiteral';
    this.parts = parts; // Array of { type: 'text'|'expr', value }
    this.loc = loc;
  }
}
class BooleanLiteral {
  constructor(value, loc) {
    this.type = 'BooleanLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class NilLiteral {
  constructor(loc) {
    this.type = 'NilLiteral';
    this.loc = loc;
  }
}
class RegexLiteral {
  constructor(pattern, flags, loc) {
    this.type = 'RegexLiteral';
    this.pattern = pattern;
    this.flags = flags;
    this.loc = loc;
  }
}
class ArrayLiteral {
  constructor(elements, loc) {
    this.type = 'ArrayLiteral';
    this.elements = elements;
    this.loc = loc;
  }
}
class ObjectLiteral {
  constructor(properties, loc) {
    this.type = 'ObjectLiteral';
    this.properties = properties; // Array of { key, value, shorthand }
    this.loc = loc;
  }
}
class BinaryExpression {
  constructor(operator, left, right, loc) {
    this.type = 'BinaryExpression';
    this.operator = operator;
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class UnaryExpression {
  constructor(operator, operand, prefix, loc) {
    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
    this.prefix = prefix;
    this.loc = loc;
  }
}
class ChainedComparison {
  constructor(operands, operators, loc) {
    this.type = 'ChainedComparison';
    this.operands = operands;   // [a, b, c] for a < b < c
    this.operators = operators; // ['<', '<']
    this.loc = loc;
  }
}
class LogicalExpression {
  constructor(operator, left, right, loc) {
    this.type = 'LogicalExpression';
    this.operator = operator; // 'and', 'or', '&&', '||'
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class CallExpression {
  constructor(callee, args, loc) {
    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = args;
    this.loc = loc;
  }
}
class NamedArgument {
  constructor(name, value, loc) {
    this.type = 'NamedArgument';
    this.name = name;
    this.value = value;
    this.loc = loc;
  }
}
class MemberExpression {
  constructor(object, property, computed, loc) {
    this.type = 'MemberExpression';
    this.object = object;
    this.property = property;
    this.computed = computed; // true for obj[expr], false for obj.prop
    this.loc = loc;
  }
}
class OptionalChain {
  constructor(object, property, computed, loc) {
    this.type = 'OptionalChain';
    this.object = object;
    this.property = property;
    this.computed = computed;
    this.loc = loc;
  }
}
class PipeExpression {
  constructor(left, right, loc) {
    this.type = 'PipeExpression';
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class LambdaExpression {
  constructor(params, body, loc, isAsync = false) {
    this.type = 'LambdaExpression';
    this.params = params;
    this.body = body;
    this.isAsync = isAsync;
    this.loc = loc;
  }
}
class MatchExpression {
  constructor(subject, arms, loc) {
    this.type = 'MatchExpression';
    this.subject = subject;
    this.arms = arms; // Array of MatchArm
    this.loc = loc;
  }
}
class MatchArm {
  constructor(pattern, guard, body, loc) {
    this.type = 'MatchArm';
    this.pattern = pattern;
    this.guard = guard;   // optional guard expression (if condition)
    this.body = body;
    this.loc = loc;
  }
}
class RangeExpression {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangeExpression';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive; // true for ..=, false for ..
    this.loc = loc;
  }
}
class SliceExpression {
  constructor(object, start, end, step, loc) {
    this.type = 'SliceExpression';
    this.object = object;
    this.start = start;
    this.end = end;
    this.step = step;
    this.loc = loc;
  }
}
class SpreadExpression {
  constructor(argument, loc) {
    this.type = 'SpreadExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class PropagateExpression {
  constructor(expression, loc) {
    this.type = 'PropagateExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class ListComprehension {
  constructor(expression, variable, iterable, condition, loc) {
    this.type = 'ListComprehension';
    this.expression = expression;
    this.variable = variable;
    this.iterable = iterable;
    this.condition = condition; // optional filter
    this.loc = loc;
  }
}
class DictComprehension {
  constructor(key, value, variables, iterable, condition, loc) {
    this.type = 'DictComprehension';
    this.key = key;
    this.value = value;
    this.variables = variables;
    this.iterable = iterable;
    this.condition = condition;
    this.loc = loc;
  }
}
class IsExpression {
  constructor(value, typeName, negated, loc) {
    this.type = 'IsExpression';
    this.value = value;
    this.typeName = typeName;     // string: "String", "Int", "Nil", etc.
    this.negated = negated;       // true for "is not"
    this.loc = loc;
  }
}
class MembershipExpression {
  constructor(value, collection, negated, loc) {
    this.type = 'MembershipExpression';
    this.value = value;
    this.collection = collection;
    this.negated = negated; // true for "not in"
    this.loc = loc;
  }
}
class CompoundAssignment {
  constructor(target, operator, value, loc) {
    this.type = 'CompoundAssignment';
    this.target = target;
    this.operator = operator; // +=, -=, *=, /=
    this.value = value;
    this.loc = loc;
  }
}
class AwaitExpression {
  constructor(argument, loc) {
    this.type = 'AwaitExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class InterfaceDeclaration {
  constructor(name, methods, loc) {
    this.type = 'InterfaceDeclaration';
    this.name = name;
    this.methods = methods; // Array of { name, params, returnType }
    this.loc = loc;
  }
}
class StringConcatPattern {
  constructor(prefix, rest, loc) {
    this.type = 'StringConcatPattern';
    this.prefix = prefix; // StringLiteral value
    this.rest = rest;     // BindingPattern or WildcardPattern
    this.loc = loc;
  }
}

// ============================================================
// Patterns (for destructuring and match)
// ============================================================
class ObjectPattern {
  constructor(properties, loc) {
    this.type = 'ObjectPattern';
    this.properties = properties; // Array of { key, value (alias), defaultValue }
    this.loc = loc;
  }
}
class ArrayPattern {
  constructor(elements, loc) {
    this.type = 'ArrayPattern';
    this.elements = elements;
    this.loc = loc;
  }
}
class WildcardPattern {
  constructor(loc) {
    this.type = 'WildcardPattern';
    this.loc = loc;
  }
}
class LiteralPattern {
  constructor(value, loc) {
    this.type = 'LiteralPattern';
    this.value = value;
    this.loc = loc;
  }
}
class VariantPattern {
  constructor(name, fields, loc) {
    this.type = 'VariantPattern';
    this.name = name;
    this.fields = fields;
    this.loc = loc;
  }
}
class BindingPattern {
  constructor(name, loc) {
    this.type = 'BindingPattern';
    this.name = name;
    this.loc = loc;
  }
}
class RangePattern {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangePattern';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive;
    this.loc = loc;
  }
}

// ============================================================
// Browser-specific nodes (lazy-loaded from browser-ast.js, re-exported for backward compat)
// ============================================================

// ============================================================
// Server-specific nodes (lazy-loaded from server-ast.js, re-exported for backward compat)
// ============================================================

// ============================================================
// Security-specific nodes (lazy-loaded from security-ast.js, re-exported for backward compat)
// ============================================================

// ============================================================
// Edge-specific nodes (lazy-loaded from edge-ast.js, re-exported for backward compat)
// ============================================================

// ============================================================
// Form-specific nodes (lazy-loaded from form-ast.js, re-exported for backward compat)
// ============================================================

// ============================================================
// Select-specific nodes (lazy-loaded from select-ast.js, re-exported for backward compat)
// ============================================================
class TestBlock {
  constructor(name, body, loc, options = {}) {
    this.type = 'TestBlock';
    this.name = name;       // optional string name
    this.body = body;       // Array of statements
    this.timeout = options.timeout || null;  // optional timeout in ms
    this.beforeEach = options.beforeEach || null; // Array of statements or null
    this.afterEach = options.afterEach || null;   // Array of statements or null
    this.loc = loc;
  }
}
class BenchBlock {
  constructor(name, body, loc) {
    this.type = 'BenchBlock';
    this.name = name;       // optional string name
    this.body = body;       // Array of statements (expressions to benchmark)
    this.loc = loc;
  }
}

// ============================================================
// Extern declarations
// ============================================================
class ExternDeclaration {
  constructor(name, params, returnType, loc, isAsync = false) {
    this.type = 'ExternDeclaration';
    this.name = name;
    this.params = params;     // Array of Parameter nodes (types only, names optional)
    this.returnType = returnType; // TypeAnnotation or null
    this.isAsync = isAsync;
    this.loc = loc;
  }
}

// ============================================================
// Type annotations
// ============================================================
class TypeAnnotation {
  constructor(name, typeParams, loc) {
    this.type = 'TypeAnnotation';
    this.name = name;         // "Int", "String", "Bool", "Float", etc.
    this.typeParams = typeParams; // Array of TypeAnnotation (for generics)
    this.loc = loc;
  }
}
class ArrayTypeAnnotation {
  constructor(elementType, loc) {
    this.type = 'ArrayTypeAnnotation';
    this.elementType = elementType;
    this.loc = loc;
  }
}
class FunctionTypeAnnotation {
  constructor(paramTypes, returnType, loc) {
    this.type = 'FunctionTypeAnnotation';
    this.paramTypes = paramTypes;
    this.returnType = returnType;
    this.loc = loc;
  }
}
class UnionTypeAnnotation {
  constructor(members, loc) {
    this.type = 'UnionTypeAnnotation';
    this.members = members; // Array of TypeAnnotation nodes
    this.loc = loc;
  }
}

// ============================================================
// Impl blocks
// ============================================================
class ImplDeclaration {
  constructor(typeName, methods, loc, traitName = null) {
    this.type = 'ImplDeclaration';
    this.typeName = typeName;
    this.traitName = traitName; // null for plain impl, string for `impl Trait for Type`
    this.methods = methods;     // Array of FunctionDeclaration (first param is self)
    this.loc = loc;
  }
}

// ============================================================
// Trait declarations
// ============================================================
class TraitDeclaration {
  constructor(name, methods, loc) {
    this.type = 'TraitDeclaration';
    this.name = name;
    this.methods = methods; // Array of { name, params, returnType, body (optional for defaults) }
    this.loc = loc;
  }
}

// ============================================================
// Type aliases
// ============================================================
class TypeAlias {
  constructor(name, typeParams, typeExpr, loc) {
    this.type = 'TypeAlias';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (for generics)
    this.typeExpr = typeExpr; // TypeAnnotation
    this.loc = loc;
  }
}

// ============================================================
// Defer statement
// ============================================================
class WithStatement {
  constructor(expression, name, body, loc) {
    this.type = 'WithStatement';
    this.expression = expression; // resource expression
    this.name = name;             // binding name (string)
    this.body = body;             // BlockStatement
    this.loc = loc;
  }
}
class DeferStatement {
  constructor(body, loc) {
    this.type = 'DeferStatement';
    this.body = body; // Expression or BlockStatement
    this.loc = loc;
  }
}

// ============================================================
// Yield expression (generators)
// ============================================================
class YieldExpression {
  constructor(argument, delegate, loc) {
    this.type = 'YieldExpression';
    this.argument = argument; // expression to yield
    this.delegate = delegate; // true for `yield from`
    this.loc = loc;
  }
}

// ============================================================
// Tuple expression/pattern/type
// ============================================================
class TupleExpression {
  constructor(elements, loc) {
    this.type = 'TupleExpression';
    this.elements = elements; // Array of expressions
    this.loc = loc;
  }
}
class TuplePattern {
  constructor(elements, loc) {
    this.type = 'TuplePattern';
    this.elements = elements; // Array of patterns
    this.loc = loc;
  }
}
class TupleTypeAnnotation {
  constructor(elementTypes, loc) {
    this.type = 'TupleTypeAnnotation';
    this.elementTypes = elementTypes;
    this.loc = loc;
  }
}

// ============================================================
// Column expressions (for table operations)
// ============================================================
class ColumnExpression {
  constructor(name, loc) {
    this.type = 'ColumnExpression';
    this.name = name;  // column name, e.g. "age" for .age
    this.loc = loc;
  }
}
class ColumnAssignment {
  constructor(target, expression, loc) {
    this.type = 'ColumnAssignment';
    this.target = target;       // column name to assign to
    this.expression = expression; // expression computing the value
    this.loc = loc;
  }
}
class NegatedColumnExpression {
  constructor(name, loc) {
    this.type = 'NegatedColumnExpression';
    this.name = name;  // column name for exclusion, e.g. "password" for -.password
    this.loc = loc;
  }
}

// ============================================================
// Data block nodes
// ============================================================
class DataBlock {
  constructor(body, loc) {
    this.type = 'DataBlock';
    this.body = body;  // Array of SourceDeclaration, PipelineDeclaration, ValidateBlock, RefreshPolicy
    this.loc = loc;
  }
}
class SourceDeclaration {
  constructor(name, typeAnnotation, expression, loc) {
    this.type = 'SourceDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.expression = expression;
    this.loc = loc;
  }
}
class PipelineDeclaration {
  constructor(name, expression, loc) {
    this.type = 'PipelineDeclaration';
    this.name = name;
    this.expression = expression;
    this.loc = loc;
  }
}
class ValidateBlock {
  constructor(typeName, rules, loc) {
    this.type = 'ValidateBlock';
    this.typeName = typeName;
    this.rules = rules;  // Array of expression predicates
    this.loc = loc;
  }
}
class RefreshPolicy {
  constructor(sourceName, interval, loc) {
    this.type = 'RefreshPolicy';
    this.sourceName = sourceName;
    this.interval = interval;  // { value, unit } or "on_demand"
    this.loc = loc;
  }
}

// ============================================================
// Refinement types
// ============================================================
class RefinementType {
  constructor(name, baseType, predicate, loc) {
    this.type = 'RefinementType';
    this.name = name;
    this.baseType = baseType;      // TypeAnnotation
    this.predicate = predicate;    // Expression (body of where block, uses 'it')
    this.loc = loc;
  }
}

// ─── src/parser/security-ast.js ────────────────────────

// Security-specific AST Node definitions for the Tova language
// Extracted for lazy loading — only loaded when security { } blocks are used.
class SecurityAuthDeclaration {
  constructor(authType, config, loc) {
    this.type = 'SecurityAuthDeclaration';
    this.authType = authType; // "jwt" or "api_key"
    this.config = config;     // { secret, expires, ... }
    this.loc = loc;
  }
}
class SecurityRoleDeclaration {
  constructor(name, permissions, loc) {
    this.type = 'SecurityRoleDeclaration';
    this.name = name;           // string — role name, e.g. "Admin"
    this.permissions = permissions; // Array of strings — permission names
    this.loc = loc;
  }
}
class SecurityProtectDeclaration {
  constructor(pattern, config, loc) {
    this.type = 'SecurityProtectDeclaration';
    this.pattern = pattern;     // string — route pattern, e.g. "/api/admin/*"
    this.config = config;       // { require, rate_limit: { max, window } }
    this.loc = loc;
  }
}
class SecuritySensitiveDeclaration {
  constructor(typeName, fieldName, config, loc) {
    this.type = 'SecuritySensitiveDeclaration';
    this.typeName = typeName;   // string — type name, e.g. "User"
    this.fieldName = fieldName; // string — field name, e.g. "password"
    this.config = config;       // { hash, never_expose, visible_to }
    this.loc = loc;
  }
}
class SecurityCorsDeclaration {
  constructor(config, loc) {
    this.type = 'SecurityCorsDeclaration';
    this.config = config;       // { origins, methods, credentials }
    this.loc = loc;
  }
}
class SecurityCspDeclaration {
  constructor(config, loc) {
    this.type = 'SecurityCspDeclaration';
    this.config = config;       // { default_src, script_src, style_src, ... }
    this.loc = loc;
  }
}
class SecurityRateLimitDeclaration {
  constructor(config, loc) {
    this.type = 'SecurityRateLimitDeclaration';
    this.config = config;       // { max, window }
    this.loc = loc;
  }
}
class SecurityCsrfDeclaration {
  constructor(config, loc) {
    this.type = 'SecurityCsrfDeclaration';
    this.config = config;       // { enabled, exempt }
    this.loc = loc;
  }
}
class SecurityAuditDeclaration {
  constructor(config, loc) {
    this.type = 'SecurityAuditDeclaration';
    this.config = config;       // { events, store, retain }
    this.loc = loc;
  }
}
class SecurityTrustProxyDeclaration {
  constructor(value, loc) {
    this.type = 'SecurityTrustProxyDeclaration';
    this.value = value;         // true | false | "loopback"
    this.loc = loc;
  }
}
class SecurityHstsDeclaration {
  constructor(config, loc) {
    this.type = 'SecurityHstsDeclaration';
    this.config = config;       // { enabled, max_age, include_subdomains, preload }
    this.loc = loc;
  }
}

// ─── src/parser/cli-ast.js ─────────────────────────────

// CLI-specific AST Node definitions for the Tova language
// Extracted for lazy loading — only loaded when cli { } blocks are used.
class CliConfigField {
  constructor(key, value, loc) {
    this.type = 'CliConfigField';
    this.key = key;       // string — "name", "version", "description"
    this.value = value;   // Expression (StringLiteral, etc.)
    this.loc = loc;
  }
}
class CliCommandDeclaration {
  constructor(name, params, body, isAsync, loc) {
    this.type = 'CliCommandDeclaration';
    this.name = name;       // string — command name
    this.params = params;   // Array of CliParam
    this.body = body;       // BlockStatement
    this.isAsync = isAsync; // boolean
    this.loc = loc;
  }
}
class CliParam {
  constructor(name, typeAnnotation, defaultValue, isFlag, isOptional, isRepeated, loc) {
    this.type = 'CliParam';
    this.name = name;               // string — parameter name
    this.typeAnnotation = typeAnnotation; // string or null — "String", "Int", "Float", "Bool"
    this.defaultValue = defaultValue;     // Expression or null
    this.isFlag = isFlag;           // boolean — prefixed with --
    this.isOptional = isOptional;   // boolean — Type? suffix
    this.isRepeated = isRepeated;   // boolean — [Type] array flag
    this.loc = loc;
  }
}

// ─── src/parser/edge-ast.js ────────────────────────────

// Edge/serverless-specific AST Node definitions for the Tova language
// Extracted for lazy loading — only loaded when edge { } blocks are used.
class EdgeConfigField {
  constructor(key, value, loc) {
    this.type = 'EdgeConfigField';
    this.key = key;       // string — "target", "name", etc.
    this.value = value;   // Expression (StringLiteral, etc.)
    this.loc = loc;
  }
}
class EdgeKVDeclaration {
  constructor(name, config, loc) {
    this.type = 'EdgeKVDeclaration';
    this.name = name;       // string — binding name (e.g., "CACHE")
    this.config = config;   // object or null — { ttl: Expression } etc.
    this.loc = loc;
  }
}
class EdgeSQLDeclaration {
  constructor(name, config, loc) {
    this.type = 'EdgeSQLDeclaration';
    this.name = name;       // string — binding name (e.g., "DB")
    this.config = config;   // object or null
    this.loc = loc;
  }
}
class EdgeStorageDeclaration {
  constructor(name, config, loc) {
    this.type = 'EdgeStorageDeclaration';
    this.name = name;       // string — binding name (e.g., "UPLOADS")
    this.config = config;   // object or null
    this.loc = loc;
  }
}
class EdgeQueueDeclaration {
  constructor(name, config, loc) {
    this.type = 'EdgeQueueDeclaration';
    this.name = name;       // string — binding name (e.g., "EMAILS")
    this.config = config;   // object or null
    this.loc = loc;
  }
}
class EdgeEnvDeclaration {
  constructor(name, defaultValue, loc) {
    this.type = 'EdgeEnvDeclaration';
    this.name = name;             // string — env var name
    this.defaultValue = defaultValue; // Expression or null
    this.loc = loc;
  }
}
class EdgeSecretDeclaration {
  constructor(name, loc) {
    this.type = 'EdgeSecretDeclaration';
    this.name = name;       // string — secret name
    this.loc = loc;
  }
}
class EdgeScheduleDeclaration {
  constructor(name, cron, body, loc) {
    this.type = 'EdgeScheduleDeclaration';
    this.name = name;       // string — schedule name
    this.cron = cron;       // string — cron expression
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class EdgeConsumeDeclaration {
  constructor(queue, handler, loc) {
    this.type = 'EdgeConsumeDeclaration';
    this.queue = queue;     // string — queue binding name
    this.handler = handler; // FunctionDeclaration or LambdaExpression
    this.loc = loc;
  }
}

// ─── src/parser/form-ast.js ────────────────────────────

// Form-specific AST Node definitions for the Tova language
// Extracted for lazy loading — only loaded when form { } blocks are used.

// ============================================================
// Form-specific nodes
// ============================================================
class FormDeclaration {
  constructor(name, typeAnnotation, fields, groups, arrays, computeds, steps, onSubmit, loc) {
    this.type = 'FormDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.fields = fields;
    this.groups = groups;
    this.arrays = arrays;
    this.computeds = computeds;
    this.steps = steps;
    this.onSubmit = onSubmit;
    this.loc = loc;
  }
}
class FormFieldDeclaration {
  constructor(name, typeAnnotation, initialValue, validators, loc) {
    this.type = 'FormFieldDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.initialValue = initialValue;
    this.validators = validators;
    this.loc = loc;
  }
}
class FormGroupDeclaration {
  constructor(name, condition, fields, groups, loc) {
    this.type = 'FormGroupDeclaration';
    this.name = name;
    this.condition = condition;
    this.fields = fields;
    this.groups = groups;
    this.loc = loc;
  }
}
class FormArrayDeclaration {
  constructor(name, fields, validators, loc) {
    this.type = 'FormArrayDeclaration';
    this.name = name;
    this.fields = fields;
    this.validators = validators;
    this.loc = loc;
  }
}
class FormValidator {
  constructor(name, args, isAsync, loc) {
    this.type = 'FormValidator';
    this.name = name;
    this.args = args;
    this.isAsync = isAsync;
    this.loc = loc;
  }
}
class FormStepsDeclaration {
  constructor(steps, loc) {
    this.type = 'FormStepsDeclaration';
    this.steps = steps;
    this.loc = loc;
  }
}
class FormStep {
  constructor(label, members, loc) {
    this.type = 'FormStep';
    this.label = label;
    this.members = members;
    this.loc = loc;
  }
}

// ─── src/parser/concurrency-ast.js ─────────────────────

// Concurrency-specific AST Node definitions for the Tova language
// Extracted for lazy loading -- only loaded when concurrent { } blocks are used.

/**
 * spawn foo(args)
 * spawn fn() { ... }
 */
class SpawnExpression {
  constructor(callee, args, loc) {
    this.type = 'SpawnExpression';
    this.callee = callee;       // Expression (function name or lambda)
    this.arguments = args;      // Array of Expression
    this.loc = loc;
  }
}

// ─── src/parser/select-ast.js ──────────────────────────

// Select-specific AST Node definitions for the Tova language
// Extracted for lazy loading -- only loaded when select { } blocks are used.

/**
 * select {
 *   msg from ch => { ... }
 *   ch.send(val) => { ... }
 *   timeout(5000) => { ... }
 *   _ => { ... }
 * }
 */
class SelectStatement {
  constructor(cases, loc) {
    this.type = 'SelectStatement';
    this.cases = cases;   // Array of SelectCase
    this.loc = loc;
  }
}

/**
 * A single case arm inside a select block.
 *
 * kind: "receive" | "send" | "timeout" | "default"
 * channel: Expression | null   (identifier for the channel; null for timeout/default)
 * binding: string | null        (variable name bound on receive; null otherwise)
 * value: Expression | null      (value to send, or timeout duration; null for receive/default)
 * body: [Statement]             (statements executed when this case fires)
 */
class SelectCase {
  constructor(kind, channel, binding, value, body, loc) {
    this.type = 'SelectCase';
    this.kind = kind;        // "receive" | "send" | "timeout" | "default"
    this.channel = channel;  // Expression | null
    this.binding = binding;  // string | null
    this.value = value;      // Expression | null
    this.body = body;        // [Statement]
    this.loc = loc;
  }
}

// AST namespace shim for parser.js compatibility

const AST = { Program, ServerBlock, BrowserBlock, SharedBlock, SecurityBlock, CliBlock, EdgeBlock, ConcurrentBlock, Assignment, VarDeclaration, LetDestructure, FunctionDeclaration, Parameter, TypeDeclaration, TypeVariant, TypeField, ImportDeclaration, ImportSpecifier, ImportDefault, ImportWildcard, BlockStatement, ReturnStatement, IfStatement, ForStatement, WhileStatement, LoopStatement, IfExpression, TryCatchStatement, BreakStatement, ContinueStatement, GuardStatement, ExpressionStatement, Identifier, NumberLiteral, StringLiteral, TemplateLiteral, BooleanLiteral, NilLiteral, RegexLiteral, ArrayLiteral, ObjectLiteral, BinaryExpression, UnaryExpression, ChainedComparison, LogicalExpression, CallExpression, NamedArgument, MemberExpression, OptionalChain, PipeExpression, LambdaExpression, MatchExpression, MatchArm, RangeExpression, SliceExpression, SpreadExpression, PropagateExpression, ListComprehension, DictComprehension, IsExpression, MembershipExpression, CompoundAssignment, AwaitExpression, InterfaceDeclaration, StringConcatPattern, ObjectPattern, ArrayPattern, WildcardPattern, LiteralPattern, VariantPattern, BindingPattern, RangePattern, TestBlock, BenchBlock, ExternDeclaration, TypeAnnotation, ArrayTypeAnnotation, FunctionTypeAnnotation, UnionTypeAnnotation, ImplDeclaration, TraitDeclaration, TypeAlias, WithStatement, DeferStatement, YieldExpression, TupleExpression, TuplePattern, TupleTypeAnnotation, ColumnExpression, ColumnAssignment, NegatedColumnExpression, DataBlock, SourceDeclaration, PipelineDeclaration, ValidateBlock, RefreshPolicy, RefinementType, StateDeclaration, ComputedDeclaration, EffectDeclaration, ComponentDeclaration, ComponentStyleBlock, StoreDeclaration, JSXElement, JSXAttribute, JSXSpreadAttribute, JSXFragment, JSXText, JSXExpression, JSXFor, JSXIf, JSXMatch, RouteDeclaration, MiddlewareDeclaration, HealthCheckDeclaration, CorsDeclaration, ErrorHandlerDeclaration, WebSocketDeclaration, StaticDeclaration, DiscoverDeclaration, AuthDeclaration, MaxBodyDeclaration, RouteGroupDeclaration, RateLimitDeclaration, LifecycleHookDeclaration, SubscribeDeclaration, EnvDeclaration, ScheduleDeclaration, UploadDeclaration, SessionDeclaration, DbDeclaration, TlsDeclaration, CompressionDeclaration, BackgroundJobDeclaration, CacheDeclaration, SseDeclaration, ModelDeclaration, AiConfigDeclaration, SecurityAuthDeclaration, SecurityRoleDeclaration, SecurityProtectDeclaration, SecuritySensitiveDeclaration, SecurityCorsDeclaration, SecurityCspDeclaration, SecurityRateLimitDeclaration, SecurityCsrfDeclaration, SecurityAuditDeclaration, SecurityTrustProxyDeclaration, SecurityHstsDeclaration, CliConfigField, CliCommandDeclaration, CliParam, EdgeConfigField, EdgeKVDeclaration, EdgeSQLDeclaration, EdgeStorageDeclaration, EdgeQueueDeclaration, EdgeEnvDeclaration, EdgeSecretDeclaration, EdgeScheduleDeclaration, EdgeConsumeDeclaration, FormDeclaration, FormFieldDeclaration, FormGroupDeclaration, FormArrayDeclaration, FormValidator, FormStepsDeclaration, FormStep, SpawnExpression, SelectStatement, SelectCase };

// ─── src/diagnostics/error-codes.js ────────────────────

// Tova Diagnostic Error Codes Registry
// Every diagnostic has a unique code: E### for errors, W### for warnings

// ─── Error Codes ─────────────────────────────────────────────
const ErrorCode = {
  // === Syntax / Parse Errors (E001–E099) ===
  E001: { code: 'E001', title: 'Unexpected token',           category: 'syntax' },
  E002: { code: 'E002', title: 'Unterminated string',        category: 'syntax' },
  E003: { code: 'E003', title: 'Expected closing delimiter', category: 'syntax' },
  E004: { code: 'E004', title: 'Invalid number literal',     category: 'syntax' },
  E005: { code: 'E005', title: 'Unexpected character',       category: 'syntax' },
  E006: { code: 'E006', title: 'Unterminated comment',       category: 'syntax' },
  E007: { code: 'E007', title: 'Expected expression',        category: 'syntax' },
  E008: { code: 'E008', title: 'Mismatched JSX tag',         category: 'syntax' },
  E009: { code: 'E009', title: 'Invalid operator',           category: 'syntax' },
  E010: { code: 'E010', title: 'Max nesting depth exceeded', category: 'syntax' },

  // === Type Errors (E100–E199) ===
  E100: { code: 'E100', title: 'Type mismatch',                  category: 'type' },
  E101: { code: 'E101', title: 'Return type mismatch',           category: 'type' },
  E102: { code: 'E102', title: 'Cannot assign to type',          category: 'type' },
  E103: { code: 'E103', title: 'Invalid argument type',          category: 'type' },
  E104: { code: 'E104', title: 'Incompatible operand types',     category: 'type' },
  E105: { code: 'E105', title: 'Cannot apply operator to type',  category: 'type' },

  // === Scope / Definition Errors (E200–E299) ===
  E200: { code: 'E200', title: 'Undefined variable',             category: 'scope' },
  E201: { code: 'E201', title: 'Duplicate definition',           category: 'scope' },
  E202: { code: 'E202', title: 'Cannot reassign immutable',      category: 'scope' },
  E203: { code: 'E203', title: 'Invalid redeclaration',          category: 'scope' },

  // === Context Errors (E300–E399) ===
  E300: { code: 'E300', title: 'Invalid context: await',         category: 'context' },
  E301: { code: 'E301', title: 'Invalid context: return',        category: 'context' },
  E302: { code: 'E302', title: 'Invalid context: browser-only',  category: 'context' },
  E303: { code: 'E303', title: 'Invalid context: server-only',   category: 'context' },
  E304: { code: 'E304', title: 'Invalid context: function-only', category: 'context' },

  // === Import Errors (E400–E499) ===
  E400: { code: 'E400', title: 'Invalid import',                 category: 'import' },
  E401: { code: 'E401', title: 'Circular import',                category: 'import' },

  // === Pattern Match Errors (E500–E599) ===
  E500: { code: 'E500', title: 'Invalid pattern',                category: 'match' },

  // === Trait / Impl Errors (E600–E699) ===
  E600: { code: 'E600', title: 'Missing trait method',           category: 'trait' },
  E601: { code: 'E601', title: 'Trait method signature mismatch', category: 'trait' },
  E602: { code: 'E602', title: 'Unknown trait',                  category: 'trait' },
};

// ─── Warning Codes ───────────────────────────────────────────
const WarningCode = {
  // === Unused (W001–W099) ===
  W001: { code: 'W001', title: 'Unused variable',            category: 'unused' },
  W002: { code: 'W002', title: 'Unused function',            category: 'unused' },
  W003: { code: 'W003', title: 'Unused import',              category: 'unused' },

  // === Style (W100–W199) ===
  W100: { code: 'W100', title: 'Naming convention violation', category: 'style' },
  W101: { code: 'W101', title: 'Variable shadows outer',      category: 'style' },

  // === Potential Bugs (W200–W299) ===
  W200: { code: 'W200', title: 'Non-exhaustive match',        category: 'match' },
  W201: { code: 'W201', title: 'Unreachable code',            category: 'logic' },
  W202: { code: 'W202', title: 'Condition always true',       category: 'logic' },
  W203: { code: 'W203', title: 'Condition always false',      category: 'logic' },
  W204: { code: 'W204', title: 'Potential data loss',         category: 'type' },
  W205: { code: 'W205', title: 'Missing return on some paths', category: 'logic' },
  W206: { code: 'W206', title: 'Non-Tova keyword used',       category: 'style' },
  W207: { code: 'W207', title: 'Unreachable match arm',       category: 'match' },
  W208: { code: 'W208', title: 'Defer outside function',      category: 'context' },

  // === Trait Conformance (W300–W399) ===
  W300: { code: 'W300', title: 'Missing trait method',        category: 'trait' },
  W301: { code: 'W301', title: 'Trait parameter mismatch',    category: 'trait' },
  W302: { code: 'W302', title: 'Trait return type mismatch',  category: 'trait' },
  W303: { code: 'W303', title: 'Unknown derive trait',        category: 'trait' },
};

// ─── Lookup maps ─────────────────────────────────────────────

const _allCodes = new Map();
for (const entry of Object.values(ErrorCode)) _allCodes.set(entry.code, entry);
for (const entry of Object.values(WarningCode)) _allCodes.set(entry.code, entry);
function lookupCode(code) {
  return _allCodes.get(code) || null;
}
function isErrorCode(code) {
  return code.startsWith('E');
}
function isWarningCode(code) {
  return code.startsWith('W');
}

// ─── tova-ignore comment parsing ─────────────────────────────

const IGNORE_PATTERN = /\/\/\s*tova-ignore\s+((?:[EW]\d{3}(?:\s*,\s*)?)+)/;
function parseIgnoreComment(line) {
  const match = line.match(IGNORE_PATTERN);
  if (!match) return null;
  return match[1].split(',').map(c => c.trim()).filter(c => c);
}

// ─── Explanation text for --explain flag ─────────────────────

const EXPLANATIONS = {
  E001: `
Unexpected token in source code.

This error occurs when the parser encounters a token it doesn't expect
in the current context.

Example:
    fn foo() {
        x = 1 +
    }            // error: unexpected '}', expected expression after '+'

Fix: complete the expression or remove the trailing operator.
`,
  E100: `
Type mismatch between expected and actual types.

This error occurs when a value of one type is used where a different
type is expected.

Example:
    fn add(a: Int, b: Int) -> Int {
        return a + b
    }
    add("hello", 5)  // error: expected Int, got String

Fix: ensure the value matches the expected type, or use a conversion
function like to_int(), to_string(), etc.
`,
  E200: `
Reference to an undefined variable or function.

This error occurs when you use a name that hasn't been defined in the
current scope or any parent scope.

Example:
    print(foo)  // error: 'foo' is not defined

Fix: define the variable before using it, or check for typos.
`,
  E202: `
Attempt to reassign an immutable variable.

In Tova, variables bound with '=' are immutable by default. Use 'var'
to create a mutable variable.

Example:
    x = 5
    x = 10     // error: cannot reassign immutable variable 'x'

    var y = 5
    y = 10     // ok: 'var' makes it mutable

Fix: change the declaration to 'var x = 5' if you need mutability.
`,
  E300: `
'await' used outside an async function.

The 'await' keyword can only be used inside functions declared with
the 'async' keyword.

Example:
    fn fetch_data() {
        data = await fetch("/api")  // error: await outside async

    }

    async fn fetch_data() {
        data = await fetch("/api")  // ok
    }

Fix: add 'async' to the enclosing function declaration.
`,
  E302: `
Client-only feature used outside a client block.

Features like 'state', 'computed', 'effect', 'component', and 'store'
can only be used inside a client { } block.

Example:
    state count = 0  // error: 'state' outside client block

    client {
        state count = 0  // ok
    }

Fix: move the code inside a client { } block.
`,
  E303: `
Server-only feature used outside a server block.

Features like 'route', 'middleware', 'ws', 'db', 'auth', etc.
can only be used inside a server { } block.

Example:
    route GET "/api/users" => get_users  // error: outside server block

    server {
        route GET "/api/users" => get_users  // ok
    }

Fix: move the code inside a server { } block.
`,
  W001: `
A variable is declared but never used.

This warning helps catch typos and dead code.

Example:
    fn foo() {
        x = 5       // warning: 'x' declared but never used
        return 10
    }

Fix: remove the variable, or prefix with _ to suppress: _x = 5
`,
  W200: `
A match expression doesn't cover all possible variants.

This can lead to runtime errors if an unmatched variant is encountered.

Example:
    type Color = Red | Green | Blue
    match color {
        Red => "red"
        Green => "green"
    }  // warning: missing 'Blue' variant

Fix: add the missing variants, or add a wildcard: _ => "other"
`,
  W204: `
Implicit narrowing conversion that may lose data.

Example:
    x: Int = 3.14  // warning: assigning Float to Int loses decimal

Fix: use an explicit conversion like floor(), round(), or to_int().
`,
};
function getExplanation(code) {
  return EXPLANATIONS[code] || null;
}

// ─── src/registry/block-registry.js ────────────────────

// Block Registry — central registry for block-type plugins.
// Each plugin describes how to detect, parse, analyze, and codegen a block type.

const _plugins = new Map();       // name → plugin
const _astTypeMap = new Map();    // astNodeType → plugin | _NOOP_SENTINEL
const _order = [];                // registration order

// Sentinel value for noop AST types (returned by getByAstType to avoid a second lookup)
const _NOOP_SENTINEL = Object.freeze({ __noop: true });
const BlockRegistry = {
  NOOP: _NOOP_SENTINEL,

  register(plugin) {
    if (_plugins.has(plugin.name)) {
      throw new Error(`Block plugin "${plugin.name}" already registered`);
    }
    _plugins.set(plugin.name, plugin);
    _order.push(plugin);

    // Map primary AST node type
    if (plugin.astNodeType) {
      _astTypeMap.set(plugin.astNodeType, plugin);
    }

    // Map child AST node types (for analyzer dispatch)
    if (plugin.analyzer?.childNodeTypes) {
      for (const t of plugin.analyzer.childNodeTypes) {
        _astTypeMap.set(t, plugin);
      }
    }

    // Register no-op leaf types as sentinel in the same map
    if (plugin.analyzer?.noopNodeTypes) {
      for (const t of plugin.analyzer.noopNodeTypes) {
        _astTypeMap.set(t, _NOOP_SENTINEL);
      }
    }
  },

  get(name) {
    return _plugins.get(name) || null;
  },

  getByAstType(type) {
    return _astTypeMap.get(type) || null;
  },

  isNoopType(type) {
    return _astTypeMap.get(type) === _NOOP_SENTINEL;
  },

  all() {
    return _order; // callers must not mutate; treated as read-only
  },
};

// ─── src/parser/server-parser.js ───────────────────────

// Server-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when server { } blocks are encountered.
function installServerParser(ParserClass) {
  if (ParserClass.prototype._serverParserInstalled) return;
  ParserClass.prototype._serverParserInstalled = true;

  ParserClass.prototype.parseServerBlock = function() {
    const l = this.loc();
    this.expect(TokenType.SERVER);
    // Optional block name: server "api" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'server'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseServerStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close server block");
    return new AST.ServerBlock(body, l, name);
  };

  ParserClass.prototype.parseServerStatement = function() {
    if (this.check(TokenType.ROUTE)) return this.parseRoute();

    // Contextual keywords in server blocks
    if (this.check(TokenType.IDENTIFIER)) {
      const val = this.current().value;
      if (val === 'middleware' && this.peek(1).type === TokenType.FN) {
        return this.parseMiddleware();
      }
      if (val === 'health') {
        return this.parseHealthCheck();
      }
      if (val === 'cors' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCorsConfig();
      }
      if (val === 'on_error' && this.peek(1).type === TokenType.FN) {
        return this.parseErrorHandler();
      }
      if (val === 'ws' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseWebSocket();
      }
      if (val === 'static' && this.peek(1).type === TokenType.STRING) {
        return this.parseStaticDeclaration();
      }
      if (val === 'discover' && this.peek(1).type === TokenType.STRING) {
        return this.parseDiscover();
      }
      if (val === 'auth' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseAuthConfig();
      }
      if (val === 'max_body') {
        return this.parseMaxBody();
      }
      if (val === 'routes' && this.peek(1).type === TokenType.STRING) {
        return this.parseRouteGroup();
      }
      if (val === 'rate_limit' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseRateLimitConfig();
      }
      if (val === 'on_start' && this.peek(1).type === TokenType.FN) {
        return this.parseLifecycleHook('start');
      }
      if (val === 'on_stop' && this.peek(1).type === TokenType.FN) {
        return this.parseLifecycleHook('stop');
      }
      if (val === 'subscribe' && this.peek(1).type === TokenType.STRING) {
        return this.parseSubscribe();
      }
      if (val === 'env' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseEnvDeclaration();
      }
      if (val === 'schedule' && this.peek(1).type === TokenType.STRING) {
        return this.parseSchedule();
      }
      if (val === 'upload' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseUploadConfig();
      }
      if (val === 'session' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSessionConfig();
      }
      if (val === 'db' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseDbConfig();
      }
      if (val === 'tls' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseTlsConfig();
      }
      if (val === 'compression' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCompressionConfig();
      }
      if (val === 'background' && this.peek(1).type === TokenType.FN) {
        return this.parseBackgroundJob();
      }
      if (val === 'cache' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCacheConfig();
      }
      if (val === 'sse' && this.peek(1).type === TokenType.STRING) {
        return this.parseSseDeclaration();
      }
      if (val === 'model' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseModelDeclaration();
      }
      // ai { ... } or ai "name" { ... }
      if (val === 'ai' && (this.peek(1).type === TokenType.LBRACE || this.peek(1).type === TokenType.STRING)) {
        return this.parseAiConfig();
      }
    }

    return this.parseStatement();
  };

  ParserClass.prototype.parseMiddleware = function() {
    const l = this.loc();
    this.advance(); // consume 'middleware'
    this.expect(TokenType.FN);
    const name = this.expect(TokenType.IDENTIFIER, "Expected middleware name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after middleware name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after middleware parameters");
    const body = this.parseBlock();
    return new AST.MiddlewareDeclaration(name, params, body, l);
  };

  ParserClass.prototype.parseHealthCheck = function() {
    const l = this.loc();
    this.advance(); // consume 'health'
    const path = this.expect(TokenType.STRING, "Expected health check path string");
    // Optional enriched checks block: health "/health" { check_memory, check_db }
    const checks = [];
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume '{'
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const checkName = this.expect(TokenType.IDENTIFIER, "Expected health check name").value;
        checks.push(checkName);
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close health check config");
    }
    return new AST.HealthCheckDeclaration(path.value, l, checks);
  };

  ParserClass.prototype.parseCorsConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'cors'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cors'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected cors config key").value;
      this.expect(TokenType.COLON, "Expected ':' after cors key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cors config");
    return new AST.CorsDeclaration(config, l);
  };

  ParserClass.prototype.parseErrorHandler = function() {
    const l = this.loc();
    this.advance(); // consume 'on_error'
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after error handler parameters");
    const body = this.parseBlock();
    return new AST.ErrorHandlerDeclaration(params, body, l);
  };

  ParserClass.prototype.parseWebSocket = function() {
    const l = this.loc();
    this.advance(); // consume 'ws'
    this.expect(TokenType.LBRACE, "Expected '{' after 'ws'");

    const handlers = {};
    const config = {};
    const validEvents = ['on_open', 'on_message', 'on_close', 'on_error'];
    const validConfigKeys = ['auth'];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const name = this.expect(TokenType.IDENTIFIER, "Expected WebSocket event handler name or config key").value;
      if (validConfigKeys.includes(name)) {
        // Config key: auth: <expr>
        this.expect(TokenType.COLON, `Expected ':' after '${name}'`);
        config[name] = this.parseExpression();
        this.match(TokenType.COMMA);
      } else if (validEvents.includes(name)) {
        this.expect(TokenType.FN, "Expected 'fn' after event name");
        this.expect(TokenType.LPAREN);
        const params = this.parseParameterList();
        this.expect(TokenType.RPAREN);
        const body = this.parseBlock();
        handlers[name] = { params, body };
      } else {
        this.error(`Invalid WebSocket key '${name}'. Expected one of: ${[...validConfigKeys, ...validEvents].join(', ')}`);
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close ws block");
    const wsConfig = Object.keys(config).length > 0 ? config : null;
    return new AST.WebSocketDeclaration(handlers, l, wsConfig);
  };

  ParserClass.prototype.parseStaticDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'static'
    const urlPath = this.expect(TokenType.STRING, "Expected URL path for static files").value;
    this.expect(TokenType.ARROW, "Expected '=>' after static path");
    const dir = this.expect(TokenType.STRING, "Expected directory path for static files").value;
    let fallback = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'fallback') {
      this.advance(); // consume 'fallback'
      fallback = this.expect(TokenType.STRING, "Expected fallback file path").value;
    }
    return new AST.StaticDeclaration(urlPath, dir, l, fallback);
  };

  ParserClass.prototype.parseDiscover = function() {
    const l = this.loc();
    this.advance(); // consume 'discover'
    const peerName = this.expect(TokenType.STRING, "Expected peer name string after 'discover'").value;
    // Expect 'at' as contextual keyword
    const atTok = this.expect(TokenType.IDENTIFIER, "Expected 'at' after peer name");
    if (atTok.value !== 'at') {
      this.error("Expected 'at' after peer name in discover declaration");
    }
    const urlExpression = this.parseExpression();
    let config = null;
    if (this.check(TokenType.WITH)) {
      this.advance(); // consume 'with'
      this.expect(TokenType.LBRACE, "Expected '{' after 'with'");
      config = {};
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const key = this.expect(TokenType.IDENTIFIER, "Expected config key").value;
        this.expect(TokenType.COLON, "Expected ':' after config key");
        const value = this.parseExpression();
        config[key] = value;
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close discover config");
    }
    return new AST.DiscoverDeclaration(peerName, urlExpression, l, config);
  };

  ParserClass.prototype.parseAuthConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'auth'
    this.expect(TokenType.LBRACE, "Expected '{' after 'auth'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      // Accept keywords (like 'type') and identifiers as config keys
      let key;
      if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.TYPE)) {
        key = this.advance().value;
      } else {
        this.error("Expected auth config key");
      }
      this.expect(TokenType.COLON, "Expected ':' after auth key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close auth config");
    return new AST.AuthDeclaration(config, l);
  };

  ParserClass.prototype.parseMaxBody = function() {
    const l = this.loc();
    this.advance(); // consume 'max_body'
    const limit = this.parseExpression();
    return new AST.MaxBodyDeclaration(limit, l);
  };

  ParserClass.prototype.parseRouteGroup = function() {
    const l = this.loc();
    this.advance(); // consume 'routes'
    const prefix = this.expect(TokenType.STRING, "Expected route group prefix string").value;

    // Optional version config: routes "/api/v2" version: "2" deprecated: true { ... }
    let version = null;
    while (this.check(TokenType.IDENTIFIER) && !this.isAtEnd()) {
      const key = this.current().value;
      if (key === 'version' || key === 'deprecated' || key === 'sunset') {
        this.advance(); // consume key
        this.expect(TokenType.COLON, `Expected ':' after '${key}'`);
        const value = this.parseExpression();
        if (!version) version = {};
        if (key === 'version') {
          version.version = value.value !== undefined ? value.value : value;
        } else if (key === 'deprecated') {
          version.deprecated = value.value !== undefined ? value.value : true;
        } else if (key === 'sunset') {
          version.sunset = value.value !== undefined ? value.value : value;
        }
      } else {
        break;
      }
    }

    this.expect(TokenType.LBRACE, "Expected '{' after route group prefix");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseServerStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close route group");
    return new AST.RouteGroupDeclaration(prefix, body, l, version);
  };

  ParserClass.prototype.parseRateLimitConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'rate_limit'
    this.expect(TokenType.LBRACE, "Expected '{' after 'rate_limit'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected rate_limit config key").value;
      this.expect(TokenType.COLON, "Expected ':' after rate_limit key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close rate_limit config");
    return new AST.RateLimitDeclaration(config, l);
  };

  ParserClass.prototype.parseLifecycleHook = function(hookName) {
    const l = this.loc();
    this.advance(); // consume 'on_start' or 'on_stop'
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after lifecycle hook parameters");
    const body = this.parseBlock();
    return new AST.LifecycleHookDeclaration(hookName, params, body, l);
  };

  ParserClass.prototype.parseSubscribe = function() {
    const l = this.loc();
    this.advance(); // consume 'subscribe'
    const event = this.expect(TokenType.STRING, "Expected event name string").value;
    this.expect(TokenType.FN, "Expected 'fn' after event name");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after subscribe parameters");
    const body = this.parseBlock();
    return new AST.SubscribeDeclaration(event, params, body, l);
  };

  ParserClass.prototype.parseEnvDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'env'
    const name = this.expect(TokenType.IDENTIFIER, "Expected env variable name").value;
    this.expect(TokenType.COLON, "Expected ':' after env variable name");
    const typeAnnotation = this.parseTypeAnnotation();
    let defaultValue = null;
    if (this.match(TokenType.ASSIGN)) {
      defaultValue = this.parseExpression();
    }
    return new AST.EnvDeclaration(name, typeAnnotation, defaultValue, l);
  };

  ParserClass.prototype.parseSchedule = function() {
    const l = this.loc();
    this.advance(); // consume 'schedule'
    const pattern = this.expect(TokenType.STRING, "Expected schedule pattern string").value;
    this.expect(TokenType.FN, "Expected 'fn' after schedule pattern");
    let name = null;
    if (this.check(TokenType.IDENTIFIER)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LPAREN, "Expected '(' after schedule fn");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after schedule parameters");
    const body = this.parseBlock();
    return new AST.ScheduleDeclaration(pattern, name, params, body, l);
  };

  ParserClass.prototype.parseUploadConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'upload'
    this.expect(TokenType.LBRACE, "Expected '{' after 'upload'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected upload config key").value;
      this.expect(TokenType.COLON, "Expected ':' after upload key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close upload config");
    return new AST.UploadDeclaration(config, l);
  };

  ParserClass.prototype.parseSessionConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'session'
    this.expect(TokenType.LBRACE, "Expected '{' after 'session'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected session config key").value;
      this.expect(TokenType.COLON, "Expected ':' after session key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close session config");
    return new AST.SessionDeclaration(config, l);
  };

  ParserClass.prototype.parseAiConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'ai'

    // Optional name: ai "claude" { ... }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }

    this.expect(TokenType.LBRACE, "Expected '{' after 'ai'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected ai config key").value;
      this.expect(TokenType.COLON, "Expected ':' after ai config key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close ai config");
    return new AST.AiConfigDeclaration(name, config, l);
  };

  ParserClass.prototype.parseDbConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'db'
    this.expect(TokenType.LBRACE, "Expected '{' after 'db'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected db config key").value;
      this.expect(TokenType.COLON, "Expected ':' after db key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close db config");
    return new AST.DbDeclaration(config, l);
  };

  ParserClass.prototype.parseTlsConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'tls'
    this.expect(TokenType.LBRACE, "Expected '{' after 'tls'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected tls config key").value;
      this.expect(TokenType.COLON, "Expected ':' after tls key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close tls config");
    return new AST.TlsDeclaration(config, l);
  };

  ParserClass.prototype.parseCompressionConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'compression'
    this.expect(TokenType.LBRACE, "Expected '{' after 'compression'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected compression config key").value;
      this.expect(TokenType.COLON, "Expected ':' after compression key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close compression config");
    return new AST.CompressionDeclaration(config, l);
  };

  ParserClass.prototype.parseBackgroundJob = function() {
    const l = this.loc();
    this.advance(); // consume 'background'
    this.expect(TokenType.FN, "Expected 'fn' after 'background'");
    const name = this.expect(TokenType.IDENTIFIER, "Expected background job name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after background job name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after background job parameters");
    const body = this.parseBlock();
    return new AST.BackgroundJobDeclaration(name, params, body, l);
  };

  ParserClass.prototype.parseCacheConfig = function() {
    const l = this.loc();
    this.advance(); // consume 'cache'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cache'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected cache config key").value;
      this.expect(TokenType.COLON, "Expected ':' after cache key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cache config");
    return new AST.CacheDeclaration(config, l);
  };

  ParserClass.prototype.parseSseDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'sse'
    const path = this.expect(TokenType.STRING, "Expected SSE endpoint path").value;
    this.expect(TokenType.FN, "Expected 'fn' after SSE path");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after SSE parameters");
    const body = this.parseBlock();
    return new AST.SseDeclaration(path, params, body, l);
  };

  ParserClass.prototype.parseModelDeclaration = function() {
    const l = this.loc();
    this.advance(); // consume 'model'
    const name = this.expect(TokenType.IDENTIFIER, "Expected model/type name after 'model'").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume '{'
      config = {};
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const key = this.expect(TokenType.IDENTIFIER, "Expected model config key").value;
        this.expect(TokenType.COLON, "Expected ':' after model config key");
        const value = this.parseExpression();
        config[key] = value;
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close model config");
    }
    return new AST.ModelDeclaration(name, config, l);
  };

  ParserClass.prototype.parseRoute = function() {
    const l = this.loc();
    this.expect(TokenType.ROUTE);

    // HTTP method: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS (as identifiers)
    const methodTok = this.expect(TokenType.IDENTIFIER, "Expected HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)");
    const method = methodTok.value.toUpperCase();
    if (!['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'].includes(method)) {
      this.error(`Invalid HTTP method: ${method}`);
    }

    const path = this.expect(TokenType.STRING, "Expected route path string");

    // Optional body type annotation: route POST "/api/users" body: User => handler
    let bodyType = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'body') {
      const next = this.peek(1);
      if (next && next.type === TokenType.COLON) {
        this.advance(); // consume 'body'
        this.advance(); // consume ':'
        bodyType = this.parseTypeAnnotation();
      }
    }

    // Optional decorators: route GET "/path" with auth, role("admin") => handler
    let decorators = [];
    if (this.check(TokenType.WITH)) {
      this.advance(); // consume 'with'
      // Parse comma-separated decorator list
      do {
        const decName = this.expect(TokenType.IDENTIFIER, "Expected decorator name").value;
        let decArgs = [];
        if (this.check(TokenType.LPAREN)) {
          this.advance(); // (
          while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
            decArgs.push(this.parseExpression());
            if (!this.match(TokenType.COMMA)) break;
          }
          this.expect(TokenType.RPAREN, "Expected ')' after decorator arguments");
        }
        decorators.push({ name: decName, args: decArgs });
      } while (this.match(TokenType.COMMA));
    }

    // Optional response type annotation: route GET "/api/users" -> [User] => handler
    let responseType = null;
    if (this.check(TokenType.THIN_ARROW)) {
      this.advance(); // consume '->'
      responseType = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ARROW, "Expected '=>' after route path");
    const handler = this.parseExpression();

    return new AST.RouteDeclaration(method, path.value, handler, l, decorators, bodyType, responseType);
  };
}

// ─── src/parser/form-parser.js ─────────────────────────

// Form-specific parser methods for the Tova language
// Extracted for lazy loading — only loaded when form { } blocks are encountered.
function installFormParser(ParserClass) {
  if (ParserClass.prototype._formParserInstalled) return;
  ParserClass.prototype._formParserInstalled = true;

  ParserClass.prototype.parseFormDeclaration = function() {
    const l = this.loc();
    this.expect(TokenType.FORM);
    const name = this.expect(TokenType.IDENTIFIER, "Expected form name").value;

    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.LBRACE, "Expected '{' after form name");

    const fields = [];
    const groups = [];
    const arrays = [];
    const computeds = [];
    let steps = null;
    let onSubmit = null;

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.FIELD)) {
        fields.push(this.parseFormField());
      } else if (this.check(TokenType.GROUP)) {
        groups.push(this.parseFormGroup());
      } else if (this._checkFormContextual('array')) {
        arrays.push(this.parseFormArray());
      } else if (this.check(TokenType.COMPUTED)) {
        computeds.push(this.parseComputed());
      } else if (this.check(TokenType.STEPS)) {
        steps = this.parseFormSteps();
      } else if (this._checkFormContextual('on') && this._peekFormContextual(1, 'submit')) {
        onSubmit = this.parseFormOnSubmit();
      } else {
        this.error("Expected 'field', 'group', 'array', 'computed', 'steps', or 'on submit' inside form block");
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close form block");
    return new FormDeclaration(name, typeAnnotation, fields, groups, arrays, computeds, steps, onSubmit, l);
  };

  ParserClass.prototype.parseFormField = function() {
    const l = this.loc();
    this.expect(TokenType.FIELD);
    const name = this.expect(TokenType.IDENTIFIER, "Expected field name").value;

    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    let initialValue = null;
    if (this.match(TokenType.ASSIGN)) {
      initialValue = this.parseExpression();
    }

    const validators = [];
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume {
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        validators.push(this.parseFormValidator());
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close validator block");
    }

    return new FormFieldDeclaration(name, typeAnnotation, initialValue, validators, l);
  };

  ParserClass.prototype.parseFormValidator = function() {
    const l = this.loc();
    let isAsync = false;
    if (this.check(TokenType.ASYNC)) {
      isAsync = true;
      this.advance();
    }
    const name = this.expect(TokenType.IDENTIFIER, "Expected validator name").value;

    const args = [];
    if (this.match(TokenType.LPAREN)) {
      if (!this.check(TokenType.RPAREN)) {
        args.push(this.parseExpression());
        while (this.match(TokenType.COMMA)) {
          args.push(this.parseExpression());
        }
      }
      this.expect(TokenType.RPAREN, "Expected ')' after validator arguments");
    }

    return new FormValidator(name, args, isAsync, l);
  };

  ParserClass.prototype.parseFormGroup = function() {
    const l = this.loc();
    this.expect(TokenType.GROUP);
    const name = this.expect(TokenType.IDENTIFIER, "Expected group name").value;

    let condition = null;
    if (this.check(TokenType.WHEN)) {
      this.advance(); // consume 'when'
      condition = this.parseExpression();
    }

    this.expect(TokenType.LBRACE, "Expected '{' after group name");

    const fields = [];
    const groups = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.FIELD)) {
        fields.push(this.parseFormField());
      } else if (this.check(TokenType.GROUP)) {
        groups.push(this.parseFormGroup());
      } else {
        this.error("Expected 'field' or 'group' inside form group");
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close group block");
    return new FormGroupDeclaration(name, condition, fields, groups, l);
  };

  ParserClass.prototype.parseFormArray = function() {
    const l = this.loc();
    this.advance(); // consume 'array' (contextual keyword — it's an IDENTIFIER with value "array")
    const name = this.expect(TokenType.IDENTIFIER, "Expected array name").value;

    this.expect(TokenType.LBRACE, "Expected '{' after array name");

    const fields = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.FIELD)) {
        fields.push(this.parseFormField());
      } else {
        this.error("Expected 'field' inside form array");
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close array block");
    return new FormArrayDeclaration(name, fields, [], l);
  };

  ParserClass.prototype.parseFormSteps = function() {
    const l = this.loc();
    this.expect(TokenType.STEPS);
    this.expect(TokenType.LBRACE, "Expected '{' after steps");

    const stepsArr = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      stepsArr.push(this.parseFormStep());
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close steps block");
    return new FormStepsDeclaration(stepsArr, l);
  };

  ParserClass.prototype.parseFormStep = function() {
    const l = this.loc();
    if (!this._checkFormContextual('step')) {
      this.error("Expected 'step' inside steps block");
    }
    this.advance(); // consume 'step'
    const label = this.expect(TokenType.STRING, "Expected step label string").value;
    this.expect(TokenType.LBRACE, "Expected '{' after step label");

    const members = [];
    members.push(this.expect(TokenType.IDENTIFIER, "Expected field/group/array name").value);
    while (this.match(TokenType.COMMA)) {
      members.push(this.expect(TokenType.IDENTIFIER, "Expected field/group/array name").value);
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close step");
    return new FormStep(label, members, l);
  };

  ParserClass.prototype.parseFormOnSubmit = function() {
    this.advance(); // consume 'on'
    this.advance(); // consume 'submit'
    return this.parseBlock();
  };

  // Helper: check if current token is an identifier with a specific value
  if (!ParserClass.prototype._checkFormContextual) {
    ParserClass.prototype._checkFormContextual = function(name) {
      return this.check(TokenType.IDENTIFIER) && this.current().value === name;
    };
  }

  if (!ParserClass.prototype._peekFormContextual) {
    ParserClass.prototype._peekFormContextual = function(offset, name) {
      const token = this.peek(offset);
      return token && token.type === TokenType.IDENTIFIER && token.value === name;
    };
  }
}

// ─── src/parser/browser-parser.js ──────────────────────

// Browser-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when browser { } blocks are encountered.
function installBrowserParser(ParserClass) {
  if (ParserClass.prototype._browserParserInstalled) return;
  ParserClass.prototype._browserParserInstalled = true;

  installFormParser(ParserClass);

  ParserClass.prototype.parseBrowserBlock = function() {
    const l = this.loc();
    // Capture the keyword value before consuming for deprecation warning
    const keyword = this.current().value;
    this.expect(TokenType.BROWSER);
    if (keyword === 'client') {
      this.warnings = this.warnings || [];
      this.warnings.push({
        message: "`client` block is deprecated, use `browser` instead",
        loc: l,
      });
    }
    // Optional block name: browser "admin" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'browser'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseBrowserStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close browser block");
    return new AST.BrowserBlock(body, l, name);
  };

  ParserClass.prototype.parseBrowserStatement = function() {
    if (this.check(TokenType.STATE)) return this.parseState();
    if (this.check(TokenType.COMPUTED)) return this.parseComputed();
    if (this.check(TokenType.EFFECT)) return this.parseEffect();
    if (this.check(TokenType.COMPONENT)) return this.parseComponent();
    if (this.check(TokenType.STORE)) return this.parseStore();
    if (this.check(TokenType.FORM)) return this.parseFormDeclaration();
    return this.parseStatement();
  };

  ParserClass.prototype.parseStore = function() {
    const l = this.loc();
    this.expect(TokenType.STORE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected store name").value;
    this.expect(TokenType.LBRACE, "Expected '{' after store name");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.STATE)) {
        body.push(this.parseState());
      } else if (this.check(TokenType.COMPUTED)) {
        body.push(this.parseComputed());
      } else if (this.check(TokenType.FN) && (this.peek(1).type === TokenType.IDENTIFIER || this._isContextualKeywordToken(this.peek(1)))) {
        body.push(this.parseFunctionDeclaration());
      } else {
        this.error("Expected 'state', 'computed', or 'fn' inside store block");
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close store block");

    return new AST.StoreDeclaration(name, body, l);
  };

  ParserClass.prototype.parseState = function() {
    const l = this.loc();
    this.expect(TokenType.STATE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected state variable name").value;

    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in state declaration");
    const value = this.parseExpression();

    return new AST.StateDeclaration(name, typeAnnotation, value, l);
  };

  ParserClass.prototype.parseComputed = function() {
    const l = this.loc();
    this.expect(TokenType.COMPUTED);
    const name = this.expect(TokenType.IDENTIFIER, "Expected computed variable name").value;
    this.expect(TokenType.ASSIGN, "Expected '=' in computed declaration");
    const expr = this.parseExpression();

    return new AST.ComputedDeclaration(name, expr, l);
  };

  ParserClass.prototype.parseEffect = function() {
    const l = this.loc();
    this.expect(TokenType.EFFECT);
    const body = this.parseBlock();
    return new AST.EffectDeclaration(body, l);
  };

  ParserClass.prototype.parseComponent = function() {
    const l = this.loc();
    this.expect(TokenType.COMPONENT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected component name").value;

    let params = [];
    if (this.match(TokenType.LPAREN)) {
      params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after component parameters");
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open component body");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.STYLE_BLOCK)) {
        const sl = this.loc();
        const css = this.current().value;
        this.advance();
        body.push(new AST.ComponentStyleBlock(css, sl));
      } else if (this.check(TokenType.LESS) && this._looksLikeJSX()) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STATE)) {
        body.push(this.parseState());
      } else if (this.check(TokenType.COMPUTED)) {
        body.push(this.parseComputed());
      } else if (this.check(TokenType.EFFECT)) {
        body.push(this.parseEffect());
      } else if (this.check(TokenType.COMPONENT)) {
        body.push(this.parseComponent());
      } else if (this.check(TokenType.FORM)) {
        body.push(this.parseFormDeclaration());
      } else {
        body.push(this.parseStatement());
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close component body");

    return new AST.ComponentDeclaration(name, params, body, l);
  };

  // ─── JSX-like parsing ─────────────────────────────────────

  ParserClass.prototype._collapseJSXWhitespace = function(text) {
    let result = text.replace(/\s+/g, ' ');
    if (result.trim() === '') return '';
    return result.trim();
  };

  ParserClass.prototype.parseJSXElementOrFragment = function() {
    // Check if this is a fragment: <>...</>
    if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.GREATER) {
      return this.parseJSXFragment();
    }
    return this.parseJSXElement();
  };

  ParserClass.prototype.parseJSXFragment = function() {
    const l = this.loc();
    this.expect(TokenType.LESS, "Expected '<'");
    this.expect(TokenType.GREATER, "Expected '>' in fragment opening");

    // Parse children until </>
    const children = this.parseJSXFragmentChildren();

    return new AST.JSXFragment(children, l);
  };

  ParserClass.prototype.parseJSXFragmentChildren = function() {
    const children = [];

    while (!this.isAtEnd()) {
      // Closing fragment: </>
      if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.SLASH) {
        // Check for </> (fragment close) vs </tag> (error)
        if (this.peek(2).type === TokenType.GREATER) {
          this.advance(); // <
          this.advance(); // /
          this.advance(); // >
          break;
        } else {
          this.error("Unexpected closing tag inside fragment. Use </> to close a fragment");
        }
      }

      // Nested element or fragment
      if (this.check(TokenType.LESS)) {
        if (this.peek(1).type === TokenType.GREATER) {
          children.push(this.parseJSXFragment());
        } else {
          children.push(this.parseJSXElement());
        }
        continue;
      }

      // String literal as text
      if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        const str = this.parseStringLiteral();
        children.push(new AST.JSXText(str, this.loc()));
        continue;
      }

      // Unquoted JSX text
      if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          children.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
        continue;
      }

      // Expression in braces: {expr}
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after JSX expression");
        children.push(new AST.JSXExpression(expr, this.loc()));
        continue;
      }

      // for loop inside JSX
      if (this.check(TokenType.FOR)) {
        children.push(this.parseJSXFor());
        continue;
      }

      // if inside JSX
      if (this.check(TokenType.IF)) {
        children.push(this.parseJSXIf());
        continue;
      }

      // match inside JSX
      if (this.check(TokenType.MATCH)) {
        children.push(this.parseJSXMatch());
        continue;
      }

      break;
    }

    return children;
  };

  ParserClass.prototype.parseJSXElement = function() {
    const l = this.loc();
    this.expect(TokenType.LESS, "Expected '<'");

    // Accept identifiers and keywords as JSX tag names (e.g., <form>, <label>)
    let tag;
    if (this.check(TokenType.IDENTIFIER) || (this.peek().value in Keywords)) {
      tag = this.advance().value;
    } else {
      tag = this.expect(TokenType.IDENTIFIER, "Expected tag name").value;
    }

    // Parse attributes (including spread: {...expr})
    const attributes = [];
    while (!this.check(TokenType.GREATER) && !this.check(TokenType.SLASH) && !this.isAtEnd()) {
      // Check for spread attribute: {...expr}
      if (this.check(TokenType.LBRACE) && this.peek(1).type === TokenType.SPREAD) {
        const sl = this.loc();
        this.advance(); // {
        this.advance(); // ...
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after spread expression");
        attributes.push(new AST.JSXSpreadAttribute(expr, sl));
      } else {
        attributes.push(this.parseJSXAttribute());
      }
    }

    // Self-closing tag: />
    if (this.match(TokenType.SLASH)) {
      this.expect(TokenType.GREATER, "Expected '>' in self-closing tag");
      return new AST.JSXElement(tag, attributes, [], true, l);
    }

    this.expect(TokenType.GREATER, "Expected '>'");

    // Parse children
    const children = this.parseJSXChildren(tag);

    return new AST.JSXElement(tag, attributes, children, false, l);
  };

  ParserClass.prototype.parseJSXAttribute = function() {
    const l = this.loc();
    // Accept keywords as attribute names (type, class, for, async, defer, etc. are valid HTML attributes)
    let name;
    if (this.check(TokenType.IDENTIFIER) || (this.peek().value in Keywords)) {
      name = this.advance().value;
    } else {
      this.error("Expected attribute name");
    }

    // Handle namespaced attributes: on:click, bind:value, class:active
    if (this.match(TokenType.COLON)) {
      let suffix;
      if (this.check(TokenType.IDENTIFIER) || (this.peek().value in Keywords)) {
        suffix = this.advance().value;
      } else {
        suffix = this.expect(TokenType.IDENTIFIER, "Expected name after ':'").value;
      }
      name = `${name}:${suffix}`;
      // Consume event modifiers: on:click.stop.prevent
      if (name.startsWith('on:') && this.check(TokenType.DOT)) {
        while (this.match(TokenType.DOT)) {
          const mod = this.expect(TokenType.IDENTIFIER, "Expected modifier name after '.'").value;
          name += `.${mod}`;
        }
      }
    }

    if (!this.match(TokenType.ASSIGN)) {
      // Boolean attribute: <input disabled />
      return new AST.JSXAttribute(name, new AST.BooleanLiteral(true, l), l);
    }

    // Value can be {expression} or "string"
    if (this.match(TokenType.LBRACE)) {
      const expr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after attribute expression");
      return new AST.JSXAttribute(name, expr, l);
    }

    if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
      const val = this.parseStringLiteral();
      return new AST.JSXAttribute(name, val, l);
    }

    this.error("Expected attribute value");
  };

  ParserClass.prototype.parseJSXChildren = function(parentTag) {
    const children = [];

    while (!this.isAtEnd()) {
      // Closing tag: </tag>
      if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.SLASH) {
        this.advance(); // <
        this.advance(); // /
        // Accept identifiers and keywords as JSX closing tag names (e.g., </form>)
        let closeTag;
        if (this.check(TokenType.IDENTIFIER) || (this.peek().value in Keywords)) {
          closeTag = this.advance().value;
        } else {
          closeTag = this.expect(TokenType.IDENTIFIER, "Expected closing tag name").value;
        }
        if (closeTag !== parentTag) {
          this.error(`Mismatched closing tag: expected </${parentTag}>, got </${closeTag}>`);
        }
        this.expect(TokenType.GREATER, "Expected '>' in closing tag");
        break;
      }

      // Nested element or fragment
      if (this.check(TokenType.LESS)) {
        children.push(this.parseJSXElementOrFragment());
        continue;
      }

      // String literal as text
      if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        const str = this.parseStringLiteral();
        children.push(new AST.JSXText(str, this.loc()));
        continue;
      }

      // Unquoted JSX text
      if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          children.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
        continue;
      }

      // Expression in braces: {expr}
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after JSX expression");
        children.push(new AST.JSXExpression(expr, this.loc()));
        continue;
      }

      // for loop inside JSX
      if (this.check(TokenType.FOR)) {
        children.push(this.parseJSXFor());
        continue;
      }

      // if inside JSX
      if (this.check(TokenType.IF)) {
        children.push(this.parseJSXIf());
        continue;
      }

      // match inside JSX
      if (this.check(TokenType.MATCH)) {
        children.push(this.parseJSXMatch());
        continue;
      }

      break;
    }

    return children;
  };

  ParserClass.prototype.parseJSXFor = function() {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // Support destructuring: for [i, item] in ..., for {name, age} in ...
    let variable;
    if (this.check(TokenType.LBRACKET)) {
      // Array destructuring: [a, b]
      this.advance(); // consume [
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' in destructuring pattern");
      variable = new AST.ArrayPattern(elements, l);
    } else if (this.check(TokenType.LBRACE)) {
      // Object destructuring: {name, age}
      this.advance(); // consume {
      const props = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        props.push({ key: this.expect(TokenType.IDENTIFIER, "Expected property name in object pattern").value });
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in destructuring pattern");
      variable = new AST.ObjectPattern(props, l);
    } else {
      variable = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
    }

    this.expect(TokenType.IN, "Expected 'in' in for loop");
    const iterable = this.parseExpression();

    // Optional key expression: for item in items key={item.id} { ... }
    let keyExpr = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'key') {
      this.advance(); // consume 'key'
      this.expect(TokenType.ASSIGN, "Expected '=' after 'key'");
      this.expect(TokenType.LBRACE, "Expected '{' after 'key='");
      keyExpr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after key expression");
    }

    this.expect(TokenType.LBRACE, "Expected '{' in JSX for body");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else if (this.check(TokenType.FOR)) {
        body.push(this.parseJSXFor());
      } else if (this.check(TokenType.IF)) {
        body.push(this.parseJSXIf());
      } else if (this.check(TokenType.MATCH)) {
        body.push(this.parseJSXMatch());
      } else {
        break;
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX for body");

    return new AST.JSXFor(variable, iterable, body, l, keyExpr);
  };

  ParserClass.prototype._parseJSXIfBody = function() {
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else if (this.check(TokenType.FOR)) {
        body.push(this.parseJSXFor());
      } else if (this.check(TokenType.IF)) {
        body.push(this.parseJSXIf());
      } else if (this.check(TokenType.MATCH)) {
        body.push(this.parseJSXMatch());
      } else {
        break;
      }
    }
    return body;
  };

  ParserClass.prototype.parseJSXIf = function() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' in JSX if body");
    const consequent = this._parseJSXIfBody();
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX if body");

    // Parse elif chains
    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance(); // consume 'elif'
      const elifCond = this.parseExpression();
      this.expect(TokenType.LBRACE, "Expected '{' in JSX elif body");
      const elifBody = this._parseJSXIfBody();
      this.expect(TokenType.RBRACE, "Expected '}' to close JSX elif body");
      alternates.push({ condition: elifCond, body: elifBody });
    }

    // Parse optional else
    let alternate = null;
    if (this.check(TokenType.ELSE)) {
      this.advance();
      this.expect(TokenType.LBRACE);
      alternate = this._parseJSXIfBody();
      this.expect(TokenType.RBRACE);
    }

    return new AST.JSXIf(condition, consequent, alternate, l, alternates);
  };

  ParserClass.prototype.parseJSXMatch = function() {
    const l = this.loc();
    this.expect(TokenType.MATCH);
    const subject = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' to open JSX match body");

    const arms = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const al = this.loc();
      const pattern = this.parsePattern();

      let guard = null;
      if (this.match(TokenType.IF)) {
        guard = this.parseExpression();
      }

      this.expect(TokenType.ARROW, "Expected '=>' in JSX match arm");

      // Parse arm body as JSX children
      const body = [];
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElementOrFragment());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else if (this.check(TokenType.FOR)) {
        body.push(this.parseJSXFor());
      } else if (this.check(TokenType.IF)) {
        body.push(this.parseJSXIf());
      } else {
        // Fallback to regular expression (e.g., null, number literals)
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
      }

      arms.push({ pattern, guard, body, loc: al });
      this.match(TokenType.COMMA); // Optional comma between arms
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close JSX match body");
    return new AST.JSXMatch(subject, arms, l);
  };
}

// ─── src/parser/security-parser.js ─────────────────────

// Security-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when security { } blocks are encountered.


// Keywords that may appear as config keys inside security blocks
const CONFIG_KEY_TOKENS = new Set([
  TokenType.IDENTIFIER, TokenType.TYPE, TokenType.STORE,
  TokenType.FN, TokenType.MATCH, TokenType.IF,
]);
function installSecurityParser(ParserClass) {
  if (ParserClass.prototype._securityParserInstalled) return;
  ParserClass.prototype._securityParserInstalled = true;

  // Helper: read a config key (identifier or keyword that acts as identifier)
  ParserClass.prototype._expectSecurityConfigKey = function(context) {
    if (CONFIG_KEY_TOKENS.has(this.current().type)) {
      return this.advance().value;
    }
    this.error(`Expected ${context} config key`);
  };

  ParserClass.prototype.parseSecurityBlock = function() {
    const l = this.loc();
    this.advance(); // consume 'security'
    this.expect(TokenType.LBRACE, "Expected '{' after 'security'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseSecurityStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close security block");
    return new AST.SecurityBlock(body, l);
  };

  ParserClass.prototype.parseSecurityStatement = function() {
    if (this.check(TokenType.IDENTIFIER)) {
      const val = this.current().value;

      if (val === 'auth' && (this.peek(1).type === TokenType.IDENTIFIER || this.peek(1).type === TokenType.LBRACE)) {
        return this.parseSecurityAuth();
      }
      if (val === 'role' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseSecurityRole();
      }
      if (val === 'protect' && this.peek(1).type === TokenType.STRING) {
        return this.parseSecurityProtect();
      }
      if (val === 'sensitive' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseSecuritySensitive();
      }
      if (val === 'cors' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSecurityCors();
      }
      if (val === 'csp' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSecurityCsp();
      }
      if (val === 'rate_limit' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSecurityRateLimit();
      }
      if (val === 'csrf' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSecurityCsrf();
      }
      if (val === 'audit' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSecurityAudit();
      }
      if (val === 'trust_proxy') {
        return this.parseSecurityTrustProxy();
      }
      if (val === 'hsts' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSecurityHsts();
      }
    }

    this.error("Expected security declaration (auth, role, protect, sensitive, cors, csp, rate_limit, csrf, audit, trust_proxy, hsts)");
  };

  // auth jwt { secret: ..., expires: ... }
  ParserClass.prototype.parseSecurityAuth = function() {
    const l = this.loc();
    this.advance(); // consume 'auth'
    let authType = 'jwt';
    if (this.check(TokenType.IDENTIFIER)) {
      authType = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after auth type");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("auth");
      this.expect(TokenType.COLON, "Expected ':' after auth key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close auth config");
    return new AST.SecurityAuthDeclaration(authType, config, l);
  };

  // role Admin { can: [manage_users, view_analytics] }
  ParserClass.prototype.parseSecurityRole = function() {
    const l = this.loc();
    this.advance(); // consume 'role'
    const name = this.expect(TokenType.IDENTIFIER, "Expected role name").value;
    this.expect(TokenType.LBRACE, "Expected '{' after role name");
    const permissions = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("role");
      this.expect(TokenType.COLON, "Expected ':' after role key");
      if (key === 'can') {
        // Parse array of identifiers: [manage_users, view_analytics]
        this.expect(TokenType.LBRACKET, "Expected '[' for permissions list");
        while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
          const perm = this.expect(TokenType.IDENTIFIER, "Expected permission name").value;
          permissions.push(perm);
          this.match(TokenType.COMMA);
        }
        this.expect(TokenType.RBRACKET, "Expected ']' to close permissions list");
      } else {
        // Skip unknown keys
        this.parseExpression();
      }
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close role definition");
    return new AST.SecurityRoleDeclaration(name, permissions, l);
  };

  // protect "/api/admin/*" { require: Admin, rate_limit: { max: 100, window: 60 } }
  ParserClass.prototype.parseSecurityProtect = function() {
    const l = this.loc();
    this.advance(); // consume 'protect'
    const pattern = this.expect(TokenType.STRING, "Expected route pattern string").value;
    this.expect(TokenType.LBRACE, "Expected '{' after protect pattern");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("protect");
      this.expect(TokenType.COLON, "Expected ':' after protect key");
      if (key === 'rate_limit') {
        // Nested config: { max: 100, window: 60 }
        this.expect(TokenType.LBRACE, "Expected '{' for rate_limit config");
        const rlConfig = {};
        while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
          const rlKey = this._expectSecurityConfigKey("rate_limit");
          this.expect(TokenType.COLON, "Expected ':' after rate_limit key");
          rlConfig[rlKey] = this.parseExpression();
          this.match(TokenType.COMMA);
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close rate_limit config");
        config[key] = rlConfig;
      } else {
        config[key] = this.parseExpression();
      }
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close protect config");
    return new AST.SecurityProtectDeclaration(pattern, config, l);
  };

  // sensitive User.password { hash: "bcrypt", never_expose: true }
  ParserClass.prototype.parseSecuritySensitive = function() {
    const l = this.loc();
    this.advance(); // consume 'sensitive'
    const typeName = this.expect(TokenType.IDENTIFIER, "Expected type name").value;
    this.expect(TokenType.DOT, "Expected '.' after type name in sensitive declaration");
    const fieldName = this.expect(TokenType.IDENTIFIER, "Expected field name").value;
    this.expect(TokenType.LBRACE, "Expected '{' after sensitive field");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("sensitive");
      this.expect(TokenType.COLON, "Expected ':' after sensitive key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close sensitive config");
    return new AST.SecuritySensitiveDeclaration(typeName, fieldName, config, l);
  };

  // cors { origins: ["..."], methods: [GET, POST], credentials: true }
  ParserClass.prototype.parseSecurityCors = function() {
    const l = this.loc();
    this.advance(); // consume 'cors'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cors'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("cors");
      this.expect(TokenType.COLON, "Expected ':' after cors key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cors config");
    return new AST.SecurityCorsDeclaration(config, l);
  };

  // csp { default_src: ["self"], script_src: ["self"] }
  ParserClass.prototype.parseSecurityCsp = function() {
    const l = this.loc();
    this.advance(); // consume 'csp'
    this.expect(TokenType.LBRACE, "Expected '{' after 'csp'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("csp");
      this.expect(TokenType.COLON, "Expected ':' after csp key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close csp config");
    return new AST.SecurityCspDeclaration(config, l);
  };

  // rate_limit { max: 1000, window: 3600 }
  ParserClass.prototype.parseSecurityRateLimit = function() {
    const l = this.loc();
    this.advance(); // consume 'rate_limit'
    this.expect(TokenType.LBRACE, "Expected '{' after 'rate_limit'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("rate_limit");
      this.expect(TokenType.COLON, "Expected ':' after rate_limit key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close rate_limit config");
    return new AST.SecurityRateLimitDeclaration(config, l);
  };

  // csrf { enabled: true, exempt: ["/api/webhooks/*"] }
  ParserClass.prototype.parseSecurityCsrf = function() {
    const l = this.loc();
    this.advance(); // consume 'csrf'
    this.expect(TokenType.LBRACE, "Expected '{' after 'csrf'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("csrf");
      this.expect(TokenType.COLON, "Expected ':' after csrf key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close csrf config");
    return new AST.SecurityCsrfDeclaration(config, l);
  };

  // trust_proxy true | trust_proxy false | trust_proxy "loopback"
  ParserClass.prototype.parseSecurityTrustProxy = function() {
    const l = this.loc();
    this.advance(); // consume 'trust_proxy'
    // Expect a value: true, false, or "loopback"
    const valueToken = this.advance();
    let value = false;
    if (valueToken.type === TokenType.STRING) {
      value = valueToken.value;
    } else if (valueToken.value === 'true') {
      value = true;
    } else if (valueToken.value === 'false') {
      value = false;
    } else {
      this.error('Expected true, false, or string for trust_proxy');
    }
    return new AST.SecurityTrustProxyDeclaration(value, l);
  };

  // hsts { max_age: 31536000, include_subdomains: true, preload: false }
  ParserClass.prototype.parseSecurityHsts = function() {
    const l = this.loc();
    this.advance(); // consume 'hsts'
    this.expect(TokenType.LBRACE, "Expected '{' after 'hsts'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("hsts");
      this.expect(TokenType.COLON, "Expected ':' after hsts key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close hsts config");
    return new AST.SecurityHstsDeclaration(config, l);
  };

  // audit { events: [login, logout], store: "audit_log", retain: 90 }
  ParserClass.prototype.parseSecurityAudit = function() {
    const l = this.loc();
    this.advance(); // consume 'audit'
    this.expect(TokenType.LBRACE, "Expected '{' after 'audit'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this._expectSecurityConfigKey("audit");
      this.expect(TokenType.COLON, "Expected ':' after audit key");
      config[key] = this.parseExpression();
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close audit config");
    return new AST.SecurityAuditDeclaration(config, l);
  };
}

// ─── src/parser/cli-parser.js ──────────────────────────

// CLI-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when cli { } blocks are encountered.



// Valid config keys inside cli blocks
const CLI_CONFIG_KEYS = new Set(['name', 'version', 'description']);
function installCliParser(ParserClass) {
  if (ParserClass.prototype._cliParserInstalled) return;
  ParserClass.prototype._cliParserInstalled = true;

  ParserClass.prototype.parseCliBlock = function() {
    const l = this.loc();
    this.advance(); // consume 'cli'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cli'");
    const config = [];
    const commands = [];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        // fn or async fn → command
        if (this.check(TokenType.FN) ||
            (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN)) {
          commands.push(this.parseCliCommand());
        }
        // identifier followed by colon → config field
        else if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
          config.push(this.parseCliConfigField());
        }
        else {
          this.error("Expected config field (name: ...) or command (fn ...) inside cli block");
        }
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close cli block");
    return new AST.CliBlock(config, commands, l);
  };

  ParserClass.prototype.parseCliConfigField = function() {
    const l = this.loc();
    const key = this.advance().value; // consume identifier
    this.expect(TokenType.COLON, "Expected ':' after config key");
    const value = this.parseExpression();
    return new CliConfigField(key, value, l);
  };

  ParserClass.prototype.parseCliCommand = function() {
    const l = this.loc();
    let isAsync = false;
    if (this.check(TokenType.ASYNC)) {
      isAsync = true;
      this.advance(); // consume 'async'
    }
    this.expect(TokenType.FN, "Expected 'fn' for cli command");
    const name = this.expect(TokenType.IDENTIFIER, "Expected command name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after command name");
    const params = this.parseCliParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    // Parse body
    const body = this.parseBlock();

    return new CliCommandDeclaration(name, params, body, isAsync, l);
  };

  ParserClass.prototype.parseCliParameterList = function() {
    const params = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      if (params.length > 0) {
        this.expect(TokenType.COMMA, "Expected ',' between parameters");
      }
      params.push(this.parseCliParam());
    }
    return params;
  };

  ParserClass.prototype.parseCliParam = function() {
    const l = this.loc();
    let isFlag = false;

    // Check for -- prefix (two MINUS tokens)
    if (this.check(TokenType.MINUS) && this.peek(1).type === TokenType.MINUS) {
      isFlag = true;
      this.advance(); // consume first -
      this.advance(); // consume second -
    }

    const name = this.expect(TokenType.IDENTIFIER, "Expected parameter name").value;

    // Parse optional type annotation: param: Type, param: Type?, param: [Type]
    let typeAnnotation = null;
    let isOptional = false;
    let isRepeated = false;

    if (this.match(TokenType.COLON)) {
      // [Type] → repeated
      if (this.check(TokenType.LBRACKET)) {
        isRepeated = true;
        this.advance(); // consume [
        typeAnnotation = this._parseCliTypeName();
        this.expect(TokenType.RBRACKET, "Expected ']' after array type");
      } else {
        typeAnnotation = this._parseCliTypeName();
        // Type? → optional
        if (this.check(TokenType.QUESTION)) {
          isOptional = true;
          this.advance(); // consume ?
        }
      }
    }

    // Bool flags are implicitly optional (default false)
    if (isFlag && typeAnnotation === 'Bool' && !isOptional) {
      isOptional = true;
    }

    // Parse default value: = expr
    let defaultValue = null;
    if (this.match(TokenType.ASSIGN)) {
      defaultValue = this.parseExpression();
    }

    return new CliParam(name, typeAnnotation, defaultValue, isFlag, isOptional, isRepeated, l);
  };

  // Helper to parse a simple type name (String, Int, Float, Bool, or IDENTIFIER)
  ParserClass.prototype._parseCliTypeName = function() {
    if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.TYPE)) {
      return this.advance().value;
    }
    this.error("Expected type name");
  };
}

// ─── src/parser/edge-parser.js ─────────────────────────

// Edge/serverless-specific parser methods for the Tova language
// Extracted from parser.js for lazy loading — only loaded when edge { } blocks are encountered.

// Valid config keys inside edge blocks
const EDGE_CONFIG_KEYS = new Set(['target']);

// Valid edge targets
const EDGE_TARGETS = new Set(['cloudflare', 'deno', 'vercel', 'lambda', 'bun']);

// Edge binding keywords (contextual identifiers)
const EDGE_BINDING_KEYWORDS = new Set(['kv', 'sql', 'storage', 'queue', 'env', 'secret']);
function installEdgeParser(ParserClass) {
  if (ParserClass.prototype._edgeParserInstalled) return;
  ParserClass.prototype._edgeParserInstalled = true;

  // Edge reuses parseRoute() and parseMiddleware() from the server parser
  installServerParser(ParserClass);

  ParserClass.prototype.parseEdgeBlock = function() {
    const l = this.loc();
    this.advance(); // consume 'edge'

    // Optional name: edge "api" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }

    this.expect(TokenType.LBRACE, "Expected '{' after 'edge'");
    const body = [];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseEdgeStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close edge block");
    return new AST.EdgeBlock(body, l, name);
  };

  ParserClass.prototype.parseEdgeStatement = function() {
    // route keyword → reuse server route parser
    if (this.check(TokenType.ROUTE)) {
      // Ensure server parser is installed (for parseRoute)
      return this.parseRoute();
    }

    // Contextual keywords in edge blocks
    if (this.check(TokenType.IDENTIFIER)) {
      const val = this.current().value;

      // middleware fn name(req, next) { ... }
      if (val === 'middleware' && this.peek(1).type === TokenType.FN) {
        return this.parseMiddleware();
      }

      // kv BINDING_NAME or kv BINDING_NAME { config }
      if (val === 'kv') {
        return this.parseEdgeKV();
      }

      // sql BINDING_NAME
      if (val === 'sql') {
        return this.parseEdgeSQL();
      }

      // storage BINDING_NAME
      if (val === 'storage') {
        return this.parseEdgeStorage();
      }

      // queue BINDING_NAME
      if (val === 'queue') {
        return this.parseEdgeQueue();
      }

      // env VAR_NAME = default_value
      if (val === 'env') {
        return this.parseEdgeEnv();
      }

      // secret SECRET_NAME
      if (val === 'secret') {
        return this.parseEdgeSecret();
      }

      // schedule "name" cron("...") { body }
      if (val === 'schedule') {
        return this.parseEdgeSchedule();
      }

      // consume QUEUE_NAME fn(messages) { body }
      if (val === 'consume') {
        return this.parseEdgeConsume();
      }

      // health "/path"
      if (val === 'health') {
        return this.parseHealthCheck();
      }

      // cors { ... }
      if (val === 'cors') {
        return this.parseCorsConfig();
      }

      // on_error fn(err, req) { ... }
      if (val === 'on_error') {
        return this.parseErrorHandler();
      }

      // Config field: identifier: value (e.g., target: "cloudflare")
      // Accept any identifier + colon pattern; analyzer validates the key
      if (this.peek(1).type === TokenType.COLON && !EDGE_BINDING_KEYWORDS.has(val)) {
        return this.parseEdgeConfigField();
      }
    }

    // fn or async fn → regular function declaration
    if (this.check(TokenType.FN) ||
        (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN)) {
      return this.parseStatement();
    }

    // Fallback to regular statement
    return this.parseStatement();
  };

  ParserClass.prototype.parseEdgeConfigField = function() {
    const l = this.loc();
    const key = this.advance().value; // consume identifier (e.g., 'target')
    this.expect(TokenType.COLON, "Expected ':' after config key");
    const value = this.parseExpression();
    return new EdgeConfigField(key, value, l);
  };

  ParserClass.prototype.parseEdgeKV = function() {
    const l = this.loc();
    this.advance(); // consume 'kv'
    const name = this.expect(TokenType.IDENTIFIER, "Expected KV binding name").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      config = this._parseEdgeBindingConfig();
    }
    return new EdgeKVDeclaration(name, config, l);
  };

  ParserClass.prototype.parseEdgeSQL = function() {
    const l = this.loc();
    this.advance(); // consume 'sql'
    const name = this.expect(TokenType.IDENTIFIER, "Expected SQL binding name").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      config = this._parseEdgeBindingConfig();
    }
    return new EdgeSQLDeclaration(name, config, l);
  };

  ParserClass.prototype.parseEdgeStorage = function() {
    const l = this.loc();
    this.advance(); // consume 'storage'
    const name = this.expect(TokenType.IDENTIFIER, "Expected storage binding name").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      config = this._parseEdgeBindingConfig();
    }
    return new EdgeStorageDeclaration(name, config, l);
  };

  ParserClass.prototype.parseEdgeQueue = function() {
    const l = this.loc();
    this.advance(); // consume 'queue'
    const name = this.expect(TokenType.IDENTIFIER, "Expected queue binding name").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      config = this._parseEdgeBindingConfig();
    }
    return new EdgeQueueDeclaration(name, config, l);
  };

  ParserClass.prototype.parseEdgeEnv = function() {
    const l = this.loc();
    this.advance(); // consume 'env'
    const name = this.expect(TokenType.IDENTIFIER, "Expected env var name").value;
    let defaultValue = null;
    if (this.match(TokenType.ASSIGN)) {
      defaultValue = this.parseExpression();
    }
    return new EdgeEnvDeclaration(name, defaultValue, l);
  };

  ParserClass.prototype.parseEdgeSecret = function() {
    const l = this.loc();
    this.advance(); // consume 'secret'
    const name = this.expect(TokenType.IDENTIFIER, "Expected secret name").value;
    return new EdgeSecretDeclaration(name, l);
  };

  ParserClass.prototype.parseEdgeSchedule = function() {
    const l = this.loc();
    this.advance(); // consume 'schedule'
    const name = this.expect(TokenType.STRING, "Expected schedule name string").value;

    // cron("expression")
    const cronIdent = this.expect(TokenType.IDENTIFIER, "Expected 'cron' after schedule name");
    if (cronIdent.value !== 'cron') {
      this.error("Expected 'cron' keyword after schedule name");
    }
    this.expect(TokenType.LPAREN, "Expected '(' after 'cron'");
    const cronExpr = this.expect(TokenType.STRING, "Expected cron expression string").value;
    this.expect(TokenType.RPAREN, "Expected ')' after cron expression");

    const body = this.parseBlock();
    return new EdgeScheduleDeclaration(name, cronExpr, body, l);
  };

  ParserClass.prototype.parseEdgeConsume = function() {
    const l = this.loc();
    this.advance(); // consume 'consume'
    const queue = this.expect(TokenType.IDENTIFIER, "Expected queue name").value;

    // fn(messages) { ... } or a function reference
    this.expect(TokenType.FN, "Expected 'fn' after queue name in consume");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after consume parameters");
    const body = this.parseBlock();

    const handler = new AST.LambdaExpression(params, body, l);
    return new EdgeConsumeDeclaration(queue, handler, l);
  };

  // Helper: parse { key: value, ... } config block for bindings
  ParserClass.prototype._parseEdgeBindingConfig = function() {
    this.expect(TokenType.LBRACE, "Expected '{' for binding config");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected config key").value;
      this.expect(TokenType.COLON, "Expected ':' after config key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close binding config");
    return config;
  };
}

// ─── src/parser/concurrency-parser.js ──────────────────

// Concurrency-specific parser methods for the Tova language
// Extracted for lazy loading — only loaded when concurrent { } blocks are used.




const CONCURRENT_MODES = new Set(['cancel_on_error', 'first', 'timeout']);
function installConcurrencyParser(ParserClass) {
  if (ParserClass.prototype._concurrencyParserInstalled) return;
  ParserClass.prototype._concurrencyParserInstalled = true;

  /**
   * Parse: concurrent [mode] { body }
   *
   * Modes:
   *   concurrent { ... }                  — mode "all" (default)
   *   concurrent cancel_on_error { ... }  — cancel siblings on first error
   *   concurrent first { ... }            — return first result, cancel rest
   *   concurrent timeout(ms) { ... }      — timeout after ms milliseconds
   */
  ParserClass.prototype.parseConcurrentBlock = function() {
    const l = this.loc();
    this.advance(); // consume 'concurrent'

    let mode = 'all';
    let timeout = null;

    // Check for mode modifier
    if (this.check(TokenType.IDENTIFIER) && CONCURRENT_MODES.has(this.current().value)) {
      const modeName = this.advance().value;
      if (modeName === 'timeout') {
        this.expect(TokenType.LPAREN, "Expected '(' after 'timeout'");
        timeout = this.parseExpression();
        this.expect(TokenType.RPAREN, "Expected ')' after timeout value");
        mode = 'timeout';
      } else {
        mode = modeName;
      }
    }

    this.expect(TokenType.LBRACE, "Expected '{' after 'concurrent'");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close concurrent block");
    return new AST.ConcurrentBlock(mode, timeout, body, l);
  };

  // Save the original parseUnary method to extend it with spawn support
  const _originalParseUnary = ParserClass.prototype.parseUnary;

  /**
   * Extend parseUnary to handle `spawn` as a prefix expression.
   * spawn foo(args) → SpawnExpression
   * Works like `await` but for concurrent task spawning.
   */
  ParserClass.prototype.parseUnary = function() {
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'spawn') {
      // Distinguish concurrency `spawn foo()` from stdlib function call `spawn("cmd", args)`.
      // If `spawn` is followed by `(`, it's a regular function call, not a concurrency keyword.
      const next = this.peek(1);
      if (next && next.type === TokenType.LPAREN) {
        return _originalParseUnary.call(this);
      }

      const l = this.loc();
      this.advance(); // consume 'spawn'

      // Parse the expression after spawn (function call, lambda, etc.)
      const expr = this.parseUnary();

      // If it's a call expression, split into callee + args
      if (expr.type === 'CallExpression') {
        return new SpawnExpression(expr.callee, expr.arguments, l);
      }

      // Otherwise treat the whole expression as the callee with no args
      return new SpawnExpression(expr, [], l);
    }

    return _originalParseUnary.call(this);
  };

  // Also support concurrent as a statement inside function bodies
  const _originalParseStatement = ParserClass.prototype.parseStatement;

  ParserClass.prototype.parseStatement = function() {
    // Check for 'concurrent' at statement level (inside function bodies)
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'concurrent') {
      return this.parseConcurrentBlock();
    }
    // Check for 'select {' at statement level (disambiguate from select() function call)
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'select'
        && this.peek(1).type === TokenType.LBRACE) {
      return this.parseSelectStatement();
    }
    return _originalParseStatement.call(this);
  };

  /**
   * Parse: select { case1  case2  ... }
   *
   * Each case is one of:
   *   binding from channel => body
   *   _ from channel => body
   *   channel.send(value) => body
   *   timeout(ms) => body
   *   _ => body
   */
  ParserClass.prototype.parseSelectStatement = function() {
    const l = this.loc();
    this.advance(); // consume 'select'
    this.expect(TokenType.LBRACE, "Expected '{' after 'select'");

    const cases = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        cases.push(this.parseSelectCase());
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close select block");
    return new SelectStatement(cases, l);
  };

  ParserClass.prototype.parseSelectCase = function() {
    const l = this.loc();

    // timeout(ms) => body
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'timeout'
        && this.peek(1).type === TokenType.LPAREN) {
      this.advance(); // consume 'timeout'
      this.expect(TokenType.LPAREN, "Expected '(' after 'timeout'");
      const ms = this.parseExpression();
      this.expect(TokenType.RPAREN, "Expected ')' after timeout value");
      this.expect(TokenType.ARROW, "Expected '=>' after timeout");
      const body = this.parseSelectCaseBody();
      return new SelectCase('timeout', null, null, ms, body, l);
    }

    // _ => body (default case) — must check before _ from channel
    if (this.check(TokenType.IDENTIFIER) && this.current().value === '_'
        && this.peek(1).type === TokenType.ARROW) {
      this.advance(); // consume '_'
      this.expect(TokenType.ARROW, "Expected '=>' after '_'");
      const body = this.parseSelectCaseBody();
      return new SelectCase('default', null, null, null, body, l);
    }

    // _ from channel => body (wildcard receive)
    if (this.check(TokenType.IDENTIFIER) && this.current().value === '_'
        && this.peek(1).type === TokenType.FROM) {
      this.advance(); // consume '_'
      this.advance(); // consume 'from'
      const channel = this._parseSelectChannel();
      this.expect(TokenType.ARROW, "Expected '=>' after channel");
      const body = this.parseSelectCaseBody();
      return new SelectCase('receive', channel, null, null, body, l);
    }

    // binding from channel => body (named receive)
    if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.FROM) {
      const binding = this.advance().value; // consume binding name
      this.advance(); // consume 'from'
      const channel = this._parseSelectChannel();
      this.expect(TokenType.ARROW, "Expected '=>' after channel");
      const body = this.parseSelectCaseBody();
      return new SelectCase('receive', channel, binding, null, body, l);
    }

    // channel.send(value) => body (send case)
    // Parse as expression, then check if it's a send call
    const expr = this.parseExpression();
    if (expr.type === 'CallExpression' && expr.callee.type === 'MemberExpression'
        && expr.callee.property === 'send') {
      this.expect(TokenType.ARROW, "Expected '=>' after send");
      const body = this.parseSelectCaseBody();
      return new SelectCase('send', expr.callee.object, null, expr.arguments[0], body, l);
    }

    throw this.error("Expected select case: 'binding from channel =>', 'timeout(ms) =>', 'channel.send(val) =>', or '_ =>'", l);
  };

  /**
   * Parse a channel expression in a select receive case.
   * Handles identifiers and member access chains (e.g., ch, obj.ch)
   * without consuming '=>' as a lambda arrow.
   */
  ParserClass.prototype._parseSelectChannel = function() {
    const l = this.loc();
    let expr = new AST.Identifier(this.advance().value, l);
    // Follow member access chains: ch.sub, obj.channels, etc.
    while (this.check(TokenType.DOT)) {
      this.advance(); // consume '.'
      const prop = this.advance().value;
      expr = new AST.MemberExpression(expr, prop, false, this.loc());
    }
    return expr;
  };

  ParserClass.prototype.parseSelectCaseBody = function() {
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume '{'
      const body = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        try {
          const stmt = this.parseStatement();
          if (stmt) body.push(stmt);
        } catch (e) {
          this.errors.push(e);
          this._synchronizeBlock();
        }
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close select case body");
      return body;
    }
    // Single statement
    const stmt = this.parseStatement();
    return stmt ? [stmt] : [];
  };
}

// ─── src/parser/parser.js ──────────────────────────────

class Parser {
  static MAX_EXPRESSION_DEPTH = 200;
  static COMPARISON_OPS = null; // initialized after class definition

  constructor(tokens, filename = '<stdin>') {
    // Pre-filter: build array of significant tokens for O(1) peek
    const significant = [];
    const docs = [];
    for (const t of tokens) {
      const type = t.type;
      if (type === TokenType.NEWLINE || type === TokenType.SEMICOLON) continue;
      if (type === TokenType.DOCSTRING) { docs.push(t); continue; }
      significant.push(t);
    }
    this.tokens = significant;
    this._eof = significant[significant.length - 1]; // cache EOF for hot-path methods
    this.filename = filename;
    this.pos = 0;
    this.errors = [];
    this._expressionDepth = 0;
    this.docstrings = docs;
  }

  // ─── Helpers ───────────────────────────────────────────────

  error(message, code = null) {
    const tok = this.current();
    const err = new Error(
      `${this.filename}:${tok.line}:${tok.column} — Parse error: ${message}\n  Got: ${tok.type} (${JSON.stringify(tok.value)})`
    );
    err.loc = { line: tok.line, column: tok.column, file: this.filename };
    if (code) err.code = code;
    throw err;
  }

  current() {
    return this.tokens[this.pos] || this._eof;
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.tokens.length ? this.tokens[idx] : this._eof;
  }

  advance() {
    return this.tokens[this.pos++] || this._eof;
  }

  check(type) {
    return this.current().type === type;
  }

  checkValue(type, value) {
    const tok = this.current();
    return tok.type === type && tok.value === value;
  }

  match(...types) {
    for (const type of types) {
      if (this.check(type)) {
        return this.advance();
      }
    }
    return null;
  }

  expect(type, message) {
    if (this.check(type)) {
      return this.advance();
    }
    this.error(message || `Expected ${type}, got ${this.current().type}`);
  }

  // Accept IDENTIFIER or any keyword token as a property name (e.g., obj.field, obj.state).
  // Keywords are valid property names after '.' and '?.' just like in JavaScript.
  expectPropertyName(message) {
    const tok = this.current();
    if (tok.type === TokenType.IDENTIFIER || (typeof tok.value === 'string' && tok.type !== TokenType.EOF && tok.type !== TokenType.NUMBER && tok.type !== TokenType.STRING && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(tok.value))) {
      return this.advance();
    }
    this.error(message || `Expected property name, got ${tok.type}`);
  }

  loc() {
    const tok = this.current();
    return { line: tok.line, column: tok.column, file: this.filename };
  }

  isAtEnd() {
    return this.check(TokenType.EOF);
  }

  _synchronize() {
    const startPos = this.pos;
    this.advance(); // skip the problematic token
    while (!this.isAtEnd()) {
      const tok = this.current();
      // Statement-starting keywords — safe to resume parsing here
      if (tok.type === TokenType.FN || tok.type === TokenType.TYPE ||
          tok.type === TokenType.IF || tok.type === TokenType.FOR ||
          tok.type === TokenType.WHILE || tok.type === TokenType.RETURN ||
          tok.type === TokenType.IMPORT || tok.type === TokenType.MATCH ||
          tok.type === TokenType.TRY || tok.type === TokenType.SERVER ||
          tok.type === TokenType.BROWSER || tok.type === TokenType.SHARED ||
          tok.type === TokenType.GUARD || tok.type === TokenType.INTERFACE ||
          tok.type === TokenType.IMPL || tok.type === TokenType.TRAIT ||
          tok.type === TokenType.PUB || tok.type === TokenType.DEFER ||
          tok.type === TokenType.EXTERN ||
          tok.type === TokenType.VAR || tok.type === TokenType.ASYNC) {
        return;
      }
      if (tok.type === TokenType.RBRACE) {
        this.advance();
        return;
      }
      this.advance();
    }
    // Safety: if we didn't advance at all, force advance to avoid infinite loop
    if (this.pos === startPos && !this.isAtEnd()) {
      this.advance();
    }
  }

  // Full-stack keywords (route, state, computed, effect, component, store) are contextual —
  // they act as keywords inside server/client blocks but can be used as identifiers elsewhere.
  _isContextualKeyword() {
    const t = this.current().type;
    return t === TokenType.ROUTE || t === TokenType.STATE || t === TokenType.COMPUTED ||
           t === TokenType.EFFECT || t === TokenType.COMPONENT || t === TokenType.STORE ||
           t === TokenType.FORM || t === TokenType.FIELD || t === TokenType.GROUP || t === TokenType.STEPS;
  }

  _isContextualKeywordToken(token) {
    const t = token.type;
    return t === TokenType.ROUTE || t === TokenType.STATE || t === TokenType.COMPUTED ||
           t === TokenType.EFFECT || t === TokenType.COMPONENT || t === TokenType.STORE ||
           t === TokenType.FORM || t === TokenType.FIELD || t === TokenType.GROUP || t === TokenType.STEPS;
  }

  _synchronizeBlock() {
    // Don't advance if already at } — that's the block closer we need
    if (!this.isAtEnd() && this.current().type !== TokenType.RBRACE) {
      this.advance(); // skip the problematic token
    }
    while (!this.isAtEnd()) {
      const tok = this.current();
      // Stop at } WITHOUT consuming — let the block close properly
      if (tok.type === TokenType.RBRACE) return;
      // Statement-starting keywords — safe to resume parsing here
      if (tok.type === TokenType.FN || tok.type === TokenType.TYPE ||
          tok.type === TokenType.IF || tok.type === TokenType.FOR ||
          tok.type === TokenType.WHILE || tok.type === TokenType.RETURN ||
          tok.type === TokenType.IMPORT || tok.type === TokenType.MATCH ||
          tok.type === TokenType.TRY || tok.type === TokenType.SERVER ||
          tok.type === TokenType.BROWSER || tok.type === TokenType.SHARED ||
          tok.type === TokenType.GUARD || tok.type === TokenType.INTERFACE ||
          tok.type === TokenType.IMPL || tok.type === TokenType.TRAIT ||
          tok.type === TokenType.PUB || tok.type === TokenType.DEFER ||
          tok.type === TokenType.EXTERN || tok.type === TokenType.VAR || tok.type === TokenType.MUT ||
          tok.type === TokenType.STATE || tok.type === TokenType.ROUTE ||
          tok.type === TokenType.IDENTIFIER) {
        return;
      }
      this.advance();
    }
  }

  // Detect if current < starts a JSX tag (vs comparison operator)
  _looksLikeJSX() {
    if (!this.check(TokenType.LESS)) return false;
    const next = this.peek(1);
    // Fragment: <>
    if (next.type === TokenType.GREATER) return true;
    // Accept identifiers and keywords as JSX tag names (e.g., <form>, <label>, <field>)
    if (next.type !== TokenType.IDENTIFIER && !(next.value in Keywords)) return false;
    // Uppercase tag is always a component reference, never a comparison variable
    if (/^[A-Z]/.test(next.value)) return true;
    const afterIdent = this.peek(2);
    // Negative check: if afterIdent is a comparison/logical operator, this is NOT JSX
    // This catches `a < b && c > d` being misread as JSX
    if (afterIdent.type === TokenType.LESS ||
        afterIdent.type === TokenType.LESS_EQUAL ||
        afterIdent.type === TokenType.GREATER_EQUAL ||
        afterIdent.type === TokenType.AND_AND ||
        afterIdent.type === TokenType.OR_OR ||
        afterIdent.type === TokenType.EQUAL ||
        afterIdent.type === TokenType.NOT_EQUAL) {
      return false;
    }
    // JSX patterns: <div>, <div/>, <div attr=...>, <div on:click=...>
    // After the tag name, we can see >, /, an attribute name (identifier or keyword), or :
    return afterIdent.type === TokenType.GREATER ||
           afterIdent.type === TokenType.SLASH ||
           afterIdent.type === TokenType.IDENTIFIER ||
           afterIdent.type === TokenType.COLON ||
           afterIdent.type === TokenType.STATE ||
           afterIdent.type === TokenType.TYPE ||
           afterIdent.type === TokenType.FOR ||
           afterIdent.type === TokenType.IN ||
           afterIdent.type === TokenType.IF ||
           afterIdent.type === TokenType.ELSE ||
           afterIdent.type === TokenType.MATCH ||
           afterIdent.type === TokenType.RETURN ||
           afterIdent.type === TokenType.NUMBER;
  }

  // ─── Program ───────────────────────────────────────────────

  parse() {
    // Eagerly install all block-plugin parser extensions so they work inside function bodies
    for (const plugin of BlockRegistry.all()) {
      const p = plugin.parser;
      if (p.install && p.installedFlag && !Parser.prototype[p.installedFlag]) {
        p.install(Parser);
      }
    }
    const body = [];
    const maxErrors = 50; // Stop after 50 errors to avoid cascading noise
    while (!this.isAtEnd()) {
      if (this.errors.length >= maxErrors) break;
      try {
        const stmt = this.parseTopLevel();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronize();
      }
    }
    if (this.errors.length > 0) {
      const program = new AST.Program(body);
      this._attachDocstrings(program);
      const combined = new Error(this.errors.map(e => e.message).join('\n'));
      combined.errors = this.errors;
      combined.partialAST = program;
      if (this.errors.length >= maxErrors) {
        combined.truncated = true;
      }
      throw combined;
    }
    const program = new AST.Program(body);
    this._attachDocstrings(program);
    return program;
  }

  _attachDocstrings(program) {
    // Use pre-extracted docstring tokens
    const docTokens = this.docstrings;
    if (docTokens.length === 0) return;

    // Group consecutive docstring lines
    const groups = [];
    let current = [docTokens[0]];
    for (let i = 1; i < docTokens.length; i++) {
      if (docTokens[i].line === current[current.length - 1].line + 1) {
        current.push(docTokens[i]);
      } else {
        groups.push(current);
        current = [docTokens[i]];
      }
    }
    groups.push(current);

    // Map: endLine → docstring text
    const docsByEndLine = new Map();
    for (const group of groups) {
      const endLine = group[group.length - 1].line;
      const text = group.map(t => t.value).join('\n');
      docsByEndLine.set(endLine, text);
    }

    // Walk top-level nodes and attach docstrings
    const docTypes = new Set(['FunctionDeclaration', 'TypeDeclaration', 'InterfaceDeclaration', 'Assignment', 'TraitDeclaration']);
    const walk = (nodes) => {
      for (const node of nodes) {
        if (!node || !node.loc) continue;
        if (docTypes.has(node.type)) {
          const doc = docsByEndLine.get(node.loc.line - 1);
          if (doc) node.docstring = doc;
        }
        // Walk into block bodies (arrays) and block nodes with body properties
        if (node.body && Array.isArray(node.body)) {
          walk(node.body);
        } else if (BlockRegistry.getByAstType(node.type) && node.body) {
          walk(node.body);
        }
      }
    };
    walk(program.body);
  }

  parseTopLevel() {
    // Registry-driven block dispatch
    for (const plugin of BlockRegistry.all()) {
      if (this._matchesBlock(plugin)) {
        const p = plugin.parser;
        if (p.install && p.installedFlag && !Parser.prototype[p.installedFlag]) {
          p.install(Parser);
        }
        return this[p.method]();
      }
    }
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    return this.parseStatement();
  }

  _matchesBlock(plugin) {
    const d = plugin.detection;
    if (d.strategy === 'keyword') {
      return this.check(TokenType[d.tokenType]);
    }
    if (d.strategy === 'identifier') {
      if (!this.check(TokenType.IDENTIFIER) || this.current().value !== d.identifierValue) return false;
      return d.lookahead ? d.lookahead(this) : this.peek(1).type === TokenType.LBRACE;
    }
    return false;
  }

  parseTestBlock() {
    const l = this.loc();
    this.advance(); // consume 'test'
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    // Parse optional timeout=N
    let timeout = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'timeout' && this.peek(1).type === TokenType.ASSIGN) {
      this.advance(); // consume 'timeout'
      this.advance(); // consume '='
      const tok = this.expect(TokenType.NUMBER, "Expected number after timeout=");
      timeout = Number(tok.value);
    }
    this.expect(TokenType.LBRACE, "Expected '{' after test block name");
    const body = [];
    let beforeEach = null;
    let afterEach = null;
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        // Check for before_each { ... }
        if (this.check(TokenType.IDENTIFIER) && this.current().value === 'before_each' && this.peek(1).type === TokenType.LBRACE) {
          this.advance(); // consume 'before_each'
          this.expect(TokenType.LBRACE, "Expected '{' after before_each");
          beforeEach = [];
          while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
            const s = this.parseStatement();
            if (s) beforeEach.push(s);
          }
          this.expect(TokenType.RBRACE, "Expected '}' to close before_each");
          continue;
        }
        // Check for after_each { ... }
        if (this.check(TokenType.IDENTIFIER) && this.current().value === 'after_each' && this.peek(1).type === TokenType.LBRACE) {
          this.advance(); // consume 'after_each'
          this.expect(TokenType.LBRACE, "Expected '{' after after_each");
          afterEach = [];
          while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
            const s = this.parseStatement();
            if (s) afterEach.push(s);
          }
          this.expect(TokenType.RBRACE, "Expected '}' to close after_each");
          continue;
        }
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close test block");
    return new AST.TestBlock(name, body, l, { timeout, beforeEach, afterEach });
  }

  parseBenchBlock() {
    const l = this.loc();
    this.advance(); // consume 'bench'
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after bench block name");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close bench block");
    return new AST.BenchBlock(name, body, l);
  }

  // ─── Full-stack blocks ────────────────────────────────────
  // parseBrowserBlock() and browser-specific methods are in browser-parser.js (lazy-loaded)

  parseSharedBlock() {
    const l = this.loc();
    this.expect(TokenType.SHARED);
    // Optional block name: shared "models" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'shared'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close shared block");
    return new AST.SharedBlock(body, l, name);
  }

  // ─── Data block ────────────────────────────────────────────

  parseDataBlock() {
    const l = this.loc();
    this.advance(); // consume 'data'
    this.expect(TokenType.LBRACE, "Expected '{' after 'data'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseDataStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close data block");
    return new AST.DataBlock(body, l);
  }

  parseDataStatement() {
    if (!this.check(TokenType.IDENTIFIER)) {
      return this.parseStatement();
    }

    const val = this.current().value;

    // source customers: Table<Customer> = read("customers.csv")
    if (val === 'source') {
      return this.parseSourceDeclaration();
    }

    // pipeline clean_customers = customers |> where(...)
    if (val === 'pipeline') {
      return this.parsePipelineDeclaration();
    }

    // validate Customer { .email |> contains("@"), ... }
    if (val === 'validate') {
      return this.parseValidateBlock();
    }

    // refresh customers every 15.minutes
    // refresh orders on_demand
    if (val === 'refresh') {
      return this.parseRefreshPolicy();
    }

    return this.parseStatement();
  }

  parseSourceDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'source'
    const name = this.expect(TokenType.IDENTIFIER, "Expected source name").value;

    // Optional type annotation: source customers: Table<Customer>
    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ASSIGN, "Expected '=' after source name");
    const expression = this.parseExpression();

    return new AST.SourceDeclaration(name, typeAnnotation, expression, l);
  }

  parsePipelineDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'pipeline'
    const name = this.expect(TokenType.IDENTIFIER, "Expected pipeline name").value;
    this.expect(TokenType.ASSIGN, "Expected '=' after pipeline name");
    const expression = this.parseExpression();
    return new AST.PipelineDeclaration(name, expression, l);
  }

  parseValidateBlock() {
    const l = this.loc();
    this.advance(); // consume 'validate'
    const typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'validate'").value;
    this.expect(TokenType.LBRACE, "Expected '{' after validate type name");

    const rules = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const rule = this.parseExpression();
      rules.push(rule);
      this.match(TokenType.COMMA); // optional comma separator
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close validate block");
    return new AST.ValidateBlock(typeName, rules, l);
  }

  parseRefreshPolicy() {
    const l = this.loc();
    this.advance(); // consume 'refresh'
    const sourceName = this.expect(TokenType.IDENTIFIER, "Expected source name after 'refresh'").value;

    // refresh X every N.unit  OR  refresh X on_demand
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'on_demand') {
      this.advance();
      return new AST.RefreshPolicy(sourceName, 'on_demand', l);
    }

    // expect 'every'
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'every') {
      this.advance(); // consume 'every'
    }

    // Parse interval: N.unit (e.g., 15.minutes, 1.hour)
    const value = this.expect(TokenType.NUMBER, "Expected interval value").value;
    this.expect(TokenType.DOT, "Expected '.' after interval value");
    const unit = this.expect(TokenType.IDENTIFIER, "Expected time unit (minutes, hours, seconds)").value;

    return new AST.RefreshPolicy(sourceName, { value, unit }, l);
  }

  // Browser-specific statements and JSX parsing are in browser-parser.js (lazy-loaded)

  // ─── Statements ───────────────────────────────────────────

  parseStatement() {
    // pub modifier: pub fn, pub type, pub x = ...
    if (this.check(TokenType.PUB)) return this.parsePubDeclaration();
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FOR) {
      this.advance(); // consume async
      return this.parseForStatement(null, true);
    }
    if (this.check(TokenType.AT)) return this.parseDecoratedDeclaration();
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN) return this.parseAsyncFunctionDeclaration();
    if (this.check(TokenType.FN) && (this.peek(1).type === TokenType.IDENTIFIER || this._isContextualKeywordToken(this.peek(1)))) return this.parseFunctionDeclaration();
    if (this.check(TokenType.TYPE)) return this.parseTypeDeclaration();
    if (this.check(TokenType.MUT)) this.error("'mut' is not supported in Tova. Use 'var' for mutable variables");
    if (this.check(TokenType.VAR)) return this.parseVarDeclaration();
    if (this.check(TokenType.LET)) return this.parseLetDestructure();
    if (this.check(TokenType.IF)) return this.parseIfStatement();
    if (this.check(TokenType.FOR)) return this.parseForStatement();
    if (this.check(TokenType.WHILE)) return this.parseWhileStatement();
    if (this.check(TokenType.LOOP)) return this.parseLoopStatement();
    if (this.check(TokenType.RETURN)) return this.parseReturnStatement();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    if (this.check(TokenType.MATCH)) return this.parseMatchAsStatement();
    if (this.check(TokenType.TRY)) return this.parseTryCatch();
    if (this.check(TokenType.BREAK)) return this.parseBreakStatement();
    if (this.check(TokenType.CONTINUE)) return this.parseContinueStatement();
    if (this.check(TokenType.GUARD)) return this.parseGuardStatement();
    if (this.check(TokenType.INTERFACE)) return this.parseInterfaceDeclaration();
    if (this.check(TokenType.IMPL)) return this.parseImplDeclaration();
    if (this.check(TokenType.TRAIT)) return this.parseTraitDeclaration();
    if (this.check(TokenType.DEFER)) return this.parseDeferStatement();
    if (this.check(TokenType.WITH)) return this.parseWithStatement();
    if (this.check(TokenType.EXTERN)) return this.parseExternDeclaration();

    // Labeled loops: name: for/while/loop
    if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
      const afterColon = this.peek(2).type;
      if (afterColon === TokenType.FOR || afterColon === TokenType.WHILE || afterColon === TokenType.LOOP) {
        const label = this.advance().value; // consume identifier
        this.advance(); // consume colon
        if (this.check(TokenType.FOR)) return this.parseForStatement(label);
        if (this.check(TokenType.WHILE)) return this.parseWhileStatement(label);
        if (this.check(TokenType.LOOP)) return this.parseLoopStatement(label);
      }
    }

    return this.parseExpressionOrAssignment();
  }

  parsePubDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'pub'
    if (this.check(TokenType.PUB)) {
      this.error("Duplicate 'pub' modifier");
    }
    const stmt = this.parseStatement();
    if (stmt) stmt.isPublic = true;
    return stmt;
  }

  parseImplDeclaration() {
    const l = this.loc();
    this.expect(TokenType.IMPL);
    const firstName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'impl'").value;

    // Check for `impl Trait for Type`
    let typeName, traitName = null;
    if (this.check(TokenType.FOR)) {
      this.advance();
      traitName = firstName;
      typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'for'").value;
    } else {
      typeName = firstName;
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open impl block");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const isAsync = this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN;
      if (isAsync) {
        methods.push(this.parseAsyncFunctionDeclaration());
      } else {
        this.expect(TokenType.FN, "Expected 'fn' in impl block");
        const methodLoc = this.loc();
        const name = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
        this.expect(TokenType.LPAREN, "Expected '(' after method name");
        const params = this.parseParameterList();
        this.expect(TokenType.RPAREN, "Expected ')' after parameters");
        let returnType = null;
        if (this.match(TokenType.THIN_ARROW)) {
          returnType = this.parseTypeAnnotation();
        }
        const body = this.parseBlock();
        methods.push(new AST.FunctionDeclaration(name, params, body, returnType, methodLoc));
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close impl block");
    return new AST.ImplDeclaration(typeName, methods, l, traitName);
  }

  parseTraitDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TRAIT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected trait name").value;
    this.expect(TokenType.LBRACE, "Expected '{' to open trait body");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      this.expect(TokenType.FN, "Expected 'fn' in trait body");
      const methodName = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
      this.expect(TokenType.LPAREN, "Expected '(' after method name");
      const params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after parameters");
      let returnType = null;
      if (this.match(TokenType.THIN_ARROW)) {
        returnType = this.parseTypeAnnotation();
      }
      // Optional default implementation
      let body = null;
      if (this.check(TokenType.LBRACE)) {
        body = this.parseBlock();
      }
      methods.push({ name: methodName, params, returnType, body });
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close trait body");
    return new AST.TraitDeclaration(name, methods, l);
  }

  parseDeferStatement() {
    const l = this.loc();
    this.expect(TokenType.DEFER);
    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }
    return new AST.DeferStatement(body, l);
  }

  parseWithStatement() {
    const l = this.loc();
    this.expect(TokenType.WITH);
    const expression = this.parseExpression();
    this.expect(TokenType.AS, "Expected 'as' after with expression");
    const name = this.expect(TokenType.IDENTIFIER, "Expected variable name after 'as'").value;
    const body = this.parseBlock();
    return new AST.WithStatement(expression, name, body, l);
  }

  parseExternDeclaration() {
    const l = this.loc();
    this.expect(TokenType.EXTERN);

    const isAsync = !!this.match(TokenType.ASYNC);
    this.expect(TokenType.FN, "Expected 'fn' after 'extern'");
    const name = this.expect(TokenType.IDENTIFIER, "Expected function name in extern declaration").value;
    this.expect(TokenType.LPAREN, "Expected '(' after extern function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after extern parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    return new AST.ExternDeclaration(name, params, returnType, l, isAsync);
  }

  parseDecoratedDeclaration() {
    const decorators = [];
    while (this.check(TokenType.AT)) {
      this.advance(); // consume @
      const decName = this.expect(TokenType.IDENTIFIER, "Expected decorator name after '@'").value;
      let decArgs = [];
      if (this.check(TokenType.LPAREN)) {
        this.advance(); // consume (
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          decArgs.push(this.parseExpression());
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN, "Expected ')' after decorator arguments");
      }
      decorators.push({ name: decName, args: decArgs });
    }
    // After decorators, expect fn or async fn
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN) {
      const node = this.parseAsyncFunctionDeclaration(decorators);
      return node;
    }
    if (this.check(TokenType.FN)) {
      const node = this.parseFunctionDeclaration(decorators);
      return node;
    }
    this.error("Expected 'fn' or 'async fn' after decorator");
  }

  parseFunctionDeclaration(decorators = []) {
    const l = this.loc();
    this.expect(TokenType.FN);
    let name;
    if (this._isContextualKeyword()) {
      name = this.advance().value;
    } else {
      name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    }

    // Parse optional type parameters: fn name<T, U>(...)
    let typeParams = [];
    if (this.check(TokenType.LESS)) {
      this.advance(); // consume <
      while (!this.check(TokenType.GREATER) && !this.isAtEnd()) {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.GREATER, "Expected '>' after type parameters");
    }

    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l, false, typeParams, decorators);
  }

  parseAsyncFunctionDeclaration(decorators = []) {
    const l = this.loc();
    this.expect(TokenType.ASYNC);
    this.expect(TokenType.FN);
    let name;
    if (this._isContextualKeyword()) {
      name = this.advance().value;
    } else {
      name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    }

    // Parse optional type parameters: async fn name<T, U>(...)
    let typeParams = [];
    if (this.check(TokenType.LESS)) {
      this.advance(); // consume <
      while (!this.check(TokenType.GREATER) && !this.isAtEnd()) {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.GREATER, "Expected '>' after type parameters");
    }

    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l, true, typeParams, decorators);
  }

  parseBreakStatement() {
    const l = this.loc();
    this.expect(TokenType.BREAK);
    // Optional label: break outer
    let label = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().line === l.line) {
      label = this.advance().value;
    }
    return new AST.BreakStatement(l, label);
  }

  parseContinueStatement() {
    const l = this.loc();
    this.expect(TokenType.CONTINUE);
    // Optional label: continue outer
    let label = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().line === l.line) {
      label = this.advance().value;
    }
    return new AST.ContinueStatement(l, label);
  }

  parseGuardStatement() {
    const l = this.loc();
    this.expect(TokenType.GUARD);
    const condition = this.parseExpression();
    this.expect(TokenType.ELSE, "Expected 'else' after guard condition");
    const elseBody = this.parseBlock();
    return new AST.GuardStatement(condition, elseBody, l);
  }

  parseInterfaceDeclaration() {
    const l = this.loc();
    this.expect(TokenType.INTERFACE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected interface name").value;
    this.expect(TokenType.LBRACE, "Expected '{' to open interface body");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      this.expect(TokenType.FN, "Expected 'fn' in interface body");
      const methodName = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
      this.expect(TokenType.LPAREN, "Expected '(' after method name");
      const params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after parameters");
      let returnType = null;
      if (this.match(TokenType.THIN_ARROW)) {
        returnType = this.parseTypeAnnotation();
      }
      methods.push({ name: methodName, params, returnType });
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close interface body");
    return new AST.InterfaceDeclaration(name, methods, l);
  }

  parseParameterList() {
    const params = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      const l = this.loc();

      // Destructuring pattern parameter: {name, email}: User or [head, ...tail]
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const properties = [];
        while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
          const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
          let value = key;
          let defaultValue = null;
          if (this.match(TokenType.COLON)) {
            value = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
          }
          if (this.match(TokenType.ASSIGN)) {
            defaultValue = this.parseExpression();
          }
          properties.push({ key, value, defaultValue });
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RBRACE, "Expected '}'");
        const pattern = new AST.ObjectPattern(properties, l);
        const param = new AST.Parameter(null, null, null, l);
        param.destructure = pattern;
        // Optional type annotation after destructure: {name, age}: User
        if (this.match(TokenType.COLON)) {
          param.typeAnnotation = this.parseTypeAnnotation();
        }
        params.push(param);
      } else if (this.check(TokenType.LBRACKET)) {
        this.advance();
        const elements = [];
        while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
          // Support spread in array destructure: [head, ...tail]
          if (this.check(TokenType.SPREAD)) {
            this.advance(); // consume ...
            const restName = this.expect(TokenType.IDENTIFIER, "Expected identifier after '...'").value;
            elements.push('...' + restName);
            break; // rest must be last
          }
          elements.push(this.expect(TokenType.IDENTIFIER, "Expected element name").value);
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RBRACKET, "Expected ']'");
        const pattern = new AST.ArrayPattern(elements, l);
        const param = new AST.Parameter(null, null, null, l);
        param.destructure = pattern;
        // Optional type annotation after destructure: [head, ...tail]: [Int]
        if (this.match(TokenType.COLON)) {
          param.typeAnnotation = this.parseTypeAnnotation();
        }
        params.push(param);
      } else {
        let name;
        if (this._isContextualKeyword()) {
          name = this.advance().value;
        } else {
          name = this.expect(TokenType.IDENTIFIER, "Expected parameter name").value;
        }

        let typeAnnotation = null;
        if (this.match(TokenType.COLON)) {
          typeAnnotation = this.parseTypeAnnotation();
        }

        let defaultValue = null;
        if (this.match(TokenType.ASSIGN)) {
          defaultValue = this.parseExpression();
        }

        params.push(new AST.Parameter(name, typeAnnotation, defaultValue, l));
      }

      if (!this.match(TokenType.COMMA)) break;
    }
    return params;
  }

  parseTypeAnnotation() {
    const l = this.loc();
    const first = this._parseSingleTypeAnnotation();

    // Union types: Type | Type | Type
    if (this.check(TokenType.BAR)) {
      const members = [first];
      while (this.match(TokenType.BAR)) {
        members.push(this._parseSingleTypeAnnotation());
      }
      return new AST.UnionTypeAnnotation(members, l);
    }

    return first;
  }

  // Parse a single type annotation without union (used as union member)
  _parseSingleTypeAnnotation() {
    const l = this.loc();

    // [Type] — array type shorthand
    if (this.match(TokenType.LBRACKET)) {
      const elementType = this._parseSingleTypeAnnotation();
      this.expect(TokenType.RBRACKET, "Expected ']' in array type");
      return new AST.ArrayTypeAnnotation(elementType, l);
    }

    // (Type, Type) — tuple type or function type
    if (this.check(TokenType.LPAREN)) {
      this.advance();
      const types = [];
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        types.push(this.parseTypeAnnotation());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RPAREN, "Expected ')' in type annotation");
      if (this.match(TokenType.THIN_ARROW)) {
        const returnType = this.parseTypeAnnotation();
        return new AST.FunctionTypeAnnotation(types, returnType, l);
      }
      return new AST.TupleTypeAnnotation(types, l);
    }

    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.parseTypeAnnotation());
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    return new AST.TypeAnnotation(name, typeParams, l);
  }

  // Parse inline validators for type fields: { required, email, min(18) }
  // Uses comma-separated validator names, supports args in parens
  _parseTypeFieldValidators() {
    const validators = [];
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume {
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        validators.push(this._parseInlineValidator());
        this.match(TokenType.COMMA); // optional comma separator
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close validator block");
    }
    return validators;
  }

  // Parse a single inline validator: name or name(args...)
  _parseInlineValidator() {
    const l = this.loc();
    let isAsync = false;
    if (this.check(TokenType.ASYNC)) {
      isAsync = true;
      this.advance();
    }
    const name = this.expect(TokenType.IDENTIFIER, "Expected validator name").value;
    const args = [];
    if (this.match(TokenType.LPAREN)) {
      if (!this.check(TokenType.RPAREN)) {
        args.push(this.parseExpression());
        while (this.match(TokenType.COMMA)) {
          args.push(this.parseExpression());
        }
      }
      this.expect(TokenType.RPAREN, "Expected ')' after validator arguments");
    }
    return new FormValidator(name, args, isAsync, l);
  }

  parseTypeDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TYPE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    // Optional type parameters: Type<T, E>
    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    // Type alias: type Name = TypeExpr
    // OR Refinement type: type Name = TypeExpr where { ... }
    if (this.match(TokenType.ASSIGN)) {
      const typeExpr = this.parseTypeAnnotation();

      // Check for refinement type: type Email = String where { ... }
      if (this.check(TokenType.IDENTIFIER) && this.current().value === 'where') {
        this.advance(); // consume 'where'
        this.expect(TokenType.LBRACE, "Expected '{' after 'where'");

        // Parse predicate block — uses 'it' as implicit parameter
        const predicates = [];
        while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
          predicates.push(this.parseExpression());
          this.match(TokenType.COMMA); // optional comma between predicates
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close where block");

        // Combine predicates with 'and'
        let predicate = predicates[0];
        for (let i = 1; i < predicates.length; i++) {
          predicate = new AST.LogicalExpression('and', predicate, predicates[i], l);
        }

        return new AST.RefinementType(name, typeExpr, predicate, l);
      }

      // Simple enum syntax: type Color = Red | Green | Blue
      // Detect when the type expression is a union of bare identifiers (PascalCase, no type params)
      // But NOT when any member is a known built-in type (that's a type alias, not an enum)
      if (typeExpr.type === 'UnionTypeAnnotation') {
        const builtinTypes = new Set(['String', 'Int', 'Float', 'Bool', 'List', 'Map', 'Set', 'Option', 'Result', 'Any', 'Nil', 'Void', 'Number', 'Array', 'Object', 'Promise', 'Tuple']);
        const isSimpleEnum = typeExpr.members.every(m =>
          m.type === 'TypeAnnotation' && m.typeParams.length === 0 && /^[A-Z]/.test(m.name)
        );
        const hasBuiltinType = typeExpr.members.some(m =>
          m.type === 'TypeAnnotation' && builtinTypes.has(m.name)
        );
        if (isSimpleEnum && !hasBuiltinType) {
          const variants = typeExpr.members.map(m =>
            new AST.TypeVariant(m.name, [], m.loc)
          );
          return new AST.TypeDeclaration(name, typeParams, variants, l);
        }
      }

      return new AST.TypeAlias(name, typeParams, typeExpr, l);
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open type body");

    const variants = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const vl = this.loc();
      const vname = this.expect(TokenType.IDENTIFIER, "Expected variant or field name").value;

      if (this.match(TokenType.LPAREN)) {
        // Variant with fields: Circle(radius: Float)
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          const fl = this.loc();
          const fname = this.expect(TokenType.IDENTIFIER, "Expected field name").value;
          let ftype = null;
          if (this.match(TokenType.COLON)) {
            ftype = this.parseTypeAnnotation();
          }
          fields.push(new AST.TypeField(fname, ftype, fl));
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN, "Expected ')' after variant fields");
        variants.push(new AST.TypeVariant(vname, fields, vl));
      } else if (this.match(TokenType.COLON)) {
        // Simple field: name: String  or  name: String { required, email }
        const ftype = this.parseTypeAnnotation();
        const validators = this._parseTypeFieldValidators();
        variants.push(new AST.TypeField(vname, ftype, vl, validators));
      } else {
        // Bare variant: None
        variants.push(new AST.TypeVariant(vname, [], vl));
      }

      this.match(TokenType.COMMA);
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close type body");

    // Optional derive clause: type Foo { ... } derive [Eq, Show, JSON]
    const node = new AST.TypeDeclaration(name, typeParams, variants, l);
    if (this.match(TokenType.DERIVE)) {
      this.expect(TokenType.LBRACKET, "Expected '[' after derive");
      node.derive = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        node.derive.push(this.expect(TokenType.IDENTIFIER, "Expected derive trait name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' after derive traits");
    }
    return node;
  }

  parseVarDeclaration() {
    const l = this.loc();
    this.expect(TokenType.VAR);

    const targets = [];
    do {
      targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
    } while (this.match(TokenType.COMMA));

    this.expect(TokenType.ASSIGN, "Expected '=' in var declaration");

    const values = [this.parseExpression()];
    while (this.match(TokenType.COMMA)) {
      values.push(this.parseExpression());
    }

    return new AST.VarDeclaration(targets, values, l);
  }

  parseLetDestructure() {
    const l = this.loc();
    this.expect(TokenType.LET);

    let pattern;
    if (this.check(TokenType.LBRACE)) {
      pattern = this.parseObjectPattern();
    } else if (this.check(TokenType.LBRACKET)) {
      pattern = this.parseArrayPattern();
    } else if (this.check(TokenType.LPAREN)) {
      // Tuple destructuring: let (a, b) = expr
      pattern = this.parseTuplePattern();
    } else if (this.check(TokenType.IDENTIFIER)) {
      const name = this.current().value;
      this.error(`Use '${name} = value' for binding or 'var ${name} = value' for mutable. 'let' is only for destructuring: let {a, b} = obj`);
    } else {
      this.error("Expected '{', '[', or '(' after 'let' for destructuring");
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in destructuring");
    const value = this.parseExpression();

    return new AST.LetDestructure(pattern, value, l);
  }

  parseObjectPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);
    const properties = [];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
      let valueName = key;
      let defaultValue = null;

      if (this.match(TokenType.COLON)) {
        valueName = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
      }
      if (this.match(TokenType.ASSIGN)) {
        defaultValue = this.parseExpression();
      }

      properties.push({ key, value: valueName, defaultValue });
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACE, "Expected '}' in object pattern");
    return new AST.ObjectPattern(properties, l);
  }

  parseArrayPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);
    const elements = [];

    while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
      if (this.check(TokenType.SPREAD)) {
        this.advance(); // consume ...
        const restName = this.expect(TokenType.IDENTIFIER, "Expected identifier after '...'").value;
        elements.push('...' + restName);
        break; // rest must be last
      } else if (this.check(TokenType.IDENTIFIER) && this.current().value === '_') {
        elements.push(null); // skip placeholder
        this.advance();
      } else {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACKET, "Expected ']' in array pattern");
    return new AST.ArrayPattern(elements, l);
  }

  parseTuplePattern() {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const elements = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in tuple pattern").value);
      if (!this.match(TokenType.COMMA)) break;
    }
    this.expect(TokenType.RPAREN, "Expected ')' in tuple pattern");
    return new AST.TuplePattern(elements, l);
  }

  parseIfStatement() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF) ||
           (this.check(TokenType.ELSE) && this.peek(1).type === TokenType.IF)) {
      if (this.check(TokenType.ELIF)) {
        this.advance();
      } else {
        this.advance(); // else
        this.advance(); // if
      }
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.IfStatement(condition, consequent, alternates, elseBody, l);
  }

  parseForStatement(label = null, isAsync = false) {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // For variable(s) — supports simple, pair, array destructuring, and object destructuring
    let variable;
    if (this.check(TokenType.LBRACKET)) {
      // Array destructuring: for [a, b] in ...
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' in destructuring pattern");
      variable = `[${elements.join(', ')}]`;
    } else if (this.check(TokenType.LBRACE)) {
      // Object destructuring: for {name, age} in ...
      this.advance();
      const props = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        props.push(this.expect(TokenType.IDENTIFIER, "Expected property name in object pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in destructuring pattern");
      variable = `{${props.join(', ')}}`;
    } else {
      const firstName = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
      if (this.match(TokenType.COMMA)) {
        const secondName = this.expect(TokenType.IDENTIFIER, "Expected second loop variable").value;
        variable = [firstName, secondName];
      } else {
        variable = firstName;
      }
    }

    this.expect(TokenType.IN, "Expected 'in' after for variable");
    const iterable = this.parseExpression();

    // Optional when guard: for user in users when user.active { ... }
    let guard = null;
    if (this.match(TokenType.WHEN)) {
      guard = this.parseExpression();
    }

    const body = this.parseBlock();

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.ForStatement(variable, iterable, body, elseBody, l, guard, label, isAsync);
  }

  parseWhileStatement(label = null) {
    const l = this.loc();
    this.expect(TokenType.WHILE);
    const condition = this.parseExpression();
    const body = this.parseBlock();
    return new AST.WhileStatement(condition, body, l, label);
  }

  parseLoopStatement(label = null) {
    const l = this.loc();
    this.expect(TokenType.LOOP);
    const body = this.parseBlock();
    return new AST.LoopStatement(body, label, l);
  }

  parseTryCatch() {
    const l = this.loc();
    this.expect(TokenType.TRY);
    const tryBlock = this.parseBlock();

    let catchParam = null;
    let catchBody = null;
    let finallyBody = null;

    // Parse optional catch block
    if (this.match(TokenType.CATCH)) {
      if (this.check(TokenType.IDENTIFIER)) {
        catchParam = this.advance().value;
      }
      const catchBlock = this.parseBlock();
      catchBody = catchBlock.body;
    }

    // Parse optional finally block
    if (this.match(TokenType.FINALLY)) {
      const finallyBlock = this.parseBlock();
      finallyBody = finallyBlock.body;
    }

    // Must have at least catch or finally
    if (!catchBody && !finallyBody) {
      this.error("Expected 'catch' or 'finally' after try block");
    }

    return new AST.TryCatchStatement(tryBlock.body, catchParam, catchBody, l, finallyBody);
  }

  parseReturnStatement() {
    const l = this.loc();
    const returnToken = this.expect(TokenType.RETURN);

    let value = null;
    // Only parse return value if the next token is on the same line as `return`
    // This prevents `return\nx = 5` from being parsed as `return x` then `= 5`
    if (!this.check(TokenType.RBRACE) && !this.isAtEnd() && this.current().line === returnToken.line) {
      value = this.parseExpression();
    }

    return new AST.ReturnStatement(value, l);
  }

  parseImport() {
    const l = this.loc();
    this.expect(TokenType.IMPORT);

    // import * as name from "module"
    if (this.check(TokenType.STAR)) {
      this.advance(); // consume *
      this.expect(TokenType.AS, "Expected 'as' after '*' in wildcard import");
      const name = this.expect(TokenType.IDENTIFIER, "Expected namespace name after 'as'").value;
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportWildcard(name, source, l);
    }

    // import { a, b } from "module"
    if (this.match(TokenType.LBRACE)) {
      const specifiers = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const imported = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
        let local = imported;
        if (this.match(TokenType.AS)) {
          local = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
        }
        specifiers.push(new AST.ImportSpecifier(imported, local, this.loc()));
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in import");
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportDeclaration(specifiers, source, l);
    }

    // import Name from "module"
    const name = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
    this.expect(TokenType.FROM, "Expected 'from' in import");
    const source = this.expect(TokenType.STRING, "Expected module path").value;
    return new AST.ImportDefault(name, source, l);
  }

  parseBlock() {
    const l = this.loc();
    this.expect(TokenType.LBRACE, "Expected '{'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}'");
    return new AST.BlockStatement(body, l);
  }

  // ─── Expression or Assignment ─────────────────────────────

  parseExpressionOrAssignment() {
    const l = this.loc();
    const expr = this.parseExpression();

    // Multiple assignment: a, b = 1, 2
    if (this.check(TokenType.COMMA) && expr.type === 'Identifier') {
      const targets = [expr.name];
      while (this.match(TokenType.COMMA)) {
        targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
      }
      this.expect(TokenType.ASSIGN, "Expected '=' in multiple assignment");
      const values = [this.parseExpression()];
      while (this.match(TokenType.COMMA)) {
        values.push(this.parseExpression());
      }
      return new AST.Assignment(targets, values, l);
    }

    // Simple assignment: x = expr (creates immutable binding), obj.x = expr, arr[i] = expr
    if (this.match(TokenType.ASSIGN)) {
      if (expr.type === 'Identifier') {
        const value = this.parseExpression();
        return new AST.Assignment([expr.name], [value], l);
      }
      if (expr.type === 'MemberExpression') {
        const value = this.parseExpression();
        return new AST.Assignment([expr], [value], l);
      }
      // Destructuring without let: {name, age} = user  or  [a, b] = list
      if (expr.type === 'ObjectLiteral') {
        const pattern = new AST.ObjectPattern(
          expr.properties.map(p => ({ key: typeof p.key === 'string' ? p.key : p.key.name || p.key, value: typeof p.key === 'string' ? p.key : p.key.name || p.key })),
          expr.loc
        );
        const value = this.parseExpression();
        return new AST.LetDestructure(pattern, value, l);
      }
      if (expr.type === 'ArrayLiteral') {
        const pattern = new AST.ArrayPattern(
          expr.elements.map(e => e.type === 'Identifier' ? e.name : '_'),
          expr.loc
        );
        const value = this.parseExpression();
        return new AST.LetDestructure(pattern, value, l);
      }
      this.error("Invalid assignment target");
    }

    // Compound assignment: x += expr
    const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
    if (compoundOp) {
      if (expr.type !== 'Identifier' && expr.type !== 'MemberExpression') {
        this.error("Invalid compound assignment target");
      }
      const value = this.parseExpression();
      return new AST.CompoundAssignment(expr, compoundOp.value, value, l);
    }

    return new AST.ExpressionStatement(expr, l);
  }

  parseMatchAsStatement() {
    const expr = this.parseMatchExpression();
    return new AST.ExpressionStatement(expr, this.loc());
  }

  parseIfExpression() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF) ||
           (this.check(TokenType.ELSE) && this.peek(1).type === TokenType.IF)) {
      if (this.check(TokenType.ELIF)) {
        this.advance();
      } else {
        this.advance(); // else
        this.advance(); // if
      }
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    if (!this.check(TokenType.ELSE)) {
      this.error("if expression requires an else branch");
    }
    this.advance();
    const elseBody = this.parseBlock();

    return new AST.IfExpression(condition, consequent, alternates, elseBody, l);
  }

  // ─── Expressions (precedence climbing) ────────────────────

  parseExpression() {
    if (this._expressionDepth >= Parser.MAX_EXPRESSION_DEPTH) {
      this.error('Expression nested too deeply (max ' + Parser.MAX_EXPRESSION_DEPTH + ' levels)');
    }
    this._expressionDepth++;
    try {
      return this.parsePipe();
    } finally {
      this._expressionDepth--;
    }
  }

  parsePipe() {
    let left = this.parseNullCoalesce();
    while (this.match(TokenType.PIPE)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      // Method pipe: |> .method(args) — parse as MemberExpression with empty Identifier
      if (this.check(TokenType.DOT)) {
        this.advance(); // consume .
        const method = this.expect(TokenType.IDENTIFIER, "Expected method name after '.'").value;
        const placeholder = new AST.Identifier(AST.PIPE_TARGET, l);
        const memberExpr = new AST.MemberExpression(placeholder, method, false, l);
        if (this.check(TokenType.LPAREN)) {
          const call = this.parseCallExpression(memberExpr);
          left = new AST.PipeExpression(left, call, l);
        } else {
          left = new AST.PipeExpression(left, memberExpr, l);
        }
      } else {
        const right = this.parseNullCoalesce();
        left = new AST.PipeExpression(left, right, l);
      }
    }
    return left;
  }

  parseNullCoalesce() {
    let left = this.parseOr();
    while (this.match(TokenType.QUESTION_QUESTION)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const right = this.parseOr();
      left = new AST.BinaryExpression('??', left, right, l);
    }
    return left;
  }

  parseOr() {
    let left = this.parseAnd();
    while (this.match(TokenType.OR_OR) || this.match(TokenType.OR)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const right = this.parseAnd();
      left = new AST.LogicalExpression('or', left, right, l);
    }
    return left;
  }

  parseAnd() {
    let left = this.parseNot();
    while (this.match(TokenType.AND_AND) || this.match(TokenType.AND)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const right = this.parseNot();
      left = new AST.LogicalExpression('and', left, right, l);
    }
    return left;
  }

  parseNot() {
    if (this.match(TokenType.NOT) || this.match(TokenType.BANG)) {
      const opTok = this.tokens[this.pos - 1];
      const l = { line: opTok.line, column: opTok.column, file: this.filename };
      const operand = this.parseNot();
      return new AST.UnaryExpression('not', operand, true, l);
    }
    return this.parseComparison();
  }

  parseComparison() {
    let left = this.parseMembership();

    // Check for chained comparisons: a < b < c
    if (Parser.COMPARISON_OPS.has(this.current().type)) {
      // Don't parse < as comparison if it looks like JSX
      if (this.check(TokenType.LESS) && this._looksLikeJSX()) {
        return left;
      }
      const l = this.loc(); // capture loc at the operator
      const operands = [left];
      const operators = [];

      while (Parser.COMPARISON_OPS.has(this.current().type)) {
        const op = this.advance();
        operators.push(op.value);
        operands.push(this.parseMembership());
      }

      if (operators.length === 1) {
        return new AST.BinaryExpression(operators[0], operands[0], operands[1], l);
      }
      return new AST.ChainedComparison(operands, operators, l);
    }

    return left;
  }

  parseMembership() {
    let left = this.parseRange();

    // "is" / "is not" — type checking: value is String, value is not Nil
    if (this.check(TokenType.IS)) {
      const l = this.loc();
      this.advance(); // is
      let negated = false;
      if (this.check(TokenType.NOT)) {
        this.advance(); // not
        negated = true;
      }
      const typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'is'").value;
      return new AST.IsExpression(left, typeName, negated, l);
    }

    // "in" / "not in"
    if (this.check(TokenType.NOT) && this.peek(1).type === TokenType.IN) {
      const l = this.loc();
      this.advance(); // not
      this.advance(); // in
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, true, l);
    }

    if (this.check(TokenType.IN)) {
      const l = this.loc();
      this.advance();
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, false, l);
    }

    return left;
  }

  parseRange() {
    let left = this.parseAddition();

    if (this.check(TokenType.DOT_DOT_EQUAL)) {
      const l = this.loc();
      this.advance();
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, true, l);
    }
    if (this.check(TokenType.DOT_DOT)) {
      const l = this.loc();
      this.advance();
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, false, l);
    }

    return left;
  }

  parseAddition() {
    let left = this.parseMultiplication();
    while (true) {
      const l = this.loc();
      const op = this.match(TokenType.PLUS, TokenType.MINUS);
      if (!op) break;
      const right = this.parseMultiplication();
      left = new AST.BinaryExpression(op.value, left, right, l);
    }
    return left;
  }

  parseMultiplication() {
    let left = this.parsePower();
    while (true) {
      const l = this.loc();
      const op = this.match(TokenType.STAR, TokenType.SLASH, TokenType.PERCENT);
      if (!op) break;
      const right = this.parsePower();
      left = new AST.BinaryExpression(op.value, left, right, l);
    }
    return left;
  }

  parsePower() {
    let base = this.parseUnary();
    if (this.check(TokenType.POWER)) {
      const l = this.loc();
      this.advance();
      const exp = this.parsePower(); // Right-associative
      return new AST.BinaryExpression('**', base, exp, l);
    }
    return base;
  }

  parseUnary() {
    if (this.check(TokenType.AWAIT)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.AwaitExpression(operand, l);
    }
    if (this.check(TokenType.YIELD)) {
      const l = this.loc();
      this.advance();
      // yield from expr
      let delegate = false;
      if (this.check(TokenType.FROM)) {
        this.advance();
        delegate = true;
      }
      const operand = this.parseUnary();
      return new AST.YieldExpression(operand, delegate, l);
    }
    // Negated column expression: -.column (for select exclusion)
    if (this.check(TokenType.MINUS) && this.peek(1).type === TokenType.DOT && this.peek(2).type === TokenType.IDENTIFIER) {
      const l = this.loc();
      this.advance(); // consume -
      this.advance(); // consume .
      const name = this.advance().value;
      return new AST.NegatedColumnExpression(name, l);
    }
    if (this.check(TokenType.MINUS)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.UnaryExpression('-', operand, true, l);
    }
    if (this.check(TokenType.SPREAD)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.SpreadExpression(operand, l);
    }
    return this.parsePostfix();
  }

  parsePostfix() {
    let expr = this.parsePrimary();

    while (true) {
      if (this.check(TokenType.DOT)) {
        const l = this.loc();
        this.advance();
        // Tuple index access: t.0, t.1, etc.
        if (this.check(TokenType.NUMBER) && Number.isInteger(this.current().value) && this.current().value >= 0) {
          const idx = this.advance().value;
          expr = new AST.MemberExpression(expr, new AST.NumberLiteral(idx, l), true, l);
          continue;
        }
        const prop = this.expectPropertyName("Expected property name after '.'").value;
        expr = new AST.MemberExpression(expr, prop, false, l);
        continue;
      }

      if (this.check(TokenType.QUESTION_DOT)) {
        const l = this.loc();
        this.advance();
        const prop = this.expectPropertyName("Expected property name after '?.'").value;
        expr = new AST.OptionalChain(expr, prop, false, l);
        continue;
      }

      if (this.check(TokenType.LBRACKET)) {
        // Don't treat [ as subscript if it's on a new line (avoids ambiguity with array patterns in match)
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine > prevLine) break;
        expr = this.parseSubscript(expr);
        continue;
      }

      if (this.check(TokenType.LPAREN)) {
        // Don't treat ( as call if it's on a new line (avoids ambiguity with grouped expressions)
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine > prevLine) break;
        expr = this.parseCallExpression(expr);
        continue;
      }

      if (this.check(TokenType.QUESTION)) {
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine === prevLine) {
          const l = this.loc();
          this.advance();
          expr = new AST.PropagateExpression(expr, l);
          continue;
        }
      }

      break;
    }

    return expr;
  }

  parseSubscript(object) {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    // Handle [::step] — DOUBLE_COLON is lexed as one token
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, null, step, l);
    }

    // Check for slice: obj[start:end:step]
    if (this.check(TokenType.COLON)) {
      // [:end] or [:end:step]
      this.advance();
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, end, step, l);
    }

    const start = this.parseExpression();

    // Handle [start::step] — DOUBLE_COLON after start expression
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, null, step, l);
    }

    if (this.match(TokenType.COLON)) {
      // [start:end] or [start:end:step]
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, end, step, l);
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.MemberExpression(object, start, true, l);
  }

  parseCallExpression(callee) {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const args = [];

    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      // Check for named argument: name: value
      if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
        const name = this.advance().value;
        this.advance(); // :
        const value = this.parseExpression();
        args.push(new AST.NamedArgument(name, this._maybeWrapItLambda(value), this.loc()));
      } else {
        args.push(this._maybeWrapItLambda(this.parseExpression()));
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RPAREN, "Expected ')' after arguments");
    return new AST.CallExpression(callee, args, l);
  }

  // ─── Primary expressions ──────────────────────────────────

  parsePrimary() {
    const l = this.loc();
    const tokenType = this.current().type;

    switch (tokenType) {
      case TokenType.NUMBER:
        return new AST.NumberLiteral(this.advance().value, l);

      case TokenType.STRING:
      case TokenType.STRING_TEMPLATE:
        return this.parseStringLiteral();

      case TokenType.REGEX: {
        const token = this.advance();
        return new AST.RegexLiteral(token.value.pattern, token.value.flags, l);
      }

      case TokenType.TRUE:
        this.advance();
        return new AST.BooleanLiteral(true, l);

      case TokenType.FALSE:
        this.advance();
        return new AST.BooleanLiteral(false, l);

      case TokenType.NIL:
        this.advance();
        return new AST.NilLiteral(l);

      case TokenType.MATCH:
        return this.parseMatchExpression();

      case TokenType.IF:
        return this.parseIfExpression();

      case TokenType.ASYNC:
        if (this.peek(1).type === TokenType.FN) {
          return this.parseAsyncLambda();
        }
        break;

      case TokenType.FN:
        if (this.peek(1).type === TokenType.LPAREN) {
          return this.parseLambda();
        }
        break;

      case TokenType.LBRACKET:
        return this.parseArrayOrComprehension();

      case TokenType.LBRACE:
        return this.parseObjectOrDictComprehension();

      case TokenType.DOT:
        // Column expression: .column (for table operations)
        if (this.peek(1).type === TokenType.IDENTIFIER) {
          this.advance(); // consume .
          const name = this.advance().value; // consume identifier
          // Check for column assignment: .col = expr (used in derive)
          if (this.check(TokenType.ASSIGN)) {
            this.advance(); // consume =
            const expr = this.parseExpression();
            return new AST.ColumnAssignment(name, expr, l);
          }
          return new AST.ColumnExpression(name, l);
        }
        break;

      case TokenType.LPAREN:
        return this.parseParenOrArrowLambda();

      case TokenType.SERVER:
      case TokenType.BROWSER:
      case TokenType.SHARED:
      case TokenType.DERIVE:
      case TokenType.FORM:
      case TokenType.FIELD:
      case TokenType.GROUP:
      case TokenType.STEPS:
        return new AST.Identifier(this.advance().value, l);

      case TokenType.IDENTIFIER: {
        const name = this.advance().value;
        // Check for arrow lambda: x => expr or x -> expr
        if (this.check(TokenType.ARROW) || this.check(TokenType.THIN_ARROW)) {
          this.advance();
          const body = this.parseExpression();
          return new AST.LambdaExpression(
            [new AST.Parameter(name, null, null, l)],
            body,
            l
          );
        }
        return new AST.Identifier(name, l);
      }
    }

    // Contextual keywords that can appear as identifiers in expression position
    if (this._isContextualKeyword()) {
      return new AST.Identifier(this.advance().value, l);
    }

    this.error(`Unexpected token: ${this.current().type}`);
  }

  parseStringLiteral() {
    const l = this.loc();
    const tok = this.advance();

    if (tok.type === TokenType.STRING) {
      return new AST.StringLiteral(tok.value, l);
    }

    // String template with interpolation
    const parts = tok.value.map(part => {
      if (part.type === 'text') {
        return { type: 'text', value: part.value };
      }
      // Re-parse the expression tokens
      const subParser = new Parser(
        [...part.tokens, { type: TokenType.EOF, value: null, line: 0, column: 0 }],
        this.filename
      );
      const expr = subParser.parseExpression();
      return { type: 'expr', value: expr };
    });

    return new AST.TemplateLiteral(parts, l);
  }

  parseLambda() {
    const l = this.loc();
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      // Parse expression, then check for compound/simple assignment
      const expr = this.parseExpression();
      const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
      if (compoundOp) {
        const value = this.parseExpression();
        body = new AST.CompoundAssignment(expr, compoundOp.value, value, l);
      } else if (this.match(TokenType.ASSIGN)) {
        if (expr.type === 'Identifier') {
          const value = this.parseExpression();
          body = new AST.Assignment([expr.name], [value], l);
        } else {
          body = expr;
        }
      } else {
        body = expr;
      }
    }

    return new AST.LambdaExpression(params, body, l);
  }

  parseAsyncLambda() {
    const l = this.loc();
    this.expect(TokenType.ASYNC);
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.LambdaExpression(params, body, l, true);
  }

  parseMatchExpression() {
    const l = this.loc();
    this.expect(TokenType.MATCH);
    const subject = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' to open match body");

    const arms = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      arms.push(this.parseMatchArm());
      this.match(TokenType.COMMA); // Optional comma between arms
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close match body");
    return new AST.MatchExpression(subject, arms, l);
  }

  parseMatchArm() {
    const l = this.loc();
    const pattern = this.parsePattern();

    let guard = null;
    if (this.match(TokenType.IF)) {
      guard = this.parseExpression();
    }

    this.expect(TokenType.ARROW, "Expected '=>' in match arm");

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.MatchArm(pattern, guard, body, l);
  }

  parsePattern() {
    const l = this.loc();

    // Wildcard _
    if (this.checkValue(TokenType.IDENTIFIER, '_')) {
      this.advance();
      return new AST.WildcardPattern(l);
    }

    // Negative number literal pattern: -1, -3.14
    if (this.check(TokenType.MINUS) && this.peek(1).type === TokenType.NUMBER) {
      this.advance(); // consume -
      const val = -this.advance().value;
      // Check for range pattern: -5..0
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const endNeg = this.match(TokenType.MINUS);
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, endNeg ? -end : end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const endNeg = this.match(TokenType.MINUS);
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, endNeg ? -end : end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // Number literal pattern
    if (this.check(TokenType.NUMBER)) {
      const val = this.advance().value;
      // Check for range pattern: 1..10
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // String literal pattern, possibly with ++ concat pattern
    if (this.check(TokenType.STRING)) {
      const strVal = this.advance().value;
      // Check for string concat pattern: "prefix" ++ rest
      // Verify the two + tokens are adjacent (no space between them) to distinguish from arithmetic
      if (this.check(TokenType.PLUS) && this.peek(1).type === TokenType.PLUS &&
          this.current().column + 1 === this.peek(1).column && this.current().line === this.peek(1).line) {
        this.advance(); // first +
        this.advance(); // second +
        const rest = this.parsePattern();
        return new AST.StringConcatPattern(strVal, rest, l);
      }
      return new AST.LiteralPattern(strVal, l);
    }

    // Boolean literal pattern
    if (this.check(TokenType.TRUE)) {
      this.advance();
      return new AST.LiteralPattern(true, l);
    }
    if (this.check(TokenType.FALSE)) {
      this.advance();
      return new AST.LiteralPattern(false, l);
    }

    // Nil pattern
    if (this.check(TokenType.NIL)) {
      this.advance();
      return new AST.LiteralPattern(null, l);
    }

    // Array pattern: [a, b, c] or [0, _]
    if (this.check(TokenType.LBRACKET)) {
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.parsePattern());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET);
      return new AST.ArrayPattern(elements, l);
    }

    // Tuple pattern: (a, b)
    if (this.check(TokenType.LPAREN)) {
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        elements.push(this.parsePattern());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RPAREN, "Expected ')' in tuple pattern");
      return new AST.TuplePattern(elements, l);
    }

    // Identifier: could be variant pattern or binding pattern
    if (this.check(TokenType.IDENTIFIER)) {
      const name = this.advance().value;

      // Variant pattern: Circle(r), Some(Ok(value))
      if (this.match(TokenType.LPAREN)) {
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          fields.push(this.parsePattern());
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN);
        return new AST.VariantPattern(name, fields, l);
      }

      // Binding pattern (lowercase = binding, uppercase = variant without args)
      if (name[0] === name[0].toUpperCase() && name[0] !== '_') {
        return new AST.VariantPattern(name, [], l);
      }
      return new AST.BindingPattern(name, l);
    }

    this.error("Expected pattern");
  }

  parseArrayOrComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    if (this.check(TokenType.RBRACKET)) {
      this.advance();
      return new AST.ArrayLiteral([], l);
    }

    // Parse first expression
    const first = this.parseExpression();

    // Check if this is a list comprehension: [expr for x in items]
    if (this.check(TokenType.FOR)) {
      this.advance();
      const variable = this.expect(TokenType.IDENTIFIER, "Expected variable in comprehension").value;
      this.expect(TokenType.IN, "Expected 'in' in comprehension");
      const iterable = this.parseExpression();

      let condition = null;
      if (this.match(TokenType.IF)) {
        condition = this.parseExpression();
      }

      this.expect(TokenType.RBRACKET, "Expected ']' to close comprehension");
      return new AST.ListComprehension(first, variable, iterable, condition, l);
    }

    // Regular array literal
    const elements = [first];
    while (this.match(TokenType.COMMA)) {
      if (this.check(TokenType.RBRACKET)) break; // trailing comma
      elements.push(this.parseExpression());
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.ArrayLiteral(elements, l);
  }

  _parseObjectProperty() {
    // Spread property: ...expr
    if (this.check(TokenType.SPREAD)) {
      const sl = this.loc();
      this.advance();
      const argument = this.parseUnary();
      return { spread: true, argument };
    }
    const key = this.parseExpression();
    if (this.match(TokenType.COLON)) {
      const value = this.parseExpression();
      return { key, value, shorthand: false };
    }
    if (key.type === 'Identifier') {
      return { key, value: key, shorthand: true };
    }
    this.error("Expected ':' in object literal");
  }

  parseObjectOrDictComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);

    if (this.check(TokenType.RBRACE)) {
      this.advance();
      return new AST.ObjectLiteral([], l);
    }

    // Check for spread as first element — always an object literal
    if (this.check(TokenType.SPREAD)) {
      const properties = [this._parseObjectProperty()];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        properties.push(this._parseObjectProperty());
      }
      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    // Try to parse first key: value pair
    const firstKey = this.parseExpression();

    if (this.match(TokenType.COLON)) {
      const firstValue = this.parseExpression();

      // Dict comprehension: {k: v for k, v in pairs}
      if (this.check(TokenType.FOR)) {
        this.advance();
        const vars = [];
        vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        if (this.match(TokenType.COMMA)) {
          vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        }
        this.expect(TokenType.IN, "Expected 'in' in comprehension");
        const iterable = this.parseExpression();
        let condition = null;
        if (this.match(TokenType.IF)) {
          condition = this.parseExpression();
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close dict comprehension");
        return new AST.DictComprehension(firstKey, firstValue, vars, iterable, condition, l);
      }

      // Regular object literal
      const properties = [{ key: firstKey, value: firstValue, shorthand: false }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        properties.push(this._parseObjectProperty());
      }

      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    // Shorthand object: { x, y } or mixed { x, y: 10 }
    if (firstKey.type === 'Identifier') {
      const properties = [{ key: firstKey, value: firstKey, shorthand: true }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        properties.push(this._parseObjectProperty());
      }
      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    this.error("Invalid object literal");
  }

  parseParenOrArrowLambda() {
    const l = this.loc();

    // Save position to backtrack if needed
    const savedPos = this.pos;

    this.expect(TokenType.LPAREN);

    // Empty parens: () => expr or () -> expr
    if (this.check(TokenType.RPAREN)) {
      this.advance();
      if (this.check(TokenType.ARROW) || this.check(TokenType.THIN_ARROW)) {
        this.advance();
        const body = this.parseExpression();
        return new AST.LambdaExpression([], body, l);
      }
      // Empty parens but not arrow — error or unit value
      this.error("Unexpected '()'");
    }

    // Try to parse as arrow lambda params
    // Look ahead: if we see ) => then it's a lambda
    const params = [];
    let isLambda = true;

    const savedErrors = this.errors.length;
    try {
      const innerSaved = this.pos;
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        if (!this.check(TokenType.IDENTIFIER)) {
          isLambda = false;
          break;
        }
        const pname = this.advance().value;
        let ptype = null;
        let pdefault = null;
        if (this.match(TokenType.COLON)) {
          // Could be a type annotation or named argument
          if (this.check(TokenType.IDENTIFIER)) {
            ptype = this.parseTypeAnnotation();
          } else {
            isLambda = false;
            break;
          }
        }
        if (this.match(TokenType.ASSIGN)) {
          pdefault = this.parseExpression();
        }
        params.push(new AST.Parameter(pname, ptype, pdefault, l));
        if (!this.match(TokenType.COMMA)) break;
      }

      if (isLambda && this.check(TokenType.RPAREN)) {
        this.advance(); // )
        if (this.check(TokenType.ARROW) || this.check(TokenType.THIN_ARROW)) {
          this.advance(); // =>
          const body = this.check(TokenType.LBRACE) ? this.parseBlock() : this.parseExpression();
          return new AST.LambdaExpression(params, body, l);
        }
        // Helpful hint: user may have typed = instead of -> or =>
        if (this.check(TokenType.ASSIGN) || this.check(TokenType.EQUAL)) {
          this.error("Use '->' or '=>' for arrow functions: (x, y) -> expr");
        }
      }
    } catch (e) {
      // Speculative parse failure — expected during backtracking, not a real error
    }

    // Backtrack and parse as parenthesized expression or tuple
    // Also restore errors to discard any ghost errors from speculative parsing
    this.errors.length = savedErrors;
    this.pos = savedPos;
    this.expect(TokenType.LPAREN);
    const expr = this.parseExpression();

    // Tuple: (a, b, c) — requires at least one comma
    if (this.check(TokenType.COMMA)) {
      const elements = [expr];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RPAREN)) break; // trailing comma
        elements.push(this.parseExpression());
      }
      this.expect(TokenType.RPAREN, "Expected ')'");
      return new AST.TupleExpression(elements, l);
    }

    this.expect(TokenType.RPAREN, "Expected ')'");
    return expr;
  }

  // ─── Implicit `it` parameter support ─────────────────────

  _containsFreeIt(node) {
    if (!node) return false;
    if (node.type === 'Identifier' && node.name === 'it') return true;
    if (node.type === 'LambdaExpression' || node.type === 'FunctionDeclaration') return false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsFreeIt(item)) return true;
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsFreeIt(val)) return true;
      }
    }
    return false;
  }

  _maybeWrapItLambda(node) {
    if (node.type === 'Identifier' && node.name === 'it') return node;
    if (node.type === 'LambdaExpression') return node;
    if (node.type === 'FunctionDeclaration') return node;
    if (this._containsFreeIt(node)) {
      const loc = node.loc || this.loc();
      return new AST.LambdaExpression(
        [new AST.Parameter('it', null, null, loc)],
        node, loc
      );
    }
    return node;
  }
}

// Initialize static Set after class definition (depends on TokenType)
Parser.COMPARISON_OPS = new Set([
  TokenType.LESS, TokenType.LESS_EQUAL,
  TokenType.GREATER, TokenType.GREATER_EQUAL,
  TokenType.EQUAL, TokenType.NOT_EQUAL
]);

// ─── src/analyzer/scope.js ─────────────────────────────

// Scope and symbol management for the Tova analyzer
class Symbol {
  constructor(name, kind, type, mutable, loc) {
    this.name = name;
    this.kind = kind;       // 'variable', 'function', 'type', 'parameter', 'state', 'computed', 'component'
    this.type = type;       // Type object or raw type annotation (optional)
    this.mutable = mutable; // true for 'var' declarations
    this.loc = loc;
    this.used = false;
    this.declaredType = null; // raw annotation for display purposes
  }
}
class Scope {
  constructor(parent = null, context = 'module') {
    this.parent = parent;
    this.context = context; // 'module', 'server', 'browser', 'shared', 'function', 'block'
    this.symbols = new Map();
    this.children = [];
    this.startLoc = null; // { line, column } for positional scope lookup
    this.endLoc = null;
    this._indexed = false;
  }

  define(name, symbol) {
    if (this.symbols.has(name)) {
      const existing = this.symbols.get(name);
      // Allow user code to shadow builtins
      if (existing.kind === 'builtin') {
        this.symbols.set(name, symbol);
        return;
      }
      throw new Error(
        `${symbol.loc.file}:${symbol.loc.line}:${symbol.loc.column} — '${name}' is already defined in this scope`
      );
    }
    this.symbols.set(name, symbol);
  }

  lookup(name) {
    if (this.symbols.has(name)) {
      return this.symbols.get(name);
    }
    if (this.parent) {
      return this.parent.lookup(name);
    }
    return null;
  }

  lookupLocal(name) {
    return this.symbols.get(name) || null;
  }

  getContext() {
    if (this.context === 'server' || this.context === 'browser' || this.context === 'client' || this.context === 'shared') {
      return this.context;
    }
    if (this.parent) {
      return this.parent.getContext();
    }
    return 'module';
  }

  child(context) {
    const c = new Scope(this, context || this.context);
    this.children.push(c);
    return c;
  }

  /**
   * Build a sorted index of children for fast binary-search lookup.
   * Call once after analysis is complete.
   */
  buildIndex() {
    // Sort children with position info by start line, then column
    if (this.children.length > 1) {
      this.children.sort((a, b) => {
        if (!a.startLoc) return 1;
        if (!b.startLoc) return -1;
        if (a.startLoc.line !== b.startLoc.line) return a.startLoc.line - b.startLoc.line;
        return a.startLoc.column - b.startLoc.column;
      });
    }
    this._indexed = true;
    for (const child of this.children) {
      child.buildIndex();
    }
  }

  /**
   * Find the narrowest scope containing a given position.
   * Uses binary search if buildIndex() has been called.
   */
  findScopeAtPosition(line, column) {
    if (this._indexed && this.children.length > 4) {
      return this._findScopeIndexed(line, column);
    }
    // Linear fallback for small lists or un-indexed scopes
    for (const child of this.children) {
      if (child.startLoc && child.endLoc) {
        if ((line > child.startLoc.line || (line === child.startLoc.line && column >= child.startLoc.column)) &&
            (line < child.endLoc.line || (line === child.endLoc.line && column <= child.endLoc.column))) {
          const nested = child.findScopeAtPosition(line, column);
          return nested || child;
        }
      } else {
        const nested = child.findScopeAtPosition(line, column);
        if (nested) return nested;
      }
    }
    if (this.startLoc && this.endLoc) {
      if ((line > this.startLoc.line || (line === this.startLoc.line && column >= this.startLoc.column)) &&
          (line < this.endLoc.line || (line === this.endLoc.line && column <= this.endLoc.column))) {
        return this;
      }
    }
    return null;
  }

  _findScopeIndexed(line, column) {
    // Binary search for the last child whose start is <= target position
    const children = this.children;
    let lo = 0, hi = children.length - 1;
    let candidate = -1;

    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const c = children[mid];
      if (!c.startLoc) { lo = mid + 1; continue; }
      if (c.startLoc.line < line || (c.startLoc.line === line && c.startLoc.column <= column)) {
        candidate = mid;
        lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }

    // Check candidate and neighbors (scopes can nest, so check a small window)
    if (candidate >= 0) {
      // Check candidate and up to 2 before it (overlapping scopes)
      const start = Math.max(0, candidate - 2);
      const end = Math.min(children.length - 1, candidate + 1);
      for (let i = start; i <= end; i++) {
        const child = children[i];
        if (child.startLoc && child.endLoc) {
          if ((line > child.startLoc.line || (line === child.startLoc.line && column >= child.startLoc.column)) &&
              (line < child.endLoc.line || (line === child.endLoc.line && column <= child.endLoc.column))) {
            const nested = child.findScopeAtPosition(line, column);
            return nested || child;
          }
        }
      }
    }

    // Fallback: check children without position info
    for (const child of children) {
      if (!child.startLoc) {
        const nested = child.findScopeAtPosition(line, column);
        if (nested) return nested;
      }
    }

    if (this.startLoc && this.endLoc) {
      if ((line > this.startLoc.line || (line === this.startLoc.line && column >= this.startLoc.column)) &&
          (line < this.endLoc.line || (line === this.endLoc.line && column <= this.endLoc.column))) {
        return this;
      }
    }
    return null;
  }
}

// ─── src/analyzer/types.js ─────────────────────────────

// Type system for the Tova analyzer
// Replaces string-based type representations with a proper class hierarchy
class Type {
  equals(other) { return false; }
  isAssignableTo(target) { return false; }
  toString() { return 'unknown'; }
  getFieldType(name) { return null; }
}

// ─── Primitive Types ──────────────────────────────────────
class PrimitiveType extends Type {
  constructor(name) {
    super();
    this.name = name;
  }

  equals(other) {
    return other instanceof PrimitiveType && this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof PrimitiveType) {
      if (this.name === target.name) return true;
      // Int -> Float widening is always allowed (safe)
      if (this.name === 'Int' && target.name === 'Float') return true;
      // Float -> Int narrowing: NOT implicitly allowed at type level.
      // The analyzer emits warning/error with conversion hint.
    }
    return false;
  }

  toString() { return this.name; }
}

// ─── Nil Type ──────────────────────────────────────────────
class NilType extends Type {
  equals(other) { return other instanceof NilType; }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof NilType) return true;
    // Nil is compatible with Option types
    if (target instanceof GenericType && target.base === 'Option') return true;
    if (target instanceof PrimitiveType && target.name === 'Option') return true;
    return false;
  }

  toString() { return 'Nil'; }
}

// ─── Any Type ──────────────────────────────────────────────
class AnyType extends Type {
  equals(other) { return other instanceof AnyType; }
  isAssignableTo(_target) { return true; }
  toString() { return 'Any'; }
}

// ─── Unknown Type (gradual typing — compatible with everything) ────
class UnknownType extends Type {
  equals(other) { return other instanceof UnknownType; }
  isAssignableTo(target) {
    // In strict mode, unknown types are NOT assignable to concrete types
    if (Type.strictMode) {
      if (!target) return true;
      if (target instanceof AnyType || target instanceof UnknownType) return true;
      return false;
    }
    return true;
  }
  toString() { return 'unknown'; }
}

// ─── Array Type ────────────────────────────────────────────
class ArrayType extends Type {
  constructor(elementType) {
    super();
    this.elementType = elementType || Type.ANY;
  }

  equals(other) {
    return other instanceof ArrayType && this.elementType.equals(other.elementType);
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof ArrayType) {
      return this.elementType.isAssignableTo(target.elementType);
    }
    return false;
  }

  toString() { return `[${this.elementType.toString()}]`; }
}

// ─── Tuple Type ────────────────────────────────────────────
class TupleType extends Type {
  constructor(elementTypes) {
    super();
    this.elementTypes = elementTypes || [];
  }

  equals(other) {
    if (!(other instanceof TupleType)) return false;
    if (this.elementTypes.length !== other.elementTypes.length) return false;
    return this.elementTypes.every((t, i) => t.equals(other.elementTypes[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof TupleType) {
      if (this.elementTypes.length !== target.elementTypes.length) return false;
      return this.elementTypes.every((t, i) => t.isAssignableTo(target.elementTypes[i]));
    }
    return false;
  }

  toString() {
    return `(${this.elementTypes.map(t => t.toString()).join(', ')})`;
  }
}

// ─── Function Type ─────────────────────────────────────────
class FunctionType extends Type {
  constructor(paramTypes, returnType) {
    super();
    this.paramTypes = paramTypes || [];
    this.returnType = returnType || Type.ANY;
  }

  equals(other) {
    if (!(other instanceof FunctionType)) return false;
    if (this.paramTypes.length !== other.paramTypes.length) return false;
    if (!this.returnType.equals(other.returnType)) return false;
    return this.paramTypes.every((t, i) => t.equals(other.paramTypes[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof FunctionType) return this.equals(target);
    return false;
  }

  toString() { return 'Function'; }
}

// ─── Record Type ───────────────────────────────────────────
class RecordType extends Type {
  constructor(name, fields) {
    super();
    this.name = name;
    this.fields = fields || new Map(); // name -> Type
  }

  equals(other) {
    if (!(other instanceof RecordType)) return false;
    return this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof RecordType) return this.name === target.name;
    if (target instanceof PrimitiveType && target.name === this.name) return true;
    if (target instanceof GenericType && target.base === this.name) return true;
    return false;
  }

  getFieldType(name) {
    return this.fields.get(name) || null;
  }

  toString() { return this.name; }
}

// ─── ADT Type ──────────────────────────────────────────────
class ADTType extends Type {
  constructor(name, typeParams, variants) {
    super();
    this.name = name;
    this.typeParams = typeParams || [];
    this.variants = variants || new Map(); // variantName -> Map<fieldName, Type>
  }

  equals(other) {
    if (!(other instanceof ADTType)) return false;
    return this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof ADTType) return this.name === target.name;
    if (target instanceof PrimitiveType && target.name === this.name) return true;
    if (target instanceof GenericType && target.base === this.name) return true;
    return false;
  }

  getFieldType(name) {
    // Look through all variants for the field
    for (const [, fields] of this.variants) {
      if (fields.has(name)) return fields.get(name);
    }
    return null;
  }

  getVariantNames() {
    return [...this.variants.keys()];
  }

  toString() {
    if (this.typeParams.length > 0) {
      return `${this.name}<${this.typeParams.join(', ')}>`;
    }
    return this.name;
  }
}

// ─── Generic Type ──────────────────────────────────────────
class GenericType extends Type {
  constructor(base, typeArgs) {
    super();
    this.base = base;
    this.typeArgs = typeArgs || [];
  }

  equals(other) {
    if (!(other instanceof GenericType)) return false;
    if (this.base !== other.base) return false;
    if (this.typeArgs.length !== other.typeArgs.length) return false;
    return this.typeArgs.every((t, i) => t.equals(other.typeArgs[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof GenericType) {
      if (this.base !== target.base) return false;
      // If one side has no type args (bare `Result`), compatible (gradual typing)
      if (this.typeArgs.length === 0 || target.typeArgs.length === 0) return true;
      if (this.typeArgs.length !== target.typeArgs.length) return false;
      return this.typeArgs.every((t, i) => t.isAssignableTo(target.typeArgs[i]));
    }
    // Compatible with a PrimitiveType of same base name (e.g. Result<Int, String> assignable to Result)
    if (target instanceof PrimitiveType && target.name === this.base) return true;
    // Compatible with ADTType of same name
    if (target instanceof ADTType && target.name === this.base) return true;
    return false;
  }

  getFieldType(name) {
    // Delegate to the base type if we had structural info — handled via TypeRegistry
    return null;
  }

  toString() {
    if (this.typeArgs.length === 0) return this.base;
    return `${this.base}<${this.typeArgs.map(t => t.toString()).join(', ')}>`;
  }
}

// ─── Type Variable ─────────────────────────────────────────
class TypeVariable extends Type {
  constructor(name) {
    super();
    this.name = name;
  }

  equals(other) {
    return other instanceof TypeVariable && this.name === other.name;
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof TypeVariable) return this.name === target.name;
    // Type variables are compatible with anything (they're placeholders)
    return true;
  }

  toString() { return this.name; }
}

// ─── Union Type ────────────────────────────────────────────
class UnionType extends Type {
  constructor(members) {
    super();
    this.members = members || [];
  }

  equals(other) {
    if (!(other instanceof UnionType)) return false;
    if (this.members.length !== other.members.length) return false;
    return this.members.every((m, i) => m.equals(other.members[i]));
  }

  isAssignableTo(target) {
    if (!target) return true;
    if (target instanceof AnyType || target instanceof UnknownType) return true;
    if (target instanceof UnionType) {
      // Every member of this must be assignable to some member of target
      return this.members.every(m =>
        target.members.some(t => m.isAssignableTo(t))
      );
    }
    // A union is assignable to T if every member is assignable to T
    return this.members.every(m => m.isAssignableTo(target));
  }

  toString() {
    return this.members.map(m => m.toString()).join(' | ');
  }
}

// ─── Strict Mode Flag ────────────────────────────────────

Type.strictMode = false; // Set to true by analyzer in --strict mode

// ─── Singleton Caching ────────────────────────────────────

Type.INT = new PrimitiveType('Int');
Type.FLOAT = new PrimitiveType('Float');
Type.STRING = new PrimitiveType('String');
Type.BOOL = new PrimitiveType('Bool');
Type.NIL = new NilType();
Type.ANY = new AnyType();
Type.UNKNOWN = new UnknownType();
Type.FUNCTION = new FunctionType([], Type.ANY);

const PRIMITIVE_CACHE = new Map([
  ['Int', Type.INT],
  ['Float', Type.FLOAT],
  ['String', Type.STRING],
  ['Bool', Type.BOOL],
  ['Nil', Type.NIL],
  ['Any', Type.ANY],
]);

// ─── Helper Functions ──────────────────────────────────────

/**
 * Convert a parser TypeAnnotation AST node to a Type object.
 */
function typeAnnotationToType(ann) {
  if (!ann) return null;
  if (typeof ann === 'string') return typeFromString(ann);

  switch (ann.type) {
    case 'TypeAnnotation': {
      if (ann.typeParams && ann.typeParams.length > 0) {
        const args = ann.typeParams.map(p => typeAnnotationToType(p) || Type.UNKNOWN);
        return new GenericType(ann.name, args);
      }
      return typeFromString(ann.name);
    }
    case 'ArrayTypeAnnotation': {
      const elType = typeAnnotationToType(ann.elementType) || Type.ANY;
      return new ArrayType(elType);
    }
    case 'TupleTypeAnnotation': {
      const elTypes = ann.elementTypes.map(t => typeAnnotationToType(t) || Type.ANY);
      return new TupleType(elTypes);
    }
    case 'FunctionTypeAnnotation':
      return Type.FUNCTION;
    case 'UnionTypeAnnotation': {
      const members = ann.members.map(m => typeAnnotationToType(m) || Type.UNKNOWN);
      return new UnionType(members);
    }
    default:
      return null;
  }
}

/**
 * Convert a type string to a Type object.
 * Bridge for migrating existing string-based code.
 */
function typeFromString(s) {
  if (!s) return null;

  // Check primitive cache
  if (PRIMITIVE_CACHE.has(s)) return PRIMITIVE_CACHE.get(s);

  // Wildcard / underscore
  if (s === '_') return Type.UNKNOWN;

  // Array type: [ElementType]
  if (s.startsWith('[') && s.endsWith(']')) {
    const inner = s.slice(1, -1);
    return new ArrayType(typeFromString(inner) || Type.ANY);
  }

  // Tuple type: (Type1, Type2)
  if (s.startsWith('(') && s.endsWith(')')) {
    const inner = s.slice(1, -1);
    const parts = splitTopLevel(inner, ',');
    return new TupleType(parts.map(p => typeFromString(p.trim()) || Type.ANY));
  }

  // Generic type: Result<Int, String>
  const ltIdx = s.indexOf('<');
  if (ltIdx !== -1) {
    const base = s.slice(0, ltIdx);
    const inner = s.slice(ltIdx + 1, s.lastIndexOf('>'));
    const params = splitTopLevel(inner, ',');
    const args = params.map(p => typeFromString(p.trim()) || Type.UNKNOWN);
    return new GenericType(base, args);
  }

  // Named type (user-defined) — treated as a primitive-like name
  return new PrimitiveType(s);
}

/**
 * Split a string on a delimiter at the top level (respecting nested <> and ()).
 */
function splitTopLevel(str, delimiter) {
  const parts = [];
  let depth = 0;
  let parenDepth = 0;
  let start = 0;
  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (ch === '<') depth++;
    else if (ch === '>') depth--;
    else if (ch === '(') parenDepth++;
    else if (ch === ')') parenDepth--;
    else if (ch === delimiter && depth === 0 && parenDepth === 0) {
      parts.push(str.slice(start, i));
      start = i + 1;
    }
  }
  parts.push(str.slice(start));
  return parts;
}

/**
 * Null-safe type compatibility check.
 * Returns true if source is assignable to target, or if either is null/unknown.
 */
function typesCompatible(target, source) {
  if (!target || !source) return true;
  if (target instanceof Type && source instanceof Type) {
    return source.isAssignableTo(target);
  }
  // Fallback for string comparison during migration
  if (typeof target === 'string' || typeof source === 'string') {
    const t = typeof target === 'string' ? typeFromString(target) : target;
    const s = typeof source === 'string' ? typeFromString(source) : source;
    if (!t || !s) return true;
    return s.isAssignableTo(t);
  }
  return true;
}

/**
 * Check if a type is numeric (Int or Float)
 */
function isNumericType(type) {
  if (!type) return false;
  if (type instanceof PrimitiveType) {
    return type.name === 'Int' || type.name === 'Float';
  }
  return false;
}

/**
 * Check strict Float -> Int narrowing.
 * Returns true if this is a Float-to-Int assignment (potential data loss).
 */
function isFloatNarrowing(source, target) {
  if (!source || !target) return false;
  return (source instanceof PrimitiveType && source.name === 'Float' &&
          target instanceof PrimitiveType && target.name === 'Int');
}

// ─── src/analyzer/server-analyzer.js ───────────────────

// Server-specific analyzer methods for the Tova language
// Extracted from analyzer.js for lazy loading — only loaded when server { } blocks are encountered.
function collectServerBlockFunctions(ast) {
  const serverBlockFunctions = new Map();
  const collectFns = (stmts) => {
    const fns = [];
    for (const stmt of stmts) {
      if (stmt.type === 'FunctionDeclaration') {
        fns.push(stmt.name);
      } else if (stmt.type === 'RouteGroupDeclaration') {
        fns.push(...collectFns(stmt.body));
      }
    }
    return fns;
  };
  for (const node of ast.body) {
    if (node.type === 'ServerBlock' && node.name) {
      const fns = collectFns(node.body);
      if (serverBlockFunctions.has(node.name)) {
        serverBlockFunctions.get(node.name).push(...fns);
      } else {
        serverBlockFunctions.set(node.name, fns);
      }
    }
  }
  return serverBlockFunctions;
}
function installServerAnalyzer(AnalyzerClass) {
  if (AnalyzerClass.prototype._serverAnalyzerInstalled) return;
  AnalyzerClass.prototype._serverAnalyzerInstalled = true;

  AnalyzerClass.prototype.visitServerBlock = function(node) {
    const prevScope = this.currentScope;
    const prevServerBlockName = this._currentServerBlockName;
    this._currentServerBlockName = node.name || null;
    this.currentScope = this.currentScope.child('server');

    try {
      // Register peer server block names as valid identifiers in this scope
      if (node.name && this.serverBlockFunctions.size > 0) {
        for (const [peerName] of this.serverBlockFunctions) {
          if (peerName !== node.name) {
            try {
              this.currentScope.define(peerName,
                new Symbol(peerName, 'builtin', null, false, { line: 0, column: 0, file: '<peer-server>' }));
            } catch (e) {
              // Ignore if already defined
            }
          }
        }
      }

      // Register AI provider names as variables (named: claude, gpt, etc.; default: ai)
      for (const stmt of node.body) {
        if (stmt.type === 'AiConfigDeclaration') {
          const aiName = stmt.name || 'ai';
          try {
            this.currentScope.define(aiName,
              new Symbol(aiName, 'builtin', null, false, stmt.loc));
          } catch (e) {
            // Ignore if already defined
          }
        }
      }

      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
      this._currentServerBlockName = prevServerBlockName;
    }
  };

  AnalyzerClass.prototype.visitRouteDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'route' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    this.visitExpression(node.handler);

    // Validate body type annotation is only used with POST/PUT/PATCH
    if (node.bodyType && !['POST', 'PUT', 'PATCH'].includes(node.method.toUpperCase())) {
      this.warn(`body type annotation on ${node.method} route is ignored — only POST, PUT, and PATCH routes parse request bodies`, node.loc);
    }

    // Route param ↔ handler signature type safety
    if (node.handler.type === 'Identifier') {
      const handlerName = node.handler.name;
      // Find the function declaration in the current server block scope
      const fnSym = this.currentScope.lookup(handlerName);
      if (fnSym && fnSym.kind === 'function' && fnSym._params) {
        const pathParams = new Set();
        const pathStr = node.path || '';
        const paramMatches = pathStr.match(/:([a-zA-Z_][a-zA-Z0-9_]*)/g);
        if (paramMatches) {
          for (const m of paramMatches) pathParams.add(m.slice(1));
        }
        const handlerParams = fnSym._params.filter(p => p !== 'req');
        for (const hp of handlerParams) {
          if (pathParams.size > 0 && !pathParams.has(hp) && node.method.toUpperCase() === 'GET') {
            // For GET routes, params not in path come from query — this is fine, just a warning
            this.warn(`Handler '${handlerName}' param '${hp}' not in route path '${pathStr}' — will be extracted from query string`, node.loc);
          }
        }
      }
    }
  };

  AnalyzerClass.prototype.visitMiddlewareDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'middleware' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitHealthCheckDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'health' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
  };

  AnalyzerClass.prototype.visitCorsDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'cors' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitErrorHandlerDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'on_error' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitWebSocketDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'ws' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const [, handler] of Object.entries(node.handlers)) {
      if (!handler) continue;
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('function');
      for (const param of handler.params) {
        try {
          this.currentScope.define(param.name,
            new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
      try {
        this.visitNode(handler.body);
      } finally {
        this.currentScope = prevScope;
      }
    }
  };

  AnalyzerClass.prototype.visitStaticDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'static' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
  };

  AnalyzerClass.prototype.visitDiscoverDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'discover' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    this.visitExpression(node.urlExpression);
  };

  AnalyzerClass.prototype.visitAuthDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'auth' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitMaxBodyDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'max_body' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    this.visitExpression(node.limit);
  };

  AnalyzerClass.prototype.visitRouteGroupDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'routes' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
  };

  AnalyzerClass.prototype.visitRateLimitDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'rate_limit' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitLifecycleHookDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'on_${node.hook}' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitSubscribeDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'subscribe' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitEnvDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'env' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'variable', node.typeAnnotation, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    if (node.defaultValue) {
      this.visitExpression(node.defaultValue);
    }
  };

  AnalyzerClass.prototype.visitScheduleDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'schedule' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    if (node.name) {
      try {
        this.currentScope.define(node.name,
          new Symbol(node.name, 'function', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitUploadDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'upload' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitSessionDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'session' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitDbDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'db' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitTlsDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'tls' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitCompressionDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'compression' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitBackgroundJobDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'background' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitCacheDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'cache' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  };

  AnalyzerClass.prototype.visitSseDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'sse' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    for (const p of node.params) {
      this.currentScope.define(p.name, { kind: 'param' });
    }
    try {
      for (const stmt of node.body.body || []) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitModelDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'model' can only be used inside a server block`, node.loc, "move this inside a server { } block", { code: 'E303' });
    }
    if (node.config) {
      for (const value of Object.values(node.config)) {
        this.visitExpression(value);
      }
    }
  };
}

// ─── src/analyzer/form-analyzer.js ─────────────────────

// Form-specific analyzer methods for the Tova language
// Extracted for lazy loading — only loaded when form { } blocks are encountered.
function installFormAnalyzer(AnalyzerClass) {
  if (AnalyzerClass.prototype._formAnalyzerInstalled) return;
  AnalyzerClass.prototype._formAnalyzerInstalled = true;

  const KNOWN_VALIDATORS = new Set([
    'required', 'minLength', 'maxLength', 'min', 'max',
    'pattern', 'email', 'matches', 'oneOf', 'validate',
  ]);

  AnalyzerClass.prototype.visitFormDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'browser') {
      this.error(`'form' can only be used inside a browser block or component`, node.loc,
        "move this inside a browser { } block", { code: 'E310' });
    }

    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'form', node.typeAnnotation, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('form');
    try {
      for (const field of node.fields) { this._visitFormField(field); }
      for (const group of node.groups) { this._visitFormGroup(group); }
      for (const arr of node.arrays) { this._visitFormArray(arr); }
      for (const comp of node.computeds) { this.visitNode(comp); }
      if (node.steps) { this._visitFormSteps(node, node.steps); }
      if (node.onSubmit) { this.visitNode(node.onSubmit); }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype._visitFormField = function(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'formField', node.typeAnnotation, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    if (node.initialValue) {
      this.visitExpression(node.initialValue);
    }
    for (const v of node.validators) {
      if (!KNOWN_VALIDATORS.has(v.name)) {
        this.warn(`Unknown validator '${v.name}'`, v.loc, null, { code: 'W_UNKNOWN_VALIDATOR' });
      }
      for (const arg of v.args) {
        this.visitExpression(arg);
      }
    }
  };

  AnalyzerClass.prototype._visitFormGroup = function(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'formGroup', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    if (node.condition) {
      this.visitExpression(node.condition);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const field of node.fields) { this._visitFormField(field); }
      for (const group of node.groups) { this._visitFormGroup(group); }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype._visitFormArray = function(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'formArray', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const field of node.fields) { this._visitFormField(field); }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype._visitFormSteps = function(formNode, stepsNode) {
    const knownMembers = new Set();
    for (const f of formNode.fields) knownMembers.add(f.name);
    for (const g of formNode.groups) knownMembers.add(g.name);
    for (const a of formNode.arrays) knownMembers.add(a.name);

    for (const step of stepsNode.steps) {
      for (const member of step.members) {
        if (!knownMembers.has(member)) {
          this.warn(`Step '${step.label}' references unknown member '${member}'`, step.loc, null, { code: 'W_STEP_UNKNOWN_MEMBER' });
        }
      }
    }
  };
}

// ─── src/analyzer/browser-analyzer.js ──────────────────

// Browser-specific analyzer methods for the Tova language
// Extracted from analyzer.js for lazy loading — only loaded when browser { } blocks are encountered.
function installBrowserAnalyzer(AnalyzerClass) {
  if (AnalyzerClass.prototype._browserAnalyzerInstalled) return;
  AnalyzerClass.prototype._browserAnalyzerInstalled = true;

  installFormAnalyzer(AnalyzerClass);

  AnalyzerClass.prototype.visitBrowserBlock = function(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('browser');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitStateDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'browser') {
      this.error(`'state' can only be used inside a browser block`, node.loc, "move this inside a browser { } block", { code: 'E302' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'state', node.typeAnnotation, true, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.initialValue);
  };

  AnalyzerClass.prototype.visitComputedDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'browser') {
      this.error(`'computed' can only be used inside a browser block`, node.loc, "move this inside a browser { } block", { code: 'E302' });
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'computed', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.expression);
  };

  AnalyzerClass.prototype.visitEffectDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'browser') {
      this.error(`'effect' can only be used inside a browser block`, node.loc, "move this inside a browser { } block", { code: 'E302' });
    }
    this.visitNode(node.body);
  };

  AnalyzerClass.prototype.visitComponentDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'browser') {
      this.error(`'component' can only be used inside a browser block`, node.loc, "move this inside a browser { } block", { code: 'E302' });
    }
    this._checkNamingConvention(node.name, 'component', node.loc);
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'component', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    try {
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitStoreDeclaration = function(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'browser') {
      this.error(`'store' can only be used inside a browser block`, node.loc, "move this inside a browser { } block", { code: 'E302' });
    }
    this._checkNamingConvention(node.name, 'store', node.loc);
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype._visitJSXChildren = function(children) {
    for (const child of children) {
      if (child.type === 'JSXElement') {
        this.visitJSXElement(child);
      } else if (child.type === 'JSXFragment') {
        this.visitJSXFragment(child);
      } else if (child.type === 'JSXExpression') {
        this.visitExpression(child.expression);
      } else if (child.type === 'JSXFor') {
        this.visitJSXFor(child);
      } else if (child.type === 'JSXIf') {
        this.visitJSXIf(child);
      } else if (child.type === 'JSXMatch') {
        this.visitJSXMatch(child);
      } else if (child.type === 'JSXText') {
        // JSXText wraps a TemplateLiteral/StringLiteral in its .value
        // Visit it so identifiers in interpolated strings are marked as used
        if (child.value) this.visitExpression(child.value);
      } else if (child.type) {
        // Other expression-type children
        this.visitExpression(child);
      }
    }
  };

  AnalyzerClass.prototype.visitJSXElement = function(node) {
    for (const attr of node.attributes) {
      if (attr.type === 'JSXSpreadAttribute') {
        this.visitExpression(attr.expression);
      } else {
        this.visitExpression(attr.value);
      }
    }
    this._visitJSXChildren(node.children);
  };

  AnalyzerClass.prototype.visitJSXFragment = function(node) {
    this._visitJSXChildren(node.children);
  };

  AnalyzerClass.prototype.visitJSXFor = function(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      this.visitExpression(node.iterable);
      const variable = node.variable;
      if (typeof variable === 'string') {
        try {
          this.currentScope.define(variable,
            new Symbol(variable, 'variable', null, false, node.loc));
        } catch (e) { this.error(e.message); }
      } else if (variable.type === 'ArrayPattern') {
        for (const el of variable.elements) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'variable', null, false, variable.loc));
          } catch (e) { this.error(e.message); }
        }
      } else if (variable.type === 'ObjectPattern') {
        for (const prop of variable.properties) {
          const name = prop.value || prop.key;
          try {
            this.currentScope.define(name,
              new Symbol(name, 'variable', null, false, variable.loc));
          } catch (e) { this.error(e.message); }
        }
      }
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  };

  AnalyzerClass.prototype.visitJSXIf = function(node) {
    this.visitExpression(node.condition);
    for (const child of node.consequent) {
      this.visitNode(child);
    }
    if (node.alternates) {
      for (const alt of node.alternates) {
        this.visitExpression(alt.condition);
        for (const child of alt.body) {
          this.visitNode(child);
        }
      }
    }
    if (node.alternate) {
      for (const child of node.alternate) {
        this.visitNode(child);
      }
    }
  };

  AnalyzerClass.prototype.visitJSXMatch = function(node) {
    this.visitExpression(node.subject);
    for (const arm of node.arms) {
      // Visit pattern bindings in a child scope
      for (const child of arm.body) {
        this.visitNode(child);
      }
    }
  };
}

// ─── src/analyzer/analyzer.js ──────────────────────────

// Pre-allocated constants for hot-path type checking (avoid per-call allocation)
const ARITHMETIC_OPS = new Set(['-', '*', '/', '%', '**']);
const NUMERIC_TYPES = new Set(['Int', 'Float']);

const _JS_GLOBALS = new Set([
  // Core globals
  'console', 'document', 'window', 'globalThis', 'self',
  'JSON', 'Math', 'Date', 'RegExp', 'Error', 'TypeError', 'RangeError',
  'SyntaxError', 'ReferenceError', 'URIError', 'EvalError', 'AggregateError',
  'Promise', 'Set', 'Map', 'WeakSet', 'WeakMap', 'WeakRef', 'Symbol',
  'Array', 'Object', 'String', 'Number', 'Boolean', 'Function',
  'BigInt', 'Proxy', 'Reflect',
  'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'NaN', 'Infinity',
  'undefined', 'null', 'true', 'false',
  'encodeURI', 'decodeURI', 'encodeURIComponent', 'decodeURIComponent',
  // Timers & scheduling
  'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
  'requestAnimationFrame', 'cancelAnimationFrame',
  'requestIdleCallback', 'cancelIdleCallback',
  'queueMicrotask', 'structuredClone',
  // Fetch & network
  'URL', 'URLSearchParams', 'Headers', 'Request', 'Response',
  'FormData', 'Blob', 'File', 'FileReader',
  'AbortController', 'AbortSignal',
  'fetch', 'WebSocket', 'EventSource', 'XMLHttpRequest',
  // Encoding
  'TextEncoder', 'TextDecoder',
  'atob', 'btoa', 'Buffer',
  // Browser APIs
  'crypto', 'performance', 'navigator', 'location', 'history', 'screen',
  'localStorage', 'sessionStorage',
  'alert', 'confirm', 'prompt',
  'getComputedStyle', 'matchMedia', 'getSelection',
  'scrollTo', 'scrollBy', 'scrollX', 'scrollY',
  'innerWidth', 'innerHeight', 'outerWidth', 'outerHeight',
  'devicePixelRatio',
  // DOM & Events
  'Event', 'CustomEvent', 'ErrorEvent',
  'MouseEvent', 'KeyboardEvent', 'FocusEvent', 'InputEvent',
  'TouchEvent', 'PointerEvent', 'WheelEvent', 'DragEvent',
  'ClipboardEvent', 'AnimationEvent', 'TransitionEvent',
  'HTMLElement', 'Element', 'Node', 'NodeList', 'DocumentFragment',
  'DOMParser', 'MutationObserver', 'IntersectionObserver', 'ResizeObserver',
  'Image', 'Audio',
  // Workers & channels
  'Worker', 'SharedWorker', 'BroadcastChannel', 'MessageChannel', 'MessagePort',
  // Media & graphics
  'AudioContext', 'OfflineAudioContext',
  'CanvasRenderingContext2D', 'WebGLRenderingContext',
  'MediaRecorder', 'MediaStream', 'MediaSource',
  // Notifications & clipboard
  'Notification', 'ClipboardItem',
  // Typed arrays
  'ArrayBuffer', 'SharedArrayBuffer', 'DataView',
  'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
  'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array',
  'Float32Array', 'Float64Array', 'BigInt64Array', 'BigUint64Array',
  // Streams
  'ReadableStream', 'WritableStream', 'TransformStream',
  // Server / Node / Bun
  'Bun', 'Deno', 'process', 'require', 'module', 'exports', '__dirname', '__filename',
]);

function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  // Ensure a is the shorter string for O(min(n,m)) space
  if (a.length > b.length) { const t = a; a = b; b = t; }
  const len = a.length;
  let prev = new Array(len + 1);
  let curr = new Array(len + 1);
  for (let j = 0; j <= len; j++) prev[j] = j;
  for (let i = 1; i <= b.length; i++) {
    curr[0] = i;
    for (let j = 1; j <= len; j++) {
      curr[j] = b[i-1] === a[j-1]
        ? prev[j-1]
        : Math.min(prev[j-1], curr[j-1], prev[j]) + 1;
    }
    const tmp = prev; prev = curr; curr = tmp;
  }
  return prev[len];
}

const _TOVA_RUNTIME = new Set([
  'Ok', 'Err', 'Some', 'None', 'Result', 'Option',
  'db', 'server', 'browser', 'client', 'shared',
]);

// Pre-built static candidate set for Levenshtein suggestions (N1 optimization)
// Lazily initialized on first use since BUILTIN_NAMES, _JS_GLOBALS, _TOVA_RUNTIME never change.
let _STATIC_SUGGESTION_NAMES = null;
function _getStaticSuggestionNames() {
  if (!_STATIC_SUGGESTION_NAMES) {
    _STATIC_SUGGESTION_NAMES = [];
    for (const n of BUILTIN_NAMES) _STATIC_SUGGESTION_NAMES.push(n);
    for (const n of _JS_GLOBALS) _STATIC_SUGGESTION_NAMES.push(n);
    for (const n of _TOVA_RUNTIME) _STATIC_SUGGESTION_NAMES.push(n);
  }
  return _STATIC_SUGGESTION_NAMES;
}
class Analyzer {
  constructor(ast, filename = '<stdin>', options = {}) {
    this.ast = ast;
    this.filename = filename;
    this.errors = [];
    this.warnings = [];
    this.tolerant = options.tolerant || false;
    this.strict = options.strict || false;
    this.globalScope = new Scope(null, 'module');
    this.currentScope = this.globalScope;
    this._allScopes = []; // Track all scopes for unused variable checking
    this._functionReturnTypeStack = []; // Stack of expected return types for type checking
    this._asyncDepth = 0; // Track nesting inside async functions for await validation

    // Propagate strict mode to the type system
    Type.strictMode = this.strict;

    // Type registry for LSP
    this.typeRegistry = {
      types: new Map(),   // type name → ADTType | RecordType
      impls: new Map(),   // type name → [{ name, params, returnType }]
      traits: new Map(),  // trait name → [{ name, paramTypes, returnType }]
    };

    // Register built-in types
    this.registerBuiltins();
  }

  registerBuiltins() {
    const builtins = [
      'Int', 'Float', 'String', 'Bool', 'Nil', 'Any',
      'print', 'range', 'len', 'type_of', 'enumerate', 'zip',
      'map', 'filter', 'reduce', 'sum', 'sorted', 'reversed',
      'fetch', 'db',
      'Ok', 'Err', 'Some', 'None', 'Result', 'Option',
      // Collections
      'find', 'any', 'all', 'flat_map', 'unique', 'group_by',
      'chunk', 'flatten', 'take', 'drop', 'first', 'last',
      'count', 'partition',
      // Math
      'abs', 'floor', 'ceil', 'round', 'clamp', 'sqrt', 'pow', 'random',
      // Strings
      'trim', 'split', 'join', 'replace', 'repeat',
      // Utility
      'keys', 'values', 'entries', 'merge', 'freeze', 'clone',
      // Async
      'sleep',
      // String functions
      'upper', 'lower', 'contains', 'starts_with', 'ends_with',
      'chars', 'words', 'lines', 'capitalize', 'title_case',
      'snake_case', 'camel_case',
      // Math extras
      'min', 'max',
      // Table operations
      'Table', 'table_where', 'table_select', 'table_derive',
      'table_group_by', 'table_agg', 'table_sort_by', 'table_limit',
      'table_join', 'table_pivot', 'table_unpivot', 'table_explode',
      'table_union', 'table_drop_duplicates', 'table_rename',
      // Table aggregation helpers
      'agg_sum', 'agg_count', 'agg_mean', 'agg_median', 'agg_min', 'agg_max',
      // Data exploration
      'peek', 'describe', 'schema_of',
      // Data cleaning
      'cast', 'drop_nil', 'fill_nil', 'filter_ok', 'filter_err',
      // I/O
      'read', 'write', 'stream',
      // CSV/JSONL helpers
      '__parseCSV', '__parseJSONL',
      // Table operation aliases (short names)
      'where', 'select', 'derive', 'agg', 'sort_by', 'limit',
      'pivot', 'unpivot', 'explode', 'union', 'drop_duplicates', 'rename',
      'mean', 'median',
      // Strings (new)
      'index_of', 'last_index_of', 'count_of', 'reverse_str', 'substr',
      'is_empty', 'kebab_case', 'center',
      // Collections (new)
      'zip_with', 'frequencies', 'scan', 'min_by', 'max_by', 'sum_by',
      'product', 'from_entries', 'has_key', 'get', 'pick', 'omit',
      'map_values', 'sliding_window',
      // JSON
      'json_parse', 'json_stringify', 'json_pretty',
      // Functional
      'compose', 'pipe_fn', 'identity', 'memoize', 'debounce', 'throttle',
      'once', 'negate',
      // Error handling
      'try_fn', 'try_async',
      // Async
      'parallel', 'timeout', 'retry',
      // Encoding
      'base64_encode', 'base64_decode', 'url_encode', 'url_decode',
      // Math (new)
      'hypot', 'lerp', 'divmod', 'avg',
      // Date/Time
      'now', 'now_iso',
      // Scripting
      'env', 'set_env', 'args', 'exit',
      'exists', 'is_dir', 'is_file', 'ls', 'glob_files',
      'mkdir', 'rm', 'cp', 'mv', 'cwd', 'chdir',
      'read_text', 'read_bytes', 'write_text',
      'sh', 'exec',
      // Scripting: new
      'read_stdin', 'read_lines',
      'script_path', 'script_dir',
      'parse_args',
      'color', 'bold', 'dim',
      // Scripting: signals, file stat, path utils, symlinks, async shell
      'on_signal',
      'file_stat', 'file_size',
      'path_join', 'path_dirname', 'path_basename', 'path_resolve', 'path_ext', 'path_relative',
      'symlink', 'readlink', 'is_symlink',
      'spawn',
      // Namespace modules
      'math', 'str', 'arr', 'dt', 're', 'json', 'fs', 'url',
      // Advanced collections
      'OrderedDict', 'DefaultDict', 'Counter', 'Deque', 'collections',
    ];
    for (const name of builtins) {
      this.globalScope.define(name, new Symbol(name, 'builtin', null, false, { line: 0, column: 0, file: '<builtin>' }));
    }
  }

  error(message, loc, hint = null, opts = {}) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    const e = {
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    };
    if (hint) e.hint = hint;
    if (opts.code) e.code = opts.code;
    if (opts.length) e.length = opts.length;
    if (opts.fix) e.fix = opts.fix;
    this.errors.push(e);
  }

  warn(message, loc, hint = null, opts = {}) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    const w = {
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    };
    if (hint) w.hint = hint;
    if (opts.code) w.code = opts.code;
    if (opts.length) w.length = opts.length;
    if (opts.fix) w.fix = opts.fix;
    this.warnings.push(w);
  }

  strictError(message, loc, hint = null, opts = {}) {
    if (this.strict) {
      this.error(message, loc, hint, opts);
    } else {
      this.warn(message, loc, hint, opts);
    }
  }

  // ─── Naming convention helpers ─────────────────────────────

  _isSnakeCase(name) {
    if (name.startsWith('_')) return true;
    if (name.length === 1) return true;
    if (/^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/.test(name)) return true; // UPPER_SNAKE_CASE
    return /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/.test(name);
  }

  _isPascalCase(name) {
    return /^[A-Z][a-zA-Z0-9]*$/.test(name);
  }

  _isUpperSnakeCase(name) {
    return /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/.test(name);
  }

  _toSnakeCase(name) {
    return name.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
  }

  _toPascalCase(name) {
    return name.replace(/(^|_)([a-z])/g, (_, __, c) => c.toUpperCase());
  }

  _checkNamingConvention(name, kind, loc) {
    if (!name || name.startsWith('_') || name.length === 1) return;
    if (this._isUpperSnakeCase(name)) return; // constants are valid for variables

    if (kind === 'type' || kind === 'component' || kind === 'store') {
      if (!this._isPascalCase(name)) {
        const suggested = this._toPascalCase(name);
        this.warn(
          `${kind[0].toUpperCase() + kind.slice(1)} '${name}' should use PascalCase`,
          loc,
          `Rename '${name}' to '${suggested}'`,
          { code: 'W100', length: name.length, fix: { description: `Rename to '${suggested}'`, replacement: suggested } }
        );
      }
    } else {
      // function, variable, parameter
      if (!this._isSnakeCase(name)) {
        const suggested = this._toSnakeCase(name);
        this.warn(
          `${kind[0].toUpperCase() + kind.slice(1)} '${name}' should use snake_case`,
          loc,
          `Rename '${name}' to '${suggested}'`,
          { code: 'W100', length: name.length, fix: { description: `Rename to '${suggested}'`, replacement: suggested } }
        );
      }
    }
  }

  analyze() {
    // Pre-pass hooks (e.g., server block function collection for RPC validation)
    for (const plugin of BlockRegistry.all()) {
      if (plugin.analyzer?.prePass) plugin.analyzer.prePass(this);
    }

    this.visitProgram(this.ast);

    // Post-visit cross-block validation
    for (const plugin of BlockRegistry.all()) {
      if (plugin.analyzer?.crossBlockValidate) plugin.analyzer.crossBlockValidate(this);
    }

    // Check for unused variables/imports (#9)
    this._collectAllScopes(this.globalScope);
    this._checkUnusedSymbols();

    if (this.errors.length > 0) {
      if (this.tolerant) {
        return { warnings: this.warnings, errors: this.errors, scope: this.globalScope, typeRegistry: this.typeRegistry };
      }
      const msgs = this.errors.map(e => `  ${e.file}:${e.line}:${e.column} — ${e.message}`);
      const err = new Error(`Analysis errors:\n${msgs.join('\n')}`);
      err.errors = this.errors;
      err.warnings = this.warnings;
      throw err;
    }

    return { warnings: this.warnings, scope: this.globalScope, typeRegistry: this.typeRegistry };
  }

  _checkUnusedSymbols() {
    for (const scope of this._allScopes) {
      // Only check inside functions, not module/server/client level
      if (!this._isScopeInsideFunction(scope)) continue;

      for (const [name, sym] of scope.symbols) {
        if (sym.kind === 'builtin') continue;
        if (name.startsWith('_')) continue;
        if (sym.kind === 'type') continue;
        if (sym.kind === 'parameter') continue;

        if (!sym.used && sym.loc && sym.loc.line > 0) {
          this.warn(`'${name}' is declared but never used`, sym.loc, "prefix with _ to suppress", {
            code: 'W001',
            length: name.length,
            fix: { description: `Prefix with _ to suppress: _${name}`, replacement: `_${name}` },
          });
        }
      }
    }

    // Check unused functions at module/server/client/shared level
    for (const scope of this._allScopes) {
      if (scope.context !== 'module' && scope.context !== 'server' &&
          scope.context !== 'client' && scope.context !== 'shared') continue;

      for (const [name, sym] of scope.symbols) {
        if (sym.kind !== 'function') continue;
        if (name.startsWith('_')) continue;
        if (sym.isPublic) continue;
        if (sym.extern) continue;
        if (sym._variantOf) continue; // ADT variant constructors
        if (name === 'main') continue;
        // Server functions are exposed as RPC endpoints callable from client blocks
        if (scope.context === 'server') continue;

        if (!sym.used && sym.loc && sym.loc.line > 0) {
          this.warn(`Function '${name}' is declared but never used`, sym.loc, "prefix with _ to suppress", {
            code: 'W002',
            length: name.length,
            fix: { description: `Prefix with _ to suppress: _${name}`, replacement: `_${name}` },
          });
        }
      }
    }
  }

  _collectAllScopes(scope) {
    this._allScopes.push(scope);
    for (const child of scope.children) {
      this._collectAllScopes(child);
    }
  }

  _isScopeInsideFunction(scope) {
    let s = scope;
    while (s) {
      if (s.context === 'function') return true;
      if (s.context === 'module' || s.context === 'server' || s.context === 'client' || s.context === 'shared') return false;
      s = s.parent;
    }
    return false;
  }

  // ─── Type Inference ──────────────────────────────────────

  _inferType(expr) {
    if (!expr) return null;
    switch (expr.type) {
      case 'NumberLiteral':
        return Number.isInteger(expr.value) ? 'Int' : 'Float';
      case 'StringLiteral':
      case 'TemplateLiteral':
        return 'String';
      case 'BooleanLiteral':
        return 'Bool';
      case 'NilLiteral':
        return 'Nil';
      case 'ArrayLiteral':
        if (expr.elements.length > 0) {
          const elType = this._inferType(expr.elements[0]);
          return elType ? `[${elType}]` : '[Any]';
        }
        return '[Any]';
      case 'CallExpression':
        if (expr.callee.type === 'Identifier') {
          const name = expr.callee.name;
          if (name === 'Ok') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Result<${innerType}, _>` : 'Result';
          }
          if (name === 'Err') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Result<_, ${innerType}>` : 'Result';
          }
          if (name === 'Some') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Option<${innerType}>` : 'Option';
          }
          if (name === 'len' || name === 'count') return 'Int';
          if (name === 'type_of') return 'String';
          if (name === 'random') return 'Float';
          // Look up declared return type from function symbol
          const fnSym = this.currentScope.lookup(name);
          if (fnSym && fnSym.kind === 'function') {
            if (fnSym._variantOf) return fnSym._variantOf;
            if (fnSym.type) {
              let retType = this._typeAnnotationToString(fnSym.type);
              // For generic functions, infer type params from call arguments
              if (fnSym._typeParams && fnSym._typeParams.length > 0 && fnSym._paramTypes) {
                const typeParamBindings = new Map();
                for (let i = 0; i < expr.arguments.length && i < fnSym._paramTypes.length; i++) {
                  const arg = expr.arguments[i];
                  if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
                  const paramTypeAnn = fnSym._paramTypes[i];
                  if (!paramTypeAnn) continue;
                  const actualType = this._inferType(arg);
                  if (actualType) {
                    this._inferTypeParamBindings(paramTypeAnn, actualType, fnSym._typeParams, typeParamBindings);
                  }
                }
                if (typeParamBindings.size > 0) {
                  retType = this._substituteTypeParams(retType, typeParamBindings);
                }
              }
              return retType;
            }
          }
        }
        return null;
      case 'Identifier':
        if (expr.name === 'None') return 'Option<_>';
        if (expr.name === 'true' || expr.name === 'false') return 'Bool';
        // Look up stored type
        const sym = this.currentScope.lookup(expr.name);
        return sym ? sym.inferredType : null;
      case 'TupleExpression':
        return `(${expr.elements.map(e => this._inferType(e) || 'Any').join(', ')})`;
      case 'BinaryExpression':
        if (expr.operator === '++') return 'String';
        if (['+', '-', '*', '/', '%', '**'].includes(expr.operator)) {
          const lt = this._inferType(expr.left);
          const rt = this._inferType(expr.right);
          if (!lt && !rt) return null;
          if (lt === 'Float' || rt === 'Float') return 'Float';
          if (lt === 'String' || rt === 'String') return 'String';
          return 'Int';
        }
        if (['==', '!=', '<', '>', '<=', '>='].includes(expr.operator)) return 'Bool';
        return null;
      case 'UnaryExpression':
        if (expr.operator === 'not' || expr.operator === '!') return 'Bool';
        if (expr.operator === '-') return this._inferType(expr.operand);
        return null;
      case 'LogicalExpression':
        return 'Bool';
      case 'PipeExpression':
        return this._inferPipeType(expr);
      case 'MemberExpression':
        // Infer .length as Int
        if (expr.property === 'length') return 'Int';
        return null;
      default:
        return null;
    }
  }

  /**
   * Infer the result type of a pipe expression like `arr |> filter(fn(x) x > 0) |> map(fn(x) x * 2)`.
   * The left side provides the input type; the right side determines the output type.
   */
  _inferPipeType(expr) {
    const inputType = this._inferType(expr.left);
    const right = expr.right;

    if (right.type === 'CallExpression' && right.callee.type === 'Identifier') {
      const fnName = right.callee.name;

      // Collection operations that preserve the array type
      if (['filter', 'sorted', 'reversed', 'unique', 'take', 'drop', 'skip'].includes(fnName)) {
        return inputType; // Same type as input
      }

      // map: transforms element type based on the mapper function
      if (fnName === 'map') {
        if (inputType && inputType.startsWith('[') && inputType.endsWith(']')) {
          // Try to infer the return type from the mapper function
          const mapperArg = right.arguments.length > 0 ? right.arguments[0] : null;
          if (mapperArg) {
            const mapperRetType = this._inferLambdaReturnType(mapperArg, inputType.slice(1, -1));
            if (mapperRetType) return `[${mapperRetType}]`;
          }
        }
        return inputType; // Fallback: preserve input type
      }

      // flat_map / flatten: reduce nesting
      if (fnName === 'flat_map' || fnName === 'flatMap') {
        if (inputType && inputType.startsWith('[') && inputType.endsWith(']')) {
          return inputType; // Simplified: same element type
        }
      }
      if (fnName === 'flatten') {
        if (inputType && inputType.startsWith('[[') && inputType.endsWith(']]')) {
          return inputType.slice(1, -1); // [[T]] -> [T]
        }
        return inputType;
      }

      // Reduction operations
      if (fnName === 'reduce' || fnName === 'fold') return null; // Can't easily infer
      if (fnName === 'join') return 'String';
      if (fnName === 'count' || fnName === 'len' || fnName === 'length') return 'Int';
      if (fnName === 'sum') return inputType === '[Float]' ? 'Float' : 'Int';
      if (fnName === 'any' || fnName === 'all' || fnName === 'every' || fnName === 'some') return 'Bool';
      if (fnName === 'first' || fnName === 'last' || fnName === 'find') {
        if (inputType && inputType.startsWith('[') && inputType.endsWith(']')) {
          return inputType.slice(1, -1); // [T] -> T
        }
      }

      // For user-defined functions, fall back to checking their return type
      const fnSym = this.currentScope.lookup(fnName);
      if (fnSym && fnSym.kind === 'function' && fnSym.type) {
        return this._typeAnnotationToString(fnSym.type);
      }
    }

    // If we can't infer the right side, return null
    return null;
  }

  /**
   * Try to infer the return type of a lambda expression given the input element type.
   */
  _inferLambdaReturnType(lambdaExpr, inputElementType) {
    if (!lambdaExpr) return null;
    if (lambdaExpr.type === 'LambdaExpression') {
      // For simple expression bodies, infer the result type
      if (lambdaExpr.body && lambdaExpr.body.type !== 'BlockStatement') {
        return this._inferType(lambdaExpr.body);
      }
    }
    return null;
  }

  _typeAnnotationToString(ann) {
    if (!ann) return null;
    if (typeof ann === 'string') return ann;
    switch (ann.type) {
      case 'TypeAnnotation':
        if (ann.typeParams && ann.typeParams.length > 0) {
          const params = ann.typeParams.map(p => this._typeAnnotationToString(p)).join(', ');
          return `${ann.name}<${params}>`;
        }
        return ann.name;
      case 'ArrayTypeAnnotation':
        return `[${this._typeAnnotationToString(ann.elementType) || 'Any'}]`;
      case 'TupleTypeAnnotation':
        return `(${ann.elementTypes.map(t => this._typeAnnotationToString(t) || 'Any').join(', ')})`;
      case 'FunctionTypeAnnotation':
        return 'Function';
      case 'UnionTypeAnnotation':
        return ann.members.map(m => this._typeAnnotationToString(m) || 'Any').join(' | ');
      default:
        return null;
    }
  }

  _parseGenericType(typeStr) {
    if (!typeStr) return { base: typeStr, params: [] };
    // Check cache first
    if (!this._parseGenericCache) this._parseGenericCache = new Map();
    const cached = this._parseGenericCache.get(typeStr);
    if (cached) return cached;

    const ltIdx = typeStr.indexOf('<');
    if (ltIdx === -1) {
      const result = { base: typeStr, params: [] };
      this._parseGenericCache.set(typeStr, result);
      return result;
    }
    const base = typeStr.slice(0, ltIdx);
    const inner = typeStr.slice(ltIdx + 1, typeStr.lastIndexOf('>'));
    // Split on top-level commas (respecting nested <>)
    const params = [];
    let depth = 0;
    let start = 0;
    for (let i = 0; i < inner.length; i++) {
      if (inner[i] === '<') depth++;
      else if (inner[i] === '>') depth--;
      else if (inner[i] === ',' && depth === 0) {
        params.push(inner.slice(start, i).trim());
        start = i + 1;
      }
    }
    params.push(inner.slice(start).trim());
    const result = { base, params };
    this._parseGenericCache.set(typeStr, result);
    return result;
  }

  _typesCompatible(expected, actual) {
    // Unknown types are always compatible (gradual typing)
    if (!expected || !actual) return true;
    if (expected === 'Any' || actual === 'Any') return true;
    if (expected === '_' || actual === '_') return true;
    // Resolve type aliases before comparison
    expected = this._resolveTypeAlias(expected);
    actual = this._resolveTypeAlias(actual);
    // Exact match
    if (expected === actual) return true;
    // Numeric compatibility: Int -> Float widening is safe; Float -> Int requires explicit conversion
    if (expected === 'Float' && actual === 'Int') return true;
    if (expected === 'Int' && actual === 'Float') return false; // caller should emit warning/error
    // Nil is compatible with Option
    if (actual === 'Nil' && (expected === 'Option' || expected.startsWith('Option'))) return true;
    if ((expected === 'Nil') && (actual === 'Option' || actual.startsWith('Option'))) return true;
    // Union type compatibility: actual must be assignable to one of the expected union members
    if (expected.includes(' | ')) {
      const members = expected.split(' | ').map(m => m.trim());
      return members.some(m => this._typesCompatible(m, actual));
    }
    // If actual is a union, every member must be compatible with expected
    if (actual.includes(' | ')) {
      const members = actual.split(' | ').map(m => m.trim());
      return members.every(m => this._typesCompatible(expected, m));
    }
    // Nil is compatible with union types that include Nil
    if (actual === 'Nil' && expected.includes('Nil')) return true;
    // Array compatibility: check element types
    if (expected.startsWith('[') && actual.startsWith('[')) {
      const expEl = expected.slice(1, -1);
      const actEl = actual.slice(1, -1);
      return this._typesCompatible(expEl, actEl);
    }
    // Tuple compatibility: check element types pairwise
    if (expected.startsWith('(') && actual.startsWith('(')) {
      const expEls = expected.slice(1, -1).split(', ');
      const actEls = actual.slice(1, -1).split(', ');
      if (expEls.length !== actEls.length) return false;
      return expEls.every((e, i) => this._typesCompatible(e, actEls[i]));
    }
    // Generic type compatibility: Result<Int, String> vs Result<String, Int>
    const expG = this._parseGenericType(expected);
    const actG = this._parseGenericType(actual);
    if (expG.params.length > 0 || actG.params.length > 0) {
      // Base types must match
      if (expG.base !== actG.base) return false;
      // If one has no params (plain `Result`), compatible with any parameterized version (gradual typing)
      if (expG.params.length === 0 || actG.params.length === 0) return true;
      // Compare params pairwise
      if (expG.params.length !== actG.params.length) return false;
      return expG.params.every((ep, i) => this._typesCompatible(ep, actG.params[i]));
    }
    return false;
  }

  // ─── Visitors ─────────────────────────────────────────────

  visitProgram(node) {
    for (const stmt of node.body) {
      if (this.tolerant) {
        try { this.visitNode(stmt); } catch (e) { /* skip nodes that crash in tolerant mode */ }
      } else {
        this.visitNode(stmt);
      }
    }
  }

  visitNode(node) {
    if (!node) return;

    // Single registry lookup: returns plugin, NOOP sentinel, or null
    const entry = BlockRegistry.getByAstType(node.type);
    if (entry) {
      if (entry === BlockRegistry.NOOP) return;
      if (entry.analyzer?.visit) return entry.analyzer.visit(this, node);
    }

    switch (node.type) {
      case 'Assignment': return this.visitAssignment(node);
      case 'VarDeclaration': return this.visitVarDeclaration(node);
      case 'LetDestructure': return this.visitLetDestructure(node);
      case 'FunctionDeclaration': return this.visitFunctionDeclaration(node);
      case 'TypeDeclaration': return this.visitTypeDeclaration(node);
      case 'ImportDeclaration': return this.visitImportDeclaration(node);
      case 'ImportDefault': return this.visitImportDefault(node);
      case 'ImportWildcard': return this.visitImportWildcard(node);
      case 'IfStatement': return this.visitIfStatement(node);
      case 'ForStatement': return this.visitForStatement(node);
      case 'WhileStatement': return this.visitWhileStatement(node);
      case 'LoopStatement': return this.visitLoopStatement(node);
      case 'TryCatchStatement': return this.visitTryCatchStatement(node);
      case 'ReturnStatement': return this.visitReturnStatement(node);
      case 'ExpressionStatement': return this.visitExpression(node.expression);
      case 'BlockStatement': return this.visitBlock(node);
      case 'CompoundAssignment': return this.visitCompoundAssignment(node);
      case 'BreakStatement': return this.visitBreakStatement(node);
      case 'ContinueStatement': return this.visitContinueStatement(node);
      case 'GuardStatement': return this.visitGuardStatement(node);
      case 'InterfaceDeclaration': return this.visitInterfaceDeclaration(node);
      case 'RefinementType': return;
      case 'ComponentStyleBlock': return; // raw CSS — no analysis needed
      case 'ImplDeclaration': return this.visitImplDeclaration(node);
      case 'TraitDeclaration': return this.visitTraitDeclaration(node);
      case 'TypeAlias': return this.visitTypeAlias(node);
      case 'DeferStatement': return this.visitDeferStatement(node);
      case 'ExternDeclaration': return this.visitExternDeclaration(node);
      default:
        // Expression nodes
        this.visitExpression(node);
    }
  }

  _visitServerNode(node) {
    const methodName = 'visit' + node.type;
    return this[methodName](node);
  }

  _visitBrowserNode(node) {
    // Ensure browser analyzer is installed (may be called from visitExpression for JSX)
    const plugin = BlockRegistry.get('browser');
    return plugin.analyzer.visit(this, node);
  }

  visitExpression(node) {
    if (!node) return;

    switch (node.type) {
      case 'Identifier':
        return this.visitIdentifier(node);
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return;
      case 'TemplateLiteral':
        for (const part of node.parts) {
          if (part.type === 'expr') this.visitExpression(part.value);
        }
        return;
      case 'BinaryExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        this._checkBinaryExprTypes(node);
        return;
      case 'UnaryExpression':
        this.visitExpression(node.operand);
        return;
      case 'LogicalExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'ChainedComparison':
        for (const op of node.operands) this.visitExpression(op);
        return;
      case 'MembershipExpression':
        this.visitExpression(node.value);
        this.visitExpression(node.collection);
        return;
      case 'CallExpression':
        // Validate inter-server RPC calls: peerName.functionName()
        if (this._currentServerBlockName && node.callee.type === 'MemberExpression' &&
            node.callee.object.type === 'Identifier' && !node.callee.computed) {
          const targetName = node.callee.object.name;
          const fnName = node.callee.property;
          if (targetName === this._currentServerBlockName) {
            this.warn(`Server block "${targetName}" is calling itself via RPC — consider calling the function directly`, node.loc);
          } else if (this.serverBlockFunctions.has(targetName)) {
            const peerFns = this.serverBlockFunctions.get(targetName);
            if (!peerFns.includes(fnName)) {
              this.error(`No function '${fnName}' in server block "${targetName}"`, node.loc);
            }
          }
        }
        // Argument count and type validation for known functions
        this._checkCallArgCount(node);
        this._checkCallArgTypes(node);
        this.visitExpression(node.callee);
        for (const arg of node.arguments) {
          if (arg.type === 'NamedArgument') {
            this.visitExpression(arg.value);
          } else {
            this.visitExpression(arg);
          }
        }
        return;
      case 'MemberExpression':
      case 'OptionalChain':
        this.visitExpression(node.object);
        if (node.computed) this.visitExpression(node.property);
        return;
      case 'PipeExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'LambdaExpression':
        return this.visitLambda(node);
      case 'MatchExpression':
        return this.visitMatchExpression(node);
      case 'ArrayLiteral':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'ObjectLiteral':
        for (const prop of node.properties) {
          if (prop.spread) {
            // Spread property: {...expr}
            this.visitExpression(prop.argument);
          } else if (prop.shorthand) {
            // Shorthand: {name} — key IS the variable reference
            this.visitExpression(prop.key);
          } else {
            // Non-shorthand: {key: value} — only visit value, key is a label
            this.visitExpression(prop.value);
          }
        }
        return;
      case 'ListComprehension':
        return this.visitListComprehension(node);
      case 'DictComprehension':
        return this.visitDictComprehension(node);
      case 'RangeExpression':
        this.visitExpression(node.start);
        this.visitExpression(node.end);
        return;
      case 'SliceExpression':
        this.visitExpression(node.object);
        if (node.start) this.visitExpression(node.start);
        if (node.end) this.visitExpression(node.end);
        if (node.step) this.visitExpression(node.step);
        return;
      case 'SpreadExpression':
        this.visitExpression(node.argument);
        return;
      case 'PropagateExpression':
        this.visitExpression(node.expression);
        return;
      case 'AwaitExpression':
        if (this._asyncDepth === 0) {
          this.error("'await' can only be used inside an async function", node.loc, "add 'async' to the enclosing function declaration", { code: 'E300' });
        }
        this.visitExpression(node.argument);
        return;
      case 'SpawnExpression':
        if (!this._concurrentDepth) {
          this.warn("'spawn' should be used inside a 'concurrent' block", node.loc, null, {
            code: 'W_SPAWN_OUTSIDE_CONCURRENT',
          });
        }
        if (node.callee) this.visitExpression(node.callee);
        if (node.arguments) {
          for (const arg of node.arguments) {
            this.visitExpression(arg);
          }
        }
        return;
      case 'YieldExpression':
        if (node.argument) this.visitExpression(node.argument);
        return;
      case 'TupleExpression':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'IfExpression':
        this.visitExpression(node.condition);
        this.visitNode(node.consequent);
        for (const alt of node.alternates) {
          this.visitExpression(alt.condition);
          this.visitNode(alt.body);
        }
        this.visitNode(node.elseBody);
        return;
      case 'JSXElement':
      case 'JSXFragment':
        return this._visitBrowserNode(node);
      // Column expressions (for table operations) — no semantic analysis needed
      case 'ColumnExpression':
        return;
      case 'ColumnAssignment':
        this.visitExpression(node.expression);
        return;
      case 'NegatedColumnExpression':
        return;
    }
  }

  // ─── Block visitors ───────────────────────────────────────

  visitDataBlock(node) {
    // Register source and pipeline names in global scope
    for (const stmt of node.body) {
      if (stmt.type === 'SourceDeclaration') {
        try {
          this.currentScope.define(stmt.name,
            new Symbol(stmt.name, 'variable', null, false, stmt.loc));
        } catch (e) { /* already defined */ }
        if (stmt.expression) this.visitExpression(stmt.expression);
      } else if (stmt.type === 'PipelineDeclaration') {
        try {
          this.currentScope.define(stmt.name,
            new Symbol(stmt.name, 'variable', null, false, stmt.loc));
        } catch (e) { /* already defined */ }
        if (stmt.expression) this.visitExpression(stmt.expression);
      }
    }
  }

  visitSecurityBlock(node) {
    // Per-block: only check for duplicate role names within this block
    const localRoles = new Set();
    for (const stmt of node.body) {
      if (stmt.type === 'SecurityRoleDeclaration') {
        if (localRoles.has(stmt.name)) {
          this.warnings.push({
            message: `Duplicate role definition: '${stmt.name}'`,
            loc: stmt.loc,
            code: 'W_DUPLICATE_ROLE',
          });
        }
        localRoles.add(stmt.name);
      }
    }
  }

  visitCliBlock(node) {
    const validKeys = new Set(['name', 'version', 'description']);

    // Validate config keys
    for (const field of node.config) {
      if (!validKeys.has(field.key)) {
        this.warnings.push({
          message: `Unknown cli config key '${field.key}' — valid keys are: ${[...validKeys].join(', ')}`,
          loc: field.loc,
          code: 'W_UNKNOWN_CLI_CONFIG',
        });
      }
    }

    // Validate commands
    const commandNames = new Set();
    for (const cmd of node.commands) {
      // Duplicate command names
      if (commandNames.has(cmd.name)) {
        this.warnings.push({
          message: `Duplicate cli command '${cmd.name}'`,
          loc: cmd.loc,
          code: 'W_DUPLICATE_CLI_COMMAND',
        });
      }
      commandNames.add(cmd.name);

      // Check for positional args after flags
      let seenFlag = false;
      for (const param of cmd.params) {
        if (param.isFlag) {
          seenFlag = true;
        } else if (seenFlag) {
          this.warnings.push({
            message: `Positional argument '${param.name}' after flag in command '${cmd.name}' — positionals should come before flags`,
            loc: param.loc,
            code: 'W_POSITIONAL_AFTER_FLAG',
          });
        }
      }

      // Visit command body with params in scope
      this.pushScope('function');
      for (const param of cmd.params) {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', null, false, param.loc));
      }
      this.visitNode(cmd.body);
      this.popScope();
    }
  }

  visitConcurrentBlock(node) {
    // Validate mode
    const validModes = new Set(['all', 'cancel_on_error', 'first', 'timeout']);
    if (!validModes.has(node.mode)) {
      this.warn(`Unknown concurrent block mode '${node.mode}'`, node.loc, null, {
        code: 'W_UNKNOWN_CONCURRENT_MODE',
      });
    }

    // Validate timeout
    if (node.mode === 'timeout' && !node.timeout) {
      this.warn("concurrent timeout mode requires a timeout value", node.loc, null, {
        code: 'W_MISSING_TIMEOUT',
      });
    }

    // Warn on empty block
    if (node.body.length === 0) {
      this.warn("Empty concurrent block", node.loc, null, {
        code: 'W_EMPTY_CONCURRENT',
      });
    }

    // Track concurrent depth for spawn validation
    this._concurrentDepth = (this._concurrentDepth || 0) + 1;

    // Visit body statements (concurrent block does NOT create a new scope —
    // variables assigned inside should be visible after the block)
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }

    // Check spawned functions for WASM compatibility — warn if mixed WASM/non-WASM
    let hasWasm = false;
    let hasNonWasm = false;
    for (const stmt of node.body) {
      const spawn = (stmt.type === 'Assignment' && stmt.values && stmt.values[0] && stmt.values[0].type === 'SpawnExpression')
        ? stmt.values[0]
        : (stmt.type === 'ExpressionStatement' && stmt.expression && stmt.expression.type === 'SpawnExpression')
          ? stmt.expression
          : null;
      if (!spawn) continue;
      const calleeName = spawn.callee && spawn.callee.type === 'Identifier' ? spawn.callee.name : null;
      if (calleeName) {
        const sym = this.currentScope.lookup(calleeName);
        if (sym && sym.isWasm) {
          hasWasm = true;
        } else {
          hasNonWasm = true;
        }
      } else {
        // Lambda or complex expression — always non-WASM
        hasNonWasm = true;
      }
    }
    if (hasWasm && hasNonWasm) {
      this.warn(
        "concurrent block mixes @wasm and non-WASM tasks — non-WASM tasks will fall back to async JS execution",
        node.loc, null, { code: 'W_SPAWN_WASM_FALLBACK' }
      );
    }

    this._concurrentDepth--;
  }

  visitSelectStatement(node) {
    if (node.cases.length === 0) {
      this.warn("Empty select block", node.loc, null, {
        code: 'W_EMPTY_SELECT',
      });
    }

    let defaultCount = 0;
    let timeoutCount = 0;
    for (const c of node.cases) {
      if (c.kind === 'default') defaultCount++;
      if (c.kind === 'timeout') timeoutCount++;
    }

    if (defaultCount > 1) {
      this.warn("select block has multiple default cases", node.loc, null, {
        code: 'W_DUPLICATE_SELECT_DEFAULT',
      });
    }
    if (timeoutCount > 1) {
      this.warn("select block has multiple timeout cases", node.loc, null, {
        code: 'W_DUPLICATE_SELECT_TIMEOUT',
      });
    }
    if (defaultCount > 0 && timeoutCount > 0) {
      this.warn("select block has both default and timeout — default makes timeout unreachable", node.loc, null, {
        code: 'W_SELECT_DEFAULT_TIMEOUT',
      });
    }

    // Visit each case's expressions and body
    for (const c of node.cases) {
      if (c.channel) this.visitNode(c.channel);
      if (c.value) this.visitNode(c.value);

      if (c.kind === 'receive' && c.binding) {
        // Create scope for the binding variable
        this.pushScope('select-case');
        this.currentScope.define(c.binding,
          new Symbol(c.binding, 'variable', null, false, c.loc));
        for (const stmt of c.body) {
          this.visitNode(stmt);
        }
        this.popScope();
      } else {
        for (const stmt of c.body) {
          this.visitNode(stmt);
        }
      }
    }
  }

  _validateCliCrossBlock() {
    const cliBlocks = this.ast.body.filter(n => n.type === 'CliBlock');
    if (cliBlocks.length === 0) return;

    // Warn if cli + server coexist
    const hasServer = this.ast.body.some(n => n.type === 'ServerBlock');
    if (hasServer) {
      this.warnings.push({
        message: 'cli {} and server {} blocks in the same file — cli produces a standalone executable, not a web server',
        loc: cliBlocks[0].loc,
        code: 'W_CLI_WITH_SERVER',
      });
    }

    // Check for missing name across all cli blocks
    let hasName = false;
    for (const block of cliBlocks) {
      for (const field of block.config) {
        if (field.key === 'name') hasName = true;
      }
    }
    if (!hasName) {
      this.warnings.push({
        message: 'cli block has no name: field — consider adding name: "your-tool"',
        loc: cliBlocks[0].loc,
        code: 'W_CLI_MISSING_NAME',
      });
    }
  }

  visitEdgeBlock(node) {
    const validTargets = new Set(['cloudflare', 'deno', 'vercel', 'lambda', 'bun']);
    const validConfigKeys = new Set(['target']);
    const bindingNames = new Set();

    // Binding support matrix per target
    const BINDING_SUPPORT = {
      cloudflare: { kv: true, sql: true, storage: true, queue: true },
      deno:       { kv: true, sql: false, storage: false, queue: false },
      vercel:     { kv: false, sql: false, storage: false, queue: false },
      lambda:     { kv: false, sql: false, storage: false, queue: false },
      bun:        { kv: false, sql: true, storage: false, queue: false },
    };

    // Targets that support schedule/consume/middleware
    const SCHEDULE_TARGETS = new Set(['cloudflare', 'deno']);
    const CONSUME_TARGETS = new Set(['cloudflare']);

    // Determine target from config fields
    let target = 'cloudflare';
    for (const stmt of node.body) {
      if (stmt.type === 'EdgeConfigField' && stmt.key === 'target' && stmt.value.type === 'StringLiteral') {
        target = stmt.value.value;
      }
    }

    this.pushScope('edge');

    let kvCount = 0;
    const queueNames = new Set();
    const consumers = [];

    for (const stmt of node.body) {
      // Validate config fields
      if (stmt.type === 'EdgeConfigField') {
        if (!validConfigKeys.has(stmt.key)) {
          this.warnings.push({
            message: `Unknown edge config key '${stmt.key}' — valid keys are: ${[...validConfigKeys].join(', ')}`,
            loc: stmt.loc,
            code: 'W_UNKNOWN_EDGE_CONFIG',
          });
        }
        if (stmt.key === 'target' && stmt.value.type === 'StringLiteral') {
          if (!validTargets.has(stmt.value.value)) {
            this.warnings.push({
              message: `Unknown edge target '${stmt.value.value}' — valid targets are: ${[...validTargets].join(', ')}`,
              loc: stmt.loc,
              code: 'W_UNKNOWN_EDGE_TARGET',
            });
          }
        }
        continue;
      }

      // Check for duplicate binding names
      if (stmt.type === 'EdgeKVDeclaration' || stmt.type === 'EdgeSQLDeclaration' ||
          stmt.type === 'EdgeStorageDeclaration' || stmt.type === 'EdgeQueueDeclaration') {
        if (bindingNames.has(stmt.name)) {
          this.warnings.push({
            message: `Duplicate edge binding '${stmt.name}'`,
            loc: stmt.loc,
            code: 'W_DUPLICATE_EDGE_BINDING',
          });
        }
        bindingNames.add(stmt.name);
      }

      // Track queue names for consume validation
      if (stmt.type === 'EdgeQueueDeclaration') {
        queueNames.add(stmt.name);
      }

      // Check for duplicate env/secret names
      if (stmt.type === 'EdgeEnvDeclaration' || stmt.type === 'EdgeSecretDeclaration') {
        if (bindingNames.has(stmt.name)) {
          this.warnings.push({
            message: `Duplicate edge binding '${stmt.name}'`,
            loc: stmt.loc,
            code: 'W_DUPLICATE_EDGE_BINDING',
          });
        }
        bindingNames.add(stmt.name);
      }

      // Unsupported binding warnings (per target)
      const support = BINDING_SUPPORT[target] || BINDING_SUPPORT.cloudflare;
      if (stmt.type === 'EdgeKVDeclaration' && !support.kv) {
        this.warnings.push({
          message: `KV binding '${stmt.name}' is not supported on target '${target}' — it will be stubbed as null`,
          loc: stmt.loc,
          code: 'W_UNSUPPORTED_KV',
        });
      }
      if (stmt.type === 'EdgeSQLDeclaration' && !support.sql) {
        this.warnings.push({
          message: `SQL binding '${stmt.name}' is not supported on target '${target}' — it will be stubbed as null`,
          loc: stmt.loc,
          code: 'W_UNSUPPORTED_SQL',
        });
      }
      if (stmt.type === 'EdgeStorageDeclaration' && !support.storage) {
        this.warnings.push({
          message: `Storage binding '${stmt.name}' is not supported on target '${target}' — it will be stubbed as null`,
          loc: stmt.loc,
          code: 'W_UNSUPPORTED_STORAGE',
        });
      }
      if (stmt.type === 'EdgeQueueDeclaration' && !support.queue) {
        this.warnings.push({
          message: `Queue binding '${stmt.name}' is not supported on target '${target}' — it will be stubbed as null`,
          loc: stmt.loc,
          code: 'W_UNSUPPORTED_QUEUE',
        });
      }

      // Deno multi-KV warning
      if (stmt.type === 'EdgeKVDeclaration') {
        kvCount++;
        if (kvCount > 1 && target === 'deno') {
          this.warnings.push({
            message: `Deno Deploy supports only one KV store — '${stmt.name}' will share the same store as the first KV binding`,
            loc: stmt.loc,
            code: 'W_DENO_MULTI_KV',
          });
        }
      }

      // Validate schedule cron expressions + target support
      if (stmt.type === 'EdgeScheduleDeclaration') {
        const parts = stmt.cron.split(/\s+/);
        if (parts.length < 5 || parts.length > 6) {
          this.warnings.push({
            message: `Invalid cron expression '${stmt.cron}' — expected 5 or 6 space-separated fields`,
            loc: stmt.loc,
            code: 'W_INVALID_CRON',
          });
        }
        if (!SCHEDULE_TARGETS.has(target)) {
          this.warnings.push({
            message: `Scheduled tasks are not supported on target '${target}' — schedule '${stmt.name}' will be ignored. Supported targets: ${[...SCHEDULE_TARGETS].join(', ')}`,
            loc: stmt.loc,
            code: 'W_UNSUPPORTED_SCHEDULE',
          });
        }
      }

      // Collect consume declarations for post-loop validation
      if (stmt.type === 'EdgeConsumeDeclaration') {
        consumers.push(stmt);
        if (!CONSUME_TARGETS.has(target)) {
          this.warnings.push({
            message: `Queue consumers are not supported on target '${target}' — consume '${stmt.queue}' will be ignored. Supported targets: ${[...CONSUME_TARGETS].join(', ')}`,
            loc: stmt.loc,
            code: 'W_UNSUPPORTED_CONSUME',
          });
        }
      }

      // Visit child nodes — edge-specific types are noop in the registry,
      // so explicitly visit bodies that contain statements
      if (stmt.type === 'EdgeScheduleDeclaration' && stmt.body) {
        for (const s of stmt.body.body || []) this.visitNode(s);
      } else if (stmt.type === 'FunctionDeclaration' || stmt.type === 'RouteDeclaration') {
        this.visitNode(stmt);
      }
    }

    // Post-loop: validate consume references a declared queue
    for (const consumer of consumers) {
      if (!queueNames.has(consumer.queue)) {
        this.warnings.push({
          message: `consume '${consumer.queue}' references undeclared queue binding — add 'queue ${consumer.queue}' to the edge block`,
          loc: consumer.loc,
          code: 'W_CONSUME_UNKNOWN_QUEUE',
        });
      }
    }

    // Warn if edge block has no route or schedule handlers
    const hasRoutes = node.body.some(s => s.type === 'RouteDeclaration');
    const hasSchedules = node.body.some(s => s.type === 'EdgeScheduleDeclaration');
    const hasConsumers = consumers.length > 0;
    if (!hasRoutes && !hasSchedules && !hasConsumers) {
      this.warnings.push({
        message: 'edge block has no routes, schedules, or consumers — it will produce no handlers',
        loc: node.loc,
        code: 'W_EDGE_NO_HANDLERS',
      });
    }

    this.popScope();
  }

  _validateEdgeCrossBlock() {
    const edgeBlocks = this.ast.body.filter(n => n.type === 'EdgeBlock');
    if (edgeBlocks.length === 0) return;

    // Warn if edge + cli coexist (cli takes over with earlyReturn)
    const hasCli = this.ast.body.some(n => n.type === 'CliBlock');
    if (hasCli) {
      this.warnings.push({
        message: 'edge {} and cli {} blocks in the same file — cli produces a standalone executable, edge block will be ignored',
        loc: edgeBlocks[0].loc,
        code: 'W_EDGE_WITH_CLI',
      });
    }
  }

  _validateSecurityCrossBlock() {
    // Collect ALL security declarations across ALL security blocks in the AST
    const allRoles = new Set();
    const allProtects = [];
    const allSensitives = [];
    let hasAuth = false;
    let hasProtect = false;
    let authDecl = null;
    let corsDecl = null;
    let rateLimitDecl = null;
    let csrfDecl = null;

    const roleDecls = []; // track all role declarations for cross-block duplicate detection
    for (const node of this.ast.body) {
      if (node.type !== 'SecurityBlock') continue;
      for (const stmt of node.body) {
        if (stmt.type === 'SecurityRoleDeclaration') {
          roleDecls.push(stmt);
          allRoles.add(stmt.name);
        } else if (stmt.type === 'SecurityProtectDeclaration') {
          allProtects.push(stmt);
          hasProtect = true;
        } else if (stmt.type === 'SecuritySensitiveDeclaration') {
          allSensitives.push(stmt);
        } else if (stmt.type === 'SecurityAuthDeclaration') {
          hasAuth = true;
          authDecl = stmt;
        } else if (stmt.type === 'SecurityCorsDeclaration') {
          corsDecl = stmt;
        } else if (stmt.type === 'SecurityRateLimitDeclaration') {
          rateLimitDecl = stmt;
        } else if (stmt.type === 'SecurityCsrfDeclaration') {
          csrfDecl = stmt;
        }
      }
    }

    // W_DUPLICATE_ROLE across blocks: detect roles with same name in different security blocks
    const seenRoleNames = new Map(); // name -> first declaration
    for (const decl of roleDecls) {
      const prev = seenRoleNames.get(decl.name);
      if (prev && prev.loc !== decl.loc) {
        // Only warn if this is from a different block (same-block dupes handled by visitSecurityBlock)
        const prevInSameBlock = this.ast.body.some(b =>
          b.type === 'SecurityBlock' && b.body.includes(prev) && b.body.includes(decl)
        );
        if (!prevInSameBlock) {
          this.warnings.push({
            message: `Role '${decl.name}' is defined in multiple security blocks — later definition overwrites earlier one`,
            loc: decl.loc,
            code: 'W_DUPLICATE_ROLE',
          });
        }
      }
      seenRoleNames.set(decl.name, decl);
    }

    // W_UNKNOWN_AUTH_TYPE — validate auth type is a known value
    if (authDecl && authDecl.authType) {
      const validAuthTypes = ['jwt', 'api_key'];
      if (!validAuthTypes.includes(authDecl.authType)) {
        this.warnings.push({
          message: `Unknown auth type '${authDecl.authType}' — supported types are: ${validAuthTypes.join(', ')}`,
          loc: authDecl.loc,
          code: 'W_UNKNOWN_AUTH_TYPE',
        });
      }
    }

    // Fix 2: W_HARDCODED_SECRET — warn if auth secret is a string literal
    if (authDecl && authDecl.config.secret) {
      const secretNode = authDecl.config.secret;
      if (secretNode.type === 'StringLiteral') {
        this.warnings.push({
          message: 'Auth secret is hardcoded as a string literal — use env("SECRET_NAME") instead',
          loc: authDecl.loc,
          code: 'W_HARDCODED_SECRET',
        });
      }
    }

    // Fix 7: W_CORS_WILDCARD — warn if cors origins contains "*"
    if (corsDecl && corsDecl.config.origins) {
      const originsNode = corsDecl.config.origins;
      if (originsNode.elements) {
        for (const elem of originsNode.elements) {
          if (elem.type === 'StringLiteral' && elem.value === '*') {
            this.warnings.push({
              message: 'CORS origins contains wildcard "*" — consider restricting to specific origins',
              loc: corsDecl.loc,
              code: 'W_CORS_WILDCARD',
            });
            break;
          }
        }
      }
    }

    // W_INVALID_RATE_LIMIT — validate rate limit max/window are positive numbers
    const _rlNumericValue = (node) => {
      if (!node) return null;
      if (node.type === 'NumberLiteral') return node.value;
      if (node.type === 'UnaryExpression' && node.operator === '-' && node.operand && node.operand.type === 'NumberLiteral') return -node.operand.value;
      return null;
    };
    if (rateLimitDecl && rateLimitDecl.config) {
      const rlMaxVal = _rlNumericValue(rateLimitDecl.config.max);
      const rlWindowVal = _rlNumericValue(rateLimitDecl.config.window);
      if (rlMaxVal !== null && rlMaxVal <= 0) {
        this.warnings.push({
          message: `Rate limit max must be a positive number, got ${rlMaxVal}`,
          loc: rateLimitDecl.loc,
          code: 'W_INVALID_RATE_LIMIT',
        });
      }
      if (rlWindowVal !== null && rlWindowVal <= 0) {
        this.warnings.push({
          message: `Rate limit window must be a positive number, got ${rlWindowVal}`,
          loc: rateLimitDecl.loc,
          code: 'W_INVALID_RATE_LIMIT',
        });
      }
    }

    // W_CSRF_DISABLED — warn when CSRF is explicitly disabled
    if (csrfDecl && csrfDecl.config && csrfDecl.config.enabled) {
      const enabledNode = csrfDecl.config.enabled;
      if ((enabledNode.type === 'BooleanLiteral' && enabledNode.value === false) ||
          (enabledNode.type === 'Identifier' && enabledNode.name === 'false')) {
        this.warnings.push({
          message: 'CSRF protection is explicitly disabled — this increases vulnerability to cross-site request forgery attacks',
          loc: csrfDecl.loc,
          code: 'W_CSRF_DISABLED',
        });
      }
    }

    // W_LOCALSTORAGE_TOKEN — warn when auth uses default localStorage storage (XSS-vulnerable)
    if (authDecl && authDecl.authType === 'jwt') {
      const storageNode = authDecl.config.storage;
      const isCookieAuth = storageNode && storageNode.type === 'StringLiteral' && storageNode.value === 'cookie';
      if (!isCookieAuth) {
        this.warnings.push({
          message: 'Auth tokens stored in localStorage are vulnerable to XSS attacks — consider using storage: "cookie" for HttpOnly cookie storage',
          loc: authDecl.loc,
          code: 'W_LOCALSTORAGE_TOKEN',
        });
      }
    }

    // Fix 5: W_INMEMORY_RATELIMIT — warn that rate limiting is in-memory only
    if (rateLimitDecl) {
      this.warnings.push({
        message: 'Rate limiting uses in-memory storage — not shared across server instances. Consider an external store for production multi-instance deployments',
        loc: rateLimitDecl.loc,
        code: 'W_INMEMORY_RATELIMIT',
      });
    }

    // Fix 6: W_NO_AUTH_RATELIMIT — warn when auth exists but no rate limiting protects against brute-force
    if (hasAuth && !rateLimitDecl) {
      const hasAuthRateLimit = allProtects.some(p => p.config && p.config.rate_limit);
      if (!hasAuthRateLimit) {
        this.warnings.push({
          message: 'Auth is configured without rate limiting — consider adding rate_limit to protect against brute-force attacks',
          loc: authDecl.loc,
          code: 'W_NO_AUTH_RATELIMIT',
        });
      }
    }

    // Fix 7: W_HASH_NOT_ENFORCED — warn when sensitive declares hash but it's not auto-enforced
    for (const s of allSensitives) {
      if (s.config && s.config.hash) {
        const hashVal = s.config.hash.value || s.config.hash;
        this.warnings.push({
          message: `sensitive ${s.typeName}.${s.fieldName} declares hash: "${hashVal}" but hashing is not automatically enforced — use hash_password() in your write handlers`,
          loc: s.loc,
          code: 'W_HASH_NOT_ENFORCED',
        });
      }
    }

    // No security blocks → nothing to validate (but allow auth/cors checks above)
    if (!hasProtect && allSensitives.length === 0) return;

    // W_PROTECT_WITHOUT_AUTH: protect rules exist but no auth configured
    if (hasProtect && !hasAuth) {
      // Find first protect for location
      this.warnings.push({
        message: 'Route protection rules exist but no auth is configured — all protected routes will be inaccessible',
        loc: allProtects[0].loc,
        code: 'W_PROTECT_WITHOUT_AUTH',
      });
    }

    // W_UNDEFINED_ROLE: protect rules reference roles not defined anywhere
    for (const protect of allProtects) {
      const requireExpr = protect.config.require;
      if (!requireExpr) {
        // W_PROTECT_NO_REQUIRE: protect rule has no require key
        this.warnings.push({
          message: `Protect rule for "${protect.pattern}" has no 'require' — route is unprotected`,
          loc: protect.loc,
          code: 'W_PROTECT_NO_REQUIRE',
        });
        continue;
      }
      if (requireExpr.type === 'Identifier' && requireExpr.name !== 'authenticated') {
        if (!allRoles.has(requireExpr.name)) {
          this.warnings.push({
            message: `Protect rule references undefined role '${requireExpr.name}'`,
            loc: protect.loc,
            code: 'W_UNDEFINED_ROLE',
          });
        }
      }
    }

    // W_UNDEFINED_ROLE: sensitive visible_to references roles not defined anywhere
    for (const sensitive of allSensitives) {
      const visibleTo = sensitive.config.visible_to;
      if (visibleTo && (visibleTo.type === 'ArrayExpression' || visibleTo.type === 'ArrayLiteral')) {
        for (const elem of visibleTo.elements) {
          if (elem.type === 'Identifier' && elem.name !== 'self') {
            if (!allRoles.has(elem.name)) {
              this.warnings.push({
                message: `Sensitive field '${sensitive.typeName}.${sensitive.fieldName}' visible_to references undefined role '${elem.name}'`,
                loc: sensitive.loc,
                code: 'W_UNDEFINED_ROLE',
              });
            }
          }
        }
      }
    }
  }

  // visitBrowserBlock and other browser visitors are in browser-analyzer.js (lazy-loaded)

  visitSharedBlock(node) {
    const prevScope = this.currentScope;
    const sharedScope = this.currentScope.child('shared');
    this.currentScope = sharedScope;
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
    // Promote shared types and functions to parent scope
    // so server/client blocks can reference them (but not variables)
    for (const [name, sym] of sharedScope.symbols) {
      if (!prevScope.symbols.has(name) && (sym.kind === 'type' || sym.kind === 'function')) {
        prevScope.symbols.set(name, sym);
      }
    }
  }

  // ─── Declaration visitors ─────────────────────────────────

  visitAssignment(node) {
    // Visit values first (for type inference)
    for (const val of node.values) {
      this.visitExpression(val);
    }

    // Check if any target is already defined (immutable reassignment check)
    for (let i = 0; i < node.targets.length; i++) {
      const target = node.targets[i];

      // Complex targets (e.g., arr[i] = val, obj.prop = val) — visit and skip declaration logic
      if (typeof target !== 'string') {
        this.visitExpression(target);
        continue;
      }

      const existing = this._lookupAssignTarget(target);
      if (existing) {
        // Allow user code to shadow builtins (e.g., url = "/api")
        if (existing.kind === 'builtin') {
          this.currentScope.define(target, new Symbol(target, 'variable', null, false, node.loc));
          continue;
        }
        if (!existing.mutable) {
          this.error(`Cannot reassign immutable variable '${target}'. Use 'var' for mutable variables.`, node.loc, null, {
            code: 'E202',
            length: target.length,
            fix: { description: `Change to 'var ${target}' at the original declaration to make it mutable` },
          });
        }
        // Type check reassignment
        if (existing.inferredType && i < node.values.length) {
          const newType = this._inferType(node.values[i]);
          if (!this._typesCompatible(existing.inferredType, newType)) {
            this.strictError(`Type mismatch: '${target}' is ${existing.inferredType}, but assigned ${newType}`, node.loc, this._conversionHint(existing.inferredType, newType), { code: 'E102' });
          }
          // Float narrowing warning in strict mode
          if (this.strict && newType === 'Float' && existing.inferredType === 'Int') {
            this.warn(`Potential data loss: assigning Float to Int variable '${target}'`, node.loc, "use floor() or round() for explicit conversion", { code: 'W204' });
          }
        }
        existing.used = true;
      } else {
        // New binding — define in current scope with inferred type
        const inferredType = i < node.values.length ? this._inferType(node.values[i]) : null;
        // Warn if this shadows a variable from an outer function scope
        if (this._existsInOuterScope(target)) {
          this.warn(`Variable '${target}' shadows a binding in an outer scope`, node.loc, null, { code: 'W101', length: target.length });
        }
        try {
          const sym = new Symbol(target, 'variable', null, false, node.loc);
          sym.inferredType = inferredType;
          this.currentScope.define(target, sym);
        } catch (e) {
          this.error(e.message);
        }
        this._checkNamingConvention(target, 'variable', node.loc);
      }
    }
  }

  visitVarDeclaration(node) {
    // Visit values first so type inference can work
    for (const val of node.values) {
      this.visitExpression(val);
    }
    for (let i = 0; i < node.targets.length; i++) {
      const target = node.targets[i];
      const inferredType = i < node.values.length ? this._inferType(node.values[i]) : null;
      try {
        const sym = new Symbol(target, 'variable', null, true, node.loc);
        sym.inferredType = inferredType;
        this.currentScope.define(target, sym);
      } catch (e) {
        this.error(e.message);
      }
      this._checkNamingConvention(target, 'variable', node.loc);
    }
  }

  visitLetDestructure(node) {
    this.visitExpression(node.value);

    if (node.pattern.type === 'ObjectPattern') {
      for (const prop of node.pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (node.pattern.type === 'ArrayPattern' || node.pattern.type === 'TuplePattern') {
      for (const el of node.pattern.elements) {
        if (el) {
          const varName = el.startsWith('...') ? el.slice(3) : el;
          try {
            this.currentScope.define(varName,
              new Symbol(varName, 'variable', null, false, node.loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitFunctionDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'function', node.returnType, false, node.loc);
      sym._params = node.params.map(p => p.name);
      sym._totalParamCount = node.params.length;
      sym._requiredParamCount = node.params.filter(p => !p.defaultValue).length;
      sym._paramTypes = node.params.map(p => p.typeAnnotation || null);
      sym._typeParams = node.typeParams || [];
      sym.isPublic = node.isPublic || false;
      sym.isWasm = !!(node.decorators && node.decorators.some(d => d.name === 'wasm'));
      this.currentScope.define(node.name, sym);
    } catch (e) {
      this.error(e.message);
    }

    // Naming convention check (skip variant constructors — handled in visitTypeDeclaration)
    this._checkNamingConvention(node.name, 'function', node.loc);

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    if (node.loc) {
      this.currentScope.startLoc = { line: node.loc.line, column: node.loc.column };
    }

    // Push expected return type for return-statement checking
    const expectedReturn = node.returnType ? this._typeAnnotationToString(node.returnType) : null;
    this._functionReturnTypeStack.push(expectedReturn);
    const prevAsyncDepth = this._asyncDepth;
    if (node.isAsync) {
      this._asyncDepth++;
    } else {
      this._asyncDepth = 0; // Non-async function resets async context
    }

    try {
      for (const param of node.params) {
        if (param.destructure) {
          this._defineDestructureParams(param.destructure, param.loc);
        } else {
          try {
            const paramSym = new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc);
            paramSym.inferredType = param.typeAnnotation ? this._typeAnnotationToString(param.typeAnnotation) : null;
            this.currentScope.define(param.name, paramSym);
          } catch (e) {
            this.error(e.message);
          }
          this._checkNamingConvention(param.name, 'parameter', param.loc);
        }
        if (param.defaultValue) {
          this.visitExpression(param.defaultValue);
        }
      }

      this.visitNode(node.body);

      // Return path analysis: check that all paths return a value
      // Skip for @wasm/@fast functions — they use implicit returns or specialized codegen
      const isWasm = node.decorators && node.decorators.some(d => d.name === 'wasm' || d.name === 'fast');
      if (expectedReturn && node.body.type === 'BlockStatement' && !isWasm) {
        if (!this._definitelyReturns(node.body)) {
          this.warn(`Function '${node.name}' declares return type ${expectedReturn} but not all code paths return a value`, node.loc, null, { code: 'W205' });
        }
      }
    } finally {
      this._asyncDepth = prevAsyncDepth;
      this._functionReturnTypeStack.pop();
      this.currentScope = prevScope;
    }
  }

  visitExternDeclaration(node) {
    const sym = new Symbol(node.name, 'function', node.returnType, false, node.loc);
    sym._params = node.params.map(p => p.name || `arg${node.params.indexOf(p)}`);
    sym._totalParamCount = node.params.length;
    sym._requiredParamCount = node.params.filter(p => !p.defaultValue).length;
    sym._paramTypes = node.params.map(p => p.typeAnnotation || null);
    sym.extern = true;
    sym.isAsync = node.isAsync;
    // Extern declarations can override builtins (they provide more precise type info)
    const existing = this.currentScope.lookupLocal(node.name);
    if (existing && existing.kind === 'builtin') {
      this.currentScope.symbols.set(node.name, sym);
    } else {
      try {
        this.currentScope.define(node.name, sym);
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  _defineDestructureParams(pattern, loc) {
    if (pattern.type === 'ObjectPattern') {
      for (const prop of pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'parameter', null, false, loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (pattern.type === 'ArrayPattern' || pattern.type === 'TuplePattern') {
      for (const el of pattern.elements) {
        if (el) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'parameter', null, false, loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitTypeDeclaration(node) {
    this._checkNamingConvention(node.name, 'type', node.loc);

    // Build ADT type structure
    const variants = new Map();
    for (const variant of node.variants) {
      if (variant.type === 'TypeVariant') {
        const fields = new Map();
        for (const f of variant.fields) {
          const fieldType = f.typeAnnotation ? typeAnnotationToType(f.typeAnnotation) : Type.ANY;
          fields.set(f.name, fieldType || Type.ANY);
        }
        variants.set(variant.name, fields);
      }
    }
    const adtType = new ADTType(node.name, node.typeParams || [], variants);

    try {
      const typeSym = new Symbol(node.name, 'type', null, false, node.loc);
      typeSym._typeParams = node.typeParams || [];
      typeSym._typeStructure = adtType;
      this.currentScope.define(node.name, typeSym);

      // Register in type registry for LSP
      this.typeRegistry.types.set(node.name, adtType);
    } catch (e) {
      this.error(e.message);
    }

    // Define variant constructors as functions
    for (const variant of node.variants) {
      if (variant.type === 'TypeVariant') {
        try {
          const varSym = new Symbol(variant.name, 'function', null, false, variant.loc);
          varSym._params = variant.fields.map(f => f.name);
          varSym._totalParamCount = variant.fields.length;
          varSym._requiredParamCount = variant.fields.length;
          varSym._variantOf = node.name;
          varSym._paramTypes = variant.fields.map(f => f.typeAnnotation || null);
          this.currentScope.define(variant.name, varSym);
        } catch (e) {
          this.error(e.message);
        }
      }
    }

    // Validate derive traits
    if (node.derive) {
      const builtinTraits = new Set(['Eq', 'Show', 'JSON']);
      for (const trait of node.derive) {
        if (!builtinTraits.has(trait)) {
          const traitSym = this.currentScope.lookup(trait);
          if (!traitSym || !traitSym._interfaceMethods) {
            this.warn(`Unknown trait '${trait}' in derive clause`, node.loc, null, { code: 'W303' });
          }
        }
      }
    }
  }

  visitImportDeclaration(node) {
    for (const spec of node.specifiers) {
      try {
        this.currentScope.define(spec.local,
          new Symbol(spec.local, 'variable', null, false, spec.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  visitImportDefault(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  visitImportWildcard(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'module', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  // ─── Statement visitors ───────────────────────────────────

  visitBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    if (node.loc) {
      this.currentScope.startLoc = { line: node.loc.line, column: node.loc.column };
    }
    try {
      let terminated = false;
      for (const stmt of node.body) {
        if (terminated) {
          this.warn("Unreachable code after return/break/continue", stmt.loc || node.loc, null, { code: 'W201' });
          break; // Only warn once per block
        }
        this.visitNode(stmt);
        if (stmt.type === 'ReturnStatement' || stmt.type === 'BreakStatement' || stmt.type === 'ContinueStatement') {
          terminated = true;
        }
      }
    } finally {
      if (node.loc) {
        this.currentScope.endLoc = { line: node.endLoc?.line || node.loc.line + 100, column: node.endLoc?.column || 0 };
      }
      this.currentScope = prevScope;
    }
  }

  visitIfStatement(node) {
    // Constant conditional check
    if (node.condition && node.condition.type === 'BooleanLiteral') {
      if (node.condition.value === true) {
        this.warn("Condition is always true", node.condition.loc || node.loc, null, { code: 'W202' });
      } else {
        this.warn("Condition is always false — branch never executes", node.condition.loc || node.loc, null, { code: 'W203' });
      }
    }

    this.visitExpression(node.condition);

    // Type narrowing: detect patterns like typeOf(x) == "String", x != nil, x.isOk()
    const narrowing = this._extractNarrowingInfo(node.condition);

    // Visit consequent with narrowed type
    if (narrowing) {
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('block');
      const sym = this.currentScope.lookup(narrowing.varName);
      if (sym) {
        // Store narrowed type info in the scope
        const narrowedSym = new Symbol(narrowing.varName, sym.kind, null, false, sym.loc);
        narrowedSym.inferredType = narrowing.narrowedType;
        narrowedSym._narrowed = true;
        try { this.currentScope.define(narrowing.varName, narrowedSym); } catch (e) { /* already defined */ }
      }
      for (const stmt of node.consequent.body) {
        this.visitNode(stmt);
      }
      this.currentScope = prevScope;
    } else {
      this.visitNode(node.consequent);
    }

    for (const alt of node.alternates) {
      this.visitExpression(alt.condition);
      this.visitNode(alt.body);
    }

    // Visit else body with inverse narrowing
    if (node.elseBody) {
      if (narrowing && narrowing.inverseType) {
        const prevScope = this.currentScope;
        this.currentScope = this.currentScope.child('block');
        const sym = this.currentScope.lookup(narrowing.varName);
        if (sym) {
          const narrowedSym = new Symbol(narrowing.varName, sym.kind, null, false, sym.loc);
          narrowedSym.inferredType = narrowing.inverseType;
          narrowedSym._narrowed = true;
          try { this.currentScope.define(narrowing.varName, narrowedSym); } catch (e) { /* already defined */ }
        }
        for (const stmt of node.elseBody.body) {
          this.visitNode(stmt);
        }
        this.currentScope = prevScope;
      } else {
        this.visitNode(node.elseBody);
      }
    }
  }

  _extractNarrowingInfo(condition) {
    if (!condition) return null;

    // Pattern: typeOf(x) == "String"  or  typeOf(x) == "Int"
    if (condition.type === 'BinaryExpression' && condition.operator === '==') {
      const { left, right } = condition;

      // typeOf(x) == "TypeName"
      if (left.type === 'CallExpression' &&
          left.callee.type === 'Identifier' &&
          (left.callee.name === 'typeOf' || left.callee.name === 'type_of') &&
          left.arguments.length === 1 &&
          left.arguments[0].type === 'Identifier' &&
          right.type === 'StringLiteral') {
        const varName = left.arguments[0].name;
        const typeName = right.value;
        // Map JS typeof strings to Tova types
        const typeMap = { 'string': 'String', 'number': 'Int', 'boolean': 'Bool', 'function': 'Function' };
        const narrowedType = typeMap[typeName] || typeName;
        return { varName, narrowedType, inverseType: null };
      }

      // "TypeName" == typeOf(x) (reversed)
      if (right.type === 'CallExpression' &&
          right.callee.type === 'Identifier' &&
          (right.callee.name === 'typeOf' || right.callee.name === 'type_of') &&
          right.arguments.length === 1 &&
          right.arguments[0].type === 'Identifier' &&
          left.type === 'StringLiteral') {
        const varName = right.arguments[0].name;
        const typeName = left.value;
        const typeMap = { 'string': 'String', 'number': 'Int', 'boolean': 'Bool', 'function': 'Function' };
        const narrowedType = typeMap[typeName] || typeName;
        return { varName, narrowedType, inverseType: null };
      }
    }

    // Pattern: x != nil  (narrow to non-nil)
    if (condition.type === 'BinaryExpression' && condition.operator === '!=' &&
        condition.right.type === 'NilLiteral' &&
        condition.left.type === 'Identifier') {
      // Try to compute a precise narrowed type by stripping Nil from the variable's type
      const varName = condition.left.name;
      const sym = this.currentScope.lookup(varName);
      let narrowedType = 'nonnil';
      if (sym && sym.inferredType) {
        const stripped = this._stripNilFromType(sym.inferredType);
        if (stripped) narrowedType = stripped;
      }
      return { varName, narrowedType, inverseType: 'Nil' };
    }

    // Pattern: nil != x  (reversed)
    if (condition.type === 'BinaryExpression' && condition.operator === '!=' &&
        condition.left.type === 'NilLiteral' &&
        condition.right.type === 'Identifier') {
      const varName = condition.right.name;
      const sym = this.currentScope.lookup(varName);
      let narrowedType = 'nonnil';
      if (sym && sym.inferredType) {
        const stripped = this._stripNilFromType(sym.inferredType);
        if (stripped) narrowedType = stripped;
      }
      return { varName, narrowedType, inverseType: 'Nil' };
    }

    // Pattern: x == nil  (narrow to Nil in consequent, non-nil in else)
    if (condition.type === 'BinaryExpression' && condition.operator === '==' &&
        condition.right.type === 'NilLiteral' &&
        condition.left.type === 'Identifier') {
      const varName = condition.left.name;
      const sym = this.currentScope.lookup(varName);
      let inverseType = 'nonnil';
      if (sym && sym.inferredType) {
        const stripped = this._stripNilFromType(sym.inferredType);
        if (stripped) inverseType = stripped;
      }
      return { varName, narrowedType: 'Nil', inverseType };
    }

    // Pattern: x.isOk()  (narrow to Ok variant)
    if (condition.type === 'CallExpression' &&
        condition.callee.type === 'MemberExpression' &&
        condition.callee.object.type === 'Identifier' &&
        condition.callee.property === 'isOk') {
      return { varName: condition.callee.object.name, narrowedType: 'Result<Ok>', inverseType: 'Result<Err>' };
    }

    // Pattern: x.isSome()  (narrow to Some variant)
    if (condition.type === 'CallExpression' &&
        condition.callee.type === 'MemberExpression' &&
        condition.callee.object.type === 'Identifier' &&
        condition.callee.property === 'isSome') {
      return { varName: condition.callee.object.name, narrowedType: 'Option<Some>', inverseType: 'Option<None>' };
    }

    return null;
  }

  /**
   * Strip Nil from a union type string. E.g., "String | Nil" -> "String".
   * For Option types, returns the inner type.
   */
  _stripNilFromType(typeStr) {
    if (!typeStr) return null;
    // Handle union types: "String | Nil" -> "String"
    if (typeStr.includes(' | ')) {
      const parts = typeStr.split(' | ').map(p => p.trim()).filter(p => p !== 'Nil');
      if (parts.length === 0) return null;
      if (parts.length === 1) return parts[0];
      return parts.join(' | ');
    }
    // Handle Option types: "Option<String>" -> "String"
    if (typeStr.startsWith('Option<') && typeStr.endsWith('>')) {
      return typeStr.slice(7, -1);
    }
    if (typeStr === 'Option') return 'Any';
    // If not a union/option, narrowing past nil means the variable keeps its type
    return typeStr;
  }

  visitForStatement(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    if (node.label) this.currentScope._loopLabel = node.label;

    try {
      this.visitExpression(node.iterable);

      // Define loop variable(s)
      const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
      for (const v of vars) {
        try {
          this.currentScope.define(v,
            new Symbol(v, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }

      if (node.guard) {
        this.visitExpression(node.guard);
      }

      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }

    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
  }

  visitWhileStatement(node) {
    // while false is suspicious (loop body never executes)
    if (node.condition && node.condition.type === 'BooleanLiteral' && node.condition.value === false) {
      this.warn("Condition is always false — loop never executes", node.condition.loc || node.loc, null, { code: 'W203' });
    }

    this.visitExpression(node.condition);
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    if (node.label) this.currentScope._loopLabel = node.label;
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitLoopStatement(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    if (node.label) this.currentScope._loopLabel = node.label;
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitTryCatchStatement(node) {
    const prevScope = this.currentScope;

    this.currentScope = prevScope.child('block');
    try {
      for (const stmt of node.tryBody) this.visitNode(stmt);
    } finally {
      this.currentScope = prevScope;
    }

    if (node.catchBody) {
      this.currentScope = prevScope.child('block');
      try {
        if (node.catchParam) {
          this.currentScope.define(node.catchParam, new Symbol(node.catchParam, 'variable', null, false, node.loc));
        }
        for (const stmt of node.catchBody) this.visitNode(stmt);
      } finally {
        this.currentScope = prevScope;
      }
    }

    if (node.finallyBody) {
      this.currentScope = prevScope.child('block');
      try {
        for (const stmt of node.finallyBody) this.visitNode(stmt);
      } finally {
        this.currentScope = prevScope;
      }
    }
  }

  visitReturnStatement(node) {
    if (node.value) {
      this.visitExpression(node.value);
    }
    // Return must be inside a function
    if (this._functionReturnTypeStack.length === 0) {
      this.error("'return' can only be used inside a function", node.loc, null, { code: 'E301' });
      return;
    }
    // Check return type against declared function return type
    if (this._functionReturnTypeStack.length > 0) {
      const expectedReturn = this._functionReturnTypeStack[this._functionReturnTypeStack.length - 1];
      if (expectedReturn) {
        const actualType = node.value ? this._inferType(node.value) : 'Nil';
        if (!this._typesCompatible(expectedReturn, actualType)) {
          this.error(`Type mismatch: function expects return type ${expectedReturn}, but got ${actualType}`, node.loc, this._conversionHint(expectedReturn, actualType), { code: 'E101' });
        }
      }
    }
  }

  visitCompoundAssignment(node) {
    // Target must be mutable
    if (node.target.type === 'Identifier') {
      const sym = this.currentScope.lookup(node.target.name);
      if (sym && !sym.mutable && sym.kind !== 'builtin') {
        this.error(`Cannot use '${node.operator}' on immutable variable '${node.target.name}'`, node.loc, `declare with 'var' to make mutable`, { code: 'E202' });
      }
      // Type check compound assignment
      if (sym && sym.inferredType) {
        const op = node.operator;
        const numerics = new Set(['Int', 'Float']);
        if (['-=', '*=', '/='].includes(op)) {
          if (!numerics.has(sym.inferredType) && sym.inferredType !== 'Any') {
            this.strictError(`Type mismatch: '${op}' requires numeric type, but '${node.target.name}' is ${sym.inferredType}`, node.loc);
          }
          const valType = this._inferType(node.value);
          if (valType && !numerics.has(valType) && valType !== 'Any') {
            this.strictError(`Type mismatch: '${op}' requires numeric value, but got ${valType}`, node.loc);
          }
        } else if (op === '+=') {
          // += on numerics requires numeric value, on strings requires string
          if (numerics.has(sym.inferredType)) {
            const valType = this._inferType(node.value);
            if (valType && !numerics.has(valType) && valType !== 'Any') {
              this.strictError(`Type mismatch: '${op}' on numeric variable requires numeric value, but got ${valType}`, node.loc);
            }
          } else if (sym.inferredType === 'String') {
            const valType = this._inferType(node.value);
            if (valType && valType !== 'String' && valType !== 'Any') {
              this.strictError(`Type mismatch: '${op}' on String variable requires String value, but got ${valType}`, node.loc);
            }
          }
        }
      }
    }
    this.visitExpression(node.target);
    this.visitExpression(node.value);
  }

  // Browser-specific visitors (visitState, visitComputed, etc.) are in browser-analyzer.js (lazy-loaded)

  visitTestBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  }

  // ─── Expression visitors ──────────────────────────────────

  visitIdentifier(node) {
    if (node.name === '_') return; // wildcard is always valid
    if (node.name === PIPE_TARGET) return; // pipe target placeholder from method pipe

    // Common mistake: using `throw` (not a Tova keyword)
    if (node.name === 'throw') {
      this.warn("'throw' is not a Tova keyword — use Result for error handling, e.g. Err(\"message\")", node.loc, "try Err(value) instead of throw", { code: 'W206' });
      return;
    }

    const sym = this.currentScope.lookup(node.name);
    if (!sym) {
      if (!this._isKnownGlobal(node.name)) {
        const suggestion = this._findClosestMatch(node.name);
        const hint = suggestion ? `did you mean '${suggestion}'?` : null;
        const fixOpts = { code: 'E200', length: node.name.length };
        if (suggestion) fixOpts.fix = { description: `Replace with '${suggestion}'`, replacement: suggestion };
        this.warn(`'${node.name}' is not defined`, node.loc, hint, fixOpts);
      }
    } else {
      sym.used = true;
    }
  }

  _isKnownGlobal(name) {
    // Tova stdlib (auto-synced from BUILTIN_FUNCTIONS in inline.js)
    if (BUILTIN_NAMES.has(name)) return true;

    // Tova runtime names
    if (_TOVA_RUNTIME.has(name)) return true;

    // JS globals / platform APIs
    return _JS_GLOBALS.has(name);
  }

  _findClosestMatch(name) {
    const candidates = [];
    // Collect scope symbols (these change per call)
    let scope = this.currentScope;
    while (scope) {
      for (const n of scope.symbols.keys()) candidates.push(n);
      scope = scope.parent;
    }

    let best = null;
    let bestDist = Infinity;
    const maxDist = Math.max(2, Math.floor(name.length * 0.4));
    const nameLower = name.toLowerCase();

    // Check scope symbols first
    for (let i = 0; i < candidates.length; i++) {
      const c = candidates[i];
      if (Math.abs(c.length - name.length) > maxDist) continue;
      const d = levenshtein(nameLower, c.toLowerCase());
      if (d < bestDist && d <= maxDist && d > 0) {
        bestDist = d;
        best = c;
      }
    }

    // Check static global names (BUILTIN_NAMES, _JS_GLOBALS, _TOVA_RUNTIME)
    const staticNames = _getStaticSuggestionNames();
    for (let i = 0; i < staticNames.length; i++) {
      const c = staticNames[i];
      if (Math.abs(c.length - name.length) > maxDist) continue;
      const d = levenshtein(nameLower, c.toLowerCase());
      if (d < bestDist && d <= maxDist && d > 0) {
        bestDist = d;
        best = c;
      }
    }
    return best;
  }

  _conversionHint(expected, actual) {
    if (!expected || !actual) return null;
    const key = `${actual}->${expected}`;
    const hints = {
      'Int->String': "try toString(value) to convert",
      'Float->String': "try toString(value) to convert",
      'Bool->String': "try toString(value) to convert",
      'String->Int': "try toInt(value) to parse",
      'String->Float': "try toFloat(value) to parse",
      'Float->Int': "try floor(value) or round(value) to convert",
    };
    if (hints[key]) return hints[key];
    if (expected.startsWith('Result')) return "try Ok(value) to wrap in Result";
    if (expected.startsWith('Option')) return "try Some(value) to wrap in Option";
    return null;
  }

  visitLambda(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');

    const expectedReturn = node.returnType ? this._typeAnnotationToString(node.returnType) : null;
    this._functionReturnTypeStack.push(expectedReturn);
    const prevAsyncDepth = this._asyncDepth;
    if (node.isAsync) {
      this._asyncDepth++;
    } else {
      this._asyncDepth = 0; // Non-async lambda resets async context
    }

    try {
      for (const param of node.params) {
        try {
          const paramSym = new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc);
          paramSym.inferredType = param.typeAnnotation ? this._typeAnnotationToString(param.typeAnnotation) : null;
          this.currentScope.define(param.name, paramSym);
        } catch (e) {
          this.error(e.message);
        }
      }
      if (node.body.type === 'BlockStatement') {
        this.visitNode(node.body);
        // Return path analysis for lambdas with block bodies and declared return types
        if (expectedReturn && !this._definitelyReturns(node.body)) {
          this.warn(`Lambda declares return type ${expectedReturn} but not all code paths return a value`, node.loc, null, { code: 'W205' });
        }
      } else {
        // Single-expression body — always returns implicitly
        this.visitExpression(node.body);
      }
    } finally {
      this._asyncDepth = prevAsyncDepth;
      this._functionReturnTypeStack.pop();
      this.currentScope = prevScope;
    }
  }

  visitMatchExpression(node) {
    this.visitExpression(node.subject);
    let catchAllSeen = false;
    for (const arm of node.arms) {
      // Warn about unreachable arms after catch-all
      if (catchAllSeen) {
        this.warn("Unreachable match arm after catch-all pattern", arm.pattern.loc || arm.body.loc || node.loc, null, { code: 'W207' });
        continue; // Still visit remaining arms for completeness but skip analysis
      }

      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('block');

      try {
        this.visitPattern(arm.pattern);
        if (arm.guard) this.visitExpression(arm.guard);

        if (arm.body.type === 'BlockStatement') {
          this.visitNode(arm.body);
        } else {
          this.visitExpression(arm.body);
        }
      } finally {
        this.currentScope = prevScope;
      }

      // Check if this arm is a catch-all (wildcard or unguarded binding)
      if ((arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') && !arm.guard) {
        catchAllSeen = true;
      }
    }

    // Exhaustive match checking (#12)
    this._checkMatchExhaustiveness(node);
  }

  _checkMatchExhaustiveness(node) {
    // Check if the match has a wildcard/binding catch-all
    const hasWildcard = node.arms.some(arm =>
      arm.pattern.type === 'WildcardPattern' ||
      (arm.pattern.type === 'BindingPattern' && !arm.guard)
    );
    if (hasWildcard) return; // Catch-all exists, always exhaustive

    // Try to resolve the subject type for better checking
    let subjectType = null;
    if (node.subject) {
      const subjectTypeStr = this._inferType(node.subject);
      if (subjectTypeStr) {
        // Look up type structure from type registry
        const typeStructure = this.typeRegistry.types.get(subjectTypeStr);
        if (typeStructure instanceof ADTType) {
          subjectType = typeStructure;
        }
      }
      // Also try to find type from identifier
      if (!subjectType && node.subject.type === 'Identifier') {
        const sym = this.currentScope.lookup(node.subject.name);
        if (sym && sym.inferredType) {
          const typeStructure = this.typeRegistry.types.get(sym.inferredType);
          if (typeStructure instanceof ADTType) {
            subjectType = typeStructure;
          }
        }
      }
    }

    const variantNames = new Set();
    const coveredVariants = new Set();

    // Collect all variant patterns used in the match
    for (const arm of node.arms) {
      if (arm.pattern.type === 'VariantPattern') {
        coveredVariants.add(arm.pattern.name);
      }
    }

    // If we have variant patterns, check if all known variants are covered
    if (coveredVariants.size > 0) {
      // If we have the ADT type structure, use it for precise checking
      if (subjectType) {
        const allVariants = subjectType.getVariantNames();
        for (const v of allVariants) {
          if (!coveredVariants.has(v)) {
            this.warn(`Non-exhaustive match: missing '${v}' variant from type '${subjectType.name}'`, node.loc, `add a '${v}' arm or use '_ =>' as a catch-all`, { code: 'W200' });
          }
        }
        return; // Done — used precise ADT checking
      }

      // Check built-in Result/Option types
      if (coveredVariants.has('Ok') || coveredVariants.has('Err')) {
        if (!coveredVariants.has('Ok')) {
          this.warn(`Non-exhaustive match: missing 'Ok' variant`, node.loc, "add an 'Ok(value) =>' arm", { code: 'W200' });
        }
        if (!coveredVariants.has('Err')) {
          this.warn(`Non-exhaustive match: missing 'Err' variant`, node.loc, "add an 'Err(e) =>' arm", { code: 'W200' });
        }
      }
      if (coveredVariants.has('Some') || coveredVariants.has('None')) {
        if (!coveredVariants.has('Some')) {
          this.warn(`Non-exhaustive match: missing 'Some' variant`, node.loc, "add a 'Some(value) =>' arm", { code: 'W200' });
        }
        if (!coveredVariants.has('None')) {
          this.warn(`Non-exhaustive match: missing 'None' variant`, node.loc, "add a 'None =>' arm", { code: 'W200' });
        }
      }

      // Check user-defined types — find the single best-matching type whose variants
      // contain ALL covered variant names (avoids false positives with shared names)
      const candidates = [];
      this._collectTypeCandidates(this.ast.body, coveredVariants, candidates);

      let matched = null;
      if (candidates.length === 1) {
        matched = candidates[0];
      } else if (candidates.length > 1) {
        // Disambiguate using subject's inferred type name
        let subjectTypeName = null;
        if (node.subject) {
          subjectTypeName = this._inferType(node.subject);
          if (!subjectTypeName && node.subject.type === 'Identifier') {
            const sym = this.currentScope.lookup(node.subject.name);
            if (sym) subjectTypeName = sym.inferredType;
          }
        }
        if (subjectTypeName) {
          const exact = candidates.find(([name]) => name === subjectTypeName);
          if (exact) matched = exact;
        }
      }

      if (matched) {
        const [typeName, typeVariants] = matched;
        for (const v of typeVariants) {
          if (!coveredVariants.has(v)) {
            this.warn(`Non-exhaustive match: missing '${v}' variant from type '${typeName}'`, node.loc, `add a '${v}' arm or use '_ =>' as a catch-all`, { code: 'W200' });
          }
        }
      }
    }
  }

  // Check if a match expression covers all variants without a wildcard (for return path analysis)
  _isMatchExhaustive(node) {
    const coveredVariants = new Set();
    for (const arm of node.arms) {
      if (arm.pattern.type === 'VariantPattern') {
        coveredVariants.add(arm.pattern.name);
      }
    }
    if (coveredVariants.size === 0) return false;

    // Check subject's inferred type
    if (node.subject) {
      const subjectTypeStr = this._inferType(node.subject);
      if (subjectTypeStr) {
        const typeStructure = this.typeRegistry.types.get(subjectTypeStr);
        if (typeStructure instanceof ADTType) {
          return typeStructure.getVariantNames().every(v => coveredVariants.has(v));
        }
      }
      if (node.subject.type === 'Identifier') {
        const sym = this.currentScope.lookup(node.subject.name);
        if (sym && sym.inferredType) {
          const typeStructure = this.typeRegistry.types.get(sym.inferredType);
          if (typeStructure instanceof ADTType) {
            return typeStructure.getVariantNames().every(v => coveredVariants.has(v));
          }
        }
      }
    }

    // Built-in Result type
    if ((coveredVariants.has('Ok') || coveredVariants.has('Err')) &&
        coveredVariants.has('Ok') && coveredVariants.has('Err')) return true;
    // Built-in Option type
    if ((coveredVariants.has('Some') || coveredVariants.has('None')) &&
        coveredVariants.has('Some') && coveredVariants.has('None')) return true;

    // Fallback: check user-defined types
    const candidates = [];
    this._collectTypeCandidates(this.ast.body, coveredVariants, candidates);

    let matched = null;
    if (candidates.length === 1) {
      matched = candidates[0];
    } else if (candidates.length > 1 && node.subject) {
      // Disambiguate using subject's inferred type name
      let subjectTypeName = this._inferType(node.subject);
      if (!subjectTypeName && node.subject.type === 'Identifier') {
        const sym = this.currentScope.lookup(node.subject.name);
        if (sym) subjectTypeName = sym.inferredType;
      }
      if (subjectTypeName) {
        const exact = candidates.find(([name]) => name === subjectTypeName);
        if (exact) matched = exact;
      }
    }

    if (matched) {
      const [, typeVariants] = matched;
      return typeVariants.every(v => coveredVariants.has(v));
    }
    return false;
  }

  _collectTypeCandidates(nodes, coveredVariants, candidates) {
    for (const node of nodes) {
      if (node.type === 'TypeDeclaration') {
        const typeVariants = node.variants.filter(v => v.type === 'TypeVariant').map(v => v.name);
        if (typeVariants.length === 0) continue;
        // All covered variants must be contained in this type's variants
        const allCovered = [...coveredVariants].every(v => typeVariants.includes(v));
        if (allCovered) {
          candidates.push([node.name, typeVariants]);
        }
      }
      if (node.type === 'SharedBlock' || node.type === 'ServerBlock' || node.type === 'BrowserBlock') {
        this._collectTypeCandidates(node.body, coveredVariants, candidates);
      }
    }
  }

  visitPattern(pattern) {
    if (!pattern) return;

    switch (pattern.type) {
      case 'WildcardPattern':
      case 'LiteralPattern':
      case 'RangePattern':
        break;
      case 'BindingPattern':
        try {
          this.currentScope.define(pattern.name,
            new Symbol(pattern.name, 'variable', null, false, pattern.loc));
        } catch (e) {
          this.error(e.message);
        }
        break;
      case 'VariantPattern':
        for (const field of pattern.fields) {
          if (typeof field === 'string') {
            // Legacy: plain string field names
            try {
              this.currentScope.define(field,
                new Symbol(field, 'variable', null, false, pattern.loc));
            } catch (e) {
              this.error(e.message);
            }
          } else {
            // Nested pattern (e.g., Some(Ok(value)))
            this.visitPattern(field);
          }
        }
        break;
      case 'ArrayPattern':
      case 'TuplePattern':
        if (pattern.elements) {
          for (const el of pattern.elements) {
            this.visitPattern(el);
          }
        }
        break;
      case 'StringConcatPattern':
        if (pattern.rest) {
          this.visitPattern(pattern.rest);
        }
        break;
    }
  }

  visitListComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    try {
      this.visitExpression(node.iterable);
      try {
        this.currentScope.define(node.variable,
          new Symbol(node.variable, 'variable', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
      if (node.condition) this.visitExpression(node.condition);
      this.visitExpression(node.expression);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitDictComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    try {
      this.visitExpression(node.iterable);
      for (const v of node.variables) {
        try {
          this.currentScope.define(v,
            new Symbol(v, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
      if (node.condition) this.visitExpression(node.condition);
      this.visitExpression(node.key);
      this.visitExpression(node.value);
    } finally {
      this.currentScope = prevScope;
    }
  }

  // visitJSXElement, visitJSXFragment, visitJSXFor, visitJSXIf are in browser-analyzer.js (lazy-loaded)

  // ─── New feature visitors ─────────────────────────────────

  visitBreakStatement(node) {
    if (!this._isInsideLoop()) {
      this.error("'break' can only be used inside a loop", node.loc);
    } else if (node.label && !this._isLabelInScope(node.label)) {
      this.error(`'break ${node.label}' references undefined label '${node.label}'`, node.loc);
    }
  }

  visitContinueStatement(node) {
    if (!this._isInsideLoop()) {
      this.error("'continue' can only be used inside a loop", node.loc);
    } else if (node.label && !this._isLabelInScope(node.label)) {
      this.error(`'continue ${node.label}' references undefined label '${node.label}'`, node.loc);
    }
  }

  _definitelyReturns(node) {
    if (!node) return false;
    switch (node.type) {
      case 'ReturnStatement':
        return true;
      case 'BlockStatement':
        if (node.body.length === 0) return false;
        // Any statement that definitely returns makes the block definitely return
        return node.body.some(stmt => this._definitelyReturns(stmt));
      case 'IfStatement':
        if (!node.elseBody) return false;
        const consequentReturns = this._definitelyReturns(node.consequent);
        const elseReturns = this._definitelyReturns(node.elseBody);
        const allAlternatesReturn = (node.alternates || []).every(alt => this._definitelyReturns(alt.body));
        return consequentReturns && elseReturns && allAlternatesReturn;
      case 'GuardStatement':
        // Guard only handles the failure case — when condition is true, execution falls through
        // A guard alone never guarantees return on ALL paths
        return false;
      case 'MatchExpression': {
        const hasWildcard = node.arms.some(arm =>
          arm.pattern.type === 'WildcardPattern' ||
          (arm.pattern.type === 'BindingPattern' && !arm.guard)
        );
        const isExhaustive = hasWildcard || this._isMatchExhaustive(node);
        if (!isExhaustive) return false;
        // Match arms with expression bodies (not block statements) are implicit returns
        return node.arms.every(arm =>
          arm.body.type !== 'BlockStatement' || this._definitelyReturns(arm.body)
        );
      }
      case 'TryCatchStatement': {
        const tryReturns = node.tryBody.length > 0 &&
          node.tryBody.some(s => this._definitelyReturns(s));
        const catchReturns = !node.catchBody || (node.catchBody.length > 0 &&
          node.catchBody.some(s => this._definitelyReturns(s)));
        return tryReturns && catchReturns;
      }
      case 'ExpressionStatement':
        return this._definitelyReturns(node.expression);
      case 'CallExpression':
        return false;
      default:
        return false;
    }
  }

  _checkCallArgCount(node) {
    if (node.callee.type !== 'Identifier') return;
    const fnSym = this.currentScope.lookup(node.callee.name);
    if (!fnSym || fnSym.kind === 'builtin' || fnSym._totalParamCount === undefined) return;

    // Skip check if any argument uses spread (unknown count)
    const hasSpread = node.arguments.some(a => a.type === 'SpreadExpression');
    if (hasSpread) return;

    // Named arguments are collapsed into a single object at codegen
    const hasNamedArgs = node.arguments.some(a => a.type === 'NamedArgument');
    if (hasNamedArgs) {
      const positionalCount = node.arguments.filter(a => a.type !== 'NamedArgument').length;
      var actualCount = positionalCount + 1; // named args become one object
    } else {
      var actualCount = node.arguments.length;
    }
    const name = node.callee.name;

    if (actualCount > fnSym._totalParamCount) {
      this.strictError(`'${name}' expects ${fnSym._totalParamCount} argument${fnSym._totalParamCount !== 1 ? 's' : ''}, but got ${actualCount}`, node.loc);
    } else if (actualCount < fnSym._requiredParamCount) {
      this.strictError(`'${name}' expects at least ${fnSym._requiredParamCount} argument${fnSym._requiredParamCount !== 1 ? 's' : ''}, but got ${actualCount}`, node.loc);
    }
  }

  _checkCallArgTypes(node) {
    if (node.callee.type !== 'Identifier') return;
    const fnSym = this.currentScope.lookup(node.callee.name);
    if (!fnSym || fnSym.kind === 'builtin' || !fnSym._paramTypes) return;

    const hasSpread = node.arguments.some(a => a.type === 'SpreadExpression');
    if (hasSpread) return;

    // Infer type parameter bindings from arguments for generic functions
    const typeParamBindings = new Map();
    if (fnSym._typeParams && fnSym._typeParams.length > 0) {
      for (let i = 0; i < node.arguments.length && i < fnSym._paramTypes.length; i++) {
        const arg = node.arguments[i];
        if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
        const paramTypeAnn = fnSym._paramTypes[i];
        if (!paramTypeAnn) continue;
        const actualType = this._inferType(arg);
        if (actualType) {
          this._inferTypeParamBindings(paramTypeAnn, actualType, fnSym._typeParams, typeParamBindings);
        }
      }
    }

    for (let i = 0; i < node.arguments.length && i < fnSym._paramTypes.length; i++) {
      const arg = node.arguments[i];
      if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
      const paramTypeAnn = fnSym._paramTypes[i];
      if (!paramTypeAnn) continue;
      let expectedType = this._typeAnnotationToString(paramTypeAnn);
      // Substitute type parameters with inferred bindings
      if (typeParamBindings.size > 0) {
        expectedType = this._substituteTypeParams(expectedType, typeParamBindings);
      }
      // Skip check if expected type is still a bare type parameter (couldn't infer)
      if (fnSym._typeParams && fnSym._typeParams.includes(expectedType)) continue;
      const actualType = this._inferType(arg);
      if (!this._typesCompatible(expectedType, actualType)) {
        const paramName = fnSym._params ? fnSym._params[i] : `argument ${i + 1}`;
        this.error(`Type mismatch: '${paramName}' expects ${expectedType}, but got ${actualType}`, arg.loc || node.loc, this._conversionHint(expectedType, actualType));
      }
    }
  }

  /**
   * Infer type parameter bindings by matching a type annotation against an actual type string.
   * E.g., matching param annotation `T` against actual `Int` binds T=Int.
   * Matching `[T]` against `[Int]` binds T=Int.
   */
  _inferTypeParamBindings(ann, actualType, typeParams, bindings) {
    if (!ann || !actualType) return;
    const annStr = typeof ann === 'string' ? ann : (ann.type === 'TypeAnnotation' ? ann.name : null);
    if (!annStr) return;

    // Direct type parameter match: T -> Int
    if (typeParams.includes(annStr) && !bindings.has(annStr)) {
      bindings.set(annStr, actualType);
      return;
    }

    // Array type: [T] -> [Int]
    if (ann.type === 'ArrayTypeAnnotation' && actualType.startsWith('[') && actualType.endsWith(']')) {
      const innerActual = actualType.slice(1, -1);
      this._inferTypeParamBindings(ann.elementType, innerActual, typeParams, bindings);
      return;
    }

    // Generic type: Result<T, E> -> Result<Int, String>
    if (ann.type === 'TypeAnnotation' && ann.typeParams && ann.typeParams.length > 0) {
      const parsed = this._parseGenericType(actualType);
      if (parsed.base === ann.name && parsed.params.length === ann.typeParams.length) {
        for (let i = 0; i < ann.typeParams.length; i++) {
          this._inferTypeParamBindings(ann.typeParams[i], parsed.params[i], typeParams, bindings);
        }
      }
    }
  }

  /**
   * Substitute type parameter names in a type string with their inferred bindings.
   */
  _substituteTypeParams(typeStr, bindings) {
    if (!typeStr || bindings.size === 0) return typeStr;
    // Direct match
    if (bindings.has(typeStr)) return bindings.get(typeStr);
    // Array type
    if (typeStr.startsWith('[') && typeStr.endsWith(']')) {
      const inner = typeStr.slice(1, -1);
      return `[${this._substituteTypeParams(inner, bindings)}]`;
    }
    // Generic type
    const parsed = this._parseGenericType(typeStr);
    if (parsed.params.length > 0) {
      const substituted = parsed.params.map(p => this._substituteTypeParams(p, bindings));
      return `${parsed.base}<${substituted.join(', ')}>`;
    }
    return typeStr;
  }

  /**
   * Resolve a type alias to its underlying type string.
   * E.g., if `type UserList = [User]`, resolves 'UserList' -> '[User]'.
   * For generic aliases like `type Callback<T> = fn(T) -> Result<T, String>`,
   * resolves 'Callback<Int>' by substituting T=Int.
   */
  _resolveTypeAlias(typeStr) {
    if (!typeStr) return typeStr;
    const parsed = this._parseGenericType(typeStr);
    const baseName = parsed.params.length > 0 ? parsed.base : typeStr;

    // Look up the type in scope
    const sym = this.currentScope.lookup(baseName);
    if (!sym || sym.kind !== 'type' || !sym._typeAliasExpr) return typeStr;

    // Resolve the alias
    let resolved = this._typeAnnotationToString(sym._typeAliasExpr);
    if (!resolved) return typeStr;

    // Substitute type parameters if the alias is generic
    if (sym._typeParams && sym._typeParams.length > 0 && parsed.params.length > 0) {
      const bindings = new Map();
      for (let i = 0; i < sym._typeParams.length && i < parsed.params.length; i++) {
        bindings.set(sym._typeParams[i], parsed.params[i]);
      }
      resolved = this._substituteTypeParams(resolved, bindings);
    }

    return resolved;
  }

  _checkBinaryExprTypes(node) {
    const op = node.operator;
    const leftType = this._inferType(node.left);
    const rightType = this._inferType(node.right);

    if (op === '++') {
      // String concatenation: both sides should be String
      if (leftType && leftType !== 'String' && leftType !== 'Any') {
        this.strictError(`Type mismatch: '++' expects String on left side, but got ${leftType}`, node.loc, "try toString(value) to convert");
      }
      if (rightType && rightType !== 'String' && rightType !== 'Any') {
        this.strictError(`Type mismatch: '++' expects String on right side, but got ${rightType}`, node.loc, "try toString(value) to convert");
      }
    } else if (ARITHMETIC_OPS.has(op)) {
      // String literal * Int is valid (string repeat) — skip warning for that case
      if (op === '*') {
        const leftIsStr = node.left.type === 'StringLiteral' || node.left.type === 'TemplateLiteral';
        const rightIsStr = node.right.type === 'StringLiteral' || node.right.type === 'TemplateLiteral';
        if (leftIsStr || rightIsStr) return;
      }
      // Arithmetic: both sides must be numeric
      if (leftType && !NUMERIC_TYPES.has(leftType) && leftType !== 'Any') {
        const hint = leftType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '${op}' expects numeric type, but got ${leftType}`, node.loc, hint);
      }
      if (rightType && !NUMERIC_TYPES.has(rightType) && rightType !== 'Any') {
        const hint = rightType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '${op}' expects numeric type, but got ${rightType}`, node.loc, hint);
      }
    } else if (op === '+') {
      // Addition: both sides must be numeric (Tova uses ++ for strings)
      if (leftType && !NUMERIC_TYPES.has(leftType) && leftType !== 'Any') {
        const hint = leftType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '+' expects numeric type, but got ${leftType}`, node.loc, hint);
      }
      if (rightType && !NUMERIC_TYPES.has(rightType) && rightType !== 'Any') {
        const hint = rightType === 'String' ? "try toInt(value) or toFloat(value) to parse" : null;
        this.strictError(`Type mismatch: '+' expects numeric type, but got ${rightType}`, node.loc, hint);
      }
    }
  }

  // Search for a variable from current scope up to the nearest function/module boundary.
  // This ensures `x = 20` inside an if/for block finds `x = 10` from the enclosing function,
  // preventing silent shadowing of immutable bindings within the same function.
  _lookupAssignTarget(name) {
    let scope = this.currentScope;
    let crossedFunction = false;
    while (scope) {
      const sym = scope.symbols.get(name);
      if (sym) {
        // After crossing a function boundary, only resolve to mutable symbols (var/state)
        // so that inner functions can reassign outer var/state but not shadow immutables
        if (crossedFunction && !sym.mutable) return null;
        return sym;
      }
      // Track when we cross a function boundary
      if (scope.context === 'function') {
        crossedFunction = true;
      }
      // Stop at module level
      if (scope.context === 'module') break;
      scope = scope.parent;
    }
    return null;
  }

  // Check if a name exists in any outer scope beyond the current function boundary.
  // Used to warn about shadowing of outer variables.
  _existsInOuterScope(name) {
    let scope = this.currentScope;
    let crossedBoundary = false;
    while (scope) {
      if (!crossedBoundary && (scope.context === 'function' || scope.context === 'module' ||
          scope.context === 'server' || scope.context === 'client' || scope.context === 'shared')) {
        crossedBoundary = true;
        scope = scope.parent;
        continue;
      }
      if (crossedBoundary) {
        const sym = scope.symbols.get(name);
        if (sym && sym.kind !== 'builtin') return true;
      }
      scope = scope.parent;
    }
    return false;
  }

  pushScope(context) {
    this.currentScope = this.currentScope.child(context);
  }

  popScope() {
    this.currentScope = this.currentScope.parent;
  }

  _isInsideLoop() {
    // Walk up the AST context — check if any parent is a for/while loop scope
    // Stop at function boundaries so break/continue inside lambdas is rejected
    let scope = this.currentScope;
    while (scope) {
      if (scope._isLoop) return true;
      if (scope.context === 'function') return false;
      scope = scope.parent;
    }
    return false;
  }

  _isLabelInScope(label) {
    // Walk up scopes to find a matching loop label
    let scope = this.currentScope;
    while (scope) {
      if (scope._isLoop && scope._loopLabel === label) return true;
      if (scope.context === 'function') return false;
      scope = scope.parent;
    }
    return false;
  }

  visitGuardStatement(node) {
    this.visitExpression(node.condition);
    this.visitNode(node.elseBody);

    // Type narrowing after guard: guard x != nil else { return }
    // The condition being true means x is non-nil for the rest of the scope
    const narrowing = this._extractNarrowingInfo(node.condition);
    if (narrowing) {
      const sym = this.currentScope.lookup(narrowing.varName);
      if (sym) {
        // Narrow the variable in the current scope (not a new child scope)
        const narrowedSym = new Symbol(narrowing.varName, sym.kind, null, sym.mutable, sym.loc);
        narrowedSym.inferredType = narrowing.narrowedType;
        narrowedSym._narrowed = true;
        narrowedSym.used = sym.used;
        // Replace in current scope so the rest of the function sees the narrowed type
        this.currentScope.symbols.set(narrowing.varName, narrowedSym);
      }
    }
  }

  visitInterfaceDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'type', null, false, node.loc);
      // Store method signatures for conformance checking
      sym._interfaceMethods = (node.methods || []).map(m => ({
        name: m.name,
        paramTypes: (m.params || []).map(p => typeAnnotationToType(p.typeAnnotation)),
        returnType: typeAnnotationToType(m.returnType),
        paramCount: (m.params || []).filter(p => p.name !== 'self').length,
      }));
      this.currentScope.define(node.name, sym);

      // Register in type registry for LSP
      this.typeRegistry.traits.set(node.name, sym._interfaceMethods);
    } catch (e) {
      this.error(e.message);
    }
  }

  visitImplDeclaration(node) {
    // Collect provided method names for conformance checking
    const providedMethods = new Map();
    for (const method of node.methods) {
      providedMethods.set(method.name, {
        paramCount: (method.params || []).filter(p => p.name !== 'self').length,
        returnType: method.returnType ? typeAnnotationToType(method.returnType) : null,
      });
    }

    // Register impl methods in type registry for LSP
    const typeName = node.typeName || node.target;
    if (typeName) {
      const existingImpls = this.typeRegistry.impls.get(typeName) || [];
      for (const method of node.methods) {
        const hasSelf = (method.params || []).some(p => p.name === 'self');
        existingImpls.push({
          name: method.name,
          params: (method.params || []).map(p => p.name),
          paramTypes: (method.params || []).map(p => typeAnnotationToType(p.typeAnnotation)),
          returnType: typeAnnotationToType(method.returnType),
          isAssociated: !hasSelf,
        });
      }
      this.typeRegistry.impls.set(typeName, existingImpls);
    }

    // Trait/interface conformance checking
    if (node.traitName) {
      const traitSym = this.currentScope.lookup(node.traitName);
      if (traitSym && traitSym._interfaceMethods) {
        for (const required of traitSym._interfaceMethods) {
          const provided = providedMethods.get(required.name);
          if (!provided) {
            this.warn(`Impl for '${typeName || 'type'}' missing required method '${required.name}' from trait '${node.traitName}'`, node.loc, null, { code: 'W300' });
          } else {
            // Check parameter count matches (excluding self)
            if (required.paramCount > 0 && provided.paramCount !== required.paramCount) {
              this.warn(`Method '${required.name}' in impl for '${typeName}' has ${provided.paramCount} parameters, but trait '${node.traitName}' expects ${required.paramCount}`, node.loc, null, { code: 'W301' });
            }
            // Check return type matches if both are annotated
            if (required.returnType && provided.returnType) {
              if (!provided.returnType.isAssignableTo(required.returnType)) {
                this.warn(`Method '${required.name}' return type mismatch in impl for '${typeName}': expected ${required.returnType}, got ${provided.returnType}`, node.loc, null, { code: 'W302' });
              }
            }
          }
        }
      }
    }

    // Validate that methods reference the type
    for (const method of node.methods) {
      const hasSelf = (method.params || []).some(p => p.name === 'self');
      this.pushScope('function');
      try {
        // self is only available for instance methods (not associated functions)
        if (hasSelf) {
          try {
            this.currentScope.define('self',
              new Symbol('self', 'variable', null, true, method.loc));
          } catch (e) { /* ignore */ }
        }
        for (const p of method.params) {
          if (p.name && p.name !== 'self') {
            try {
              this.currentScope.define(p.name,
                new Symbol(p.name, 'variable', null, false, p.loc));
            } catch (e) { /* ignore */ }
          }
        }
        if (method.body) {
          this.visitBlock(method.body);
        }
      } finally {
        this.popScope();
      }
    }
  }

  visitTraitDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'type', null, false, node.loc);
      // Store method signatures for conformance checking
      sym._interfaceMethods = (node.methods || []).map(m => ({
        name: m.name,
        paramTypes: (m.params || []).map(p => typeAnnotationToType(p.typeAnnotation)),
        returnType: typeAnnotationToType(m.returnType),
        paramCount: (m.params || []).filter(p => p.name !== 'self').length,
      }));
      this.currentScope.define(node.name, sym);

      // Register in type registry for LSP
      this.typeRegistry.traits.set(node.name, sym._interfaceMethods);
    } catch (e) {
      this.error(e.message);
    }
    // Visit default implementations
    for (const method of node.methods) {
      if (method.body) {
        this.pushScope('function');
        try {
          for (const p of method.params) {
            if (p.name) {
              try {
                this.currentScope.define(p.name,
                  new Symbol(p.name, 'variable', null, false, p.loc || node.loc));
              } catch (e) { /* ignore */ }
            }
          }
          this.visitBlock(method.body);
        } finally {
          this.popScope();
        }
      }
    }
  }

  visitTypeAlias(node) {
    try {
      const typeSym = new Symbol(node.name, 'type', null, false, node.loc);
      // Store type alias info for resolution
      if (node.typeExpr) {
        typeSym._typeAliasExpr = node.typeExpr;
        typeSym._typeParams = node.typeParams || [];
        const resolved = typeAnnotationToType(node.typeExpr);
        if (resolved) {
          typeSym._typeStructure = resolved;
          this.typeRegistry.types.set(node.name, resolved);
        }
      }
      this.currentScope.define(node.name, typeSym);
    } catch (e) {
      this.error(e.message);
    }
  }

  visitDeferStatement(node) {
    // Validate defer is inside a function
    let scope = this.currentScope;
    let insideFunction = false;
    while (scope) {
      if (scope.context === 'function') {
        insideFunction = true;
        break;
      }
      scope = scope.parent;
    }
    if (!insideFunction) {
      this.warn("'defer' used outside of a function", node.loc, null, { code: 'W208' });
    }
    if (node.body) {
      if (node.body.type === 'BlockStatement') {
        this.visitBlock(node.body);
      } else {
        this.visitExpression(node.body);
      }
    }
  }
}

// ─── src/stdlib/inline.js ──────────────────────────────

// Tova standard library — inline string versions for codegen
// Single source of truth for all inline stdlib code used in code generation.
// Used by: base-codegen.js, browser-codegen.js, bin/tova.js
const RESULT_OPTION = `class _Ok { constructor(value) { this.value = value; } }
_Ok.prototype.__tag = "Ok";
_Ok.prototype.map = function(fn) { return new _Ok(fn(this.value)); };
_Ok.prototype.flatMap = function(fn) { const r = fn(this.value); if (r && r.__tag) return r; throw new Error("flatMap callback must return Ok/Err"); };
_Ok.prototype.andThen = _Ok.prototype.flatMap;
_Ok.prototype.unwrap = function() { return this.value; };
_Ok.prototype.unwrapOr = function(_) { return this.value; };
_Ok.prototype.expect = function(_) { return this.value; };
_Ok.prototype.isOk = function() { return true; };
_Ok.prototype.isErr = function() { return false; };
_Ok.prototype.mapErr = function(_) { return this; };
_Ok.prototype.unwrapErr = function() { throw new Error("Called unwrapErr on Ok"); };
_Ok.prototype.or = function(_) { return this; };
_Ok.prototype.and = function(other) { return other; };
_Ok.prototype.context = function(_) { return this; };
function Ok(value) { return new _Ok(value); }
class _Err { constructor(error) { this.error = error; } }
_Err.prototype.__tag = "Err";
_Err.prototype.map = function(_) { return this; };
_Err.prototype.flatMap = function(_) { return this; };
_Err.prototype.andThen = _Err.prototype.flatMap;
_Err.prototype.unwrap = function() { throw new Error("Called unwrap on Err: " + (typeof this.error === "object" ? JSON.stringify(this.error) : this.error)); };
_Err.prototype.unwrapOr = function(def) { return def; };
_Err.prototype.expect = function(msg) { throw new Error(msg); };
_Err.prototype.isOk = function() { return false; };
_Err.prototype.isErr = function() { return true; };
_Err.prototype.mapErr = function(fn) { return new _Err(fn(this.error)); };
_Err.prototype.unwrapErr = function() { return this.error; };
_Err.prototype.or = function(other) { return other; };
_Err.prototype.and = function(_) { return this; };
_Err.prototype.context = function(msg) { const inner = typeof this.error === "object" ? JSON.stringify(this.error) : String(this.error); return new _Err(msg + " \\u2192 caused by: " + inner); };
function Err(error) { return new _Err(error); }
class _Some { constructor(value) { this.value = value; } }
_Some.prototype.__tag = "Some";
_Some.prototype.map = function(fn) { return new _Some(fn(this.value)); };
_Some.prototype.flatMap = function(fn) { const r = fn(this.value); if (r && r.__tag) return r; throw new Error("flatMap callback must return Some/None"); };
_Some.prototype.andThen = _Some.prototype.flatMap;
_Some.prototype.unwrap = function() { return this.value; };
_Some.prototype.unwrapOr = function(_) { return this.value; };
_Some.prototype.expect = function(_) { return this.value; };
_Some.prototype.isSome = function() { return true; };
_Some.prototype.isNone = function() { return false; };
_Some.prototype.or = function(_) { return this; };
_Some.prototype.and = function(other) { return other; };
_Some.prototype.filter = function(pred) { return pred(this.value) ? this : None; };
function Some(value) { return new _Some(value); }
const None = Object.freeze({ __tag: "None", map(_) { return None; }, flatMap(_) { return None; }, andThen(_) { return None; }, unwrap() { throw new Error("Called unwrap on None"); }, unwrapOr(def) { return def; }, expect(msg) { throw new Error(msg); }, isSome() { return false; }, isNone() { return true; }, or(other) { return other; }, and(_) { return None; }, filter(_) { return None; } });`;
const PROPAGATE = `function __propagate(val) {
  if (val && val.__tag === "Err") throw { __tova_propagate: true, value: val };
  if (val && val.__tag === "None") throw { __tova_propagate: true, value: val };
  if (val && val.__tag === "Ok") return val.value;
  if (val && val.__tag === "Some") return val.value;
  return val;
}`;

// Individual builtin functions for tree-shaking
const BUILTIN_FUNCTIONS = {
  print: `function print(...args) { console.log(...args); }`,
  len: `function len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v) || ArrayBuffer.isView(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }`,
  range: `function range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; if (st === 0) return []; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }`,
  enumerate: `function enumerate(a) { return a.map((v, i) => [i, v]); }`,
  sum: `function sum(a) { return a.reduce((x, y) => x + y, 0); }`,
  sorted: `function sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else if (c.length > 0 && typeof c[0] === 'number') { if (typeof __tova_native !== 'undefined' && __tova_native && c.length > 128) { const f = new Float64Array(c); __tova_native.tova_sort_f64(f, f.length); for (let i = 0; i < c.length; i++) c[i] = f[i]; } else if (c.length > 128) { const f = new Float64Array(c); f.sort(); for (let i = 0; i < c.length; i++) c[i] = f[i]; } else { c.sort((a, b) => a - b); } } else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }`,
  reversed: `function reversed(a) { return [...a].reverse(); }`,
  zip: `function zip(...as) { if (as.length === 0) return []; const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }`,
  min: `function min(a) { if (a.length === 0) return null; let m = a[0]; for (let i = 1; i < a.length; i++) if (a[i] < m) m = a[i]; return m; }`,
  max: `function max(a) { if (a.length === 0) return null; let m = a[0]; for (let i = 1; i < a.length; i++) if (a[i] > m) m = a[i]; return m; }`,
  type_of: `function type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }`,
  filter: `function filter(arr, fn) { return arr.filter(fn); }`,
  map: `function map(arr, fn) { return arr.map(fn); }`,
  find: `function find(arr, fn) { return arr.find(fn) ?? null; }`,
  any: `function any(arr, fn) { return arr.some(fn); }`,
  all: `function all(arr, fn) { return arr.every(fn); }`,
  flat_map: `function flat_map(arr, fn) { return arr.flatMap(fn); }`,
  reduce: `function reduce(arr, fn, init) { return init === undefined ? arr.reduce(fn) : arr.reduce(fn, init); }`,
  unique: `function unique(arr) { return [...new Set(arr)]; }`,
  group_by: `function group_by(arr, fn) { const r = {}; for (const v of arr) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; }`,
  chunk: `function chunk(arr, n) { const r = []; for (let i = 0; i < arr.length; i += n) r.push(arr.slice(i, i + n)); return r; }`,
  flatten: `function flatten(arr) { return arr.flat(); }`,
  take: `function take(arr, n) { return arr.slice(0, n); }`,
  drop: `function drop(arr, n) { return arr.slice(n); }`,
  first: `function first(arr) { return arr.length > 0 ? arr[0] : null; }`,
  last: `function last(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }`,
  count: `function count(arr, fn) { return arr.filter(fn).length; }`,
  partition: `function partition(arr, fn) { const y = [], n = []; for (const v of arr) { (fn(v) ? y : n).push(v); } return [y, n]; }`,
  filled: `function filled(n, val) { return new Array(n).fill(val); }`,
  abs: `function abs(n) { return Math.abs(n); }`,
  floor: `function floor(n) { return Math.floor(n); }`,
  ceil: `function ceil(n) { return Math.ceil(n); }`,
  round: `function round(n) { return Math.round(n); }`,
  clamp: `function clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); }`,
  sqrt: `function sqrt(n) { return Math.sqrt(n); }`,
  pow: `function pow(b, e) { return Math.pow(b, e); }`,
  random: `function random() { return Math.random(); }`,
  trim: `function trim(s) { return s.trim(); }`,
  split: `function split(s, sep) { return s.split(sep); }`,
  join: `function join(arr, sep) { return arr.join(sep); }`,
  replace: `function replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); }`,
  repeat: `function repeat(s, n) { return s.repeat(n); }`,
  keys: `function keys(obj) { return Object.keys(obj); }`,
  values: `function values(obj) { return Object.values(obj); }`,
  entries: `function entries(obj) { return Object.entries(obj); }`,
  merge: `function merge(...objs) { return Object.assign({}, ...objs); }`,
  freeze: `function freeze(obj) { return Object.freeze(obj); }`,
  clone: `function clone(obj) { return structuredClone(obj); }`,
  sleep: `function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }`,
  parallel_map: `async function parallel_map(arr, fn, numWorkers) {
  if (!arr || arr.length === 0) return [];
  const cores = numWorkers || (typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : 4) || 4;
  const n = Math.min(cores, arr.length);
  if (n <= 1 || arr.length < 4) return arr.map(fn);
  if (!parallel_map._pool) {
    const { Worker } = await import("worker_threads");
    const wc = 'const{parentPort}=require("worker_threads");parentPort.on("message",m=>{const fn=(0,eval)("("+m.f+")");try{const r=m.c.map(fn);parentPort.postMessage({i:m.i,r})}catch(e){parentPort.postMessage({i:m.i,e:e.message})}})';
    parallel_map._pool = Array.from({length: n}, () => new Worker(wc, {eval: true}));
    parallel_map._cid = 0;
  }
  const pool = parallel_map._pool;
  const cs = Math.ceil(arr.length / pool.length);
  const fnStr = fn.toString();
  const cid = ++parallel_map._cid;
  const promises = [];
  const usedWorkers = [];
  for (let ci = 0; ci < pool.length && ci * cs < arr.length; ci++) {
    const chunk = arr.slice(ci * cs, (ci + 1) * cs);
    const mid = cid * 1000 + ci;
    const w = pool[ci];
    w.ref();
    usedWorkers.push(w);
    promises.push(new Promise((resolve, reject) => {
      const h = (msg) => { if (msg.i === mid) { w.removeListener("message", h); if (msg.e) reject(new Error(msg.e)); else resolve(msg.r); } };
      w.on("message", h);
      w.postMessage({i: mid, c: chunk, f: fnStr});
    }));
  }
  try { return (await Promise.all(promises)).flat(); } finally { for (const w of usedWorkers) w.unref(); }
}`,
  upper: `function upper(s) { return s.toUpperCase(); }`,
  lower: `function lower(s) { return s.toLowerCase(); }`,
  contains: `function contains(s, sub) { return s.includes(sub); }`,
  starts_with: `function starts_with(s, prefix) { return s.startsWith(prefix); }`,
  ends_with: `function ends_with(s, suffix) { return s.endsWith(suffix); }`,
  chars: `function chars(s) { return [...s]; }`,
  words: `function words(s) { return s.split(/\\s+/).filter(Boolean); }`,
  lines: `function lines(s) { return s.split('\\n'); }`,
  capitalize: `function capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; }`,
  title_case: `function title_case(s) { return s.replace(/\\b\\w/g, c => c.toUpperCase()); }`,
  snake_case: `function snake_case(s) { return s.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); }`,
  camel_case: `function camel_case(s) { return s.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); }`,
  assert_eq: `function assert_eq(a, b, msg) { if (a !== b) throw new Error(msg || \`Assertion failed: \${JSON.stringify(a)} !== \${JSON.stringify(b)}\`); }`,
  assert_ne: `function assert_ne(a, b, msg) { if (a === b) throw new Error(msg || \`Assertion failed: values should not be equal: \${JSON.stringify(a)}\`); }`,
  assert: `function assert(cond, msg) { if (!cond) throw new Error(msg || "Assertion failed"); }`,
  assert_throws: `function assert_throws(fn, expected) {
  try { fn(); } catch (e) {
    if (expected !== undefined) {
      const msg = e instanceof Error ? e.message : String(e);
      if (typeof expected === 'string' && !msg.includes(expected)) {
        throw new Error("Expected error containing \\"" + expected + "\\" but got \\"" + msg + "\\"");
      }
      if (expected instanceof RegExp && !expected.test(msg)) {
        throw new Error("Expected error matching " + expected + " but got \\"" + msg + "\\"");
      }
    }
    return e;
  }
  throw new Error("Expected function to throw" + (expected ? " \\"" + expected + "\\"" : "") + " but it did not");
}`,

  // ── Missing from module files (synced to BUILTIN_FUNCTIONS) ──
  find_index: `function find_index(arr, fn) { const i = arr.findIndex(fn); return i === -1 ? null : i; }`,
  includes: `function includes(arr, value) { return arr.includes(value); }`,
  replace_first: `function replace_first(s, from, to) { return s.replace(from, to); }`,
  pad_start: `function pad_start(s, n, fill) { return s.padStart(n, fill || ' '); }`,
  pad_end: `function pad_end(s, n, fill) { return s.padEnd(n, fill || ' '); }`,
  char_at: `function char_at(s, i) { return i < s.length ? s[i] : null; }`,
  trim_start: `function trim_start(s) { return s.trimStart(); }`,
  trim_end: `function trim_end(s) { return s.trimEnd(); }`,

  // ── Math constants ────────────────────────────────────
  PI: `const PI = Math.PI;`,
  E: `const E = Math.E;`,
  INF: `const INF = Infinity;`,

  // ── Trigonometric ─────────────────────────────────────
  sin: `function sin(n) { return Math.sin(n); }`,
  cos: `function cos(n) { return Math.cos(n); }`,
  tan: `function tan(n) { return Math.tan(n); }`,
  asin: `function asin(n) { return Math.asin(n); }`,
  acos: `function acos(n) { return Math.acos(n); }`,
  atan: `function atan(n) { return Math.atan(n); }`,
  atan2: `function atan2(y, x) { return Math.atan2(y, x); }`,

  // ── Logarithmic / Exponential ─────────────────────────
  log: `function log(n) { return Math.log(n); }`,
  log2: `function log2(n) { return Math.log2(n); }`,
  log10: `function log10(n) { return Math.log10(n); }`,
  exp: `function exp(n) { return Math.exp(n); }`,

  // ── Numeric Utilities ─────────────────────────────────
  sign: `function sign(n) { return Math.sign(n); }`,
  trunc: `function trunc(n) { return Math.trunc(n); }`,
  is_nan: `function is_nan(n) { return Number.isNaN(n); }`,
  is_finite: `function is_finite(n) { return Number.isFinite(n); }`,
  is_close: `function is_close(a, b, tol) { return Math.abs(a - b) <= (tol === undefined ? 1e-9 : tol); }`,
  to_radians: `function to_radians(deg) { return deg * Math.PI / 180; }`,
  to_degrees: `function to_degrees(rad) { return rad * 180 / Math.PI; }`,

  // ── Integer Math ──────────────────────────────────────
  gcd: `function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); while (b) { [a, b] = [b, a % b]; } return a; }`,
  lcm: `function lcm(a, b) { if (a === 0 && b === 0) return 0; let x = Math.abs(a), y = Math.abs(b); while (y) { const t = y; y = x % y; x = t; } return Math.abs(a * b) / x; }`,
  factorial: `function factorial(n) { if (n < 0) return null; if (n <= 1) return 1; let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; }`,

  // ── Randomness ────────────────────────────────────────
  random_int: `function random_int(lo, hi) { return Math.floor(Math.random() * (hi - lo + 1)) + lo; }`,
  random_float: `function random_float(lo, hi) { return Math.random() * (hi - lo) + lo; }`,
  choice: `function choice(arr) { return arr.length === 0 ? null : arr[Math.floor(Math.random() * arr.length)]; }`,
  sample: `function sample(arr, n) { const c = [...arr]; for (let i = c.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [c[i], c[j]] = [c[j], c[i]]; } return c.slice(0, n); }`,
  shuffle: `function shuffle(arr) { const c = [...arr]; for (let i = c.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [c[i], c[j]] = [c[j], c[i]]; } return c; }`,

  // ── Type Conversion ───────────────────────────────────
  to_int: `function to_int(v) { if (typeof v === 'boolean') return v ? 1 : 0; const n = typeof v === 'string' ? parseInt(v, 10) : Math.trunc(Number(v)); return isNaN(n) ? null : n; }`,
  to_float: `function to_float(v) { if (typeof v === 'boolean') return v ? 1.0 : 0.0; const n = Number(v); return isNaN(n) ? null : n; }`,
  to_string: `function to_string(v) { if (v == null) return 'nil'; if (v && v.__tag) return v.__tag + (v.value !== undefined ? '(' + String(v.value) + ')' : ''); return String(v); }`,
  to_bool: `function to_bool(v) { if (typeof v === 'string') return v !== '' && v !== '0' && v !== 'false'; return Boolean(v); }`,

  // ── Table runtime ───────────────────────────────────
  Table: `function Table(rows, columns) { if (rows instanceof Table) return rows; const t = Object.create(Table.prototype); t._rows = Array.isArray(rows) ? rows : []; t._columns = columns || (t._rows.length > 0 ? Object.keys(t._rows[0]) : []); return t; }
Table.prototype = { get rows() { return this._rows.length; }, get columns() { return [...this._columns]; }, get shape() { return [this._rows.length, this._columns.length]; }, get length() { return this._rows.length; }, [Symbol.iterator]() { return this._rows[Symbol.iterator](); }, at(i) { if (i < 0) i = this._rows.length + i; return this._rows[i] ?? null; }, slice(s, e) { return Table(this._rows.slice(s, e), this._columns); }, getColumn(n) { return this._rows.map(r => r[n]); }, toArray() { return [...this._rows]; }, toJSON() { return this._rows; }, toString() { if (this._rows.length === 0) return 'Table(0 rows, 0 columns)'; return 'Table(' + this._rows.length + ' rows, ' + this._columns.length + ' columns)'; }, _format(maxRows, title) { const lines = []; if (title) lines.push('── ' + title + ' ──'); const cols = this._columns; const dr = this._rows.slice(0, maxRows || 10); if (cols.length === 0 || dr.length === 0) { lines.push('(empty table)'); lines.push(this._rows.length + ' rows × ' + cols.length + ' columns'); return lines.join('\\n'); } const w = {}; for (const c of cols) { w[c] = c.length; for (const r of dr) { const s = r[c] == null ? 'nil' : String(r[c]); w[c] = Math.max(w[c], s.length); } w[c] = Math.min(w[c], 30); } lines.push(cols.map(c => c.padEnd(w[c])).join(' │ ')); lines.push(cols.map(c => '─'.repeat(w[c])).join('─┼─')); for (const r of dr) { lines.push(cols.map(c => { const s = r[c] == null ? 'nil' : String(r[c]); return s.slice(0, 30).padEnd(w[c]); }).join(' │ ')); } if (this._rows.length > (maxRows || 10)) lines.push('... ' + (this._rows.length - (maxRows || 10)) + ' more rows'); lines.push(this._rows.length + ' rows × ' + cols.length + ' columns'); return lines.join('\\n'); } };`,

  // ── Table operations ────────────────────────────────
  table_where: `function table_where(table, pred) { return Table(table._rows.filter(pred), table._columns); }`,
  table_select: `function table_select(table, ...args) { let cols; if (args.length === 1 && args[0] && args[0].__exclude) { const ex = new Set(Array.isArray(args[0].__exclude) ? args[0].__exclude : [args[0].__exclude]); cols = table._columns.filter(c => !ex.has(c)); } else { cols = args.filter(a => typeof a === 'string'); } const rows = table._rows.map(r => { const row = {}; for (const c of cols) row[c] = r[c]; return row; }); return Table(rows, cols); }`,
  table_derive: `function table_derive(table, derivations) { const nc = [...table._columns]; for (const k of Object.keys(derivations)) { if (!nc.includes(k)) nc.push(k); } const rows = table._rows.map(r => { const row = { ...r }; for (const [k, fn] of Object.entries(derivations)) { row[k] = typeof fn === 'function' ? fn(r) : fn; } return row; }); return Table(rows, nc); }`,
  table_group_by: `function table_group_by(table, keyFn) { const groups = new Map(); for (const row of table._rows) { const key = typeof keyFn === 'function' ? keyFn(row) : row[keyFn]; const ks = String(key); if (!groups.has(ks)) groups.set(ks, { key, rows: [] }); groups.get(ks).rows.push(row); } return { __grouped: true, groups, columns: table._columns }; }`,
  table_agg: `function table_agg(grouped, aggregations) { if (!grouped || !grouped.__grouped) throw new Error('agg() must be called after group_by()'); const rows = []; for (const [, { key, rows: gr }] of grouped.groups) { const row = typeof key === 'object' && key !== null ? { ...key } : { _group: key }; for (const [n, fn] of Object.entries(aggregations)) { row[n] = fn(gr); } rows.push(row); } return Table(rows, rows.length > 0 ? Object.keys(rows[0]) : []); }`,
  table_sort_by: `function table_sort_by(table, keyFn, opts) { const desc = opts && opts.desc; const rows = [...table._rows].sort((a, b) => { const ka = typeof keyFn === 'function' ? keyFn(a) : a[keyFn]; const kb = typeof keyFn === 'function' ? keyFn(b) : b[keyFn]; let c = ka < kb ? -1 : ka > kb ? 1 : 0; return desc ? -c : c; }); return Table(rows, table._columns); }`,
  table_limit: `function table_limit(table, n) { return Table(table._rows.slice(0, n), table._columns); }`,
  table_join: `function table_join(table, other, opts) { const { left, right, how } = opts || {}; if (!left || !right) throw new Error('join() requires left and right key functions'); const rows = []; const ri = new Map(); for (const r of other._rows) { const k = typeof right === 'function' ? right(r) : r[right]; const ks = String(k); if (!ri.has(ks)) ri.set(ks, []); ri.get(ks).push(r); } const cc = [...new Set([...table._columns, ...other._columns])]; for (const lr of table._rows) { const k = typeof left === 'function' ? left(lr) : lr[left]; const ms = ri.get(String(k)) || []; if (ms.length > 0) { for (const rr of ms) rows.push({ ...lr, ...rr }); } else if (how === 'left' || how === 'outer') { const row = { ...lr }; for (const c of other._columns) { if (!(c in row)) row[c] = null; } rows.push(row); } } return Table(rows, cc); }`,
  table_pivot: `function table_pivot(table, opts) { const { index, columns: colFn, values: valFn } = opts || {}; const pm = new Map(); const ac = new Set(); for (const row of table._rows) { const ik = typeof index === 'function' ? index(row) : row[index]; const col = typeof colFn === 'function' ? colFn(row) : row[colFn]; const val = typeof valFn === 'function' ? valFn(row) : row[valFn]; const ks = String(ik); if (!pm.has(ks)) pm.set(ks, { _index: ik }); pm.get(ks)[String(col)] = val; ac.add(String(col)); } return Table([...pm.values()], ['_index', ...ac]); }`,
  table_unpivot: `function table_unpivot(table, opts) { const { id, columns: uc } = opts || {}; const cn = uc.filter(c => typeof c === 'string'); const rows = []; for (const row of table._rows) { const iv = typeof id === 'function' ? id(row) : row[id]; for (const col of cn) rows.push({ id: iv, variable: col, value: row[col] }); } return Table(rows, ['id', 'variable', 'value']); }`,
  table_explode: `function table_explode(table, colFn) { const rows = []; for (const row of table._rows) { const arr = typeof colFn === 'function' ? colFn(row) : row[colFn]; if (Array.isArray(arr)) { const cn = typeof colFn === 'string' ? colFn : null; for (const val of arr) { const r = { ...row }; if (cn) r[cn] = val; rows.push(r); } } else { rows.push({ ...row }); } } return Table(rows, table._columns); }`,
  table_union: `function table_union(table, other) { return Table([...table._rows, ...other._rows], [...new Set([...table._columns, ...other._columns])]); }`,
  table_drop_duplicates: `function table_drop_duplicates(table, opts) { const by = opts && opts.by; const seen = new Set(); const rows = []; for (const row of table._rows) { const k = by ? (typeof by === 'function' ? String(by(row)) : String(row[by])) : JSON.stringify(row); if (!seen.has(k)) { seen.add(k); rows.push(row); } } return Table(rows, table._columns); }`,
  table_rename: `function table_rename(table, oldName, newName) { const cols = table._columns.map(c => c === oldName ? newName : c); const rows = table._rows.map(r => { const row = {}; for (const c of table._columns) row[c === oldName ? newName : c] = r[c]; return row; }); return Table(rows, cols); }`,

  // ── Lazy Table Query Builder ────────────────────────
  lazy: `function lazy(table) { return new LazyTable(table); }`,
  collect: `function collect(v) { if (v instanceof LazyTable) return v.collect(); if (v && v._gen) return v.collect(); return v; }`,
  LazyTable: `class LazyTable {
  constructor(source) {
    this._source = source;
    this._steps = [];
  }
  _push(step) { const lt = new LazyTable(this._source); lt._steps = [...this._steps, step]; return lt; }
  where(pred) { return this._push({ op: 'where', fn: pred }); }
  select(...args) {
    let cols;
    if (args.length === 1 && args[0] && args[0].__exclude) {
      cols = { exclude: new Set(Array.isArray(args[0].__exclude) ? args[0].__exclude : [args[0].__exclude]) };
    } else { cols = args.filter(a => typeof a === 'string'); }
    return this._push({ op: 'select', cols });
  }
  derive(derivations) { return this._push({ op: 'derive', derivations }); }
  limit(n) { return this._push({ op: 'limit', n }); }
  drop_duplicates(opts) { return this._push({ op: 'dedup', by: opts && opts.by }); }
  rename(oldName, newName) { return this._push({ op: 'rename', oldName, newName }); }
  sort_by(keyFn, opts) { return this._push({ op: 'sort', keyFn, desc: opts && opts.desc }); }
  group_by(keyFn) {
    const rows = this.collect()._rows;
    const src = Table(rows, this._resolveColumns());
    return table_group_by(src, keyFn);
  }
  _resolveColumns() {
    let cols = [...this._source._columns];
    for (const s of this._steps) {
      if (s.op === 'select') {
        cols = s.cols.exclude ? cols.filter(c => !s.cols.exclude.has(c)) : [...s.cols];
      } else if (s.op === 'derive') {
        for (const k of Object.keys(s.derivations)) { if (!cols.includes(k)) cols.push(k); }
      } else if (s.op === 'rename') {
        cols = cols.map(c => c === s.oldName ? s.newName : c);
      }
    }
    return cols;
  }
  collect() {
    let rows = this._source._rows;
    let cols = [...this._source._columns];
    for (const step of this._steps) {
      switch (step.op) {
        case 'where': rows = rows.filter(step.fn); break;
        case 'select': {
          const sc = step.cols.exclude ? cols.filter(c => !step.cols.exclude.has(c)) : step.cols;
          rows = rows.map(r => { const row = {}; for (const c of sc) row[c] = r[c]; return row; });
          cols = [...sc];
          break;
        }
        case 'derive': {
          for (const k of Object.keys(step.derivations)) { if (!cols.includes(k)) cols.push(k); }
          rows = rows.map(r => { const row = { ...r }; for (const [k, fn] of Object.entries(step.derivations)) { row[k] = typeof fn === 'function' ? fn(r) : fn; } return row; });
          break;
        }
        case 'limit': rows = rows.slice(0, step.n); break;
        case 'dedup': {
          const seen = new Set();
          const filtered = [];
          for (const row of rows) {
            const k = step.by ? (typeof step.by === 'function' ? String(step.by(row)) : String(row[step.by])) : JSON.stringify(row);
            if (!seen.has(k)) { seen.add(k); filtered.push(row); }
          }
          rows = filtered;
          break;
        }
        case 'rename': {
          cols = cols.map(c => c === step.oldName ? step.newName : c);
          rows = rows.map(r => { const row = {}; for (const c of cols) row[c === step.newName ? step.newName : c] = r[c === step.newName ? step.oldName : c]; return row; });
          break;
        }
        case 'sort': {
          rows = [...rows].sort((a, b) => {
            const ka = typeof step.keyFn === 'function' ? step.keyFn(a) : a[step.keyFn];
            const kb = typeof step.keyFn === 'function' ? step.keyFn(b) : b[step.keyFn];
            let c = ka < kb ? -1 : ka > kb ? 1 : 0;
            return step.desc ? -c : c;
          });
          break;
        }
      }
    }
    return Table(rows, cols);
  }
  toArray() { return this.collect()._rows; }
  toJSON() { return this.toArray(); }
  get rows() { return this.collect()._rows.length; }
  get columns() { return this._resolveColumns(); }
  get shape() { const t = this.collect(); return [t._rows.length, t._columns.length]; }
  toString() { return this.collect().toString(); }
  _format(maxRows, title) { return this.collect()._format(maxRows, title); }
  [Symbol.iterator]() { return this.collect()._rows[Symbol.iterator](); }
}`,

  // ── Aggregation helpers ─────────────────────────────
  agg_sum: `function agg_sum(fn) { return (rows) => rows.reduce((a, r) => a + (typeof fn === 'function' ? fn(r) : r[fn]), 0); }`,
  agg_count: `function agg_count(fn) { if (!fn) return (rows) => rows.length; return (rows) => rows.filter(fn).length; }`,
  agg_mean: `function agg_mean(fn) { return (rows) => { if (rows.length === 0) return 0; return rows.reduce((a, r) => a + (typeof fn === 'function' ? fn(r) : r[fn]), 0) / rows.length; }; }`,
  agg_median: `function agg_median(fn) { return (rows) => { if (rows.length === 0) return 0; const vs = rows.map(r => typeof fn === 'function' ? fn(r) : r[fn]).sort((a, b) => a - b); const m = Math.floor(vs.length / 2); return vs.length % 2 !== 0 ? vs[m] : (vs[m - 1] + vs[m]) / 2; }; }`,
  agg_min: `function agg_min(fn) { return (rows) => { if (rows.length === 0) return null; let m = typeof fn === 'function' ? fn(rows[0]) : rows[0][fn]; for (let i = 1; i < rows.length; i++) { const v = typeof fn === 'function' ? fn(rows[i]) : rows[i][fn]; if (v < m) m = v; } return m; }; }`,
  agg_max: `function agg_max(fn) { return (rows) => { if (rows.length === 0) return null; let m = typeof fn === 'function' ? fn(rows[0]) : rows[0][fn]; for (let i = 1; i < rows.length; i++) { const v = typeof fn === 'function' ? fn(rows[i]) : rows[i][fn]; if (v > m) m = v; } return m; }; }`,

  // ── Data exploration ────────────────────────────────
  peek: `function peek(table, opts) { const o = typeof opts === 'object' ? opts : {}; console.log(table._format ? table._format(o.n || 10, o.title) : String(table)); return table; }`,
  describe: `function describe(table) { const stats = []; for (const col of table._columns) { const vals = table._rows.map(r => r[col]).filter(v => v != null); const st = { Column: col, Type: 'Unknown', 'Non-Null': vals.length }; if (vals.length > 0) { const s = vals[0]; if (typeof s === 'number') { st.Type = Number.isInteger(s) ? 'Int' : 'Float'; st.Mean = vals.reduce((a, b) => a + b, 0) / vals.length; let mn = vals[0], mx = vals[0]; for (let i = 1; i < vals.length; i++) { if (vals[i] < mn) mn = vals[i]; if (vals[i] > mx) mx = vals[i]; } st.Min = mn; st.Max = mx; } else if (typeof s === 'string') { st.Type = 'String'; st.Unique = new Set(vals).size; } else if (typeof s === 'boolean') { st.Type = 'Bool'; } } stats.push(st); } const dt = Table(stats); console.log(dt._format(100, 'describe()')); return dt; }`,
  schema_of: `function schema_of(table) { const sc = {}; if (table._rows.length === 0) { for (const c of table._columns) sc[c] = 'Unknown'; } else { const s = table._rows[0]; for (const c of table._columns) { const v = s[c]; if (v == null) sc[c] = 'Nil'; else if (typeof v === 'number') sc[c] = Number.isInteger(v) ? 'Int' : 'Float'; else if (typeof v === 'string') sc[c] = 'String'; else if (typeof v === 'boolean') sc[c] = 'Bool'; else if (Array.isArray(v)) sc[c] = 'Array'; else sc[c] = 'Object'; } } console.log('Schema:'); for (const [c, t] of Object.entries(sc)) console.log('  ' + c + ': ' + t); return sc; }`,

  // ── Data cleaning ───────────────────────────────────
  cast: `function cast(table, colFn, targetType) { const cn = typeof colFn === 'string' ? colFn : null; const rows = table._rows.map(r => { const row = { ...r }; const k = cn; if (k && k in row) { const v = row[k]; if (targetType === 'Int') row[k] = parseInt(v, 10) || 0; else if (targetType === 'Float') row[k] = parseFloat(v) || 0; else if (targetType === 'String') row[k] = String(v); else if (targetType === 'Bool') row[k] = Boolean(v); } return row; }); return Table(rows, table._columns); }`,
  drop_nil: `function drop_nil(table, colFn) { const cn = typeof colFn === 'string' ? colFn : null; const rows = table._rows.filter(r => { const v = cn ? r[cn] : colFn(r); return v != null; }); return Table(rows, table._columns); }`,
  fill_nil: `function fill_nil(table, colFn, defaultValue) { const cn = typeof colFn === 'string' ? colFn : null; const rows = table._rows.map(r => { const row = { ...r }; if (cn && (row[cn] == null)) row[cn] = defaultValue; return row; }); return Table(rows, table._columns); }`,
  filter_ok: `function filter_ok(arr) { return arr.filter(r => r && r.__tag === 'Ok').map(r => r.value); }`,
  filter_err: `function filter_err(arr) { return arr.filter(r => r && r.__tag === 'Err').map(r => r.error); }`,

  // ── I/O functions ───────────────────────────────────
  read: `async function read(sourceOrDb, queryOrOpts, opts) {
  if (sourceOrDb && typeof sourceOrDb === 'object' && sourceOrDb.query) { const result = await sourceOrDb.query(queryOrOpts); return Table(result); }
  const source = sourceOrDb;
  if (typeof source !== 'string') throw new Error('read() expects a file path or URL string');
  const options = typeof queryOrOpts === 'object' ? queryOrOpts : (opts || {});
  if (source.startsWith('http://') || source.startsWith('https://')) {
    const response = await fetch(source);
    if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);
    const ct = response.headers.get('content-type') || '';
    if (ct.includes('json')) { const data = await response.json(); if (Array.isArray(data)) return Table(data); return data; }
    const text = await response.text();
    if (source.endsWith('.csv')) return __parseCSV(text, options);
    if (source.endsWith('.jsonl') || source.endsWith('.ndjson')) return __parseJSONL(text);
    try { const data = JSON.parse(text); if (Array.isArray(data)) return Table(data); return data; } catch { return __parseCSV(text, options); }
  }
  const fs = await import('fs'); const path = await import('path');
  const ext = path.extname(source).toLowerCase(); const text = fs.readFileSync(source, 'utf-8');
  if (ext === '.csv') return __parseCSV(text, options);
  if (ext === '.tsv') return __parseCSV(text, { ...options, delimiter: '\\t' });
  if (ext === '.json') { const data = JSON.parse(text); if (Array.isArray(data)) return Table(data); return data; }
  if (ext === '.jsonl' || ext === '.ndjson') return __parseJSONL(text);
  try { const d = JSON.parse(text); if (Array.isArray(d)) return Table(d); return d; } catch { return __parseCSV(text, options); }
}`,
  write: `async function write(data, destination, opts) {
  const fs = await import('fs'); const path = await import('path');
  const ext = path.extname(destination).toLowerCase();
  const isTable = data && data._rows && data._columns;
  const td = isTable ? data : (Array.isArray(data) ? Table(data) : null);
  let content;
  if (ext === '.csv' || ext === '.tsv') { if (!td) throw new Error('write() to CSV requires table/array data'); const delim = ext === '.tsv' ? '\\t' : ','; const cols = td._columns; const lines = [cols.join(delim)]; for (const row of td._rows) { lines.push(cols.map(c => { const v = row[c]; if (v == null) return ''; const s = String(v); return (s.includes(delim) || s.includes('"') || s.includes('\\n')) ? '"' + s.replace(/"/g, '""') + '"' : s; }).join(delim)); } content = lines.join('\\n'); }
  else if (ext === '.jsonl' || ext === '.ndjson') { if (!td) throw new Error('write() to JSONL requires table/array data'); content = td._rows.map(r => JSON.stringify(r)).join('\\n'); }
  else { content = JSON.stringify(isTable ? data._rows : data, null, 2); }
  if (opts && opts.append) fs.appendFileSync(destination, content + '\\n', 'utf-8');
  else fs.writeFileSync(destination, content, 'utf-8');
}`,

  // ── CSV/JSONL parsing helpers ───────────────────────
  __parseCSV: `function __parseCSV(text, opts) {
  const delim = (opts && opts.delimiter) || ','; const hasHeader = !opts || opts.header !== false;
  const lines = text.split('\\n').filter(l => l.trim());
  if (lines.length === 0) return Table([]);
  const parseLine = (line) => { const fields = []; let cur = ''; let inQ = false; for (let i = 0; i < line.length; i++) { const ch = line[i]; if (inQ) { if (ch === '"' && line[i+1] === '"') { cur += '"'; i++; } else if (ch === '"') { inQ = false; } else { cur += ch; } } else { if (ch === '"') inQ = true; else if (ch === delim) { fields.push(cur.trim()); cur = ''; } else { cur += ch; } } } fields.push(cur.trim()); return fields; };
  const _reInt = /^-?\\d+$/; const _reFloat = /^-?\\d*\\.\\d+$/;
  let headers, ds; if (hasHeader) { headers = parseLine(lines[0]); ds = 1; } else { const fr = parseLine(lines[0]); headers = fr.map((_, i) => 'col_' + i); ds = 0; }
  const rows = []; for (let i = ds; i < lines.length; i++) { const f = parseLine(lines[i]); const row = {}; for (let j = 0; j < headers.length; j++) { let v = f[j] ?? null; if (v !== null && v !== '') { if (_reInt.test(v)) v = parseInt(v, 10); else if (_reFloat.test(v)) v = parseFloat(v); else if (v === 'true') v = true; else if (v === 'false') v = false; else if (v === 'null' || v === 'nil') v = null; } else if (v === '') v = null; row[headers[j]] = v; } rows.push(row); }
  return Table(rows, headers);
}`,
  __parseJSONL: `function __parseJSONL(text) { return Table(text.split('\\n').filter(l => l.trim()).map(l => JSON.parse(l))); }`,

  // ── Table operation aliases (short names for pipe-friendly use) ──
  where: `function where(tableOrArr, pred) { if (tableOrArr instanceof LazyTable) return tableOrArr.where(pred); if (tableOrArr && tableOrArr._rows) return table_where(tableOrArr, pred); return tableOrArr.filter(pred); }`,
  select: `function select(table, ...args) { if (table instanceof LazyTable) return table.select(...args); return table_select(table, ...args); }`,
  derive: `function derive(table, derivations) { if (table instanceof LazyTable) return table.derive(derivations); return table_derive(table, derivations); }`,
  agg: `function agg(grouped, aggregations) { return table_agg(grouped, aggregations); }`,
  sort_by: `function sort_by(table, keyFn, opts) { if (table instanceof LazyTable) return table.sort_by(keyFn, opts); return table_sort_by(table, keyFn, opts); }`,
  limit: `function limit(table, n) { if (table instanceof LazyTable) return table.limit(n); return table_limit(table, n); }`,
  pivot: `function pivot(table, opts) { return table_pivot(table, opts); }`,
  unpivot: `function unpivot(table, opts) { return table_unpivot(table, opts); }`,
  explode: `function explode(table, colFn) { return table_explode(table, colFn); }`,
  union: `function union(a, b) { if (a && a._rows) return table_union(a, b); return [...new Set([...a, ...b])]; }`,
  drop_duplicates: `function drop_duplicates(table, opts) { if (table instanceof LazyTable) return table.drop_duplicates(opts); return table_drop_duplicates(table, opts); }`,
  rename: `function rename(table, oldName, newName) { if (table instanceof LazyTable) return table.rename(oldName, newName); return table_rename(table, oldName, newName); }`,
  mean: `function mean(v) { if (Array.isArray(v)) { return v.length === 0 ? 0 : v.reduce((a, b) => a + b, 0) / v.length; } return agg_mean(v); }`,
  median: `function median(v) { if (Array.isArray(v)) { if (v.length === 0) return null; const s = [...v].sort((a, b) => a - b); const m = Math.floor(s.length / 2); return s.length % 2 === 0 ? (s[m - 1] + s[m]) / 2 : s[m]; } return agg_median(v); }`,

  // ── Strings (new) ──────────────────────────────────────
  index_of: `function index_of(s, sub) { const i = s.indexOf(sub); return i === -1 ? null : i; }`,
  last_index_of: `function last_index_of(s, sub) { const i = s.lastIndexOf(sub); return i === -1 ? null : i; }`,
  count_of: `function count_of(s, sub) { if (!sub) return 0; let c = 0, i = 0; while ((i = s.indexOf(sub, i)) !== -1) { c++; i += sub.length; } return c; }`,
  reverse_str: `function reverse_str(s) { return [...s].reverse().join(''); }`,
  substr: `function substr(s, start, end) { return end === undefined ? s.slice(start) : s.slice(start, end); }`,
  is_empty: `function is_empty(v) { if (v == null) return true; if (typeof v === 'string' || Array.isArray(v)) return v.length === 0; if (typeof v === 'object') return Object.keys(v).length === 0; return false; }`,
  kebab_case: `function kebab_case(s) { return s.replace(/[-\\s]+/g, '-').replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase().replace(/^-/, ''); }`,
  center: `function center(s, n, fill) { if (s.length >= n) return s; const f = fill || ' '; const total = n - s.length; const left = Math.floor(total / 2); const right = total - left; return f.repeat(Math.ceil(left / f.length)).slice(0, left) + s + f.repeat(Math.ceil(right / f.length)).slice(0, right); }`,

  // ── Collections (new) ──────────────────────────────────
  zip_with: `function zip_with(a, b, fn) { const m = Math.min(a.length, b.length); const r = []; for (let i = 0; i < m; i++) r.push(fn(a[i], b[i])); return r; }`,
  frequencies: `function frequencies(arr) { const r = {}; for (const v of arr) { const k = String(v); r[k] = (r[k] || 0) + 1; } return r; }`,
  scan: `function scan(arr, fn, init) { const r = []; let acc = init; for (const v of arr) { acc = fn(acc, v); r.push(acc); } return r; }`,
  min_by: `function min_by(arr, fn) { if (arr.length === 0) return null; let best = arr[0], bestK = fn(arr[0]); for (let i = 1; i < arr.length; i++) { const k = fn(arr[i]); if (k < bestK) { best = arr[i]; bestK = k; } } return best; }`,
  max_by: `function max_by(arr, fn) { if (arr.length === 0) return null; let best = arr[0], bestK = fn(arr[0]); for (let i = 1; i < arr.length; i++) { const k = fn(arr[i]); if (k > bestK) { best = arr[i]; bestK = k; } } return best; }`,
  sum_by: `function sum_by(arr, fn) { let s = 0; for (const v of arr) s += fn(v); return s; }`,
  product: `function product(arr) { return arr.reduce((a, b) => a * b, 1); }`,
  from_entries: `function from_entries(pairs) { return Object.fromEntries(pairs); }`,
  has_key: `function has_key(obj, key) { return obj != null && Object.prototype.hasOwnProperty.call(obj, key); }`,
  get: `function get(obj, path, def) { const keys = Array.isArray(path) ? path : String(path).split('.'); let cur = obj; for (const k of keys) { if (cur == null || typeof cur !== 'object') return def !== undefined ? def : null; cur = cur[k]; } return cur !== undefined ? cur : (def !== undefined ? def : null); }`,
  pick: `function pick(obj, ks) { const r = {}; for (const k of ks) { if (k in obj) r[k] = obj[k]; } return r; }`,
  omit: `function omit(obj, ks) { const s = new Set(ks); const r = {}; for (const k of Object.keys(obj)) { if (!s.has(k)) r[k] = obj[k]; } return r; }`,
  map_values: `function map_values(obj, fn) { const r = {}; for (const [k, v] of Object.entries(obj)) r[k] = fn(v, k); return r; }`,
  sliding_window: `function sliding_window(arr, n) { if (n <= 0 || n > arr.length) return []; const r = []; for (let i = 0; i <= arr.length - n; i++) r.push(arr.slice(i, i + n)); return r; }`,

  // ── JSON (new) ─────────────────────────────────────────
  json_parse: `function json_parse(s) { try { return Ok(JSON.parse(s)); } catch (e) { return Err(e.message); } }`,
  json_stringify: `function json_stringify(v) { return JSON.stringify(v); }`,
  json_pretty: `function json_pretty(v) { return JSON.stringify(v, null, 2); }`,

  // ── Functional (new) ───────────────────────────────────
  compose: `function compose(...fns) { return (x) => fns.reduceRight((v, fn) => fn(v), x); }`,
  pipe_fn: `function pipe_fn(...fns) { return (x) => fns.reduce((v, fn) => fn(v), x); }`,
  identity: `function identity(x) { return x; }`,
  memoize: `function memoize(fn) { const cache = new Map(); return function(...args) { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn.apply(this, args); cache.set(key, result); return result; }; }`,
  debounce: `function debounce(fn, ms) { let timer; return function(...args) { clearTimeout(timer); timer = setTimeout(() => fn.apply(this, args), ms); }; }`,
  throttle: `function throttle(fn, ms) { let last = 0; return function(...args) { const now = Date.now(); if (now - last >= ms) { last = now; return fn.apply(this, args); } }; }`,
  once: `function once(fn) { let called = false, result; return function(...args) { if (!called) { called = true; result = fn.apply(this, args); } return result; }; }`,
  negate: `function negate(fn) { return function(...args) { return !fn.apply(this, args); }; }`,

  // ── Error Handling (new) ───────────────────────────────
  try_fn: `function try_fn(fn) { try { return Ok(fn()); } catch (e) { return Err(e instanceof Error ? e.message : String(e)); } }`,
  try_async: `async function try_async(fn) { try { return Ok(await fn()); } catch (e) { return Err(e instanceof Error ? e.message : String(e)); } }`,

  // ── Async (new) ────────────────────────────────────────
  parallel: `function parallel(list) { return Promise.all(list); }`,
  race: `function race(promises) { return Promise.race(promises); }`,
  timeout: `function timeout(promise, ms) { return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout after ' + ms + 'ms')), ms))]); }`,
  retry: `async function retry(fn, opts) { const o = opts || {}; const times = o.times || 3; const delay = o.delay || 100; const backoff = o.backoff || 1; let lastErr; for (let i = 0; i < times; i++) { try { return await fn(); } catch (e) { lastErr = e; if (i < times - 1) await new Promise(r => setTimeout(r, delay * Math.pow(backoff, i))); } } throw lastErr; }`,

  // ── Encoding (new) ─────────────────────────────────────
  base64_encode: `function base64_encode(s) { return typeof btoa === 'function' ? btoa(unescape(encodeURIComponent(s))) : Buffer.from(s, 'utf-8').toString('base64'); }`,
  base64_decode: `function base64_decode(s) { return typeof atob === 'function' ? decodeURIComponent(escape(atob(s))) : Buffer.from(s, 'base64').toString('utf-8'); }`,
  url_encode: `function url_encode(s) { return encodeURIComponent(s); }`,
  url_decode: `function url_decode(s) { return decodeURIComponent(s); }`,

  // ── Math (new) ─────────────────────────────────────────
  hypot: `function hypot(a, b) { return Math.hypot(a, b); }`,
  lerp: `function lerp(a, b, t) { return a + (b - a) * t; }`,
  divmod: `function divmod(a, b) { const q = Math.floor(a / b); return [q, a - q * b]; }`,
  avg: `function avg(arr) { return arr.length === 0 ? 0 : arr.reduce((a, b) => a + b, 0) / arr.length; }`,

  // ── Date/Time (new) ────────────────────────────────────
  now: `function now() { return Date.now(); }`,
  now_iso: `function now_iso() { return new Date().toISOString(); }`,
  date_parse: `function date_parse(s) { const d = new Date(s); return isNaN(d.getTime()) ? Err('Invalid date: ' + s) : Ok(d); }`,
  date_format: `function date_format(d, fmt) { if (typeof d === 'number') d = new Date(d); if (fmt === 'iso') return d.toISOString(); if (fmt === 'date') return d.toISOString().slice(0, 10); if (fmt === 'time') return d.toTimeString().slice(0, 8); if (fmt === 'datetime') return d.toISOString().slice(0, 10) + ' ' + d.toTimeString().slice(0, 8); return fmt.replace('YYYY', String(d.getFullYear())).replace('MM', String(d.getMonth() + 1).padStart(2, '0')).replace('DD', String(d.getDate()).padStart(2, '0')).replace('HH', String(d.getHours()).padStart(2, '0')).replace('mm', String(d.getMinutes()).padStart(2, '0')).replace('ss', String(d.getSeconds()).padStart(2, '0')); }`,
  date_add: `function date_add(d, amount, unit) { if (typeof d === 'number') d = new Date(d); const r = new Date(d.getTime()); if (unit === 'years') r.setFullYear(r.getFullYear() + amount); else if (unit === 'months') r.setMonth(r.getMonth() + amount); else if (unit === 'days') r.setDate(r.getDate() + amount); else if (unit === 'hours') r.setHours(r.getHours() + amount); else if (unit === 'minutes') r.setMinutes(r.getMinutes() + amount); else if (unit === 'seconds') r.setSeconds(r.getSeconds() + amount); return r; }`,
  date_diff: `function date_diff(d1, d2, unit) { if (typeof d1 === 'number') d1 = new Date(d1); if (typeof d2 === 'number') d2 = new Date(d2); const ms = d2.getTime() - d1.getTime(); if (unit === 'seconds') return Math.floor(ms / 1000); if (unit === 'minutes') return Math.floor(ms / 60000); if (unit === 'hours') return Math.floor(ms / 3600000); if (unit === 'days') return Math.floor(ms / 86400000); if (unit === 'months') return (d2.getFullYear() - d1.getFullYear()) * 12 + (d2.getMonth() - d1.getMonth()); if (unit === 'years') return d2.getFullYear() - d1.getFullYear(); return ms; }`,
  date_from: `function date_from(parts) { return new Date(parts.year || 0, (parts.month || 1) - 1, parts.day || 1, parts.hour || 0, parts.minute || 0, parts.second || 0); }`,
  date_part: `function date_part(d, part) { if (typeof d === 'number') d = new Date(d); if (part === 'year') return d.getFullYear(); if (part === 'month') return d.getMonth() + 1; if (part === 'day') return d.getDate(); if (part === 'hour') return d.getHours(); if (part === 'minute') return d.getMinutes(); if (part === 'second') return d.getSeconds(); if (part === 'weekday') return d.getDay(); return null; }`,
  time_ago: `function time_ago(d) { if (typeof d === 'number') d = new Date(d); const s = Math.floor((Date.now() - d.getTime()) / 1000); if (s < 60) return s + ' seconds ago'; const m = Math.floor(s / 60); if (m < 60) return m + (m === 1 ? ' minute ago' : ' minutes ago'); const h = Math.floor(m / 60); if (h < 24) return h + (h === 1 ? ' hour ago' : ' hours ago'); const dy = Math.floor(h / 24); if (dy < 30) return dy + (dy === 1 ? ' day ago' : ' days ago'); const mo = Math.floor(dy / 30); if (mo < 12) return mo + (mo === 1 ? ' month ago' : ' months ago'); const yr = Math.floor(mo / 12); return yr + (yr === 1 ? ' year ago' : ' years ago'); }`,

  // ── Regex (with compiled regex cache) ─────────────────
  __regex_cache: `const __reCache = new Map(); function __re(p, f) { const k = p + '\\0' + (f || ''); let r = __reCache.get(k); if (!r) { r = new RegExp(p, f); __reCache.set(k, r); if (__reCache.size > 1000) { const first = __reCache.keys().next().value; __reCache.delete(first); } } return r; }`,
  regex_test: `function regex_test(s, pattern, flags) { return __re(pattern, flags).test(s); }`,
  regex_match: `function regex_match(s, pattern, flags) { const m = s.match(__re(pattern, flags)); if (!m) return Err('No match'); return Ok({ match: m[0], index: m.index, groups: m.slice(1) }); }`,
  regex_find_all: `function regex_find_all(s, pattern, flags) { const re = __re(pattern, (flags || '') + (flags && flags.includes('g') ? '' : 'g')); const results = []; let m; re.lastIndex = 0; while ((m = re.exec(s)) !== null) { results.push({ match: m[0], index: m.index, groups: m.slice(1) }); } return results; }`,
  regex_replace: `function regex_replace(s, pattern, replacement, flags) { return s.replace(__re(pattern, flags || 'g'), replacement); }`,
  regex_split: `function regex_split(s, pattern, flags) { return s.split(__re(pattern, flags)); }`,
  regex_capture: `function regex_capture(s, pattern, flags) { const m = s.match(__re(pattern, flags)); if (!m) return Err('No match'); if (!m.groups) return Err('No named groups'); return Ok(m.groups); }`,

  // ── Validation ─────────────────────────────────────────
  is_email: `function is_email(s) { return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(s); }`,
  is_url: `function is_url(s) { try { new URL(s); return true; } catch { return false; } }`,
  is_numeric: `function is_numeric(s) { return typeof s === 'string' && s.length > 0 && !isNaN(Number(s)); }`,
  is_alpha: `function is_alpha(s) { return /^[a-zA-Z]+$/.test(s); }`,
  is_alphanumeric: `function is_alphanumeric(s) { return /^[a-zA-Z0-9]+$/.test(s); }`,
  is_uuid: `function is_uuid(s) { return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(s); }`,
  is_hex: `function is_hex(s) { return /^[0-9a-fA-F]+$/.test(s); }`,

  // ── URL & UUID ─────────────────────────────────────────
  uuid: `function uuid() { return typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0; return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16); }); }`,
  parse_url: `function parse_url(s) { try { const u = new URL(s); return Ok({ protocol: u.protocol.replace(':', ''), host: u.host, pathname: u.pathname, search: u.search, hash: u.hash }); } catch (e) { return Err('Invalid URL: ' + s); } }`,
  build_url: `function build_url(parts) { let url = (parts.protocol || 'https') + '://' + (parts.host || ''); url += parts.pathname || '/'; if (parts.search) url += (parts.search.startsWith('?') ? '' : '?') + parts.search; if (parts.hash) url += (parts.hash.startsWith('#') ? '' : '#') + parts.hash; return url; }`,
  parse_query: `function parse_query(s) { const r = {}; const qs = s.startsWith('?') ? s.slice(1) : s; if (!qs) return r; for (const pair of qs.split('&')) { const [k, ...v] = pair.split('='); r[decodeURIComponent(k)] = decodeURIComponent(v.join('=')); } return r; }`,
  build_query: `function build_query(obj) { return Object.entries(obj).map(([k, v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); }`,

  // ── Set Operations ─────────────────────────────────────
  intersection: `function intersection(a, b) { const s = new Set(b); return a.filter(x => s.has(x)); }`,
  difference: `function difference(a, b) { const s = new Set(b); return a.filter(x => !s.has(x)); }`,
  symmetric_difference: `function symmetric_difference(a, b) { const sa = new Set(a); const sb = new Set(b); return [...a.filter(x => !sb.has(x)), ...b.filter(x => !sa.has(x))]; }`,
  is_subset: `function is_subset(a, b) { const s = new Set(b); return a.every(x => s.has(x)); }`,
  is_superset: `function is_superset(a, b) { const s = new Set(a); return b.every(x => s.has(x)); }`,

  // ── Statistics ─────────────────────────────────────────
  mode: `function mode(arr) { if (arr.length === 0) return null; const freq = {}; let maxF = 0, result = arr[0]; for (const v of arr) { const k = String(v); freq[k] = (freq[k] || 0) + 1; if (freq[k] > maxF) { maxF = freq[k]; result = v; } } return result; }`,
  stdev: `function stdev(arr) { if (arr.length === 0) return 0; const m = arr.reduce((a, b) => a + b, 0) / arr.length; return Math.sqrt(arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length); }`,
  variance: `function variance(arr) { if (arr.length === 0) return 0; const m = arr.reduce((a, b) => a + b, 0) / arr.length; return arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length; }`,
  percentile: `function percentile(arr, p) { if (arr.length === 0) return null; const s = [...arr].sort((a, b) => a - b); const i = (p / 100) * (s.length - 1); const lo = Math.floor(i); const hi = Math.ceil(i); if (lo === hi) return s[lo]; return s[lo] + (s[hi] - s[lo]) * (i - lo); }`,

  // ── Text Utilities ─────────────────────────────────────
  truncate: `function truncate(s, n, suffix) { const sf = suffix !== undefined ? suffix : '...'; return s.length <= n ? s : s.slice(0, n - sf.length) + sf; }`,
  word_wrap: `function word_wrap(s, width) { const ws = s.split(' '); const lines = []; let line = ''; for (const w of ws) { if (line && (line.length + 1 + w.length) > width) { lines.push(line); line = w; } else { line = line ? line + ' ' + w : w; } } if (line) lines.push(line); return lines.join('\\n'); }`,
  dedent: `function dedent(s) { const lines = s.split('\\n'); const nonEmpty = lines.filter(l => l.trim().length > 0); if (nonEmpty.length === 0) return s; const indent = Math.min(...nonEmpty.map(l => l.match(/^(\\s*)/)[1].length)); return lines.map(l => l.slice(indent)).join('\\n'); }`,
  indent_str: `function indent_str(s, n, ch) { const prefix = (ch || ' ').repeat(n); return s.split('\\n').map(l => prefix + l).join('\\n'); }`,
  slugify: `function slugify(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, ''); }`,
  escape_html: `function escape_html(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }`,
  unescape_html: `function unescape_html(s) { return s.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'"); }`,

  // ── Number Formatting ──────────────────────────────────
  format_number: `function format_number(n, opts) { const o = opts || {}; const sep = o.separator || ','; const dec = o.decimals; let s = dec !== undefined ? n.toFixed(dec) : String(n); const parts = s.split('.'); parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, sep); return parts.join('.'); }`,
  to_hex: `function to_hex(n) { return Math.trunc(n).toString(16); }`,
  to_binary: `function to_binary(n) { return Math.trunc(n).toString(2); }`,
  to_octal: `function to_octal(n) { return Math.trunc(n).toString(8); }`,
  to_fixed: `function to_fixed(n, decimals) { return Number(n.toFixed(decimals)); }`,

  // ── Itertools ──────────────────────────────────────────
  pairwise: `function pairwise(arr) { const r = []; for (let i = 0; i < arr.length - 1; i++) r.push([arr[i], arr[i + 1]]); return r; }`,
  combinations: `function combinations(arr, r) { const result = []; const combo = []; function gen(start, depth) { if (depth === r) { result.push([...combo]); return; } for (let i = start; i < arr.length; i++) { combo.push(arr[i]); gen(i + 1, depth + 1); combo.pop(); } } gen(0, 0); return result; }`,
  permutations: `function permutations(arr, r) { const n = r === undefined ? arr.length : r; const result = []; const perm = []; const used = new Array(arr.length).fill(false); function gen() { if (perm.length === n) { result.push([...perm]); return; } for (let i = 0; i < arr.length; i++) { if (!used[i]) { used[i] = true; perm.push(arr[i]); gen(); perm.pop(); used[i] = false; } } } gen(); return result; }`,
  intersperse: `function intersperse(arr, sep) { if (arr.length <= 1) return [...arr]; const r = [arr[0]]; for (let i = 1; i < arr.length; i++) { r.push(sep, arr[i]); } return r; }`,
  interleave: `function interleave(...arrs) { if (arrs.length === 0) return []; const m = Math.max(...arrs.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) { for (const a of arrs) { if (i < a.length) r.push(a[i]); } } return r; }`,
  repeat_value: `function repeat_value(val, n) { return Array(n).fill(val); }`,

  // ── Array Utilities ────────────────────────────────────
  binary_search: `function binary_search(arr, target, keyFn) { let lo = 0, hi = arr.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; const val = keyFn ? keyFn(arr[mid]) : arr[mid]; if (val === target) return mid; if (val < target) lo = mid + 1; else hi = mid - 1; } return -1; }`,
  is_sorted: `function is_sorted(arr, keyFn) { for (let i = 1; i < arr.length; i++) { const a = keyFn ? keyFn(arr[i - 1]) : arr[i - 1]; const b = keyFn ? keyFn(arr[i]) : arr[i]; if (a > b) return false; } return true; }`,
  compact: `function compact(arr) { return arr.filter(v => v != null); }`,
  rotate: `function rotate(arr, n) { if (arr.length === 0) return []; const k = ((n % arr.length) + arr.length) % arr.length; return [...arr.slice(k), ...arr.slice(0, k)]; }`,
  insert_at: `function insert_at(arr, idx, val) { const r = [...arr]; r.splice(idx, 0, val); return r; }`,
  remove_at: `function remove_at(arr, idx) { const r = [...arr]; r.splice(idx, 1); return r; }`,
  update_at: `function update_at(arr, idx, val) { const r = [...arr]; r[idx] = val; return r; }`,

  // ── Functional (extended) ──────────────────────────────
  partial: `function partial(fn, ...bound) { return function(...args) { return fn(...bound, ...args); }; }`,
  curry: `function curry(fn, arity) { const n = arity || fn.length; return function curried(...args) { if (args.length >= n) return fn(...args); return function(...more) { return curried(...args, ...more); }; }; }`,
  flip: `function flip(fn) { return function(a, b, ...rest) { return fn(b, a, ...rest); }; }`,

  // ── Encoding (extended) ────────────────────────────────
  hex_encode: `function hex_encode(s) { let r = ''; for (let i = 0; i < s.length; i++) r += s.charCodeAt(i).toString(16).padStart(2, '0'); return r; }`,
  hex_decode: `function hex_decode(s) { let r = ''; for (let i = 0; i < s.length; i += 2) r += String.fromCharCode(parseInt(s.substr(i, 2), 16)); return r; }`,

  // ── String (extended) ──────────────────────────────────
  fmt: `function fmt(template, ...args) { let i = 0; return template.replace(/\\{\\}/g, () => i < args.length ? String(args[i++]) : '{}'); }`,

  // ── Scripting: Environment & CLI ──────────────────────
  env: `function env(key, fallback) { if (key === undefined) return { ...process.env }; const v = process.env[key]; return v !== undefined ? v : (fallback !== undefined ? fallback : null); }`,
  set_env: `function set_env(key, value) { process.env[key] = String(value); }`,
  args: `function args() { return typeof __tova_args !== 'undefined' ? __tova_args : process.argv.slice(2); }`,
  exit: `function exit(code) { process.exit(code !== undefined ? code : 0); }`,

  // ── Scripting: Filesystem ─────────────────────────────
  exists: `function exists(path) { const fs = require('fs'); return fs.existsSync(path); }`,
  is_dir: `function is_dir(path) { try { return require('fs').statSync(path).isDirectory(); } catch { return false; } }`,
  is_file: `function is_file(path) { try { return require('fs').statSync(path).isFile(); } catch { return false; } }`,
  ls: `function ls(dir, opts) { const fs = require('fs'); const p = require('path'); const d = dir || '.'; const entries = fs.readdirSync(d); if (opts && opts.full) return entries.map(e => p.join(d, e)); return entries; }`,
  glob_files: `function glob_files(pattern, opts) { if (typeof Bun !== 'undefined' && Bun.Glob) { const glob = new Bun.Glob(pattern); const results = [...glob.scanSync(opts && opts.cwd || '.')]; return results; } const fs = require('fs'); if (fs.globSync) return fs.globSync(pattern, opts); return []; }`,
  mkdir: `function mkdir(dir) { try { require('fs').mkdirSync(dir, { recursive: true }); return Ok(dir); } catch (e) { return Err(e.message); } }`,
  rm: `function rm(path, opts) { try { require('fs').rmSync(path, { recursive: !!(opts && opts.recursive), force: !!(opts && opts.force) }); return Ok(path); } catch (e) { return Err(e.message); } }`,
  cp: `function cp(src, dest, opts) { try { const fs = require('fs'); if (opts && opts.recursive) { fs.cpSync(src, dest, { recursive: true }); } else { fs.copyFileSync(src, dest); } return Ok(dest); } catch (e) { return Err(e.message); } }`,
  mv: `function mv(src, dest) { try { require('fs').renameSync(src, dest); return Ok(dest); } catch (e) { return Err(e.message); } }`,
  cwd: `function cwd() { return process.cwd(); }`,
  chdir: `function chdir(dir) { try { process.chdir(dir); return Ok(dir); } catch (e) { return Err(e.message); } }`,
  read_text: `function read_text(path, enc) { try { return Ok(require('fs').readFileSync(path, enc || 'utf-8')); } catch (e) { return Err(e.message); } }`,
  read_bytes: `function read_bytes(path) { try { return Ok(require('fs').readFileSync(path)); } catch (e) { return Err(e.message); } }`,
  write_text: `function write_text(path, content, opts) { try { const fs = require('fs'); if (opts && opts.append) fs.appendFileSync(path, content); else fs.writeFileSync(path, content); return Ok(path); } catch (e) { return Err(e.message); } }`,

  // ── Scripting: Shell ──────────────────────────────────
  // sh() uses shell:true for convenience (pipes, redirects). For trusted commands only.
  // exec() uses shell:false — safe from injection by default (array args).
  sh: `function sh(cmd, opts) { try { const cp = require('child_process'); const o = opts || {}; const result = cp.spawnSync(cmd, { shell: true, cwd: o.cwd, env: o.env ? { ...process.env, ...o.env } : undefined, timeout: o.timeout, stdio: o.inherit ? 'inherit' : 'pipe', encoding: 'utf-8' }); if (result.error) return Err(result.error.message); return Ok({ stdout: (result.stdout || '').trimEnd(), stderr: (result.stderr || '').trimEnd(), exitCode: result.status }); } catch (e) { return Err(e.message); } }`,
  exec: `function exec(cmd, cmdArgs, opts) { try { const cp = require('child_process'); if (cmdArgs && typeof cmdArgs === 'object' && !Array.isArray(cmdArgs)) { opts = cmdArgs; cmdArgs = []; } const o = opts || {}; const a = cmdArgs || []; const result = cp.spawnSync(cmd, a, { shell: false, cwd: o.cwd, env: o.env ? { ...process.env, ...o.env } : undefined, timeout: o.timeout, stdio: o.inherit ? 'inherit' : 'pipe', encoding: 'utf-8' }); if (result.error) return Err(result.error.message); return Ok({ stdout: (result.stdout || '').trimEnd(), stderr: (result.stderr || '').trimEnd(), exitCode: result.status }); } catch (e) { return Err(e.message); } }`,

  // ── Scripting: stdin ─────────────────────────────────
  read_stdin: `function read_stdin() { try { return require('fs').readFileSync(0, 'utf-8'); } catch { return ''; } }`,
  read_lines: `function read_lines() { try { return require('fs').readFileSync(0, 'utf-8').split('\\n').filter(l => l.length > 0); } catch { return []; } }`,

  // ── Scripting: Script path ──────────────────────────
  script_path: `function script_path() { return typeof __tova_filename !== 'undefined' ? __tova_filename : null; }`,
  script_dir: `function script_dir() { return typeof __tova_dirname !== 'undefined' ? __tova_dirname : null; }`,

  // ── Scripting: Argument parsing ──────────────────────
  parse_args: `function parse_args(argv) { const flags = {}; const positional = []; let i = 0; while (i < argv.length) { const arg = argv[i]; if (arg === '--') { positional.push(...argv.slice(i + 1)); break; } if (arg.startsWith('--')) { const eq = arg.indexOf('='); if (eq !== -1) { flags[arg.slice(2, eq)] = arg.slice(eq + 1); } else if (i + 1 < argv.length && !argv[i + 1].startsWith('-')) { flags[arg.slice(2)] = argv[i + 1]; i++; } else { flags[arg.slice(2)] = true; } } else if (arg.startsWith('-') && arg.length > 1) { for (let j = 1; j < arg.length; j++) flags[arg[j]] = true; } else { positional.push(arg); } i++; } return { flags, positional }; }`,

  // ── Lazy Iterators / Sequences ──────────────────────
  iter: `function iter(source) { return new Seq(function*() { for (const x of source) yield x; }); }`,
  Seq: `class Seq {
  constructor(gen) { this._gen = gen; }
  filter(fn) { const g = this._gen; return new Seq(function*() { for (const x of g()) if (fn(x)) yield x; }); }
  map(fn) { const g = this._gen; return new Seq(function*() { for (const x of g()) yield fn(x); }); }
  take(n) { const g = this._gen; return new Seq(function*() { let i = 0; for (const x of g()) { if (i++ >= n) return; yield x; } }); }
  drop(n) { const g = this._gen; return new Seq(function*() { let i = 0; for (const x of g()) { if (i++ < n) continue; yield x; } }); }
  zip(other) { const g1 = this._gen; const g2 = other._gen; return new Seq(function*() { const i1 = g1(), i2 = g2(); while (true) { const a = i1.next(), b = i2.next(); if (a.done || b.done) return; yield [a.value, b.value]; } }); }
  flat_map(fn) { const g = this._gen; return new Seq(function*() { for (const x of g()) { const result = fn(x); if (result && result._gen) { for (const y of result._gen()) yield y; } else if (result && result[Symbol.iterator]) { for (const y of result) yield y; } else { yield result; } } }); }
  enumerate() { const g = this._gen; return new Seq(function*() { let i = 0; for (const x of g()) yield [i++, x]; }); }
  collect() { return [...this._gen()]; }
  toArray() { return this.collect(); }
  reduce(fn, init) { let acc = init; for (const x of this._gen()) acc = fn(acc, x); return acc; }
  first() { for (const x of this._gen()) return Some(x); return None; }
  count() { let n = 0; for (const x of this._gen()) n++; return n; }
  forEach(fn) { for (const x of this._gen()) fn(x); }
  any(fn) { for (const x of this._gen()) if (fn(x)) return true; return false; }
  all(fn) { for (const x of this._gen()) if (!fn(x)) return false; return true; }
  find(fn) { for (const x of this._gen()) if (fn(x)) return Some(x); return None; }
  [Symbol.iterator]() { return this._gen(); }
}`,

  // ── Scripting: Terminal colors ──────────────────────
  color: `function color(text, name) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); const codes = { red: '31', green: '32', yellow: '33', blue: '34', magenta: '35', cyan: '36', white: '37', gray: '90' }; const c = codes[name]; return c ? '\\x1b[' + c + 'm' + text + '\\x1b[0m' : String(text); }`,
  bold: `function bold(text) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); return '\\x1b[1m' + text + '\\x1b[0m'; }`,
  dim: `function dim(text) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); return '\\x1b[2m' + text + '\\x1b[0m'; }`,

  // ── Scripting: Color shortcuts ────────────────────────
  green: `function green(text) { return color(text, 'green'); }`,
  red: `function red(text) { return color(text, 'red'); }`,
  yellow: `function yellow(text) { return color(text, 'yellow'); }`,
  blue: `function blue(text) { return color(text, 'blue'); }`,
  cyan: `function cyan(text) { return color(text, 'cyan'); }`,
  magenta: `function magenta(text) { return color(text, 'magenta'); }`,
  gray: `function gray(text) { return color(text, 'gray'); }`,
  underline: `function underline(text) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); return '\\x1b[4m' + text + '\\x1b[0m'; }`,
  strikethrough: `function strikethrough(text) { if (typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY))) return String(text); return '\\x1b[9m' + text + '\\x1b[0m'; }`,

  // ── Scripting: Rich output ────────────────────────────
  table: `function table(data, opts) {
  if (!data || data.length === 0) { console.log("(empty)"); return; }
  const o = opts || {};
  const headers = o.headers || Object.keys(data[0]);
  const rows = data.map(function(row) { return headers.map(function(h) { return String(row[h] != null ? row[h] : ''); }); });
  const widths = headers.map(function(h, i) {
    return Math.max(h.length, ...rows.map(function(r) { return r[i].length; }));
  });
  const noColor = typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY));
  const b = function(t) { return noColor ? t : '\\x1b[1m' + t + '\\x1b[0m'; };
  const line = widths.map(function(w) { return '-'.repeat(w + 2); }).join('+');
  console.log(b(headers.map(function(h, i) { return ' ' + h.padEnd(widths[i]) + ' '; }).join('|')));
  console.log(line);
  rows.forEach(function(r) { console.log(r.map(function(c, i) { return ' ' + c.padEnd(widths[i]) + ' '; }).join('|')); });
}`,

  panel: `function panel(title, content) {
  var lines = String(content).split('\\n');
  var maxLen = Math.max(title ? title.length + 2 : 0, ...lines.map(function(l) { return l.length; }));
  var noColor = typeof process !== 'undefined' && (process.env.NO_COLOR || (process.stdout && !process.stdout.isTTY));
  var b = function(t) { return noColor ? t : '\\x1b[1m' + t + '\\x1b[0m'; };
  var top = '\\u250c' + (title ? '\\u2500 ' + b(title) + ' ' + '\\u2500'.repeat(Math.max(0, maxLen - title.length - 2)) : '\\u2500'.repeat(maxLen + 2)) + '\\u2510';
  var bot = '\\u2514' + '\\u2500'.repeat(maxLen + 2) + '\\u2518';
  var body = lines.map(function(l) { return '\\u2502 ' + l.padEnd(maxLen) + ' \\u2502'; }).join('\\n');
  console.log(top + '\\n' + body + '\\n' + bot);
}`,

  progress: `function progress(items, opts) {
  var o = opts || {};
  var total = items.length || o.total || 0;
  var label = o.label || '';
  var width = o.width || 30;
  var isTTY = typeof process !== 'undefined' && process.stderr && process.stderr.isTTY;
  var idx = 0;
  return { [Symbol.iterator]() {
    var it = items[Symbol.iterator]();
    return { next() {
      var r = it.next();
      if (!r.done) {
        idx++;
        if (isTTY) {
          var pct = Math.round(idx / total * 100);
          var filled = Math.round(idx / total * width);
          var bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(width - filled);
          process.stderr.write('\\r' + label + ' [' + bar + '] ' + pct + '% ' + idx + '/' + total);
        }
      } else if (isTTY) {
        process.stderr.write('\\r' + ' '.repeat(width + label.length + 20) + '\\r');
      }
      return r;
    }};
  }};
}`,

  spin: `async function spin(label, fn) {
  var frames = ['\\u2838','\\u2834','\\u2826','\\u2823','\\u2831','\\u2839'];
  var isTTY = typeof process !== 'undefined' && process.stderr && process.stderr.isTTY;
  var i = 0;
  var iv = isTTY ? setInterval(function() { process.stderr.write('\\r' + frames[i++ % frames.length] + ' ' + label); }, 80) : null;
  try {
    var result = await fn();
    if (iv) clearInterval(iv);
    if (isTTY) process.stderr.write('\\r\\u2714 ' + label + '\\n');
    return result;
  } catch (e) {
    if (iv) clearInterval(iv);
    if (isTTY) process.stderr.write('\\r\\u2718 ' + label + '\\n');
    throw e;
  }
}`,

  // ── Scripting: Interactive prompts ─────────────────────
  ask: `async function ask(prompt, opts) {
  var o = opts || {};
  var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
  var suffix = o.default ? ' (' + o.default + ')' : '';
  return new Promise(function(resolve) {
    rl.question(prompt + suffix + ' ', function(answer) {
      rl.close();
      resolve(answer || o.default || '');
    });
  });
}`,

  confirm: `async function confirm(prompt, opts) {
  var o = opts || {};
  var def = o.default !== undefined ? o.default : true;
  var hint = def ? '[Y/n]' : '[y/N]';
  var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(function(resolve) {
    rl.question(prompt + ' ' + hint + ' ', function(answer) {
      rl.close();
      if (!answer) { resolve(def); return; }
      resolve(answer.toLowerCase().startsWith('y'));
    });
  });
}`,

  choose: `async function choose(prompt, options) {
  console.log(prompt);
  for (var i = 0; i < options.length; i++) console.log('  ' + (i + 1) + '. ' + options[i]);
  var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(function(resolve) {
    rl.question('Select [1-' + options.length + ']: ', function(answer) {
      rl.close();
      var idx = parseInt(answer, 10) - 1;
      resolve(idx >= 0 && idx < options.length ? options[idx] : options[0]);
    });
  });
}`,

  choose_many: `async function choose_many(prompt, options) {
  console.log(prompt);
  for (var i = 0; i < options.length; i++) console.log('  ' + (i + 1) + '. ' + options[i]);
  var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(function(resolve) {
    rl.question('Select (comma-separated): ', function(answer) {
      rl.close();
      var indices = answer.split(',').map(function(s) { return parseInt(s.trim(), 10) - 1; });
      resolve(indices.filter(function(i) { return i >= 0 && i < options.length; }).map(function(i) { return options[i]; }));
    });
  });
}`,

  secret: `async function secret(prompt) {
  var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(function(resolve) {
    if (process.stdin.isTTY) {
      process.stdout.write(prompt + ' ');
      process.stdin.setRawMode(true);
      process.stdin.resume();
      var buf = '';
      var onData = function(ch) {
        ch = ch.toString();
        if (ch === '\\n' || ch === '\\r' || ch === '\\u0004') {
          process.stdin.setRawMode(false);
          process.stdin.pause();
          process.stdin.removeListener('data', onData);
          process.stdout.write('\\n');
          rl.close();
          resolve(buf);
        } else if (ch === '\\u007f' || ch === '\\b') {
          if (buf.length > 0) { buf = buf.slice(0, -1); process.stdout.write('\\b \\b'); }
        } else {
          buf += ch;
          process.stdout.write('*');
        }
      };
      process.stdin.on('data', onData);
    } else {
      rl.question(prompt + ' ', function(answer) { rl.close(); resolve(answer); });
    }
  });
}`,

  // ── Scripting: Signal handling ────────────────────────
  on_signal: `function on_signal(name, callback) { process.on(name, callback); }`,

  // ── Scripting: File stat ──────────────────────────────
  file_stat: `function file_stat(path) { try { const s = require('fs').statSync(path); return Ok({ size: s.size, mode: s.mode, mtime: s.mtime.toISOString(), atime: s.atime.toISOString(), isDir: s.isDirectory(), isFile: s.isFile(), isSymlink: s.isSymbolicLink() }); } catch (e) { return Err(e.message); } }`,
  file_size: `function file_size(path) { try { return Ok(require('fs').statSync(path).size); } catch (e) { return Err(e.message); } }`,

  // ── Scripting: Path utilities ─────────────────────────
  path_join: `function path_join(...parts) { return require('path').join(...parts); }`,
  path_dirname: `function path_dirname(p) { return require('path').dirname(p); }`,
  path_basename: `function path_basename(p, ext) { return ext ? require('path').basename(p, ext) : require('path').basename(p); }`,
  path_resolve: `function path_resolve(p) { return require('path').resolve(p); }`,
  path_ext: `function path_ext(p) { return require('path').extname(p); }`,
  path_relative: `function path_relative(from, to) { return require('path').relative(from, to); }`,

  // ── Scripting: Symlinks ───────────────────────────────
  symlink: `function symlink(target, path) { try { require('fs').symlinkSync(target, path); return Ok(null); } catch (e) { return Err(e.message); } }`,
  readlink: `function readlink(path) { try { return Ok(require('fs').readlinkSync(path)); } catch (e) { return Err(e.message); } }`,
  is_symlink: `function is_symlink(path) { try { return require('fs').lstatSync(path).isSymbolicLink(); } catch { return false; } }`,

  // ── Scripting: Async shell ────────────────────────────
  spawn: `function spawn(cmd, cmdArgs, opts) { if (cmdArgs && typeof cmdArgs === 'object' && !Array.isArray(cmdArgs)) { opts = cmdArgs; cmdArgs = []; } const o = opts || {}; const a = cmdArgs || []; return new Promise(function(resolve) { try { const cp = require('child_process'); const child = cp.spawn(cmd, a, { shell: !!o.shell, cwd: o.cwd, env: o.env ? Object.assign({}, process.env, o.env) : undefined, stdio: 'pipe' }); let stdout = ''; let stderr = ''; child.stdout.on('data', function(d) { stdout += d; }); child.stderr.on('data', function(d) { stderr += d; }); child.on('error', function(e) { resolve(Err(e.message)); }); child.on('close', function(code) { resolve(Ok({ stdout: stdout.trimEnd(), stderr: stderr.trimEnd(), exitCode: code })); }); } catch (e) { resolve(Err(e.message)); } }); }`,

  // ── Ordering type ─────────────────────────────────────
  Less: `const Less = Object.freeze({ __tag: "Less", value: -1 });`,
  Equal: `const Equal = Object.freeze({ __tag: "Equal", value: 0 });`,
  Greater: `const Greater = Object.freeze({ __tag: "Greater", value: 1 });`,
  compare: `function compare(a, b) { if (a < b) return Less; if (a > b) return Greater; return Equal; }`,
  compare_by: `function compare_by(arr, fn) { return [...arr].sort(function(a, b) { const ord = fn(a, b); return ord.value; }); }`,

  // ── Regex Builder ─────────────────────────────────────
  RegexBuilder: `class RegexBuilder {
  constructor() { this._parts = []; this._flags = ''; }
  literal(s) { this._parts.push(s.replace(/[.*+?^\${}()|[\\]\\\\]/g, '\\\\$&')); return this; }
  digits(n) { this._parts.push(n ? '\\\\d{' + n + '}' : '\\\\d+'); return this; }
  word() { this._parts.push('\\\\w+'); return this; }
  space() { this._parts.push('\\\\s+'); return this; }
  any() { this._parts.push('.'); return this; }
  oneOf(chars) { this._parts.push('[' + chars.replace(/[\\]\\\\]/g, '\\\\$&') + ']'); return this; }
  group(name) { this._parts.push(name ? '(?<' + name + '>' : '('); return this; }
  endGroup() { this._parts.push(')'); return this; }
  optional() { this._parts.push('?'); return this; }
  oneOrMore() { this._parts.push('+'); return this; }
  zeroOrMore() { this._parts.push('*'); return this; }
  startOfLine() { this._parts.push('^'); return this; }
  endOfLine() { this._parts.push('$'); return this; }
  flags(f) { this._flags = f; return this; }
  build() { return new RegExp(this._parts.join(''), this._flags); }
  test(s) { return this.build().test(s); }
  match(s) { return s.match(this.build()); }
}`,
  regex_builder: `function regex_builder() { return new RegexBuilder(); }`,

  // ── Namespace modules ──────────────────────────────────
  math: `const math = Object.freeze({
  sin(n) { return Math.sin(n); },
  cos(n) { return Math.cos(n); },
  tan(n) { return Math.tan(n); },
  asin(n) { return Math.asin(n); },
  acos(n) { return Math.acos(n); },
  atan(n) { return Math.atan(n); },
  atan2(y, x) { return Math.atan2(y, x); },
  log(n) { return Math.log(n); },
  log2(n) { return Math.log2(n); },
  log10(n) { return Math.log10(n); },
  exp(n) { return Math.exp(n); },
  abs(n) { return Math.abs(n); },
  floor(n) { return Math.floor(n); },
  ceil(n) { return Math.ceil(n); },
  round(n) { return Math.round(n); },
  sqrt(n) { return Math.sqrt(n); },
  pow(b, e) { return Math.pow(b, e); },
  clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); },
  random() { return Math.random(); },
  sign(n) { return Math.sign(n); },
  trunc(n) { return Math.trunc(n); },
  hypot(a, b) { return Math.hypot(a, b); },
  lerp(a, b, t) { return a + (b - a) * t; },
  gcd(a, b) { a = Math.abs(a); b = Math.abs(b); while (b) { [a, b] = [b, a % b]; } return a; },
  lcm(a, b) { if (a === 0 && b === 0) return 0; let x = Math.abs(a), y = Math.abs(b); while (y) { const t = y; y = x % y; x = t; } return Math.abs(a * b) / x; },
  factorial(n) { if (n < 0) return null; if (n <= 1) return 1; let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; },
  PI: Math.PI,
  E: Math.E,
  INF: Infinity
});`,

  str: `const str = Object.freeze({
  upper(s) { return s.toUpperCase(); },
  lower(s) { return s.toLowerCase(); },
  trim(s) { return s.trim(); },
  trim_start(s) { return s.trimStart(); },
  trim_end(s) { return s.trimEnd(); },
  split(s, sep) { return s.split(sep); },
  join(arr, sep) { return arr.join(sep); },
  replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); },
  repeat(s, n) { return s.repeat(n); },
  contains(s, sub) { return s.includes(sub); },
  starts_with(s, prefix) { return s.startsWith(prefix); },
  ends_with(s, suffix) { return s.endsWith(suffix); },
  chars(s) { return [...s]; },
  words(s) { return s.split(/\\s+/).filter(Boolean); },
  lines(s) { return s.split('\\n'); },
  capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; },
  title_case(s) { return s.replace(/\\b\\w/g, c => c.toUpperCase()); },
  snake_case(s) { return s.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },
  camel_case(s) { return s.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },
  kebab_case(s) { return s.replace(/[-\\s]+/g, '-').replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase().replace(/^-/, ''); },
  index_of(s, sub) { const i = s.indexOf(sub); return i === -1 ? null : i; },
  last_index_of(s, sub) { const i = s.lastIndexOf(sub); return i === -1 ? null : i; },
  pad_start(s, n, fill) { return s.padStart(n, fill || ' '); },
  pad_end(s, n, fill) { return s.padEnd(n, fill || ' '); },
  center(s, n, fill) { if (s.length >= n) return s; const f = fill || ' '; const total = n - s.length; const left = Math.floor(total / 2); const right = total - left; return f.repeat(Math.ceil(left / f.length)).slice(0, left) + s + f.repeat(Math.ceil(right / f.length)).slice(0, right); },
  slugify(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, ''); },
  escape_html(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); },
  unescape_html(s) { return s.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'"); }
});`,

  arr: `const arr = Object.freeze({
  sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; },
  reversed(a) { return [...a].reverse(); },
  unique(a) { return [...new Set(a)]; },
  chunk(a, n) { const r = []; for (let i = 0; i < a.length; i += n) r.push(a.slice(i, i + n)); return r; },
  flatten(a) { return a.flat(); },
  take(a, n) { return a.slice(0, n); },
  drop(a, n) { return a.slice(n); },
  first(a) { return a.length > 0 ? a[0] : null; },
  last(a) { return a.length > 0 ? a[a.length - 1] : null; },
  count(a, fn) { return a.filter(fn).length; },
  partition(a, fn) { const y = [], n = []; for (const v of a) { (fn(v) ? y : n).push(v); } return [y, n]; },
  group_by(a, fn) { const r = {}; for (const v of a) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; },
  zip_with(a, b, fn) { const m = Math.min(a.length, b.length); const r = []; for (let i = 0; i < m; i++) r.push(fn ? fn(a[i], b[i]) : [a[i], b[i]]); return r; },
  frequencies(a) { const r = {}; for (const v of a) { const k = String(v); r[k] = (r[k] || 0) + 1; } return r; },
  scan(a, fn, init) { const r = []; let acc = init; for (const v of a) { acc = fn(acc, v); r.push(acc); } return r; },
  min_by(a, fn) { if (a.length === 0) return null; let best = a[0], bestK = fn(a[0]); for (let i = 1; i < a.length; i++) { const k = fn(a[i]); if (k < bestK) { best = a[i]; bestK = k; } } return best; },
  max_by(a, fn) { if (a.length === 0) return null; let best = a[0], bestK = fn(a[0]); for (let i = 1; i < a.length; i++) { const k = fn(a[i]); if (k > bestK) { best = a[i]; bestK = k; } } return best; },
  sum_by(a, fn) { let s = 0; for (const v of a) s += fn(v); return s; },
  compact(a) { return a.filter(v => v != null); },
  rotate(a, n) { if (a.length === 0) return []; const k = ((n % a.length) + a.length) % a.length; return [...a.slice(k), ...a.slice(0, k)]; },
  insert_at(a, idx, val) { const r = [...a]; r.splice(idx, 0, val); return r; },
  remove_at(a, idx) { const r = [...a]; r.splice(idx, 1); return r; },
  binary_search(a, target, keyFn) { let lo = 0, hi = a.length - 1; while (lo <= hi) { const mid = (lo + hi) >> 1; const val = keyFn ? keyFn(a[mid]) : a[mid]; if (val === target) return mid; if (val < target) lo = mid + 1; else hi = mid - 1; } return -1; },
  is_sorted(a, keyFn) { for (let i = 1; i < a.length; i++) { const x = keyFn ? keyFn(a[i - 1]) : a[i - 1]; const y = keyFn ? keyFn(a[i]) : a[i]; if (x > y) return false; } return true; }
});`,

  dt: `const dt = Object.freeze({
  now() { return Date.now(); },
  now_iso() { return new Date().toISOString(); },
  parse(s) { const d = new Date(s); return isNaN(d.getTime()) ? Err('Invalid date: ' + s) : Ok(d); },
  format(d, fmt) { if (typeof d === 'number') d = new Date(d); if (fmt === 'iso') return d.toISOString(); if (fmt === 'date') return d.toISOString().slice(0, 10); if (fmt === 'time') return d.toTimeString().slice(0, 8); if (fmt === 'datetime') return d.toISOString().slice(0, 10) + ' ' + d.toTimeString().slice(0, 8); return fmt.replace('YYYY', String(d.getFullYear())).replace('MM', String(d.getMonth() + 1).padStart(2, '0')).replace('DD', String(d.getDate()).padStart(2, '0')).replace('HH', String(d.getHours()).padStart(2, '0')).replace('mm', String(d.getMinutes()).padStart(2, '0')).replace('ss', String(d.getSeconds()).padStart(2, '0')); },
  add(d, amount, unit) { if (typeof d === 'number') d = new Date(d); const r = new Date(d.getTime()); if (unit === 'years') r.setFullYear(r.getFullYear() + amount); else if (unit === 'months') r.setMonth(r.getMonth() + amount); else if (unit === 'days') r.setDate(r.getDate() + amount); else if (unit === 'hours') r.setHours(r.getHours() + amount); else if (unit === 'minutes') r.setMinutes(r.getMinutes() + amount); else if (unit === 'seconds') r.setSeconds(r.getSeconds() + amount); return r; },
  diff(d1, d2, unit) { if (typeof d1 === 'number') d1 = new Date(d1); if (typeof d2 === 'number') d2 = new Date(d2); const ms = d2.getTime() - d1.getTime(); if (unit === 'seconds') return Math.floor(ms / 1000); if (unit === 'minutes') return Math.floor(ms / 60000); if (unit === 'hours') return Math.floor(ms / 3600000); if (unit === 'days') return Math.floor(ms / 86400000); if (unit === 'months') return (d2.getFullYear() - d1.getFullYear()) * 12 + (d2.getMonth() - d1.getMonth()); if (unit === 'years') return d2.getFullYear() - d1.getFullYear(); return ms; },
  from(parts) { return new Date(parts.year || 0, (parts.month || 1) - 1, parts.day || 1, parts.hour || 0, parts.minute || 0, parts.second || 0); },
  part(d, p) { if (typeof d === 'number') d = new Date(d); if (p === 'year') return d.getFullYear(); if (p === 'month') return d.getMonth() + 1; if (p === 'day') return d.getDate(); if (p === 'hour') return d.getHours(); if (p === 'minute') return d.getMinutes(); if (p === 'second') return d.getSeconds(); if (p === 'weekday') return d.getDay(); return null; },
  time_ago(d) { if (typeof d === 'number') d = new Date(d); const s = Math.floor((Date.now() - d.getTime()) / 1000); if (s < 60) return s + ' seconds ago'; const m = Math.floor(s / 60); if (m < 60) return m + (m === 1 ? ' minute ago' : ' minutes ago'); const h = Math.floor(m / 60); if (h < 24) return h + (h === 1 ? ' hour ago' : ' hours ago'); const dy = Math.floor(h / 24); if (dy < 30) return dy + (dy === 1 ? ' day ago' : ' days ago'); const mo = Math.floor(dy / 30); if (mo < 12) return mo + (mo === 1 ? ' month ago' : ' months ago'); const yr = Math.floor(mo / 12); return yr + (yr === 1 ? ' year ago' : ' years ago'); }
});`,

  re: `const re = Object.freeze({
  test(s, pattern, flags) { return new RegExp(pattern, flags).test(s); },
  match(s, pattern, flags) { const m = s.match(new RegExp(pattern, flags)); if (!m) return Err('No match'); return Ok({ match: m[0], index: m.index, groups: m.slice(1) }); },
  find_all(s, pattern, flags) { const r = new RegExp(pattern, (flags || '') + (flags && flags.includes('g') ? '' : 'g')); const results = []; let m; while ((m = r.exec(s)) !== null) { results.push({ match: m[0], index: m.index, groups: m.slice(1) }); } return results; },
  replace(s, pattern, replacement, flags) { return s.replace(new RegExp(pattern, flags || 'g'), replacement); },
  split(s, pattern, flags) { return s.split(new RegExp(pattern, flags)); },
  capture(s, pattern, flags) { const m = s.match(new RegExp(pattern, flags)); if (!m) return Err('No match'); if (!m.groups) return Err('No named groups'); return Ok(m.groups); }
});`,

  json: `const json = Object.freeze({
  parse(s) { try { return Ok(JSON.parse(s)); } catch (e) { return Err(e.message); } },
  stringify(v) { return JSON.stringify(v); },
  pretty(v) { return JSON.stringify(v, null, 2); }
});`,

  fs: `const fs = Object.freeze({
  read_text(path, enc) { try { return Ok(require('fs').readFileSync(path, enc || 'utf-8')); } catch (e) { return Err(e.message); } },
  write_text(path, content, opts) { try { const f = require('fs'); if (opts && opts.append) f.appendFileSync(path, content); else f.writeFileSync(path, content); return Ok(path); } catch (e) { return Err(e.message); } },
  exists(path) { return require('fs').existsSync(path); },
  is_dir(path) { try { return require('fs').statSync(path).isDirectory(); } catch { return false; } },
  is_file(path) { try { return require('fs').statSync(path).isFile(); } catch { return false; } },
  ls(dir, opts) { const f = require('fs'); const p = require('path'); const d = dir || '.'; const entries = f.readdirSync(d); if (opts && opts.full) return entries.map(e => p.join(d, e)); return entries; },
  mkdir(dir) { try { require('fs').mkdirSync(dir, { recursive: true }); return Ok(dir); } catch (e) { return Err(e.message); } },
  rm(path, opts) { try { require('fs').rmSync(path, { recursive: !!(opts && opts.recursive), force: !!(opts && opts.force) }); return Ok(path); } catch (e) { return Err(e.message); } },
  cp(src, dest, opts) { try { const f = require('fs'); if (opts && opts.recursive) { f.cpSync(src, dest, { recursive: true }); } else { f.copyFileSync(src, dest); } return Ok(dest); } catch (e) { return Err(e.message); } },
  mv(src, dest) { try { require('fs').renameSync(src, dest); return Ok(dest); } catch (e) { return Err(e.message); } },
  glob_files(pattern, opts) { if (typeof Bun !== 'undefined' && Bun.Glob) { const glob = new Bun.Glob(pattern); return [...glob.scanSync(opts && opts.cwd || '.')]; } const f = require('fs'); if (f.globSync) return f.globSync(pattern, opts); return []; }
});`,

  url: `const url = Object.freeze({
  parse(s) { try { const u = new URL(s); return Ok({ protocol: u.protocol.replace(':', ''), host: u.host, pathname: u.pathname, search: u.search, hash: u.hash }); } catch (e) { return Err('Invalid URL: ' + s); } },
  build(parts) { let u = (parts.protocol || 'https') + '://' + (parts.host || ''); u += parts.pathname || '/'; if (parts.search) u += (parts.search.startsWith('?') ? '' : '?') + parts.search; if (parts.hash) u += (parts.hash.startsWith('#') ? '' : '#') + parts.hash; return u; },
  parse_query(s) { const r = {}; const qs = s.startsWith('?') ? s.slice(1) : s; if (!qs) return r; for (const pair of qs.split('&')) { const [k, ...v] = pair.split('='); r[decodeURIComponent(k)] = decodeURIComponent(v.join('=')); } return r; },
  build_query(obj) { return Object.entries(obj).map(([k, v]) => encodeURIComponent(k) + '=' + encodeURIComponent(v)).join('&'); }
});`,

  // ── Channel-based async ───────────────────────────────
  Channel: `class Channel {
  constructor(capacity) {
    this._capacity = capacity || 0;
    this._buffer = [];
    this._closed = false;
    this._sendWaiters = [];
    this._recvWaiters = [];
  }
  async send(value) {
    if (this._closed) throw new Error('Cannot send on closed channel');
    if (this._recvWaiters.length > 0) {
      const waiter = this._recvWaiters.shift();
      waiter(Some(value));
      return;
    }
    if (this._capacity > 0 && this._buffer.length < this._capacity) {
      this._buffer.push(value);
      return;
    }
    return new Promise(function(resolve) {
      this._sendWaiters.push({ value: value, resolve: resolve });
    }.bind(this));
  }
  async receive() {
    if (this._buffer.length > 0) {
      const value = this._buffer.shift();
      if (this._sendWaiters.length > 0) {
        const waiter = this._sendWaiters.shift();
        this._buffer.push(waiter.value);
        waiter.resolve();
      }
      return Some(value);
    }
    if (this._closed) return None;
    if (this._sendWaiters.length > 0) {
      const waiter = this._sendWaiters.shift();
      waiter.resolve();
      return Some(waiter.value);
    }
    return new Promise(function(resolve) {
      this._recvWaiters.push(resolve);
    }.bind(this));
  }
  _tryReceive() {
    if (this._buffer.length > 0) {
      const value = this._buffer.shift();
      if (this._sendWaiters.length > 0) {
        const waiter = this._sendWaiters.shift();
        this._buffer.push(waiter.value);
        waiter.resolve();
      }
      return Some(value);
    }
    if (this._sendWaiters.length > 0) {
      const waiter = this._sendWaiters.shift();
      waiter.resolve();
      return Some(waiter.value);
    }
    return None;
  }
  _trySend(value) {
    if (this._recvWaiters.length > 0) {
      const waiter = this._recvWaiters.shift();
      waiter(Some(value));
      return true;
    }
    if (this._capacity > 0 && this._buffer.length < this._capacity) {
      this._buffer.push(value);
      return true;
    }
    return false;
  }
  close() {
    this._closed = true;
    for (const waiter of this._recvWaiters) waiter(None);
    this._recvWaiters = [];
  }
  [Symbol.asyncIterator]() {
    const ch = this;
    return {
      async next() {
        const val = await ch.receive();
        if (val.__tag === 'None') return { done: true, value: undefined };
        return { done: false, value: val.value };
      }
    };
  }
}`,

  // ── Snapshot testing ──────────────────────────────────
  assert_snapshot: `function assert_snapshot(value, name) {
  const snap = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
  const updateMode = typeof process !== 'undefined' && process.env.TOVA_UPDATE_SNAPSHOTS === '1';
  if (typeof __tova_snapshots === 'undefined') { globalThis.__tova_snapshots = {}; }
  const key = name || ('snapshot_' + Object.keys(__tova_snapshots).length);
  if (updateMode || !__tova_snapshots[key]) {
    __tova_snapshots[key] = snap;
    return;
  }
  if (__tova_snapshots[key] !== snap) {
    throw new Error('Snapshot mismatch for "' + key + '":\\nExpected:\\n' + __tova_snapshots[key] + '\\nActual:\\n' + snap);
  }
}`,

  // ── Property-based testing ────────────────────────────
  Gen: `const Gen = {
  int: function(min, max) { return function() { const lo = min !== undefined ? min : -1000; const hi = max !== undefined ? max : 1000; return Math.floor(Math.random() * (hi - lo + 1)) + lo; }; },
  float: function(min, max) { return function() { const lo = min !== undefined ? min : -1000; const hi = max !== undefined ? max : 1000; return Math.random() * (hi - lo) + lo; }; },
  bool: function() { return function() { return Math.random() < 0.5; }; },
  string: function(maxLen) { return function() { const len = Math.floor(Math.random() * (maxLen || 20)); const chars = 'abcdefghijklmnopqrstuvwxyz0123456789'; let s = ''; for (let i = 0; i < len; i++) s += chars[Math.floor(Math.random() * chars.length)]; return s; }; },
  array: function(gen, maxLen) { return function() { const len = Math.floor(Math.random() * (maxLen || 10)); const arr = []; for (let i = 0; i < len; i++) arr.push(gen()); return arr; }; },
  oneOf: function(values) { return function() { return values[Math.floor(Math.random() * values.length)]; }; }
};`,
  forAll: `function forAll(generators, property, opts) {
  const runs = (opts && opts.runs) || 100;
  for (let i = 0; i < runs; i++) {
    const args = generators.map(function(g) { return g(); });
    let result;
    try { result = property.apply(null, args); } catch (e) { throw new Error('Property failed on input ' + JSON.stringify(args) + ': ' + e.message); }
    if (result === false) { throw new Error('Property failed on input: ' + JSON.stringify(args)); }
  }
}`,

  // ── Mock / Spy Utilities ────────────────────────────────
  create_spy: `function create_spy(impl) {
  const spy = function(...args) {
    spy.calls.push(args);
    spy.call_count++;
    spy.called = true;
    spy.last_args = args;
    if (spy._impl) return spy._impl(...args);
    return spy._return_value;
  };
  spy.calls = [];
  spy.call_count = 0;
  spy.called = false;
  spy.last_args = null;
  spy._impl = impl || null;
  spy._return_value = undefined;
  spy.returns = function(val) { spy._return_value = val; spy._impl = null; return spy; };
  spy.reset = function() { spy.calls = []; spy.call_count = 0; spy.called = false; spy.last_args = null; };
  spy.called_with = function(...expected) {
    return spy.calls.some(function(call) {
      return expected.length === call.length && expected.every(function(v, i) { return v === call[i]; });
    });
  };
  return spy;
}`,
  create_mock: `function create_mock(return_value) {
  return create_spy(typeof return_value === 'function' ? return_value : function() { return return_value; });
}`,

  // ── Advanced Collections ────────────────────────────────
  OrderedDict: `class OrderedDict {
  constructor(entries) { this._map = new Map(entries || []); }
  get(key) { return this._map.has(key) ? this._map.get(key) : null; }
  set(key, value) { const m = new Map(this._map); m.set(key, value); return new OrderedDict([...m]); }
  delete(key) { const m = new Map(this._map); m.delete(key); return new OrderedDict([...m]); }
  has(key) { return this._map.has(key); }
  keys() { return [...this._map.keys()]; }
  values() { return [...this._map.values()]; }
  entries() { return [...this._map.entries()]; }
  get length() { return this._map.size; }
  [Symbol.iterator]() { return this._map[Symbol.iterator](); }
  toString() { return 'OrderedDict(' + this._map.size + ' entries)'; }
}`,

  DefaultDict: `class DefaultDict {
  constructor(defaultFn) { this._map = new Map(); this._default = defaultFn; }
  get(key) { if (!this._map.has(key)) { this._map.set(key, this._default()); } return this._map.get(key); }
  set(key, value) { this._map.set(key, value); return this; }
  has(key) { return this._map.has(key); }
  delete(key) { this._map.delete(key); return this; }
  keys() { return [...this._map.keys()]; }
  values() { return [...this._map.values()]; }
  entries() { return [...this._map.entries()]; }
  get length() { return this._map.size; }
  [Symbol.iterator]() { return this._map[Symbol.iterator](); }
  toString() { return 'DefaultDict(' + this._map.size + ' entries)'; }
}`,

  Counter: `class Counter {
  constructor(items) { this._counts = new Map(); if (items) { for (const item of items) { this._counts.set(item, (this._counts.get(item) || 0) + 1); } } }
  count(item) { return this._counts.get(item) || 0; }
  total() { let s = 0; for (const v of this._counts.values()) s += v; return s; }
  most_common(n) { const sorted = [...this._counts.entries()].sort((a, b) => b[1] - a[1]); return n !== undefined ? sorted.slice(0, n) : sorted; }
  keys() { return [...this._counts.keys()]; }
  values() { return [...this._counts.values()]; }
  entries() { return [...this._counts.entries()]; }
  has(item) { return this._counts.has(item); }
  get length() { return this._counts.size; }
  [Symbol.iterator]() { return this._counts[Symbol.iterator](); }
  toString() { return 'Counter(' + this._counts.size + ' items)'; }
}`,

  Deque: `class Deque {
  constructor(items) { this._items = items ? [...items] : []; }
  push_back(val) { return new Deque([...this._items, val]); }
  push_front(val) { return new Deque([val, ...this._items]); }
  pop_back() { if (this._items.length === 0) return [null, this]; return [this._items[this._items.length - 1], new Deque(this._items.slice(0, -1))]; }
  pop_front() { if (this._items.length === 0) return [null, this]; return [this._items[0], new Deque(this._items.slice(1))]; }
  peek_front() { return this._items.length > 0 ? this._items[0] : null; }
  peek_back() { return this._items.length > 0 ? this._items[this._items.length - 1] : null; }
  get length() { return this._items.length; }
  toArray() { return [...this._items]; }
  [Symbol.iterator]() { return this._items[Symbol.iterator](); }
  toString() { return 'Deque(' + this._items.length + ' items)'; }
}`,

  collections: `const collections = Object.freeze({
  OrderedDict, DefaultDict, Counter, Deque
});`,

  // ─── Typed numeric array functions for @fast mode ───────────────

  typed_zeros: `function typed_zeros(n, Type) {
  return new (Type || Float64Array)(n);
}`,

  typed_ones: `function typed_ones(n, Type) {
  const out = new (Type || Float64Array)(n);
  out.fill(1);
  return out;
}`,

  typed_fill: `function typed_fill(arr, value) {
  const out = new arr.constructor(arr.length);
  out.fill(value);
  return out;
}`,

  typed_range: `function typed_range(start, end, step) {
  step = step || 1;
  const n = Math.ceil((end - start) / step);
  const arr = new Float64Array(n);
  for (let i = 0; i < n; i++) arr[i] = start + i * step;
  return arr;
}`,

  typed_linspace: `function typed_linspace(start, end, n) {
  const out = new Float64Array(n);
  if (n <= 1) { if (n === 1) out[0] = start; return out; }
  const step = (end - start) / (n - 1);
  for (let i = 0; i < n; i++) out[i] = start + i * step;
  return out;
}`,

  typed_sum: `function typed_sum(arr) {
  let s = 0, c = 0;
  for (let i = 0; i < arr.length; i++) {
    const y = arr[i] - c;
    const t = s + y;
    c = (t - s) - y;
    s = t;
  }
  return s;
}`,

  typed_dot: `function typed_dot(a, b) {
  const n = a.length;
  let s = 0;
  for (let i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}`,

  typed_norm: `function typed_norm(arr) {
  let s = 0;
  for (let i = 0; i < arr.length; i++) s += arr[i] * arr[i];
  return Math.sqrt(s);
}`,

  typed_add: `function typed_add(a, b) {
  const n = a.length;
  const out = new a.constructor(n);
  for (let i = 0; i < n; i++) out[i] = a[i] + b[i];
  return out;
}`,

  typed_scale: `function typed_scale(arr, scalar) {
  const out = new arr.constructor(arr.length);
  for (let i = 0; i < arr.length; i++) out[i] = arr[i] * scalar;
  return out;
}`,

  typed_map: `function typed_map(arr, fn) {
  const out = new arr.constructor(arr.length);
  for (let i = 0; i < arr.length; i++) out[i] = fn(arr[i], i);
  return out;
}`,

  typed_reduce: `function typed_reduce(arr, fn, init) {
  let acc = init;
  for (let i = 0; i < arr.length; i++) acc = fn(acc, arr[i], i);
  return acc;
}`,

  typed_sort: `function typed_sort(arr) {
  if (arr instanceof Float64Array || arr instanceof Int32Array || arr instanceof Uint8Array ||
      arr instanceof Float32Array || arr instanceof Int16Array || arr instanceof Uint16Array ||
      arr instanceof Uint32Array || arr instanceof Int8Array) {
    const out = new arr.constructor(arr);
    out.sort();
    return out;
  }
  const out = [...arr];
  out.sort((a, b) => a - b);
  return out;
}`,
};

// All known builtin names for matching
const BUILTIN_NAMES = new Set(Object.keys(BUILTIN_FUNCTIONS));

// ─── Stdlib Dependency Graph ──────────────────────────────────
// Maps each builtin to the builtins it depends on (must be emitted first).
// This replaces scattered ad-hoc dependency checks throughout the codebase.
const STDLIB_DEPS = {
  // iter() requires the Seq class
  iter: ['Seq'],
  // collections namespace requires all collection classes
  collections: ['OrderedDict', 'DefaultDict', 'Counter', 'Deque'],
  // Table operations may use Table
  describe: ['Table'],
  // Some builtins reference Result/Option types (Ok, Err, Some, None)
  // These are provided by RESULT_OPTION, not the builtin map, so no dep here
  // Namespace modules that use builtins internally
  json: ['Ok', 'Err'],
  re: ['Ok', 'Err'],
  dt: ['Ok', 'Err'],
  fs: ['Ok', 'Err'],
  url: ['Ok', 'Err'],
  parse_url: ['Ok', 'Err'],
  regex_test: ['__regex_cache'],
  regex_match: ['Ok', 'Err', '__regex_cache'],
  regex_find_all: ['__regex_cache'],
  regex_replace: ['__regex_cache'],
  regex_split: ['__regex_cache'],
  regex_capture: ['Ok', 'Err', '__regex_cache'],
  json_parse: ['Ok', 'Err'],
  date_parse: ['Ok', 'Err'],
  read_text: ['Ok', 'Err'],
  try_fn: ['Ok', 'Err'],
  try_async: ['Ok', 'Err'],
  // LazyTable requires Table and table_* functions
  lazy: ['LazyTable', 'Table'],
  collect: ['LazyTable'],
  LazyTable: ['Table', 'table_where', 'table_group_by'],
  // Seq uses Some/None
  Seq: ['Some', 'None'],
  // compare family
  compare: ['Less', 'Equal', 'Greater'],
  compare_by: ['Less', 'Equal', 'Greater'],
  // mock/spy
  create_mock: ['create_spy'],
  // color shortcuts depend on color()
  green: ['color'],
  red: ['color'],
  yellow: ['color'],
  blue: ['color'],
  cyan: ['color'],
  magenta: ['color'],
  gray: ['color'],
};

// Resolve all transitive dependencies for a set of used names
function resolveStdlibDeps(usedNames) {
  const resolved = new Set(usedNames);
  const queue = [...usedNames];
  while (queue.length > 0) {
    const name = queue.pop();
    const deps = STDLIB_DEPS[name];
    if (deps) {
      for (const dep of deps) {
        if (!resolved.has(dep)) {
          resolved.add(dep);
          queue.push(dep);
        }
      }
    }
  }
  return resolved;
}

// Topological sort: emit dependencies before dependents
function _topoSort(names) {
  const result = [];
  const visited = new Set();
  const visiting = new Set();

  function visit(name) {
    if (visited.has(name)) return;
    if (visiting.has(name)) return; // circular — break
    visiting.add(name);
    const deps = STDLIB_DEPS[name];
    if (deps) {
      for (const dep of deps) {
        if (names.has(dep)) visit(dep);
      }
    }
    visiting.delete(name);
    visited.add(name);
    result.push(name);
  }

  for (const name of names) visit(name);
  return result;
}

// Legacy compat: full stdlib as a single string (derived from BUILTIN_FUNCTIONS)
// Only includes non-internal, non-table functions for backward compat with tests/playground
const _LEGACY_NAMES = [
  'print', 'len', 'range', 'enumerate', 'sum', 'sorted', 'reversed', 'zip',
  'min', 'max', 'type_of', 'filter', 'map', 'find', 'any', 'all', 'flat_map',
  'reduce', 'unique', 'group_by', 'chunk', 'flatten', 'take', 'drop', 'first',
  'last', 'count', 'partition', 'abs', 'floor', 'ceil', 'round', 'clamp',
  'sqrt', 'pow', 'random', 'trim', 'split', 'join', 'replace', 'repeat',
  'keys', 'values', 'entries', 'merge', 'freeze', 'clone', 'sleep',
  'upper', 'lower', 'contains', 'starts_with', 'ends_with', 'chars', 'words',
  'lines', 'capitalize', 'title_case', 'snake_case', 'camel_case',
  'assert_eq', 'assert_ne', 'assert', 'assert_throws',
  'create_spy', 'create_mock',
  'parallel_map',
];
const BUILTINS = _LEGACY_NAMES.map(n => BUILTIN_FUNCTIONS[n]).join('\n');

// Build stdlib containing only the functions that are actually used
function buildSelectiveStdlib(usedNames) {
  // Resolve transitive dependencies and topologically sort
  const withDeps = resolveStdlibDeps(usedNames);
  const ordered = _topoSort(withDeps);
  const parts = [];
  for (const name of ordered) {
    if (BUILTIN_FUNCTIONS[name]) {
      parts.push(BUILTIN_FUNCTIONS[name]);
    }
  }
  return parts.join('\n');
}

// Native FFI bridge initialization (server-side only, Bun runtime)
// Lazily loads the Rust native library for high-performance stdlib operations
// Async version for tova run (AsyncFunction context supports await)
const NATIVE_INIT = `var __tova_native = null;
try {
  if (typeof Bun !== 'undefined') {
    const { dlopen: __dl, FFIType: __F } = await import('bun:ffi');
    const __path = await import('path');
    const __fs = await import('fs');
    const __searchDirs = [
      __path.join(__path.dirname(typeof __tova_filename !== 'undefined' ? __tova_filename : ''), 'native', 'target', 'release'),
      __path.join(process.cwd(), 'native', 'target', 'release'),
      __path.join(process.env.HOME || '', '.tova', 'lib'),
    ];
    const __libName = process.platform === 'darwin' ? 'libtova_native.dylib' : process.platform === 'win32' ? 'tova_native.dll' : 'libtova_native.so';
    for (const __d of __searchDirs) {
      const __p = __path.join(__d, __libName);
      if (__fs.existsSync(__p)) {
        const __lib = __dl(__p, {
          tova_sort_f64: { args: [__F.ptr, __F.u64], returns: __F.void },
          tova_sort_i64: { args: [__F.ptr, __F.u64], returns: __F.void },
          tova_sum_f64: { args: [__F.ptr, __F.u64], returns: __F.f64 },
          tova_min_f64: { args: [__F.ptr, __F.u64], returns: __F.f64 },
          tova_max_f64: { args: [__F.ptr, __F.u64], returns: __F.f64 },
        });
        __tova_native = __lib.symbols;
        break;
      }
    }
  }
} catch (__e) {}`;

// Sync-safe version without await (for non-async contexts like tests, REPL eval)
const NATIVE_INIT_SYNC = `var __tova_native = null;`;

// Full stdlib for runtime (REPL, run command) — sync-safe (no await)
function getFullStdlib() {
  return `${NATIVE_INIT_SYNC}\n${buildSelectiveStdlib(BUILTIN_NAMES)}\n${RESULT_OPTION}\n${PROPAGATE}`;
}

// Stdlib for browser codegen (includes builtins + result/option + propagate)
function getBrowserStdlib() {
  return `${buildSelectiveStdlib(BUILTIN_NAMES)}\n${RESULT_OPTION}\n${PROPAGATE}`;
}

// ─── src/registry/plugins/shared-plugin.js ─────────────

const sharedPlugin = {
  name: 'shared',
  astNodeType: 'SharedBlock',
  detection: {
    strategy: 'keyword',
    tokenType: 'SHARED',
  },
  parser: {
    install: null,
    installedFlag: null,
    method: 'parseSharedBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitSharedBlock(node),
  },
  codegen: {},
};

// ─── src/registry/plugins/server-plugin.js ─────────────

const serverPlugin = {
  name: 'server',
  astNodeType: 'ServerBlock',
  detection: {
    strategy: 'keyword',
    tokenType: 'SERVER',
  },
  parser: {
    install: installServerParser,
    installedFlag: '_serverParserInstalled',
    method: 'parseServerBlock',
  },
  analyzer: {
    visit: (analyzer, node) => {
      if (!analyzer.constructor.prototype._serverAnalyzerInstalled) {
        installServerAnalyzer(analyzer.constructor);
      }
      return analyzer._visitServerNode(node);
    },
    childNodeTypes: [
      'RouteDeclaration', 'MiddlewareDeclaration', 'HealthCheckDeclaration',
      'CorsDeclaration', 'ErrorHandlerDeclaration', 'WebSocketDeclaration',
      'StaticDeclaration', 'DiscoverDeclaration', 'AuthDeclaration',
      'MaxBodyDeclaration', 'RouteGroupDeclaration', 'RateLimitDeclaration',
      'LifecycleHookDeclaration', 'SubscribeDeclaration', 'EnvDeclaration',
      'ScheduleDeclaration', 'UploadDeclaration', 'SessionDeclaration',
      'DbDeclaration', 'TlsDeclaration', 'CompressionDeclaration',
      'BackgroundJobDeclaration', 'CacheDeclaration', 'SseDeclaration',
      'ModelDeclaration',
    ],
    noopNodeTypes: ['AiConfigDeclaration'],
    prePass: (analyzer) => {
      const has = analyzer.ast.body.some(n => n.type === 'ServerBlock');
      if (has) {
        installServerAnalyzer(analyzer.constructor);
        analyzer.serverBlockFunctions = collectServerBlockFunctions(analyzer.ast);
      } else {
        analyzer.serverBlockFunctions = new Map();
      }
    },
  },
  codegen: {},
};

// ─── src/registry/plugins/browser-plugin.js ────────────

const browserPlugin = {
  name: 'browser',
  astNodeType: 'BrowserBlock',
  detection: {
    strategy: 'keyword',
    tokenType: 'BROWSER',
  },
  parser: {
    install: installBrowserParser,
    installedFlag: '_browserParserInstalled',
    method: 'parseBrowserBlock',
  },
  analyzer: {
    visit: (analyzer, node) => {
      if (!analyzer.constructor.prototype._browserAnalyzerInstalled) {
        installBrowserAnalyzer(analyzer.constructor);
      }
      const methodName = 'visit' + node.type;
      return analyzer[methodName](node);
    },
    childNodeTypes: [
      'StateDeclaration', 'ComputedDeclaration', 'EffectDeclaration',
      'ComponentDeclaration', 'StoreDeclaration', 'FormDeclaration',
    ],
  },
  codegen: {},
};

// ─── src/registry/plugins/security-plugin.js ───────────

const securityPlugin = {
  name: 'security',
  astNodeType: 'SecurityBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'security',
  },
  parser: {
    install: installSecurityParser,
    installedFlag: '_securityParserInstalled',
    method: 'parseSecurityBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitSecurityBlock(node),
    noopNodeTypes: [
      'SecurityAuthDeclaration', 'SecurityRoleDeclaration',
      'SecurityProtectDeclaration', 'SecuritySensitiveDeclaration',
      'SecurityCorsDeclaration', 'SecurityCspDeclaration',
      'SecurityRateLimitDeclaration', 'SecurityCsrfDeclaration',
      'SecurityAuditDeclaration',
    ],
    crossBlockValidate: (analyzer) => analyzer._validateSecurityCrossBlock(),
  },
  codegen: {},
};

// ─── src/registry/plugins/cli-plugin.js ────────────────

const cliPlugin = {
  name: 'cli',
  astNodeType: 'CliBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'cli',
  },
  parser: {
    install: installCliParser,
    installedFlag: '_cliParserInstalled',
    method: 'parseCliBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitCliBlock(node),
    noopNodeTypes: ['CliConfigField', 'CliCommandDeclaration', 'CliParam'],
    crossBlockValidate: (analyzer) => analyzer._validateCliCrossBlock(),
  },
  codegen: {
    earlyReturn: true,
    earlyReturnMethod: '_generateCli',
  },
};

// ─── src/registry/plugins/edge-plugin.js ───────────────

const edgePlugin = {
  name: 'edge',
  astNodeType: 'EdgeBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'edge',
    lookahead: (parser) => {
      const next = parser.peek(1);
      // edge {} or edge "name" {}
      return next.type === TokenType.LBRACE || next.type === TokenType.STRING;
    },
  },
  parser: {
    install: installEdgeParser,
    installedFlag: '_edgeParserInstalled',
    method: 'parseEdgeBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitEdgeBlock(node),
    childNodeTypes: [],
    noopNodeTypes: [
      'EdgeKVDeclaration', 'EdgeSQLDeclaration', 'EdgeStorageDeclaration',
      'EdgeQueueDeclaration', 'EdgeEnvDeclaration', 'EdgeSecretDeclaration',
      'EdgeScheduleDeclaration', 'EdgeConsumeDeclaration', 'EdgeConfigField',
    ],
    crossBlockValidate: (analyzer) => analyzer._validateEdgeCrossBlock(),
  },
  codegen: {},
};

// ─── src/registry/plugins/data-plugin.js ───────────────

const dataPlugin = {
  name: 'data',
  astNodeType: 'DataBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'data',
  },
  parser: {
    install: null,
    installedFlag: null,
    method: 'parseDataBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitDataBlock(node),
    noopNodeTypes: [
      'SourceDeclaration', 'PipelineDeclaration',
      'ValidateBlock', 'RefreshPolicy',
    ],
  },
  codegen: {},
};

// ─── src/registry/plugins/test-plugin.js ───────────────

const testPlugin = {
  name: 'test',
  astNodeType: 'TestBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'test',
    lookahead: (parser) => {
      const next = parser.peek(1);
      return next.type === TokenType.LBRACE || next.type === TokenType.STRING;
    },
  },
  parser: {
    install: null,
    installedFlag: null,
    method: 'parseTestBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitTestBlock(node),
  },
  codegen: {},
};

// ─── src/registry/plugins/bench-plugin.js ──────────────

const benchPlugin = {
  name: 'bench',
  astNodeType: 'BenchBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'bench',
    lookahead: (parser) => {
      const next = parser.peek(1);
      return next.type === TokenType.LBRACE || next.type === TokenType.STRING;
    },
  },
  parser: {
    install: null,
    installedFlag: null,
    method: 'parseBenchBlock',
  },
  analyzer: {
    visit: (analyzer, node) => analyzer.visitTestBlock(node), // reuses test visitor
  },
  codegen: {},
};

// ─── src/registry/plugins/concurrency-plugin.js ────────

const concurrencyPlugin = {
  name: 'concurrency',
  astNodeType: 'ConcurrentBlock',
  detection: {
    strategy: 'identifier',
    identifierValue: 'concurrent',
    lookahead: (parser) => {
      const next = parser.peek(1);
      // concurrent {} or concurrent mode {}
      return next.type === TokenType.LBRACE ||
             (next.type === TokenType.IDENTIFIER &&
              ['cancel_on_error', 'first', 'timeout'].includes(next.value));
    },
  },
  parser: {
    install: installConcurrencyParser,
    installedFlag: '_concurrencyParserInstalled',
    method: 'parseConcurrentBlock',
  },
  analyzer: {
    visit: (analyzer, node) => {
      if (node.type === 'SelectStatement') return analyzer.visitSelectStatement(node);
      return analyzer.visitConcurrentBlock(node);
    },
    childNodeTypes: ['SelectStatement'],
    noopNodeTypes: ['SpawnExpression', 'SelectCase'],
  },
  codegen: {},
};

// ─── src/registry/register-all.js ──────────────────────

// Registers all built-in block plugins and re-exports BlockRegistry.
// Import this module (instead of block-registry.js directly) to ensure all plugins are loaded.











BlockRegistry.register(serverPlugin);
BlockRegistry.register(browserPlugin);
BlockRegistry.register(sharedPlugin);
BlockRegistry.register(securityPlugin);
BlockRegistry.register(cliPlugin);
BlockRegistry.register(dataPlugin);
BlockRegistry.register(testPlugin);
BlockRegistry.register(benchPlugin);
BlockRegistry.register(edgePlugin);
BlockRegistry.register(concurrencyPlugin);

// ─── src/codegen/wasm-codegen.js ───────────────────────

// WASM binary code generator for @wasm-annotated Tova functions
// Compiles a subset of Tova (numeric types, control flow, recursion) to WebAssembly binary format
// No external dependencies — generates WASM binary directly

// WASM type constants
const I32 = 0x7F;
const I64 = 0x7E;
const F64 = 0x7C;
const VOID = 0x40;
const FUNC_TYPE = 0x60;

// WASM section IDs
const SEC_TYPE = 1;
const SEC_FUNCTION = 3;
const SEC_EXPORT = 7;
const SEC_CODE = 10;

// WASM opcodes
const OP = {
  unreachable: 0x00,
  nop: 0x01,
  block: 0x02,
  loop: 0x03,
  if: 0x04,
  else: 0x05,
  end: 0x0B,
  br: 0x0C,
  br_if: 0x0D,
  return: 0x0F,
  call: 0x10,
  drop: 0x1A,
  select: 0x1B,
  local_get: 0x20,
  local_set: 0x21,
  local_tee: 0x22,
  i32_const: 0x41,
  i64_const: 0x42,
  f64_const: 0x44,
  i32_eqz: 0x45,
  i32_eq: 0x46,
  i32_ne: 0x47,
  i32_lt_s: 0x48,
  i32_gt_s: 0x4A,
  i32_le_s: 0x4C,
  i32_ge_s: 0x4E,
  f64_eq: 0x61,
  f64_ne: 0x62,
  f64_lt: 0x63,
  f64_gt: 0x64,
  f64_le: 0x65,
  f64_ge: 0x66,
  i32_add: 0x6A,
  i32_sub: 0x6B,
  i32_mul: 0x6C,
  i32_div_s: 0x6D,
  i32_rem_s: 0x6F,
  i32_and: 0x71,
  i32_or: 0x72,
  f64_neg: 0x9A,
  f64_add: 0xA0,
  f64_sub: 0xA1,
  f64_mul: 0xA2,
  f64_div: 0xA3,
  f64_convert_i32_s: 0xB7,
  i32_trunc_f64_s: 0xAA,
};

// LEB128 encoding
function uleb128(value) {
  const r = [];
  do {
    let b = value & 0x7F;
    value >>>= 7;
    if (value !== 0) b |= 0x80;
    r.push(b);
  } while (value !== 0);
  return r;
}

function sleb128(value) {
  const r = [];
  let more = true;
  while (more) {
    let b = value & 0x7F;
    value >>= 7;
    if ((value === 0 && (b & 0x40) === 0) || (value === -1 && (b & 0x40) !== 0)) {
      more = false;
    } else {
      b |= 0x80;
    }
    r.push(b);
  }
  return r;
}

function encodeString(s) {
  const bytes = new TextEncoder().encode(s);
  return [...uleb128(bytes.length), ...bytes];
}

function encodeSection(id, contents) {
  return [id, ...uleb128(contents.length), ...contents];
}

function encodeF64(value) {
  const buf = new ArrayBuffer(8);
  new Float64Array(buf)[0] = value;
  return [...new Uint8Array(buf)];
}

// Map Tova type annotations to WASM types
function tovaTypeToWasm(typeStr) {
  if (!typeStr) return I32;
  const t = typeof typeStr === 'string' ? typeStr : (typeStr.name || typeStr.value || String(typeStr));
  switch (t) {
    case 'Int': case 'int': case 'i32': case 'Bool': case 'bool': return I32;
    case 'Float': case 'float': case 'f64': case 'Number': return F64;
    default: return I32;
  }
}

// Compile a single @wasm function to WASM binary
function compileWasmFunction(funcNode) {
  const ctx = new WasmFuncContext(funcNode);
  const bodyBytes = ctx.compile();
  return buildModule(funcNode.name, ctx.paramTypes, ctx.returnType, ctx.localTypes, bodyBytes);
}

// Compile multiple @wasm functions into a single module
function compileWasmModule(funcNodes) {
  if (funcNodes.length === 1) return compileWasmFunction(funcNodes[0]);
  const contexts = funcNodes.map(f => new WasmFuncContext(f));
  const nameMap = {};
  funcNodes.forEach((f, i) => { nameMap[f.name] = i; });
  contexts.forEach(ctx => { ctx.funcNameMap = nameMap; });
  const bodies = contexts.map(ctx => ctx.compile());
  return buildMultiModule(funcNodes.map(f => f.name), contexts, bodies);
}

function buildModule(name, paramTypes, returnType, localTypes, bodyBytes) {
  const typeSection = encodeSection(SEC_TYPE, [
    ...uleb128(1), FUNC_TYPE,
    ...uleb128(paramTypes.length), ...paramTypes,
    ...(returnType !== null ? [1, returnType] : [0])
  ]);
  const funcSection = encodeSection(SEC_FUNCTION, [...uleb128(1), ...uleb128(0)]);
  const exportSection = encodeSection(SEC_EXPORT, [
    ...uleb128(1), ...encodeString(name), 0x00, ...uleb128(0),
  ]);
  const localDecls = encodeLocalDecls(localTypes);
  const funcBody = [...localDecls, ...bodyBytes, OP.end];
  const codeSection = encodeSection(SEC_CODE, [...uleb128(1), ...uleb128(funcBody.length), ...funcBody]);

  return new Uint8Array([
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    ...typeSection, ...funcSection, ...exportSection, ...codeSection,
  ]);
}

function buildMultiModule(names, contexts, bodies) {
  const types = [];
  for (const ctx of contexts) {
    types.push(FUNC_TYPE, ...uleb128(ctx.paramTypes.length), ...ctx.paramTypes,
      ...(ctx.returnType !== null ? [1, ctx.returnType] : [0]));
  }
  const typeSection = encodeSection(SEC_TYPE, [...uleb128(contexts.length), ...types]);
  const funcSection = encodeSection(SEC_FUNCTION, [...uleb128(contexts.length), ...contexts.map((_, i) => uleb128(i)).flat()]);
  const exports = [];
  for (let i = 0; i < names.length; i++) exports.push(...encodeString(names[i]), 0x00, ...uleb128(i));
  const exportSection = encodeSection(SEC_EXPORT, [...uleb128(names.length), ...exports]);
  const funcBodies = [];
  for (let i = 0; i < contexts.length; i++) {
    const fb = [...encodeLocalDecls(contexts[i].localTypes), ...bodies[i], OP.end];
    funcBodies.push(...uleb128(fb.length), ...fb);
  }
  const codeSection = encodeSection(SEC_CODE, [...uleb128(contexts.length), ...funcBodies]);
  return new Uint8Array([
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    ...typeSection, ...funcSection, ...exportSection, ...codeSection,
  ]);
}

function encodeLocalDecls(localTypes) {
  if (localTypes.length === 0) return uleb128(0);
  const groups = [];
  let cur = localTypes[0], count = 1;
  for (let i = 1; i < localTypes.length; i++) {
    if (localTypes[i] === cur) { count++; }
    else { groups.push([count, cur]); cur = localTypes[i]; count = 1; }
  }
  groups.push([count, cur]);
  const r = [...uleb128(groups.length)];
  for (const [cnt, typ] of groups) r.push(...uleb128(cnt), typ);
  return r;
}

// ─── WASM Function Context ─────────────────────────────────

class WasmFuncContext {
  constructor(funcNode) {
    this.funcNode = funcNode;
    this.name = funcNode.name;
    this.locals = new Map();       // name -> local index
    this.localTypes = [];          // types of non-param locals
    this.paramTypes = [];
    this.returnType = null;
    this.funcNameMap = { [funcNode.name]: 0 };
    this.blockDepth = 0;

    // Parse params — Tova AST: param.name, param.typeAnnotation
    for (const p of funcNode.params) {
      const pName = p.name || '_';
      const wt = tovaTypeToWasm(p.typeAnnotation);
      this.locals.set(pName, this.locals.size);
      this.paramTypes.push(wt);
    }

    // Parse return type
    this.returnType = funcNode.returnType ? tovaTypeToWasm(funcNode.returnType) : I32;
  }

  addLocal(name, wasmType) {
    if (this.locals.has(name)) return this.locals.get(name);
    const idx = this.locals.size;
    this.locals.set(name, idx);
    this.localTypes.push(wasmType || I32);
    return idx;
  }

  getLocal(name) { return this.locals.get(name); }

  typeOf(name) {
    const idx = this.locals.get(name);
    if (idx === undefined) return I32;
    if (idx < this.paramTypes.length) return this.paramTypes[idx];
    return this.localTypes[idx - this.paramTypes.length];
  }

  compile() {
    const body = this.funcNode.body;
    if (body.type === 'BlockStatement') return this.compileBlockAsValue(body);
    return this.compileExpr(body);
  }

  // ─── Block compilation (implicit return from last expression) ───

  compileBlockAsValue(block) {
    const stmts = block.body || [];
    if (stmts.length === 0) return this.defaultValue();

    const bytes = [];
    for (let i = 0; i < stmts.length; i++) {
      const stmt = stmts[i];
      const isLast = i === stmts.length - 1;

      if (isLast) {
        if (stmt.type === 'ExpressionStatement') {
          bytes.push(...this.compileExpr(stmt.expression));
        } else if (stmt.type === 'ReturnStatement') {
          if (stmt.value) bytes.push(...this.compileExpr(stmt.value));
          bytes.push(OP.return);
        } else if (stmt.type === 'IfStatement') {
          bytes.push(...this.compileIfExpr(stmt));
        } else {
          bytes.push(...this.compileStatement(stmt));
          bytes.push(...this.defaultValue());
        }
      } else {
        bytes.push(...this.compileStatement(stmt));
      }
    }
    return bytes;
  }

  compileBlockValue(block) {
    if (block.type === 'BlockStatement') {
      const stmts = block.body || [];
      if (stmts.length === 0) return this.defaultValue();
      const bytes = [];
      for (let i = 0; i < stmts.length - 1; i++) bytes.push(...this.compileStatement(stmts[i]));
      const last = stmts[stmts.length - 1];
      if (last.type === 'ExpressionStatement') {
        bytes.push(...this.compileExpr(last.expression));
      } else if (last.type === 'ReturnStatement') {
        if (last.value) bytes.push(...this.compileExpr(last.value));
        bytes.push(OP.return);
      } else if (last.type === 'IfStatement') {
        bytes.push(...this.compileIfExpr(last));
      } else {
        bytes.push(...this.compileStatement(last));
        bytes.push(...this.defaultValue());
      }
      return bytes;
    }
    return this.compileExpr(block);
  }

  defaultValue() {
    return this.returnType === F64 ? [OP.f64_const, ...encodeF64(0)] : [OP.i32_const, ...sleb128(0)];
  }

  // ─── Statement compilation ───

  compileStatement(stmt) {
    switch (stmt.type) {
      case 'VarDeclaration': return this.compileVarDecl(stmt);
      case 'Assignment': return this.compileAssignment(stmt);
      case 'ExpressionStatement': {
        const bytes = this.compileExpr(stmt.expression);
        bytes.push(OP.drop);
        return bytes;
      }
      case 'ReturnStatement': {
        const bytes = [];
        if (stmt.value) bytes.push(...this.compileExpr(stmt.value));
        bytes.push(OP.return);
        return bytes;
      }
      case 'IfStatement': return this.compileIfStmt(stmt);
      case 'WhileStatement': return this.compileWhile(stmt);
      default:
        throw new Error(`@wasm: unsupported statement type '${stmt.type}'`);
    }
  }

  // Tova VarDeclaration: { targets: [identifier], values: [expression] }
  compileVarDecl(node) {
    const bytes = [];
    const targets = node.targets || [];
    const values = node.values || [];
    for (let i = 0; i < targets.length; i++) {
      const name = typeof targets[i] === 'string' ? targets[i] : targets[i].name;
      const init = values[i];
      let wt = I32;
      if (init) wt = this.inferType(init);
      const idx = this.addLocal(name, wt);
      if (init) {
        bytes.push(...this.compileExpr(init));
        bytes.push(OP.local_set, ...uleb128(idx));
      }
    }
    return bytes;
  }

  // Tova Assignment: { targets: [identifier/expr], values: [expression] }
  compileAssignment(node) {
    const bytes = [];
    const targets = node.targets || [];
    const values = node.values || [];
    for (let i = 0; i < targets.length; i++) {
      const target = targets[i];
      const name = typeof target === 'string' ? target : target.name;
      if (!name) throw new Error('@wasm: assignment target must be a simple identifier');
      let idx = this.getLocal(name);
      if (idx === undefined) {
        // Implicit variable declaration (Tova allows `x = 5` without `var`)
        const wt = values[i] ? this.inferType(values[i]) : I32;
        idx = this.addLocal(name, wt);
      }
      bytes.push(...this.compileExpr(values[i]));
      bytes.push(OP.local_set, ...uleb128(idx));
    }
    return bytes;
  }

  // ─── If statement (void) ───

  compileIfStmt(node) {
    const bytes = [];
    bytes.push(...this.compileExpr(node.condition));
    bytes.push(OP.if, VOID);
    if (node.consequent) {
      const stmts = node.consequent.body || [node.consequent];
      for (const s of stmts) bytes.push(...this.compileStatement(s));
    }
    // Handle elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        bytes.push(OP.else);
        bytes.push(...this.compileExpr(alt.condition));
        bytes.push(OP.if, VOID);
        const altStmts = alt.body.body || [alt.body];
        for (const s of altStmts) bytes.push(...this.compileStatement(s));
      }
      // Close all elif if-blocks
      if (node.elseBody) {
        bytes.push(OP.else);
        const elseStmts = node.elseBody.body || [node.elseBody];
        for (const s of elseStmts) bytes.push(...this.compileStatement(s));
      }
      for (let i = 0; i < node.alternates.length; i++) bytes.push(OP.end);
    } else if (node.elseBody) {
      bytes.push(OP.else);
      const elseStmts = node.elseBody.body || [node.elseBody];
      for (const s of elseStmts) bytes.push(...this.compileStatement(s));
    }
    bytes.push(OP.end);
    return bytes;
  }

  // ─── If expression (returns a value) ───

  compileIfExpr(node) {
    const bytes = [];
    bytes.push(...this.compileExpr(node.condition));
    bytes.push(OP.if, this.returnType);

    // Then branch
    if (node.consequent) {
      bytes.push(...this.compileBlockValue(node.consequent));
    } else {
      bytes.push(...this.defaultValue());
    }

    // Handle elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        bytes.push(OP.else);
        bytes.push(...this.compileExpr(alt.condition));
        bytes.push(OP.if, this.returnType);
        bytes.push(...this.compileBlockValue(alt.body));
      }
      // Final else
      bytes.push(OP.else);
      if (node.elseBody) {
        bytes.push(...this.compileBlockValue(node.elseBody));
      } else {
        bytes.push(...this.defaultValue());
      }
      // Close all elif if-blocks
      for (let i = 0; i < node.alternates.length; i++) bytes.push(OP.end);
    } else {
      // Simple if/else
      bytes.push(OP.else);
      if (node.elseBody) {
        bytes.push(...this.compileBlockValue(node.elseBody));
      } else {
        bytes.push(...this.defaultValue());
      }
    }

    bytes.push(OP.end);
    return bytes;
  }

  // ─── While loop ───

  compileWhile(node) {
    const bytes = [];
    bytes.push(OP.block, VOID);
    bytes.push(OP.loop, VOID);
    this.blockDepth += 2;

    bytes.push(...this.compileExpr(node.condition));
    bytes.push(OP.i32_eqz);
    bytes.push(OP.br_if, ...uleb128(1));

    const bodyStmts = node.body.body || [node.body];
    for (const s of bodyStmts) bytes.push(...this.compileStatement(s));

    bytes.push(OP.br, ...uleb128(0));
    bytes.push(OP.end);
    bytes.push(OP.end);
    this.blockDepth -= 2;
    return bytes;
  }

  // ─── Expression compilation ───

  compileExpr(node) {
    switch (node.type) {
      case 'NumberLiteral': return this.compileNumber(node);
      case 'BooleanLiteral': return [OP.i32_const, ...sleb128(node.value ? 1 : 0)];
      case 'Identifier': return this.compileIdentifier(node);
      case 'BinaryExpression': return this.compileBinary(node);
      case 'UnaryExpression': return this.compileUnary(node);
      case 'CallExpression': return this.compileCall(node);
      case 'IfStatement': return this.compileIfExpr(node);
      case 'LogicalExpression': return this.compileLogical(node);
      case 'BlockStatement': return this.compileBlockAsValue(node);
      default:
        throw new Error(`@wasm: unsupported expression type '${node.type}'`);
    }
  }

  compileNumber(node) {
    const val = node.value;
    if (Number.isInteger(val) && val >= -2147483648 && val <= 2147483647) {
      return [OP.i32_const, ...sleb128(val)];
    }
    return [OP.f64_const, ...encodeF64(val)];
  }

  compileIdentifier(node) {
    const name = node.name;
    const idx = this.getLocal(name);
    if (idx === undefined) throw new Error(`@wasm: undefined variable '${name}'`);
    return [OP.local_get, ...uleb128(idx)];
  }

  compileBinary(node) {
    const lt = this.inferType(node.left);
    const rt = this.inferType(node.right);
    const t = (lt === F64 || rt === F64) ? F64 : I32;

    const bytes = [];
    bytes.push(...this.compileExpr(node.left));
    if (t === F64 && lt === I32) bytes.push(OP.f64_convert_i32_s);
    bytes.push(...this.compileExpr(node.right));
    if (t === F64 && rt === I32) bytes.push(OP.f64_convert_i32_s);

    switch (node.operator) {
      case '+': bytes.push(t === F64 ? OP.f64_add : OP.i32_add); break;
      case '-': bytes.push(t === F64 ? OP.f64_sub : OP.i32_sub); break;
      case '*': bytes.push(t === F64 ? OP.f64_mul : OP.i32_mul); break;
      case '/': bytes.push(t === F64 ? OP.f64_div : OP.i32_div_s); break;
      case '%': bytes.push(OP.i32_rem_s); break;
      case '==': bytes.push(t === F64 ? OP.f64_eq : OP.i32_eq); break;
      case '!=': bytes.push(t === F64 ? OP.f64_ne : OP.i32_ne); break;
      case '<': bytes.push(t === F64 ? OP.f64_lt : OP.i32_lt_s); break;
      case '>': bytes.push(t === F64 ? OP.f64_gt : OP.i32_gt_s); break;
      case '<=': bytes.push(t === F64 ? OP.f64_le : OP.i32_le_s); break;
      case '>=': bytes.push(t === F64 ? OP.f64_ge : OP.i32_ge_s); break;
      default:
        throw new Error(`@wasm: unsupported binary operator '${node.operator}'`);
    }
    return bytes;
  }

  compileUnary(node) {
    switch (node.operator) {
      case '-': {
        const t = this.inferType(node.operand);
        if (t === F64) {
          return [...this.compileExpr(node.operand), OP.f64_neg];
        }
        return [OP.i32_const, ...sleb128(0), ...this.compileExpr(node.operand), OP.i32_sub];
      }
      case 'not': case '!':
        return [...this.compileExpr(node.operand), OP.i32_eqz];
      default:
        throw new Error(`@wasm: unsupported unary operator '${node.operator}'`);
    }
  }

  compileCall(node) {
    const name = node.callee.name;
    if (!name) throw new Error('@wasm: only direct function calls are supported');
    const funcIdx = this.funcNameMap[name];
    if (funcIdx === undefined) throw new Error(`@wasm: undefined function '${name}'`);
    const bytes = [];
    for (const arg of node.arguments) bytes.push(...this.compileExpr(arg));
    bytes.push(OP.call, ...uleb128(funcIdx));
    return bytes;
  }

  compileLogical(node) {
    const bytes = [];
    if (node.operator === 'and' || node.operator === '&&') {
      bytes.push(...this.compileExpr(node.left));
      bytes.push(OP.if, I32);
      bytes.push(...this.compileExpr(node.right));
      bytes.push(OP.else, OP.i32_const, ...sleb128(0));
      bytes.push(OP.end);
    } else {
      bytes.push(...this.compileExpr(node.left));
      bytes.push(OP.if, I32);
      bytes.push(OP.i32_const, ...sleb128(1));
      bytes.push(OP.else);
      bytes.push(...this.compileExpr(node.right));
      bytes.push(OP.end);
    }
    return bytes;
  }

  // ─── Type inference ───

  inferType(node) {
    if (!node) return I32;
    switch (node.type) {
      case 'NumberLiteral':
        return (Number.isInteger(node.value) && node.value >= -2147483648 && node.value <= 2147483647) ? I32 : F64;
      case 'BooleanLiteral': return I32;
      case 'Identifier': return this.typeOf(node.name);
      case 'BinaryExpression': {
        if (['==', '!=', '<', '>', '<=', '>='].includes(node.operator)) return I32;
        const lt = this.inferType(node.left);
        const rt = this.inferType(node.right);
        return (lt === F64 || rt === F64) ? F64 : I32;
      }
      case 'UnaryExpression': return this.inferType(node.operand);
      case 'CallExpression': return this.returnType || I32;
      default: return I32;
    }
  }
}

// Generate JS glue code for a @wasm function
function generateWasmGlue(funcNode, wasmBytes) {
  const bytesStr = Array.from(wasmBytes).join(',');
  const name = funcNode.name;
  return `const ${name} = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([${bytesStr}]))).exports.${name};`;
}

// Generate a module-level constant holding the raw WASM bytes for runtime use
function generateWasmBytesExport(funcName, wasmBytes) {
  const bytesStr = Array.from(wasmBytes).join(',');
  return `const __wasm_bytes_${funcName} = new Uint8Array([${bytesStr}]);`;
}

// Generate JS glue code for a multi-function WASM module
function generateMultiWasmGlue(funcNodes, wasmBytes) {
  const bytesStr = Array.from(wasmBytes).join(',');
  const names = funcNodes.map(f => f.name);
  return `const { ${names.join(', ')} } = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([${bytesStr}]))).exports;`;
}

// ─── src/codegen/base-codegen.js ───────────────────────

// Base code generation utilities shared across all codegen targets
class BaseCodegen {
  constructor() {
    this.indent = 0;
    this._counter = 0;
    this._scopes = [new Set()]; // scope stack for tracking declared variables
    this._visibleNames = new Set(); // flattened view of all declared names for O(1) lookup
    this._nameRefCount = new Map(); // name -> count of scopes declaring it (for O(1) popScope)
    this._needsContainsHelper = false; // track if __contains helper is needed
    this._needsPropagateHelper = false; // track if __propagate helper is needed
    this._usedBuiltins = new Set(); // track which stdlib builtins are actually used
    this._userDefinedNames = new Set(); // track user-defined top-level names (to avoid stdlib conflicts)
    this._needsResultOption = false; // track if Ok/Err/Some/None are used
    this._variantFields = { 'Ok': ['value'], 'Err': ['error'], 'Some': ['value'] }; // map variant name -> [field names] for pattern destructuring
    this._traitDecls = new Map(); // traitName -> { methods: [...] }
    this._traitImpls = new Map(); // "TraitName:TypeName" -> ImplDeclaration node
    // Source map tracking
    this._sourceMapsEnabled = true; // can be disabled for REPL/check mode
    this._propagateCache = new WeakMap(); // memoize _containsPropagate()
    this._yieldCache = new WeakMap(); // memoize _containsYield()
    this._sourceMappings = []; // {sourceLine, sourceCol, outputLine, outputCol, sourceFile?}
    this._outputLineCount = 0;
    this._sourceFile = null; // current source file for multi-file source maps
    // @wasm function tracking for concurrent block WASM routing
    this._wasmFunctions = new Map(); // funcName -> { node, wasmBytes }
    this._needsRuntimeBridge = false; // set true when concurrent block uses WASM tasks
    // @fast mode for TypedArray optimization
    this._fastMode = false;
    this._typedArrayParams = new Map(); // paramName -> 'Float64Array' | 'Int32Array' | 'Uint8Array'
    this._typedArrayLocals = new Map(); // varName -> 'Float64Array' | 'Int32Array' | 'Uint8Array'
  }

  static TYPED_ARRAY_MAP = {
    'Int': 'Int32Array',
    'Float': 'Float64Array',
    'Byte': 'Uint8Array',
    'Int8': 'Int8Array',
    'Int16': 'Int16Array',
    'Int32': 'Int32Array',
    'Uint8': 'Uint8Array',
    'Uint16': 'Uint16Array',
    'Uint32': 'Uint32Array',
    'Float32': 'Float32Array',
    'Float64': 'Float64Array',
  };

  _uid() {
    return this._counter++;
  }

  // Returns true for AST nodes with no side effects that are safe to evaluate multiple times
  _isSimpleExpression(node) {
    if (!node) return false;
    switch (node.type) {
      case 'Identifier':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return true;
      case 'MemberExpression':
        return !node.computed && this._isSimpleExpression(node.object);
      default:
        return false;
    }
  }

  // Check if an AST expression references a given variable name
  _exprReferencesName(node, name) {
    if (!node) return false;
    switch (node.type) {
      case 'Identifier': return node.name === name;
      case 'BinaryExpression':
      case 'LogicalExpression':
        return this._exprReferencesName(node.left, name) || this._exprReferencesName(node.right, name);
      case 'UnaryExpression':
        return this._exprReferencesName(node.operand, name);
      case 'CallExpression':
        return this._exprReferencesName(node.callee, name) || node.arguments.some(a => this._exprReferencesName(a, name));
      case 'MemberExpression':
        return this._exprReferencesName(node.object, name) || (node.computed && this._exprReferencesName(node.property, name));
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return false;
      default:
        return true; // conservative: assume it references the name
    }
  }

  // Known void/side-effect-only calls that shouldn't be implicitly returned
  static VOID_FNS = new Set(['print', 'assert', 'assert_eq', 'assert_ne']);
  _isVoidCall(expr) {
    if (expr.type !== 'CallExpression') return false;
    if (expr.callee.type === 'Identifier') {
      return BaseCodegen.VOID_FNS.has(expr.callee.name);
    }
    return false;
  }

  // ─── Scope tracking ─────────────────────────────────────────

  pushScope() {
    this._scopes.push(new Set());
  }

  popScope() {
    const removed = this._scopes.pop();
    // O(n) cleanup using reference counts instead of O(n*m) scope search
    for (const name of removed) {
      const rc = this._nameRefCount.get(name) - 1;
      if (rc <= 0) {
        this._nameRefCount.delete(name);
        this._visibleNames.delete(name);
      } else {
        this._nameRefCount.set(name, rc);
      }
    }
  }

  declareVar(name) {
    this._scopes[this._scopes.length - 1].add(name);
    this._visibleNames.add(name);
    this._nameRefCount.set(name, (this._nameRefCount.get(name) || 0) + 1);
  }

  isDeclared(name) {
    return this._visibleNames.has(name);
  }

  // ─── Helpers ────────────────────────────────────────────────

  i() {
    return '  '.repeat(this.indent);
  }

  // Set current source file for multi-file source map tracking
  setSourceFile(filename) {
    this._sourceFile = filename;
  }

  // Source map: record a mapping from source location to output line
  _addMapping(node, outputLine) {
    if (!this._sourceMapsEnabled) return;
    if (node && node.loc && node.loc.line) {
      const mapping = {
        sourceLine: node.loc.line - 1, // 0-based
        sourceCol: (node.loc.column || 1) - 1, // 0-based
        outputLine,
        outputCol: this.indent * 2, // approximate column from indent
      };
      if (this._sourceFile) mapping.sourceFile = this._sourceFile;
      this._sourceMappings.push(mapping);
    }
  }

  // Count newlines in a generated string to update output line tracking
  _countLines(code) {
    if (!code) return 0;
    let count = 0;
    for (let i = 0; i < code.length; i++) {
      if (code.charCodeAt(i) === 10) count++;
    }
    return count;
  }

  // Get collected source mappings
  getSourceMappings() {
    return this._sourceMappings;
  }

  getUsedBuiltins() {
    // Exclude builtins that the user has redefined at top level
    if (this._userDefinedNames.size > 0) {
      const filtered = new Set(this._usedBuiltins);
      for (const name of this._userDefinedNames) {
        filtered.delete(name);
      }
      return filtered;
    }
    return this._usedBuiltins;
  }

  // Track a builtin and its transitive dependencies from the stdlib dependency graph
  _trackBuiltin(name) {
    this._usedBuiltins.add(name);
    const deps = STDLIB_DEPS[name];
    if (deps) {
      for (const dep of deps) {
        this._usedBuiltins.add(dep);
      }
    }
  }

  getContainsHelper() {
    return [
      'function __contains(col, val) {',
      '  if (Array.isArray(col) || typeof col === \'string\') return col.includes(val);',
      '  if (col instanceof Set || col instanceof Map) return col.has(val);',
      '  if (typeof col === \'object\' && col !== null) return val in col;',
      '  return false;',
      '}',
    ].join('\n');
  }

  genPropagateExpression(node) {
    this._needsPropagateHelper = true;
    return `__propagate(${this.genExpression(node.expression)})`;
  }

  _containsPropagate(node) {
    if (!node) return false;
    if (node.type === 'PropagateExpression') return true;
    if (node.type === 'FunctionDeclaration' || node.type === 'LambdaExpression') return false;
    const cached = this._propagateCache.get(node);
    if (cached !== undefined) return cached;
    let result = false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsPropagate(item)) { result = true; break; }
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsPropagate(val)) { result = true; break; }
      }
      if (result) break;
    }
    this._propagateCache.set(node, result);
    return result;
  }

  getPropagateHelper() {
    return PROPAGATE;
  }

  getResultOptionHelper() {
    return RESULT_OPTION;
  }

  getStringProtoHelper() {
    return '// String methods are now standalone stdlib functions';
  }

  generateStatement(node) {
    if (!node) return '';

    // Record source mapping before generating (skip when source maps disabled)
    if (this._sourceMapsEnabled) this._addMapping(node, this._outputLineCount);

    let result;
    switch (node.type) {
      case 'Assignment': result = this.genAssignment(node); break;
      case 'VarDeclaration': result = this.genVarDeclaration(node); break;
      case 'LetDestructure': result = this.genLetDestructure(node); break;
      case 'FunctionDeclaration': result = this.genFunctionDeclaration(node); break;
      case 'TypeDeclaration': result = this.genTypeDeclaration(node); break;
      case 'ImportDeclaration': result = this.genImport(node); break;
      case 'ImportDefault': result = this.genImportDefault(node); break;
      case 'ImportWildcard': result = this.genImportWildcard(node); break;
      case 'IfStatement': result = this.genIfStatement(node); break;
      case 'ForStatement': result = this.genForStatement(node); break;
      case 'WhileStatement': result = this.genWhileStatement(node); break;
      case 'LoopStatement': result = this.genLoopStatement(node); break;
      case 'TryCatchStatement': result = this.genTryCatchStatement(node); break;
      case 'ReturnStatement': result = this.genReturnStatement(node); break;
      case 'ExpressionStatement': result = `${this.i()}${this.genExpression(node.expression)};`; break;
      case 'BlockStatement': result = this.genBlock(node); break;
      case 'CompoundAssignment': result = this.genCompoundAssignment(node); break;
      case 'BreakStatement': result = node.label ? `${this.i()}break ${node.label};` : `${this.i()}break;`; break;
      case 'ContinueStatement': result = node.label ? `${this.i()}continue ${node.label};` : `${this.i()}continue;`; break;
      case 'GuardStatement': result = this.genGuardStatement(node); break;
      case 'InterfaceDeclaration': result = this.genInterfaceDeclaration(node); break;
      case 'ImplDeclaration': result = this.genImplDeclaration(node); break;
      case 'TraitDeclaration': result = this.genTraitDeclaration(node); break;
      case 'TypeAlias': result = this.genTypeAlias(node); break;
      case 'DeferStatement': result = this.genDeferStatement(node); break;
      case 'WithStatement': result = this.genWithStatement(node); break;
      case 'ConcurrentBlock': result = this.genConcurrentBlock(node); break;
      case 'SelectStatement': result = this.genSelectStatement(node); break;
      case 'ExternDeclaration': result = `${this.i()}// extern: ${node.name}`; break;
      // Config declarations handled at block level — emit nothing in statement context
      case 'AiConfigDeclaration': result = ''; break;
      case 'DataBlock': result = ''; break;
      case 'SourceDeclaration': result = ''; break;
      case 'PipelineDeclaration': result = ''; break;
      case 'ValidateBlock': result = ''; break;
      case 'FormDeclaration': result = ''; break;
      case 'RefreshPolicy': result = ''; break;
      case 'RefinementType': result = this.genRefinementType(node); break;
      default:
        result = `${this.i()}${this.genExpression(node)};`;
    }

    // Track output line count using fast character scan (skip when source maps disabled)
    if (this._sourceMapsEnabled && result) {
      this._outputLineCount += this._countLines(result) + 1; // +1 for the join newline
    }

    return result;
  }

  genExpression(node) {
    if (!node) return 'undefined';

    switch (node.type) {
      case 'Identifier':
        // Parameter substitution for map chain fusion
        if (this._paramSubstitutions && this._paramSubstitutions.has(node.name)) {
          return this._paramSubstitutions.get(node.name);
        }
        // Track builtin identifier usage (e.g., None used without call)
        if (BUILTIN_NAMES.has(node.name)) {
          this._usedBuiltins.add(node.name);
        }
        if (node.name === 'Ok' || node.name === 'Err' || node.name === 'Some' || node.name === 'None') {
          this._needsResultOption = true;
        }
        return node.name === '_' ? '_' : node.name;
      case 'NumberLiteral': return String(node.value);
      case 'StringLiteral': return JSON.stringify(node.value);
      case 'BooleanLiteral': return String(node.value);
      case 'NilLiteral': return 'null';
      case 'RegexLiteral': return `/${node.pattern}/${node.flags}`;
      case 'TemplateLiteral': return this.genTemplateLiteral(node);
      case 'BinaryExpression': return this.genBinaryExpression(node);
      case 'UnaryExpression': return this.genUnaryExpression(node);
      case 'LogicalExpression': return this.genLogicalExpression(node);
      case 'ChainedComparison': return this.genChainedComparison(node);
      case 'MembershipExpression': return this.genMembershipExpression(node);
      case 'IsExpression': return this.genIsExpression(node);
      case 'CallExpression': return this.genCallExpression(node);
      case 'MemberExpression': return this.genMemberExpression(node);
      case 'OptionalChain': return this.genOptionalChain(node);
      case 'PipeExpression': return this.genPipeExpression(node);
      case 'LambdaExpression': return this.genLambdaExpression(node);
      case 'MatchExpression': return this.genMatchExpression(node);
      case 'IfExpression': return this.genIfExpression(node);
      case 'ArrayLiteral': return this.genArrayLiteral(node);
      case 'ObjectLiteral': return this.genObjectLiteral(node);
      case 'ListComprehension': return this.genListComprehension(node);
      case 'DictComprehension': return this.genDictComprehension(node);
      case 'RangeExpression': return this.genRangeExpression(node);
      case 'SliceExpression': return this.genSliceExpression(node);
      case 'SpreadExpression': return `...${this.genExpression(node.argument)}`;
      case 'PropagateExpression': return this.genPropagateExpression(node);
      case 'NamedArgument': return this.genExpression(node.value);
      case 'AwaitExpression': return `(await ${this.genExpression(node.argument)})`;
      case 'YieldExpression': return node.delegate ? `(yield* ${this.genExpression(node.argument)})` : `(yield ${this.genExpression(node.argument)})`;
      case 'TupleExpression': return `[${node.elements.map(e => this.genExpression(e)).join(', ')}]`;
      // Column expressions (for table operations)
      case 'ColumnExpression': return this.genColumnExpression(node);
      case 'ColumnAssignment': return this.genColumnAssignment(node);
      case 'NegatedColumnExpression': return `{ __exclude: ${JSON.stringify(node.name)} }`;
      case 'SpawnExpression': return this.genSpawnExpression(node);
      default:
        throw new Error(`Codegen: unknown expression type '${node.type}'`);
    }
  }

  // ─── Statements ───────────────────────────────────────────

  genAssignment(node) {
    const exportPrefix = node.isPublic ? 'export ' : '';
    if (node.targets.length === 1 && node.values.length === 1) {
      const target = node.targets[0];
      const value = node.values[0];
      // Member expression target: obj.x = expr, arr[i] = expr
      if (typeof target === 'object' && target.type === 'MemberExpression') {
        // IIFE elimination: match/if on RHS of member assignment
        if (this._needsIIFE(value)) {
          const memberExpr = this.genExpression(target);
          const lines = [];
          if (value.type === 'MatchExpression') {
            lines.push(this._genMatchAssign(value, memberExpr));
          } else {
            lines.push(this._genIfAssign(value, memberExpr));
          }
          return lines.join('\n');
        }
        return `${this.i()}${this.genExpression(target)} = ${this.genExpression(value)};`;
      }
      if (target === '_') {
        return `${this.i()}${this.genExpression(value)};`;
      }
      if (this.isDeclared(target)) {
        // Reassignment to an already-declared variable (must be mutable)
        // IIFE elimination: match/if on RHS of reassignment (skip if binding conflicts)
        if (this._needsIIFE(value) && !this._matchBindingsConflict(value, target)) {
          if (value.type === 'MatchExpression') {
            return this._genMatchAssign(value, target);
          } else {
            return this._genIfAssign(value, target);
          }
        }
        return `${this.i()}${target} = ${this.genExpression(value)};`;
      }
      this.declareVar(target);
      // Track top-level user definitions to avoid stdlib conflicts
      if (this._scopes.length === 1 && BUILTIN_NAMES.has(target)) {
        this._userDefinedNames.add(target);
      }
      // @fast mode: track typed array local variables for loop optimization
      if (this._fastMode && this._typedArrayLocals) {
        const taType = this._detectTypedArrayExpr(value);
        if (taType) this._typedArrayLocals.set(target, taType);
      }
      // IIFE elimination: match/if on RHS of new const declaration (skip if binding conflicts)
      if (this._needsIIFE(value) && !this._matchBindingsConflict(value, target)) {
        const lines = [];
        lines.push(`${this.i()}${exportPrefix}let ${target};`);
        if (value.type === 'MatchExpression') {
          lines.push(this._genMatchAssign(value, target));
        } else {
          lines.push(this._genIfAssign(value, target));
        }
        return lines.join('\n');
      }
      return `${this.i()}${exportPrefix}const ${target} = ${this.genExpression(value)};`;
    }

    // Multiple assignment: a, b = 1, 2 (uses destructuring for atomicity)
    const vals = node.values.map(v => this.genExpression(v));
    const allDeclared = node.targets.every(t => this.isDeclared(t));
    const noneDeclared = node.targets.every(t => !this.isDeclared(t));

    if (allDeclared) {
      // Reassignment (e.g., swap): [a, b] = [v1, v2]
      return `${this.i()}[${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    if (noneDeclared) {
      // New declarations: const [a, b] = [v1, v2]
      for (const t of node.targets) this.declareVar(t);
      return `${this.i()}${exportPrefix}const [${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    // Mixed: some declared, some new — generate individual assignments
    const lines = [];
    const tempArr = `__tmp_${this._uid()}`;
    lines.push(`${this.i()}const ${tempArr} = [${vals.join(', ')}];`);
    for (let idx = 0; idx < node.targets.length; idx++) {
      const t = node.targets[idx];
      if (this.isDeclared(t)) {
        lines.push(`${this.i()}${t} = ${tempArr}[${idx}];`);
      } else {
        this.declareVar(t);
        lines.push(`${this.i()}const ${t} = ${tempArr}[${idx}];`);
      }
    }
    return lines.join('\n');
  }

  genVarDeclaration(node) {
    const exportPrefix = node.isPublic ? 'export ' : '';
    if (node.targets.length === 1 && node.values.length === 1) {
      const target = node.targets[0];
      const value = node.values[0];
      this.declareVar(target);
      // IIFE elimination for var declarations too (skip if binding conflicts)
      if (this._needsIIFE(value) && !this._matchBindingsConflict(value, target)) {
        const lines = [];
        lines.push(`${this.i()}${exportPrefix}let ${target};`);
        if (value.type === 'MatchExpression') {
          lines.push(this._genMatchAssign(value, target));
        } else {
          lines.push(this._genIfAssign(value, target));
        }
        return lines.join('\n');
      }
      return `${this.i()}${exportPrefix}let ${target} = ${this.genExpression(value)};`;
    }
    const lines = [];
    for (let idx = 0; idx < node.targets.length; idx++) {
      this.declareVar(node.targets[idx]);
      const val = idx < node.values.length ? node.values[idx] : node.values[node.values.length - 1];
      lines.push(`${this.i()}${exportPrefix}let ${node.targets[idx]} = ${this.genExpression(val)};`);
    }
    return lines.join('\n');
  }

  genLetDestructure(node) {
    if (node.pattern.type === 'ObjectPattern') {
      for (const p of node.pattern.properties) this.declareVar(p.value);
      const props = node.pattern.properties.map(p => {
        let str = p.key;
        if (p.value !== p.key) str += `: ${p.value}`;
        if (p.defaultValue) str += ` = ${this.genExpression(p.defaultValue)}`;
        return str;
      }).join(', ');
      return `${this.i()}const { ${props} } = ${this.genExpression(node.value)};`;
    }
    if (node.pattern.type === 'ArrayPattern' || node.pattern.type === 'TuplePattern') {
      for (const e of node.pattern.elements) {
        if (e) this.declareVar(e.startsWith('...') ? e.slice(3) : e);
      }
      const els = node.pattern.elements.map(e => e || '').join(', ');
      return `${this.i()}const [${els}] = ${this.genExpression(node.value)};`;
    }
    return '';
  }

  genFunctionDeclaration(node) {
    // Check for @wasm decorator — compile to WebAssembly
    if (node.decorators && node.decorators.some(d => d.name === 'wasm')) {
      return this.genWasmFunction(node);
    }
    // Check for @fast decorator — enable TypedArray optimizations
    const isFast = node.decorators && node.decorators.some(d => d.name === 'fast');
    const prevFastMode = this._fastMode;
    const prevTypedParams = this._typedArrayParams;
    const prevTypedLocals = this._typedArrayLocals;
    if (isFast) {
      this._fastMode = true;
      this._typedArrayParams = new Map();
      this._typedArrayLocals = new Map(); // track locally-created typed arrays
      // Scan params for typed array annotations: param: [Int], param: [Float], param: [Byte]
      for (const p of node.params) {
        if (p.typeAnnotation && p.typeAnnotation.type === 'ArrayTypeAnnotation' && p.typeAnnotation.elementType) {
          const elemName = p.typeAnnotation.elementType.name;
          const typedArrayType = BaseCodegen.TYPED_ARRAY_MAP[elemName];
          if (typedArrayType) {
            this._typedArrayParams.set(p.name, typedArrayType);
          }
        }
      }
    }
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const isGenerator = this._containsYield(node.body);
    const exportPrefix = node.isPublic ? 'export ' : '';
    const asyncPrefix = node.isAsync ? 'async ' : '';
    const genStar = isGenerator ? '*' : '';
    this.pushScope();
    for (const p of node.params) {
      if (p.destructure) {
        this._declareDestructureVars(p.destructure);
      } else {
        this.declareVar(p.name);
      }
    }
    const body = this.genBlockBody(node.body);
    this.popScope();
    const lines = [];
    lines.push(`${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {`);
    // In @fast mode, convert typed array params at function entry
    if (isFast && this._typedArrayParams.size > 0) {
      for (const [pName, taType] of this._typedArrayParams) {
        lines.push(`${this.i()}  ${pName} = ${pName} instanceof ${taType} ? ${pName} : new ${taType}(${pName});`);
      }
    }
    if (hasPropagate) {
      lines.push(`${this.i()}  try {`);
      lines.push(body);
      lines.push(`${this.i()}  } catch (__e) {`);
      lines.push(`${this.i()}    if (__e && __e.__tova_propagate) return __e.value;`);
      lines.push(`${this.i()}    throw __e;`);
      lines.push(`${this.i()}  }`);
    } else {
      lines.push(body);
    }
    lines.push(`${this.i()}}`);
    // Restore @fast state
    if (isFast) {
      this._fastMode = prevFastMode;
      this._typedArrayParams = prevTypedParams;
      this._typedArrayLocals = prevTypedLocals;
    }
    return lines.join('\n');
  }

  genWasmFunction(node) {
    try {
      // Track as user-defined to suppress stdlib version
      if (BUILTIN_NAMES.has(node.name)) this._userDefinedNames.add(node.name);
      const wasmBytes = compileWasmFunction(node);
      // Track this WASM function for concurrent block routing
      this._wasmFunctions.set(node.name, { node, wasmBytes });
      const exportPrefix = node.isPublic ? 'export ' : '';
      // Emit bytes constant first, then glue that references it (avoids duplication)
      const bytesExport = generateWasmBytesExport(node.name, wasmBytes);
      const name = node.name;
      const glue = `const ${name} = new WebAssembly.Instance(new WebAssembly.Module(__wasm_bytes_${name})).exports.${name};`;
      return `${this.i()}${bytesExport}\n${this.i()}${exportPrefix}${glue}`;
    } catch (e) {
      // Fall back to JS if WASM compilation fails
      console.error(`Warning: @wasm compilation failed for '${node.name}': ${e.message}. Falling back to JS.`);
      node.decorators = node.decorators.filter(d => d.name !== 'wasm');
      return this.genFunctionDeclaration(node);
    }
  }

  genParams(params) {
    return params.map(p => {
      if (p.destructure) {
        if (p.destructure.type === 'ObjectPattern') {
          const props = p.destructure.properties.map(prop => {
            let str = prop.key;
            if (prop.value !== prop.key) str += `: ${prop.value}`;
            if (prop.defaultValue) str += ` = ${this.genExpression(prop.defaultValue)}`;
            return str;
          }).join(', ');
          return `{ ${props} }`;
        }
        if (p.destructure.type === 'ArrayPattern' || p.destructure.type === 'TuplePattern') {
          return `[${p.destructure.elements.join(', ')}]`;
        }
      }
      if (p.defaultValue) {
        return `${p.name} = ${this.genExpression(p.defaultValue)}`;
      }
      return p.name;
    }).join(', ');
  }

  genImport(node) {
    for (const s of node.specifiers) this.declareVar(s.local);
    const specs = node.specifiers.map(s => {
      if (s.imported !== s.local) return `${s.imported} as ${s.local}`;
      return s.imported;
    }).join(', ');
    return `${this.i()}import { ${specs} } from ${JSON.stringify(node.source)};`;
  }

  genImportDefault(node) {
    this.declareVar(node.local);
    return `${this.i()}import ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genImportWildcard(node) {
    this.declareVar(node.local);
    return `${this.i()}import * as ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genIfStatement(node) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.consequent));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      this.indent++;
      this.pushScope();
      p.push(this.genBlockStatements(alt.body));
      this.popScope();
      this.indent--;
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      this.indent++;
      this.pushScope();
      p.push(this.genBlockStatements(node.elseBody));
      this.popScope();
      this.indent--;
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  // Check if a for-loop over a range can be emitted as a C-style for loop
  _isRangeForOptimizable(node) {
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    if (vars.length !== 1 || typeof vars[0] !== 'string' || node.isAsync || node.elseBody) return false;
    if (node.iterable.type === 'RangeExpression') return true;
    // Optimize for i in range(n) / range(start, end) / range(start, end, step)
    if (node.iterable.type === 'CallExpression' &&
        node.iterable.callee.type === 'Identifier' &&
        node.iterable.callee.name === 'range' &&
        node.iterable.arguments.length >= 1 && node.iterable.arguments.length <= 3) return true;
    return false;
  }

  // @fast mode: detect if an expression produces a TypedArray
  // Returns the TypedArray type string (e.g. 'Float64Array') or null
  _detectTypedArrayExpr(value) {
    if (!value) return null;
    // Type.new(n) → new Type(n), where Type is a TypedArray
    if (value.type === 'MethodCall' && value.methodName === 'new' &&
        value.object && value.object.type === 'Identifier') {
      const taType = BaseCodegen.TYPED_ARRAY_MAP[value.object.name];
      if (taType) return taType;
      // Direct TypedArray names: Float64Array.new(n)
      if (Object.values(BaseCodegen.TYPED_ARRAY_MAP).includes(value.object.name)) return value.object.name;
    }
    // typed_add/typed_scale/typed_map/typed_sort return same type as input
    if (value.type === 'CallExpression' && value.callee && value.callee.type === 'Identifier') {
      const fname = value.callee.name;
      if (['typed_add', 'typed_scale', 'typed_map', 'typed_sort'].includes(fname)) {
        return 'Float64Array'; // conservative default
      }
      // typed_linspace returns Float64Array
      if (fname === 'typed_linspace') return 'Float64Array';
    }
    return null;
  }

  // @fast mode: check if a for-loop iterates over a known typed array
  // Returns the TypedArray type or null
  _getTypedArrayIterable(node) {
    if (!this._fastMode) return null;
    const iter = node.iterable;
    if (iter.type !== 'Identifier') return null;
    const name = iter.name;
    return this._typedArrayParams.get(name) || (this._typedArrayLocals && this._typedArrayLocals.get(name)) || null;
  }

  genForStatement(node) {
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    const labelPrefix = node.label ? `${node.label}: ` : '';
    const awaitKeyword = node.isAsync ? ' await' : '';

    // Optimization: for i in start..end => C-style for loop (avoids array allocation)
    if (this._isRangeForOptimizable(node)) {
      const varName = vars[0];
      let start, end, step, cmpOp;

      if (node.iterable.type === 'RangeExpression') {
        start = this.genExpression(node.iterable.start);
        end = this.genExpression(node.iterable.end);
        cmpOp = node.iterable.inclusive ? '<=' : '<';
        step = null;
      } else {
        // range(n) / range(start, end) / range(start, end, step)
        const args = node.iterable.arguments;
        if (args.length === 1) {
          start = '0';
          end = this.genExpression(args[0]);
          cmpOp = '<';
        } else if (args.length === 2) {
          start = this.genExpression(args[0]);
          end = this.genExpression(args[1]);
          cmpOp = '<';
        } else {
          start = this.genExpression(args[0]);
          end = this.genExpression(args[1]);
          step = this.genExpression(args[2]);
          cmpOp = '<';
        }
      }

      this.pushScope();
      this.declareVar(varName);
      const p = [];
      if (step) {
        // With explicit step: need to handle positive and negative step
        const stepVar = `__step_${this._uid()}`;
        p.push(`${this.i()}${labelPrefix}{ const ${stepVar} = ${step};\n`);
        p.push(`${this.i()}for (let ${varName} = ${start}; ${stepVar} > 0 ? ${varName} < ${end} : ${varName} > ${end}; ${varName} += ${stepVar}) {\n`);
      } else {
        p.push(`${this.i()}${labelPrefix}for (let ${varName} = ${start}; ${varName} ${cmpOp} ${end}; ${varName}++) {\n`);
      }
      this.indent++;
      if (node.guard) {
        p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
      }
      p.push(this.genBlockStatements(node.body));
      this.indent--;
      p.push(`\n${this.i()}}`);
      if (step) p.push(`\n${this.i()}}`);
      this.popScope();
      return p.join('');
    }

    // @fast mode optimization: for val in typedArray => index-based loop (avoids iterator overhead)
    if (vars.length === 1 && !node.isAsync && !node.elseBody) {
      const taType = this._getTypedArrayIterable(node);
      if (taType) {
        const varName = vars[0];
        const arrName = node.iterable.name;
        const idxVar = `__i_${this._uid()}`;
        this.pushScope();
        this.declareVar(varName);
        const p = [];
        p.push(`${this.i()}${labelPrefix}for (let ${idxVar} = 0; ${idxVar} < ${arrName}.length; ${idxVar}++) {\n`);
        this.indent++;
        p.push(`${this.i()}const ${varName} = ${arrName}[${idxVar}];\n`);
        if (node.guard) {
          p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
        }
        p.push(this.genBlockStatements(node.body));
        this.indent--;
        p.push(`\n${this.i()}}`);
        this.popScope();
        return p.join('');
      }
    }

    const iterExpr = this.genExpression(node.iterable);

    if (node.elseBody) {
      // for-else: run else if iterable was empty
      const tempVar = `__iter_${this._uid()}`;
      const enteredVar = `__entered_${this._uid()}`;
      const p = [];
      p.push(`${this.i()}{\n`);
      this.indent++;
      p.push(`${this.i()}const ${tempVar} = ${iterExpr};\n`);
      p.push(`${this.i()}let ${enteredVar} = false;\n`);
      this.pushScope();
      for (const v of vars) this.declareVar(v);
      if (vars.length === 2) {
        p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const [${vars[0]}, ${vars[1]}] of ${tempVar}) {\n`);
      } else {
        p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const ${vars[0]} of ${tempVar}) {\n`);
      }
      this.indent++;
      p.push(`${this.i()}${enteredVar} = true;\n`);
      if (node.guard) {
        p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
      }
      p.push(this.genBlockStatements(node.body));
      this.indent--;
      p.push(`\n${this.i()}}\n`);
      this.popScope();
      this.pushScope();
      p.push(`${this.i()}if (!${enteredVar}) {\n`);
      this.indent++;
      p.push(this.genBlockStatements(node.elseBody));
      this.indent--;
      p.push(`\n${this.i()}}\n`);
      this.popScope();
      this.indent--;
      p.push(`${this.i()}}`);
      return p.join('');
    }

    this.pushScope();
    for (const v of vars) this.declareVar(v);
    const p = [];
    if (vars.length === 2) {
      p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const [${vars[0]}, ${vars[1]}] of ${iterExpr}) {\n`);
    } else {
      p.push(`${this.i()}${labelPrefix}for${awaitKeyword} (const ${vars[0]} of ${iterExpr}) {\n`);
    }
    this.indent++;
    if (node.guard) {
      p.push(`${this.i()}if (!(${this.genExpression(node.guard)})) continue;\n`);
    }
    p.push(this.genBlockStatements(node.body));
    this.indent--;
    p.push(`\n${this.i()}}`);
    this.popScope();

    return p.join('');
  }

  genWhileStatement(node) {
    const labelPrefix = node.label ? `${node.label}: ` : '';
    const p = [];
    p.push(`${this.i()}${labelPrefix}while (${this.genExpression(node.condition)}) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.body));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genLoopStatement(node) {
    const labelPrefix = node.label ? `${node.label}: ` : '';
    const p = [];
    p.push(`${this.i()}${labelPrefix}while (true) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.body));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genTryCatchStatement(node) {
    const p = [];
    p.push(`${this.i()}try {\n`);
    this.indent++;
    this.pushScope();
    for (const stmt of node.tryBody) {
      p.push(this.generateStatement(stmt) + '\n');
    }
    this.popScope();
    this.indent--;

    if (node.catchBody) {
      const catchVar = node.catchParam || '__err';
      p.push(`${this.i()}} catch (${catchVar}) {\n`);
      this.pushScope();
      this.declareVar(catchVar);
      this.indent++;
      // Re-throw propagation sentinels so ? operator works through user try/catch
      p.push(`${this.i()}if (${catchVar} && ${catchVar}.__tova_propagate) throw ${catchVar};\n`);
      for (const stmt of node.catchBody) {
        p.push(this.generateStatement(stmt) + '\n');
      }
      this.popScope();
      this.indent--;
      p.push(`${this.i()}}`);
    }

    if (node.finallyBody) {
      if (!node.catchBody) {
        // try/finally without catch
        p.push(`${this.i()}}`);
      }
      p.push(` finally {\n`);
      this.indent++;
      this.pushScope();
      for (const stmt of node.finallyBody) {
        p.push(this.generateStatement(stmt) + '\n');
      }
      this.popScope();
      this.indent--;
      p.push(`${this.i()}}`);
    }

    return p.join('');
  }

  genReturnStatement(node) {
    if (node.value) {
      return `${this.i()}return ${this.genExpression(node.value)};`;
    }
    return `${this.i()}return;`;
  }

  genCompoundAssignment(node) {
    return `${this.i()}${this.genExpression(node.target)} ${node.operator} ${this.genExpression(node.value)};`;
  }

  genBlock(node) {
    const p = [];
    p.push(`{\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genBlockBody(block) {
    if (block.type !== 'BlockStatement') {
      this.indent++;
      const code = `${this.i()}return ${this.genExpression(block)};`;
      this.indent--;
      return code;
    }

    this.indent++;
    const stmts = block.body;

    // Collect defer statements and separate them from regular statements
    const regularStmts = [];
    const deferBodies = [];
    for (const stmt of stmts) {
      if (stmt.type === 'DeferStatement') {
        deferBodies.push(stmt.body);
      } else {
        regularStmts.push(stmt);
      }
    }

    const lines = [];

    // If there are defers, wrap in try/finally
    if (deferBodies.length > 0) {
      lines.push(`${this.i()}try {`);
      this.indent++;
    }

    // Pre-scan for array fill patterns in function bodies
    const bodySkipSet = new Set();
    for (let i = 0; i < regularStmts.length - 1; i++) {
      const fillResult = this._detectArrayFillPattern(regularStmts[i], regularStmts[i + 1]);
      if (fillResult) {
        bodySkipSet.add(i);
        bodySkipSet.add(i + 1);
        lines.push(fillResult);
      }
    }

    // Pre-scan for scalar-replaceable Result/Option variables
    const scalarMap = this._preAnalyzeScalarResults(regularStmts);
    const prevScalar = this._scalarReplacements;
    this._scalarReplacements = scalarMap.size > 0 ? new Map([...(prevScalar || new Map()), ...scalarMap]) : prevScalar;

    for (let idx = 0; idx < regularStmts.length; idx++) {
      if (bodySkipSet.has(idx)) continue;
      const stmt = regularStmts[idx];
      const isLast = idx === regularStmts.length - 1;
      // Scalar replacement: emit boolean+value pair instead of Result/Option allocation
      if (stmt.type === 'Assignment' && stmt.targets.length === 1 && typeof stmt.targets[0] === 'string' &&
          scalarMap.has(stmt.targets[0]) && scalarMap.get(stmt.targets[0]).assignIdx === idx) {
        lines.push(this._genScalarAssignment(stmt, scalarMap.get(stmt.targets[0])));
      // Implicit return: last expression in function body
      // Skip implicit return for known void/side-effect-only calls (print, assert, etc.)
      } else if (isLast && stmt.type === 'ExpressionStatement' && !this._isVoidCall(stmt.expression)) {
        // IIFE elimination: match/if as last expression in function body → direct returns
        const expr = stmt.expression;
        if (expr.type === 'MatchExpression' && !this._isSimpleMatch(expr)) {
          lines.push(this._genMatchReturn(expr));
        } else if (expr.type === 'IfExpression' && this._needsIIFE(expr)) {
          lines.push(this._genIfReturn(expr));
        } else {
          lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
        }
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithReturns(stmt));
      } else if (isLast && stmt.type === 'MatchExpression') {
        lines.push(`${this.i()}return ${this.genExpression(stmt)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }

    this._scalarReplacements = prevScalar;

    if (deferBodies.length > 0) {
      this.indent--;
      lines.push(`${this.i()}} finally {`);
      this.indent++;
      // Execute defers in LIFO order
      for (let i = deferBodies.length - 1; i >= 0; i--) {
        const body = deferBodies[i];
        if (body.type === 'BlockStatement') {
          lines.push(this.genBlockStatements(body));
        } else {
          lines.push(`${this.i()}${this.genExpression(body)};`);
        }
      }
      this.indent--;
      lines.push(`${this.i()}}`);
    }

    this.indent--;
    return lines.join('\n');
  }

  _genIfStatementWithReturns(node) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyReturns(node.consequent));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyReturns(alt.body));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyReturns(node.elseBody));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  _genBlockBodyReturns(block) {
    // Like genBlockBody but always adds return to the last statement
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    this.indent++;
    const lines = [];
    for (let idx = 0; idx < stmts.length; idx++) {
      const stmt = stmts[idx];
      const isLast = idx === stmts.length - 1;
      if (isLast && stmt.type === 'ExpressionStatement') {
        lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithReturns(stmt));
      } else if (isLast && stmt.type === 'MatchExpression') {
        lines.push(`${this.i()}return ${this.genExpression(stmt)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }
    this.indent--;
    return lines.join('\n');
  }

  _genBlockBodyAssign(block, targetVar) {
    // Like _genBlockBodyReturns but emits `targetVar = expr` instead of `return expr`
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    this.indent++;
    const lines = [];
    for (let idx = 0; idx < stmts.length; idx++) {
      const stmt = stmts[idx];
      const isLast = idx === stmts.length - 1;
      if (isLast && stmt.type === 'ExpressionStatement') {
        lines.push(`${this.i()}${targetVar} = ${this.genExpression(stmt.expression)};`);
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithAssigns(stmt, targetVar));
      } else if (isLast && stmt.type === 'MatchExpression') {
        // Nested match inside block — generate as assignment too
        lines.push(this._genMatchAssign(stmt, targetVar));
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }
    this.indent--;
    return lines.join('\n');
  }

  _genIfStatementWithAssigns(node, targetVar) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyAssign(node.consequent, targetVar));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyAssign(alt.body, targetVar));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyAssign(node.elseBody, targetVar));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  genBlockStatements(block) {
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    const lines = [];
    const skipSet = new Set(); // indices to skip (consumed by pattern optimizations)
    // Pre-scan for array fill patterns: arr = []; for i in range(n) { arr.push(val) }
    for (let i = 0; i < stmts.length - 1; i++) {
      const fillResult = this._detectArrayFillPattern(stmts[i], stmts[i + 1]);
      if (fillResult) {
        skipSet.add(i);
        skipSet.add(i + 1);
        lines.push(fillResult);
      }
    }
    // Pre-scan for scalar-replaceable Result/Option variables
    const scalarMap = this._preAnalyzeScalarResults(stmts);
    const prevScalar = this._scalarReplacements;
    this._scalarReplacements = scalarMap.size > 0 ? new Map([...(prevScalar || new Map()), ...scalarMap]) : prevScalar;
    for (let i = 0; i < stmts.length; i++) {
      if (skipSet.has(i)) continue;
      const s = stmts[i];
      // Scalar replacement: emit boolean+value pair instead of Result/Option allocation
      if (s.type === 'Assignment' && s.targets.length === 1 && typeof s.targets[0] === 'string' &&
          scalarMap.has(s.targets[0]) && scalarMap.get(s.targets[0]).assignIdx === i) {
        lines.push(this._genScalarAssignment(s, scalarMap.get(s.targets[0])));
      } else {
        lines.push(this.generateStatement(s));
      }
      // Dead code elimination: stop after unconditional return/break/continue
      if (s.type === 'ReturnStatement' || s.type === 'BreakStatement' || s.type === 'ContinueStatement') break;
    }
    this._scalarReplacements = prevScalar;
    return lines.join('\n');
  }

  // Detect pattern: arr = []; for i in range(n) { arr.push(val) }
  // Also handles: var arr = []; for i in range(n) { arr.push(val) }
  // Returns optimized code string or null
  _detectArrayFillPattern(assignStmt, forStmt) {
    // Step 1: Check first statement is `arr = []` or `var arr = []` (empty array)
    let target, isVar = false, exportPrefix = '';
    if (assignStmt.type === 'Assignment') {
      if (assignStmt.targets.length !== 1 || assignStmt.values.length !== 1) return null;
      target = assignStmt.targets[0];
      if (typeof target !== 'string') return null;
      const val = assignStmt.values[0];
      if (val.type !== 'ArrayLiteral' || val.elements.length !== 0) return null;
      exportPrefix = assignStmt.isPublic ? 'export ' : '';
    } else if (assignStmt.type === 'VarDeclaration') {
      if (assignStmt.targets.length !== 1 || assignStmt.values.length !== 1) return null;
      target = assignStmt.targets[0];
      if (typeof target !== 'string') return null;
      const val = assignStmt.values[0];
      if (val.type !== 'ArrayLiteral' || val.elements.length !== 0) return null;
      isVar = true;
      exportPrefix = assignStmt.isPublic ? 'export ' : '';
    } else {
      return null;
    }

    // Step 2: Check second statement is `for _ in range(n) { arr.push(fillVal) }`
    if (forStmt.type !== 'ForStatement') return null;
    if (forStmt.elseBody || forStmt.guard || forStmt.isAsync) return null;
    if (!this._isRangeForOptimizable(forStmt)) return null;

    // Get the range size
    let sizeExpr;
    if (forStmt.iterable.type === 'RangeExpression') {
      return null; // Only handle range(n) for now
    } else {
      const args = forStmt.iterable.arguments;
      if (args.length === 1) {
        sizeExpr = this.genExpression(args[0]);
      } else {
        return null; // range(start, end) / range(start, end, step) — not a simple fill
      }
    }

    // Step 3: Check the body is a single `arr.push(fillVal)` statement
    const body = forStmt.body;
    const bodyStmts = body.type === 'BlockStatement' ? body.body : [body];
    if (bodyStmts.length !== 1) return null;
    const bodyStmt = bodyStmts[0];
    // It should be an ExpressionStatement wrapping a CallExpression
    let callExpr;
    if (bodyStmt.type === 'ExpressionStatement') {
      callExpr = bodyStmt.expression;
    } else if (bodyStmt.type === 'CallExpression') {
      callExpr = bodyStmt;
    } else {
      return null;
    }
    if (callExpr.type !== 'CallExpression') return null;
    if (callExpr.callee.type !== 'MemberExpression') return null;
    if (callExpr.callee.property !== 'push') return null;
    if (callExpr.callee.object.type !== 'Identifier') return null;
    if (callExpr.callee.object.name !== target) return null;
    if (callExpr.arguments.length !== 1) return null;

    const fillArg = callExpr.arguments[0];
    // Ensure the fill value doesn't reference the loop variable (must be a constant fill)
    const loopVar = Array.isArray(forStmt.variable) ? forStmt.variable[0] : forStmt.variable;
    if (this._exprReferencesName(fillArg, loopVar)) return null;
    const fillExpr = this.genExpression(fillArg);

    // Declare the variable
    const isDeclared = this.isDeclared(target);
    if (!isDeclared) {
      this.declareVar(target);
    }
    const declKeyword = isVar ? `${exportPrefix}let ` : (isDeclared ? '' : `${exportPrefix}const `);
    // Boolean fills use Uint8Array for contiguous memory (3x faster for sieve-like patterns)
    if (fillArg.type === 'BooleanLiteral') {
      const fillVal = fillArg.value ? 1 : 0;
      return `${this.i()}${declKeyword}${target} = new Uint8Array(${sizeExpr})${fillVal ? '.fill(1)' : ''};`;
    }
    return `${this.i()}${declKeyword}${target} = new Array(${sizeExpr}).fill(${fillExpr});`;
  }

  // ─── Expressions ──────────────────────────────────────────

  genTemplateLiteral(node) {
    const parts = node.parts.map(p => {
      if (p.type === 'text') {
        return p.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
      }
      return `\${${this.genExpression(p.value)}}`;
    }).join('');
    return `\`${parts}\``;
  }

  genBinaryExpression(node) {
    const op = node.operator;

    // Constant folding: arithmetic on two number literals
    if (node.left.type === 'NumberLiteral' && node.right.type === 'NumberLiteral') {
      const l = node.left.value, r = node.right.value;
      let folded = null;
      switch (op) {
        case '+': folded = l + r; break;
        case '-': folded = l - r; break;
        case '*': folded = l * r; break;
        case '/': if (r !== 0) folded = l / r; break;
        case '%': if (r !== 0) folded = l % r; break;
        case '**': folded = l ** r; break;
      }
      if (folded !== null && Number.isFinite(folded)) {
        return folded < 0 ? `(${folded})` : String(folded);
      }
    }

    // Constant folding: string concatenation with ++
    if (op === '++' && node.left.type === 'StringLiteral' && node.right.type === 'StringLiteral') {
      return JSON.stringify(node.left.value + node.right.value);
    }

    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);

    // String multiply: "ha" * 3 => "ha".repeat(3), also x * 3 when x is string
    if (op === '*' &&
      (node.left.type === 'StringLiteral' || node.left.type === 'TemplateLiteral')) {
      return `${left}.repeat(${right})`;
    }
    if (op === '*' &&
      (node.right.type === 'StringLiteral' || node.right.type === 'TemplateLiteral')) {
      return `${right}.repeat(${left})`;
    }

    // Tova ?? is NaN-safe: catches null, undefined, AND NaN
    if (op === '??') {
      if (this._isSimpleExpression(node.left)) {
        return `((${left} != null && ${left} === ${left}) ? ${left} : ${right})`;
      }
      return `((__tova_v) => (__tova_v != null && __tova_v === __tova_v) ? __tova_v : ${right})(${left})`;
    }

    return `(${left} ${op} ${right})`;
  }

  genUnaryExpression(node) {
    const operand = this.genExpression(node.operand);
    if (node.operator === 'not') return `(!${operand})`;
    return `(${node.operator}${operand})`;
  }

  genLogicalExpression(node) {
    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);
    const op = node.operator === 'and' ? '&&' : node.operator === 'or' ? '||' : node.operator;
    return `(${left} ${op} ${right})`;
  }

  genChainedComparison(node) {
    // a < b < c => ((__t0 = a) < (__t1 = b) && __t1 < c)
    // Use temp vars for intermediate operands to avoid evaluating expressions multiple times
    if (node.operators.length === 1) {
      // Simple case: no duplication needed
      const left = this.genExpression(node.operands[0]);
      const right = this.genExpression(node.operands[1]);
      return `(${left} ${node.operators[0]} ${right})`;
    }
    // Optimization: if all intermediate operands are simple (no side effects),
    // we can inline them without temp vars or IIFE
    const intermediateOperands = node.operands.slice(1, -1);
    const allSimple = intermediateOperands.every(op => this._isSimpleExpression(op));

    if (allSimple) {
      const parts = [];
      for (let idx = 0; idx < node.operators.length; idx++) {
        const left = this.genExpression(node.operands[idx]);
        const right = this.genExpression(node.operands[idx + 1]);
        parts.push(`(${left} ${node.operators[idx]} ${right})`);
      }
      return `(${parts.join(' && ')})`;
    }

    const temps = [];
    const parts = [];
    for (let idx = 0; idx < node.operators.length; idx++) {
      let left, right;
      if (idx === 0) {
        left = this.genExpression(node.operands[idx]);
      } else {
        left = temps[idx - 1];
      }
      if (idx < node.operators.length - 1) {
        // Intermediate operand: assign to temp var so it's not evaluated twice
        const tmp = `__cmp_${this._uid()}`;
        temps.push(tmp);
        right = `(${tmp} = ${this.genExpression(node.operands[idx + 1])})`;
      } else {
        right = this.genExpression(node.operands[idx + 1]);
      }
      parts.push(`(${left} ${node.operators[idx]} ${right})`);
    }
    if (temps.length > 0) {
      return `(() => { let ${temps.join(', ')}; return (${parts.join(' && ')}); })()`;
    }
    return `(${parts.join(' && ')})`;
  }

  // Try to specialize `in` checks based on the collection's AST type
  _specializeContains(collectionNode, colCode, valCode) {
    switch (collectionNode.type) {
      case 'ArrayLiteral':
        return `${colCode}.includes(${valCode})`;
      case 'StringLiteral':
      case 'TemplateLiteral':
        return `${colCode}.includes(${valCode})`;
      case 'CallExpression':
        if (collectionNode.callee.type === 'MemberExpression' &&
            !collectionNode.callee.computed &&
            collectionNode.callee.property === 'new') {
          const objName = collectionNode.callee.object.type === 'Identifier'
            ? collectionNode.callee.object.name : null;
          if (objName === 'Set' || objName === 'Map') {
            return `${colCode}.has(${valCode})`;
          }
        }
        return null;
      case 'ObjectLiteral':
        return `(${valCode} in ${colCode})`;
      default:
        return null;
    }
  }

  genMembershipExpression(node) {
    const val = this.genExpression(node.value);
    const col = this.genExpression(node.collection);

    // Try specialized check based on collection type
    const specialized = this._specializeContains(node.collection, col, val);
    if (specialized) {
      if (node.negated) {
        return `(!${specialized})`;
      }
      return specialized;
    }

    this._needsContainsHelper = true;
    if (node.negated) {
      return `(!__contains(${col}, ${val}))`;
    }
    return `__contains(${col}, ${val})`;
  }

  genIsExpression(node) {
    const val = this.genExpression(node.value);
    const op = node.negated ? '!==' : '===';
    const notOp = node.negated ? '!' : '';

    // Map Tova type names to JS runtime checks
    switch (node.typeName) {
      case 'String':
        return `(typeof ${val} ${op} 'string')`;
      case 'Int':
        return node.negated
          ? `(typeof ${val} !== 'number' || !Number.isInteger(${val}))`
          : `(typeof ${val} === 'number' && Number.isInteger(${val}))`;
      case 'Float':
        return node.negated
          ? `(typeof ${val} !== 'number' || Number.isInteger(${val}))`
          : `(typeof ${val} === 'number' && !Number.isInteger(${val}))`;
      case 'Bool':
        return `(typeof ${val} ${op} 'boolean')`;
      case 'Nil':
        return `(${val} ${op} null)`;
      case 'Array':
        return `(${notOp}Array.isArray(${val}))`;
      case 'Function':
        return `(typeof ${val} ${op} 'function')`;
      case 'Number':
        return `(typeof ${val} ${op} 'number')`;
      default:
        // For ADT variants, check __tag; for classes, use instanceof
        return node.negated
          ? `(!(${val} != null && (${val}.__tag === '${node.typeName}' || ${val} instanceof (typeof ${node.typeName} !== 'undefined' ? ${node.typeName} : function(){}))))`
          : `(${val} != null && (${val}.__tag === '${node.typeName}' || ${val} instanceof (typeof ${node.typeName} !== 'undefined' ? ${node.typeName} : function(){})))`;
    }
  }

  genCallExpression(node) {
    // Result/Option .map() chain fusion: Ok(val).map(fn(x) e1).map(fn(x) e2) → Ok(e2(e1(val)))
    const fusedResult = this._tryFuseMapChain(node);
    if (fusedResult !== null) return fusedResult;

    // Compile-time devirtualization: Ok(x).unwrap() → x, Err(e).isOk() → false, etc.
    const devirt = this._tryDevirtualizeResultOption(node);
    if (devirt !== null) return devirt;

    // Scalar replacement: intercept method calls on scalar-replaced Result/Option variables
    if (this._scalarReplacements && this._scalarReplacements.size > 0 &&
        node.callee.type === 'MemberExpression' && !node.callee.computed &&
        node.callee.object && node.callee.object.type === 'Identifier') {
      const varName = node.callee.object.name;
      const scalarInfo = this._scalarReplacements.get(varName);
      if (scalarInfo) {
        const okVar = `${varName}__ok`;
        const vVar = `${varName}__v`;
        const method = node.callee.property;

        if (scalarInfo.kind === 'result') {
          switch (method) {
            case 'isOk': return okVar;
            case 'isErr': return `!${okVar}`;
            case 'unwrap': return vVar;
            case 'unwrapOr': return node.arguments.length > 0 ? `(${okVar} ? ${vVar} : ${this.genExpression(node.arguments[0])})` : vVar;
            case 'expect': return vVar;
          }
        } else if (scalarInfo.kind === 'option') {
          switch (method) {
            case 'isSome': return okVar;
            case 'isNone': return `!${okVar}`;
            case 'unwrap': return vVar;
            case 'unwrapOr': return node.arguments.length > 0 ? `(${okVar} ? ${vVar} : ${this.genExpression(node.arguments[0])})` : vVar;
            case 'expect': return vVar;
          }
        }
      }
    }

    // Transform Foo.new(...) → new Foo(...)
    if (node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property === 'new') {
      const obj = this.genExpression(node.callee.object);
      const args = node.arguments.map(a => this.genExpression(a)).join(', ');
      return `new ${obj}(${args})`;
    }

    // Track builtin usage for tree-shaking (with dependency resolution)
    if (node.callee.type === 'Identifier') {
      if (BUILTIN_NAMES.has(node.callee.name)) {
        this._trackBuiltin(node.callee.name);
      }
      if (node.callee.name === 'Ok' || node.callee.name === 'Err' || node.callee.name === 'Some') {
        this._needsResultOption = true;
      }
      // Seq is a dependency of iter — handled by _trackBuiltin via STDLIB_DEPS
      if (node.callee.name === 'iter') {
        this._needsResultOption = true; // Seq.first()/find() return Option
      }

      // Inline string/collection builtins to direct method calls
      const inlined = this._tryInlineBuiltin(node);
      if (inlined !== null) return inlined;
    }

    // Track namespace builtin usage: math.sin() → include 'math' namespace + deps
    if (node.callee.type === 'MemberExpression' &&
        node.callee.object.type === 'Identifier' &&
        BUILTIN_NAMES.has(node.callee.object.name)) {
      const ns = node.callee.object.name;
      this._trackBuiltin(ns);
      // Namespaces that depend on Ok/Err need Result/Option
      const deps = STDLIB_DEPS[ns];
      if (deps && (deps.includes('Ok') || deps.includes('Err'))) {
        this._needsResultOption = true;
      }
    }

    // Check for table operation calls with column expressions
    const hasColumnExprs = node.arguments.some(a => this._containsColumnExpr(a));
    if (hasColumnExprs || (node.callee.type === 'Identifier' && ['agg', 'table_agg'].includes(node.callee.name))) {
      const tableArgs = this._genTableCallArgs(node);
      if (tableArgs) {
        const callee = this.genExpression(node.callee);
        return `${callee}(${tableArgs.join(', ')})`;
      }
    }

    const callee = this.genExpression(node.callee);
    const hasNamedArgs = node.arguments.some(a => a.type === 'NamedArgument');

    if (hasNamedArgs) {
      const allNamed = node.arguments.every(a => a.type === 'NamedArgument');
      if (allNamed) {
        // All named args → single object argument
        const parts = node.arguments.map(a => `${a.name}: ${this.genExpression(a.value)}`);
        return `${callee}({ ${parts.join(', ')} })`;
      }
      // Mixed: positional first, then named as trailing object
      const positional = [];
      const named = [];
      for (const a of node.arguments) {
        if (a.type === 'NamedArgument') {
          named.push(`${a.name}: ${this.genExpression(a.value)}`);
        } else {
          positional.push(this.genExpression(a));
        }
      }
      return `${callee}(${[...positional, `{ ${named.join(', ')} }`].join(', ')})`;
    }

    const args = node.arguments.map(a => this.genExpression(a)).join(', ');
    return `${callee}(${args})`;
  }

  // Fuse Ok(val).map(fn(x) e1).map(fn(x) e2) → Ok(composed(val))
  // Eliminates intermediate Ok/Some allocations in .map() chains
  _tryFuseMapChain(node) {
    // Must be a .map() call with exactly 1 argument
    if (node.callee.type !== 'MemberExpression' || node.callee.computed) return null;
    if (node.callee.property !== 'map') return null;
    if (node.arguments.length !== 1) return null;

    // Collect the chain of .map() calls
    const mapFns = []; // array of lambda AST nodes, outermost first
    let current = node;
    while (
      current.type === 'CallExpression' &&
      current.callee.type === 'MemberExpression' &&
      !current.callee.computed &&
      current.callee.property === 'map' &&
      current.arguments.length === 1
    ) {
      const lambda = current.arguments[0];
      // Only fuse simple single-expression lambdas with exactly 1 param
      if (lambda.type !== 'FunctionExpression' && lambda.type !== 'ArrowFunction' && lambda.type !== 'LambdaExpression') return null;
      const params = lambda.params || [];
      if (params.length !== 1) return null;
      const paramName = typeof params[0] === 'string' ? params[0] : (params[0].name || null);
      if (!paramName) return null;
      // Body must be a single expression (not a BlockStatement, or a block with 1 expression)
      let bodyExpr = lambda.body;
      if (bodyExpr && bodyExpr.type === 'BlockStatement') {
        if (bodyExpr.body.length === 1) {
          const s = bodyExpr.body[0];
          if (s.type === 'ExpressionStatement') bodyExpr = s.expression;
          else if (s.type === 'ReturnStatement' && s.value) bodyExpr = s.value;
          else return null;
        } else {
          return null;
        }
      }
      mapFns.unshift({ paramName, bodyExpr }); // prepend so inner is first
      current = current.callee.object;
    }

    // Need at least 2 .map() calls to benefit from fusion
    if (mapFns.length < 2) return null;

    // The base must be Ok(val) or Some(val)
    if (current.type !== 'CallExpression') return null;
    if (current.callee.type !== 'Identifier') return null;
    const wrapperFn = current.callee.name;
    if (wrapperFn !== 'Ok' && wrapperFn !== 'Some') return null;
    if (current.arguments.length !== 1) return null;

    this._needsResultOption = true;

    // Compose the lambdas: val → f1(val) → f2(f1(val)) → ...
    // Generate inner-to-outer composition
    let innerExpr = this.genExpression(current.arguments[0]);
    for (const { paramName, bodyExpr } of mapFns) {
      // Substitute paramName with the current innerExpr in bodyExpr
      innerExpr = this._substituteParam(bodyExpr, paramName, innerExpr);
    }

    return `${wrapperFn}(${innerExpr})`;
  }

  // Generate expression code with a parameter substituted by a value expression string
  _substituteParam(exprNode, paramName, valueCode) {
    // Simple approach: generate the expression, but override identifier resolution
    // We save and restore a substitution map
    if (!this._paramSubstitutions) this._paramSubstitutions = new Map();
    this._paramSubstitutions.set(paramName, valueCode);
    const result = this.genExpression(exprNode);
    this._paramSubstitutions.delete(paramName);
    return result;
  }

  // ─── Compile-time devirtualization for Result/Option ──────────
  // When the codegen sees Ok(val).method(), Err(val).method(), Some(val).method(),
  // or None.method(), it knows the exact type at compile time. Instead of allocating
  // a Result/Option object and calling a method, inline the method body directly.

  _tryDevirtualizeResultOption(node) {
    // Must be a CallExpression where callee is a non-computed MemberExpression
    if (node.callee.type !== 'MemberExpression' || node.callee.computed) return null;
    const method = node.callee.property;
    const obj = node.callee.object;
    const args = node.arguments;

    // Case 1: None.method()
    if (obj.type === 'Identifier' && obj.name === 'None') {
      return this._devirtNone(method, args);
    }

    // Case 2: Ok(val).method(), Err(val).method(), Some(val).method()
    if (obj.type === 'CallExpression' && obj.callee.type === 'Identifier' && obj.arguments.length === 1) {
      const ctor = obj.callee.name;
      const val = obj.arguments[0];
      if (ctor === 'Ok') return this._devirtOk(val, method, args);
      if (ctor === 'Err') return this._devirtErr(val, method, args);
      if (ctor === 'Some') return this._devirtSome(val, method, args);
    }

    return null;
  }

  _devirtOk(val, method, args) {
    switch (method) {
      case 'unwrap':
      case 'expect':
        return this.genExpression(val);
      case 'unwrapOr':
        return this.genExpression(val); // Ok ignores default
      case 'isOk':
        return 'true';
      case 'isErr':
        return 'false';
      case 'map': {
        if (!this._isSimpleLambda(args[0])) return null;
        const parts = this._extractLambdaParts(args[0]);
        if (!parts) return null;
        this._needsResultOption = true;
        return `Ok(${this._substituteParam(parts.bodyExpr, parts.paramName, this.genExpression(val))})`;
      }
      case 'flatMap': {
        if (!this._isSimpleLambda(args[0])) return null;
        const parts = this._extractLambdaParts(args[0]);
        if (!parts) return null;
        return this._substituteParam(parts.bodyExpr, parts.paramName, this.genExpression(val));
      }
      case 'mapErr':
        this._needsResultOption = true;
        return `Ok(${this.genExpression(val)})`; // passes through
      case 'or':
        this._needsResultOption = true;
        return `Ok(${this.genExpression(val)})`; // passes through
      case 'and':
        if (args[0]) return this.genExpression(args[0]);
        return null;
      default:
        return null;
    }
  }

  _devirtErr(val, method, args) {
    switch (method) {
      case 'unwrapOr':
        if (args[0]) return this.genExpression(args[0]);
        return null;
      case 'isOk':
        return 'false';
      case 'isErr':
        return 'true';
      case 'unwrapErr':
        return this.genExpression(val);
      case 'map':
        this._needsResultOption = true;
        return `Err(${this.genExpression(val)})`; // passes through
      case 'flatMap':
        this._needsResultOption = true;
        return `Err(${this.genExpression(val)})`;
      case 'mapErr': {
        if (!this._isSimpleLambda(args[0])) return null;
        const parts = this._extractLambdaParts(args[0]);
        if (!parts) return null;
        this._needsResultOption = true;
        return `Err(${this._substituteParam(parts.bodyExpr, parts.paramName, this.genExpression(val))})`;
      }
      case 'or':
        if (args[0]) return this.genExpression(args[0]);
        return null;
      case 'and':
        this._needsResultOption = true;
        return `Err(${this.genExpression(val)})`;
      default:
        return null;
    }
  }

  _devirtSome(val, method, args) {
    switch (method) {
      case 'unwrap':
      case 'expect':
        return this.genExpression(val);
      case 'unwrapOr':
        return this.genExpression(val); // Some ignores default
      case 'isSome':
        return 'true';
      case 'isNone':
        return 'false';
      case 'map': {
        if (!this._isSimpleLambda(args[0])) return null;
        const parts = this._extractLambdaParts(args[0]);
        if (!parts) return null;
        this._needsResultOption = true;
        return `Some(${this._substituteParam(parts.bodyExpr, parts.paramName, this.genExpression(val))})`;
      }
      case 'flatMap': {
        if (!this._isSimpleLambda(args[0])) return null;
        const parts = this._extractLambdaParts(args[0]);
        if (!parts) return null;
        return this._substituteParam(parts.bodyExpr, parts.paramName, this.genExpression(val));
      }
      case 'filter': {
        if (!this._isSimpleLambda(args[0])) return null;
        const parts = this._extractLambdaParts(args[0]);
        if (!parts) return null;
        this._needsResultOption = true;
        const valCode = this.genExpression(val);
        const predCode = this._substituteParam(parts.bodyExpr, parts.paramName, valCode);
        return `(${predCode} ? Some(${valCode}) : None)`;
      }
      case 'or':
        this._needsResultOption = true;
        return `Some(${this.genExpression(val)})`; // passes through
      case 'and':
        if (args[0]) return this.genExpression(args[0]);
        return null;
      default:
        return null;
    }
  }

  _devirtNone(method, args) {
    switch (method) {
      case 'unwrapOr':
        if (args[0]) return this.genExpression(args[0]);
        return null;
      case 'isSome':
        return 'false';
      case 'isNone':
        return 'true';
      case 'map':
        this._needsResultOption = true;
        return 'None';
      case 'flatMap':
        this._needsResultOption = true;
        return 'None';
      case 'filter':
        this._needsResultOption = true;
        return 'None';
      case 'or':
        if (args[0]) return this.genExpression(args[0]);
        return null;
      case 'and':
        this._needsResultOption = true;
        return 'None';
      default:
        return null;
    }
  }

  _isSimpleLambda(node) {
    if (!node) return false;
    if (node.type !== 'FunctionExpression' && node.type !== 'ArrowFunction' && node.type !== 'LambdaExpression') return false;
    const params = node.params || [];
    if (params.length !== 1) return false;
    return true;
  }

  _extractLambdaParts(lambda) {
    const params = lambda.params || [];
    const paramName = typeof params[0] === 'string' ? params[0] : (params[0].name || null);
    if (!paramName) return null;
    let bodyExpr = lambda.body;
    if (bodyExpr && bodyExpr.type === 'BlockStatement') {
      if (bodyExpr.body.length === 1) {
        const s = bodyExpr.body[0];
        if (s.type === 'ExpressionStatement') bodyExpr = s.expression;
        else if (s.type === 'ReturnStatement' && s.value) bodyExpr = s.value;
        else return null;
      } else {
        return null;
      }
    }
    return { paramName, bodyExpr };
  }

  // Inline known builtins to direct method calls, eliminating wrapper overhead.
  // Returns the inlined code string, or null if not inlineable.
  _tryInlineBuiltin(node) {
    const name = node.callee.name;
    const args = node.arguments;

    switch (name) {
      // String methods: fn(str, ...) → str.method(...)
      case 'split':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.split(${this.genExpression(args[1])})`;
        break;
      case 'join':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.join(${this.genExpression(args[1])})`;
        if (args.length === 1)
          return `${this.genExpression(args[0])}.join('')`;
        break;
      case 'replace':
        if (args.length === 3)
          return `${this.genExpression(args[0])}.replaceAll(${this.genExpression(args[1])}, ${this.genExpression(args[2])})`;
        break;
      case 'contains':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.includes(${this.genExpression(args[1])})`;
        break;
      case 'upper':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.toUpperCase()`;
        break;
      case 'lower':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.toLowerCase()`;
        break;
      case 'trim':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.trim()`;
        break;
      case 'trim_start':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.trimStart()`;
        break;
      case 'trim_end':
        if (args.length === 1)
          return `${this.genExpression(args[0])}.trimEnd()`;
        break;
      case 'repeat':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.repeat(${this.genExpression(args[1])})`;
        break;
      case 'starts_with':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.startsWith(${this.genExpression(args[1])})`;
        break;
      case 'ends_with':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.endsWith(${this.genExpression(args[1])})`;
        break;
      case 'pad_start':
        if (args.length >= 2)
          return `${this.genExpression(args[0])}.padStart(${this.genExpression(args[1])}${args[2] ? ', ' + this.genExpression(args[2]) : ''})`;
        break;
      case 'pad_end':
        if (args.length >= 2)
          return `${this.genExpression(args[0])}.padEnd(${this.genExpression(args[1])}${args[2] ? ', ' + this.genExpression(args[2]) : ''})`;
        break;
      case 'includes':
        if (args.length === 2)
          return `${this.genExpression(args[0])}.includes(${this.genExpression(args[1])})`;
        break;
      case 'char_at':
        if (args.length === 2)
          return `${this.genExpression(args[0])}[${this.genExpression(args[1])}]`;
        break;
    }

    return null;
  }

  genMemberExpression(node) {
    // Track namespace builtin usage: math.PI → include 'math' namespace + deps
    if (node.object.type === 'Identifier' && BUILTIN_NAMES.has(node.object.name)) {
      this._trackBuiltin(node.object.name);
    }
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}[${this.genExpression(node.property)}]`;
    }
    return `${obj}.${node.property}`;
  }

  genOptionalChain(node) {
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}?.[${this.genExpression(node.property)}]`;
    }
    return `${obj}?.${node.property}`;
  }

  genPipeExpression(node) {
    const left = this.genExpression(node.left);
    const right = node.right;

    // Method pipe: x |> .method(args) => x.method(args)
    if (right.type === 'CallExpression' && right.callee.type === 'MemberExpression' &&
        right.callee.object.type === 'Identifier' && right.callee.object.name === PIPE_TARGET) {
      // This is the .method() case - handled through special MemberExpression with empty object
      const method = right.callee.property;
      const args = right.arguments.map(a => this.genExpression(a)).join(', ');
      return `${left}.${method}(${args})`;
    }

    // If right is a call expression, check for placeholder _ or insert as first arg
    if (right.type === 'CallExpression') {
      // Check for table operations with column expressions
      const hasColumnExprs = right.arguments.some(a => this._containsColumnExpr(a));
      if (hasColumnExprs || (right.callee.type === 'Identifier' && ['agg', 'table_agg'].includes(right.callee.name))) {
        const tableArgs = this._genTableCallArgs(right);
        if (tableArgs) {
          const callee = this.genExpression(right.callee);
          // Track builtin usage
          if (right.callee.type === 'Identifier' && BUILTIN_NAMES.has(right.callee.name)) {
            this._usedBuiltins.add(right.callee.name);
          }
          return `${callee}(${[left, ...tableArgs].join(', ')})`;
        }
      }

      const placeholderCount = right.arguments.filter(a => a.type === 'Identifier' && a.name === '_').length;
      if (placeholderCount > 0) {
        const callee = this.genExpression(right.callee);
        if (placeholderCount > 1) {
          // Multiple placeholders: inline if left is simple, otherwise IIFE temp var
          if (this._isSimpleExpression(node.left)) {
            const args = right.arguments.map(a => {
              if (a.type === 'Identifier' && a.name === '_') return left;
              return this.genExpression(a);
            }).join(', ');
            return `${callee}(${args})`;
          }
          const tmp = `__pipe_${this._uid()}`;
          const args = right.arguments.map(a => {
            if (a.type === 'Identifier' && a.name === '_') return tmp;
            return this.genExpression(a);
          }).join(', ');
          return `((${tmp}) => ${callee}(${args}))(${left})`;
        }
        // Single placeholder: inline directly
        const args = right.arguments.map(a => {
          if (a.type === 'Identifier' && a.name === '_') return left;
          return this.genExpression(a);
        }).join(', ');
        return `${callee}(${args})`;
      }
      const callee = this.genExpression(right.callee);
      const args = [left, ...right.arguments.map(a => this.genExpression(a))].join(', ');
      return `${callee}(${args})`;
    }
    // If right is an identifier, call it with left as argument
    if (right.type === 'Identifier') {
      return `${right.name}(${left})`;
    }
    // Method pipe without call: x |> .method => x.method
    if (right.type === 'MemberExpression' && right.object.type === 'Identifier' && right.object.name === PIPE_TARGET) {
      return `${left}.${right.property}`;
    }
    // Fallback
    return `(${this.genExpression(right)})(${left})`;
  }

  // ─── Column expressions ──────────────────────────────────

  // Context flag for whether we're inside a select() call argument list
  _columnAsString = false;

  genColumnExpression(node) {
    // Inside select(), column expressions compile to string names
    if (this._columnAsString) {
      return JSON.stringify(node.name);
    }
    // Default: compile to row lambda
    return `(__row) => __row.${node.name}`;
  }

  genColumnAssignment(node) {
    // Compile to object entry for derive(): { colName: (row) => expr }
    // The expression inside the assignment may reference other columns
    const expr = this._genColumnBody(node.expression);
    return `${JSON.stringify(node.target)}: (__row) => ${expr}`;
  }

  // Generate an expression body that wraps column references as __row.col
  _genColumnBody(node) {
    if (!node) return 'undefined';
    if (node.type === 'ColumnExpression') {
      return `__row.${node.name}`;
    }
    if (node.type === 'BinaryExpression') {
      return `(${this._genColumnBody(node.left)} ${node.operator} ${this._genColumnBody(node.right)})`;
    }
    if (node.type === 'LogicalExpression') {
      const op = node.operator === 'and' ? '&&' : node.operator === 'or' ? '||' : node.operator;
      return `(${this._genColumnBody(node.left)} ${op} ${this._genColumnBody(node.right)})`;
    }
    if (node.type === 'UnaryExpression') {
      return `${node.operator}${this._genColumnBody(node.operand)}`;
    }
    if (node.type === 'CallExpression') {
      // Check if callee is a builtin used as pipe target
      const callee = this.genExpression(node.callee);
      const args = node.arguments.map(a => this._genColumnBody(a)).join(', ');
      return `${callee}(${args})`;
    }
    if (node.type === 'PipeExpression') {
      const left = this._genColumnBody(node.left);
      const right = node.right;
      if (right.type === 'CallExpression') {
        const callee = this.genExpression(right.callee);
        const args = [left, ...right.arguments.map(a => this._genColumnBody(a))].join(', ');
        return `${callee}(${args})`;
      }
      if (right.type === 'Identifier') {
        return `${right.name}(${left})`;
      }
      return `(${this._genColumnBody(right)})(${left})`;
    }
    if (node.type === 'TemplateLiteral') {
      // Template literal with column references
      const parts = node.parts.map(p => {
        if (p.type === 'text') return p.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
        return `\${${this._genColumnBody(p.value)}}`;
      });
      return '`' + parts.join('') + '`';
    }
    if (node.type === 'ConditionalExpression' || node.type === 'IfExpression') {
      const cond = this._genColumnBody(node.condition);
      const cons = this._genColumnBody(node.consequent);
      const alt = node.alternate || node.elseBody;
      const altCode = alt ? this._genColumnBody(alt) : 'undefined';
      return `(${cond} ? ${cons} : ${altCode})`;
    }
    if (node.type === 'MatchExpression') {
      // Match on column value
      const subject = this._genColumnBody(node.subject);
      const tmp = `__match_${this._uid()}`;
      let code = `((__m) => { `;
      for (const arm of node.arms) {
        if (arm.pattern.type === 'WildcardPattern') {
          const body = this._genColumnBody(arm.body);
          code += `return ${body}; `;
        } else if (arm.pattern.type === 'RangePattern') {
          const start = this.genExpression(arm.pattern.start);
          const end = this.genExpression(arm.pattern.end);
          const op = arm.pattern.inclusive ? '<=' : '<';
          code += `if (__m >= ${start} && __m ${op} ${end}) return ${this._genColumnBody(arm.body)}; `;
        } else {
          const pat = this.genExpression(arm.pattern.value || arm.pattern);
          code += `if (__m === ${pat}) return ${this._genColumnBody(arm.body)}; `;
        }
      }
      code += `})(${subject})`;
      return code;
    }
    if (node.type === 'MemberExpression') {
      const obj = this._genColumnBody(node.object);
      if (node.computed) {
        return `${obj}[${this._genColumnBody(node.property)}]`;
      }
      return `${obj}.${node.property}`;
    }
    // Fallback to normal expression generation for constants, strings, etc.
    return this.genExpression(node);
  }

  // Override genCallExpression to handle table operations with column expressions
  _genTableCallArgs(node) {
    const calleeName = node.callee.type === 'Identifier' ? node.callee.name : null;

    // select() — column expressions should compile to strings
    if (calleeName === 'select' || calleeName === 'table_select') {
      this._columnAsString = true;
      const args = node.arguments.map(a => this.genExpression(a));
      this._columnAsString = false;
      return args;
    }

    // where() — column expressions compile to row lambdas
    if (calleeName === 'where' || calleeName === 'table_where') {
      return node.arguments.map(a => {
        if (this._containsColumnExpr(a)) {
          return `(__row) => ${this._genColumnBody(a)}`;
        }
        return this.genExpression(a);
      });
    }

    // sort_by() — column expression compiles to row lambda
    if (calleeName === 'sort_by' || calleeName === 'table_sort_by') {
      return node.arguments.map(a => {
        if (this._containsColumnExpr(a)) {
          return `(__row) => ${this._genColumnBody(a)}`;
        }
        return this.genExpression(a);
      });
    }

    // group_by() — column expression compiles to row lambda
    if (calleeName === 'group_by' || calleeName === 'table_group_by') {
      return node.arguments.map(a => {
        if (this._containsColumnExpr(a)) {
          return `(__row) => ${this._genColumnBody(a)}`;
        }
        return this.genExpression(a);
      });
    }

    // derive() — column assignments compile to { name: (row) => expr }
    if (calleeName === 'derive' || calleeName === 'table_derive') {
      const parts = [];
      for (const a of node.arguments) {
        if (a.type === 'ColumnAssignment') {
          parts.push(this.genColumnAssignment(a));
        } else {
          parts.push(this.genExpression(a));
        }
      }
      // Wrap column assignments in an object
      const hasAssignments = node.arguments.some(a => a.type === 'ColumnAssignment');
      if (hasAssignments) {
        return [`{ ${parts.join(', ')} }`];
      }
      return parts;
    }

    // agg() — named arguments with aggregation functions
    if (calleeName === 'agg' || calleeName === 'table_agg') {
      const parts = [];
      for (const a of node.arguments) {
        if (a.type === 'NamedArgument') {
          // Named agg: total: sum(.amount) → total: agg_sum((__row) => __row.amount)
          const val = a.value;
          if (val.type === 'CallExpression' && val.callee.type === 'Identifier') {
            const aggName = val.callee.name;
            const aggFn = `agg_${aggName}`;
            if (['sum', 'count', 'mean', 'median', 'min', 'max'].includes(aggName)) {
              this._usedBuiltins.add(aggFn);
              if (val.arguments.length === 0) {
                // count() with no args
                parts.push(`${a.name}: ${aggFn}()`);
              } else {
                const inner = val.arguments[0];
                if (this._containsColumnExpr(inner)) {
                  parts.push(`${a.name}: ${aggFn}((__row) => ${this._genColumnBody(inner)})`);
                } else {
                  parts.push(`${a.name}: ${aggFn}(${this.genExpression(inner)})`);
                }
              }
              continue;
            }
          }
          parts.push(`${a.name}: ${this.genExpression(a.value)}`);
        } else {
          parts.push(this.genExpression(a));
        }
      }
      const hasNamed = node.arguments.some(a => a.type === 'NamedArgument');
      if (hasNamed) {
        return [`{ ${parts.join(', ')} }`];
      }
      return parts;
    }

    // drop_nil/fill_nil — column expression compiles to string or lambda
    if (calleeName === 'drop_nil' || calleeName === 'fill_nil') {
      return node.arguments.map(a => {
        if (a.type === 'ColumnExpression') {
          return JSON.stringify(a.name);
        }
        return this.genExpression(a);
      });
    }

    // join() — handle left/right column expressions
    if (calleeName === 'join' || calleeName === 'table_join') {
      return node.arguments.map(a => {
        if (a.type === 'NamedArgument') {
          if ((a.name === 'left' || a.name === 'right') && a.value.type === 'ColumnExpression') {
            return this.genExpression(a); // NamedArgument genExpression handles it
          }
        }
        return this.genExpression(a);
      });
    }

    return null; // No special handling needed
  }

  _containsColumnExpr(node) {
    if (!node) return false;
    if (node.type === 'ColumnExpression' || node.type === 'ColumnAssignment' || node.type === 'NegatedColumnExpression') return true;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsColumnExpr(item)) return true;
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsColumnExpr(val)) return true;
      }
    }
    return false;
  }

  genLambdaExpression(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const asyncPrefix = node.isAsync ? 'async ' : '';

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      const body = this.genBlockBody(node.body);
      this.popScope();
      if (hasPropagate) {
        const p = [];
        p.push(`${asyncPrefix}(${params}) => {`);
        p.push(`${this.i()}  try {`);
        p.push(body);
        p.push(`${this.i()}  } catch (__e) {`);
        p.push(`${this.i()}    if (__e && __e.__tova_propagate) return __e.value;`);
        p.push(`${this.i()}    throw __e;`);
        p.push(`${this.i()}  }`);
        p.push(`${this.i()}}`);
        return p.join('\n');
      }
      return [`${asyncPrefix}(${params}) => {`, body, `${this.i()}}`].join('\n');
    }

    // Statement bodies (compound assignment, assignment in lambda)
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      this.indent++;
      const stmt = this.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `${asyncPrefix}(${params}) => { ${stmt.trim()} }`;
    }

    if (hasPropagate) {
      return `${asyncPrefix}(${params}) => { try { return ${this.genExpression(node.body)}; } catch (__e) { if (__e && __e.__tova_propagate) return __e.value; throw __e; } }`;
    }
    return `${asyncPrefix}(${params}) => ${this.genExpression(node.body)}`;
  }

  // Check if a match can be emitted as a ternary chain instead of IIFE
  _isSimpleMatch(node) {
    if (!this._isSimpleExpression(node.subject)) return false;
    for (const arm of node.arms) {
      // All bodies must be expressions (not block statements)
      if (arm.body.type === 'BlockStatement') return false;
      // No patterns that need variable bindings
      if (this._patternNeedsBindings(arm.pattern)) return false;
      // Guards with BindingPattern need IIFE for binding
      if (arm.guard && arm.pattern.type === 'BindingPattern') return false;
    }
    return true;
  }

  // Check recursively whether a pattern requires const bindings
  _patternNeedsBindings(pattern) {
    switch (pattern.type) {
      case 'LiteralPattern':
      case 'WildcardPattern':
      case 'RangePattern':
        return false;
      case 'BindingPattern':
        return true;
      case 'VariantPattern':
        return pattern.fields.some(f => typeof f === 'string' || (f && this._patternNeedsBindings(f)));
      case 'ArrayPattern':
      case 'TuplePattern':
        return pattern.elements.some(el => el && this._patternNeedsBindings(el));
      default:
        return true; // Conservative: unknown patterns may need bindings
    }
  }

  // Generate a simple match as nested ternary
  _genSimpleMatch(node) {
    const subject = this.genExpression(node.subject);
    let result = '';
    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const body = this.genExpression(arm.body);
      // Last arm with wildcard → else branch
      if ((arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') && !arm.guard) {
        result += body;
        break;
      }
      const condition = this.genPatternCondition(arm.pattern, subject, arm.guard);
      result += `(${condition}) ? ${body} : `;
      // If this is the last arm and not a wildcard, add undefined as fallback
      if (idx === node.arms.length - 1) {
        result += 'undefined';
      }
    }
    return `(${result})`;
  }

  // Check if all arms are literal patterns (string/number/boolean) or wildcard, with no guards
  _isLiteralMatch(node) {
    let hasWildcard = false;
    for (const arm of node.arms) {
      if (arm.guard) return false;
      const pt = arm.pattern.type;
      if (pt === 'LiteralPattern') continue;
      if (pt === 'WildcardPattern' || pt === 'BindingPattern') {
        hasWildcard = true;
        continue;
      }
      return false;
    }
    return true;
  }

  _genSwitchMatch(node) {
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';
    const p = [];
    p.push(`((${tempVar}) => {\n`);
    this.indent++;
    p.push(`${this.i()}switch (${tempVar}) {\n`);
    this.indent++;

    for (const arm of node.arms) {
      if (arm.pattern.type === 'WildcardPattern') {
        p.push(`${this.i()}default:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this.genBlockBody(arm.body) + '\n');
        } else {
          p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
        }
        this.indent--;
      } else if (arm.pattern.type === 'BindingPattern') {
        p.push(`${this.i()}default: {\n`);
        this.indent++;
        p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
        if (arm.body.type === 'BlockStatement') {
          p.push(this.genBlockBody(arm.body) + '\n');
        } else {
          p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
        }
        this.indent--;
        p.push(`${this.i()}}\n`);
      } else {
        // LiteralPattern
        p.push(`${this.i()}case ${JSON.stringify(arm.pattern.value)}:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this.genBlockBody(arm.body) + '\n');
        } else {
          p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
        }
        this.indent--;
      }
    }

    this.indent--;
    p.push(`${this.i()}}\n`);
    this.indent--;
    p.push(`${this.i()}})(${subject})`);
    return p.join('');
  }

  genMatchExpression(node) {
    // Optimization: simple matches emit ternary chain instead of IIFE
    if (this._isSimpleMatch(node)) {
      return this._genSimpleMatch(node);
    }

    // Optimization: literal-only patterns emit switch for V8 jump tables
    if (this._isLiteralMatch(node)) {
      return this._genSwitchMatch(node);
    }

    // Generate as IIFE with if-else chain
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';

    const p = [];
    p.push(`((${tempVar}) => {\n`);
    this.indent++;

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case — wrap in else block if preceded by if/else-if arms
          if (idx > 0) {
            p.push(`${this.i()}else {\n`);
            this.indent++;
          }
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
          }
          if (arm.body.type === 'BlockStatement') {
            p.push(this._genBlockBodyReturns(arm.body) + '\n');
          } else {
            p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
          }
          if (idx > 0) {
            this.indent--;
            p.push(`${this.i()}}\n`);
          }
          break;
        }
      }

      const keyword = idx === 0 ? 'if' : 'else if';
      p.push(`${this.i()}${keyword} (${condition}) {\n`);
      this.indent++;

      // Bind variables from pattern
      p.push(this.genPatternBindings(arm.pattern, tempVar));

      if (arm.body.type === 'BlockStatement') {
        p.push(this._genBlockBodyReturns(arm.body) + '\n');
      } else {
        p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
      }
      this.indent--;
      p.push(`${this.i()}}\n`);
    }

    this.indent--;
    p.push(`${this.i()}})(${subject})`);
    return p.join('');
  }

  genIfExpression(node) {
    // Optimization: if all branches are single expressions, use ternary
    const isSingleExpr = (block) =>
      block.type === 'BlockStatement' && block.body.length === 1 && block.body[0].type === 'ExpressionStatement';

    if (node.alternates.length === 0 && isSingleExpr(node.consequent) && isSingleExpr(node.elseBody)) {
      const cond = this.genExpression(node.condition);
      const thenExpr = this.genExpression(node.consequent.body[0].expression);
      const elseExpr = this.genExpression(node.elseBody.body[0].expression);
      return `((${cond}) ? (${thenExpr}) : (${elseExpr}))`;
    }

    // Extended optimization: if/elif/else where ALL branches are single expressions → nested ternary
    if (node.alternates.length > 0 && node.elseBody &&
        isSingleExpr(node.consequent) && isSingleExpr(node.elseBody) &&
        node.alternates.every(alt => isSingleExpr(alt.body))) {
      let result = `((${this.genExpression(node.condition)}) ? (${this.genExpression(node.consequent.body[0].expression)})`;
      for (const alt of node.alternates) {
        result += ` : (${this.genExpression(alt.condition)}) ? (${this.genExpression(alt.body.body[0].expression)})`;
      }
      result += ` : (${this.genExpression(node.elseBody.body[0].expression)}))`;
      return result;
    }

    // Full IIFE for multi-statement branches
    const p = [];
    p.push(`(() => {\n`);
    this.indent++;

    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this.genBlockBody(node.consequent));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this.genBlockBody(alt.body));
      p.push(`\n${this.i()}}`);
    }

    p.push(` else {\n`);
    p.push(this.genBlockBody(node.elseBody));
    p.push(`\n${this.i()}}`);

    this.indent--;
    p.push(`\n${this.i()}})()`);
    return p.join('');
  }

  // ─── IIFE-free match/if codegen (assign to variable instead of return) ───

  _genMatchAssign(node, targetVar) {
    // Block-scoped match that assigns to targetVar instead of wrapping in IIFE
    // Handles switch optimization and general if-else chain

    // Simple ternary matches don't need this optimization (already no IIFE)
    // Literal-only switch matches benefit from assignment form

    if (this._isLiteralMatch(node)) {
      return this._genSwitchMatchAssign(node, targetVar);
    }

    const subject = this.genExpression(node.subject);
    const tempVar = `__match`;
    const p = [];
    p.push(`${this.i()}{\n`);
    this.indent++;
    p.push(`${this.i()}const ${tempVar} = ${subject};\n`);

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case — wrap in else if preceded by if branches
          if (idx > 0) {
            p.push(` else {\n`);
            this.indent++;
          }
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
          }
          if (arm.body.type === 'BlockStatement') {
            p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
          } else {
            p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
          }
          if (idx > 0) {
            this.indent--;
            p.push(`${this.i()}}\n`);
          }
          break;
        }
      }

      if (idx === 0) {
        p.push(`${this.i()}if (${condition}) {\n`);
      } else {
        p.push(` else if (${condition}) {\n`);
      }
      this.indent++;

      // Bind variables from pattern
      p.push(this.genPatternBindings(arm.pattern, tempVar));

      if (arm.body.type === 'BlockStatement') {
        p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
      } else {
        p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
      }
      this.indent--;
      p.push(`${this.i()}}`);
    }
    p.push('\n');

    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('');
  }

  _genSwitchMatchAssign(node, targetVar) {
    // Switch-based match that assigns to targetVar instead of wrapping in IIFE
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';
    const p = [];
    p.push(`${this.i()}{\n`);
    this.indent++;
    p.push(`${this.i()}const ${tempVar} = ${subject};\n`);
    p.push(`${this.i()}switch (${tempVar}) {\n`);
    this.indent++;

    for (const arm of node.arms) {
      if (arm.pattern.type === 'WildcardPattern') {
        p.push(`${this.i()}default:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
        } else {
          p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
        }
        p.push(`${this.i()}break;\n`);
        this.indent--;
      } else if (arm.pattern.type === 'BindingPattern') {
        p.push(`${this.i()}default: {\n`);
        this.indent++;
        p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
        if (arm.body.type === 'BlockStatement') {
          p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
        } else {
          p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
        }
        p.push(`${this.i()}break;\n`);
        this.indent--;
        p.push(`${this.i()}}\n`);
      } else {
        // LiteralPattern
        p.push(`${this.i()}case ${JSON.stringify(arm.pattern.value)}:\n`);
        this.indent++;
        if (arm.body.type === 'BlockStatement') {
          p.push(this._genBlockBodyAssign(arm.body, targetVar) + '\n');
        } else {
          p.push(`${this.i()}${targetVar} = ${this.genExpression(arm.body)};\n`);
        }
        p.push(`${this.i()}break;\n`);
        this.indent--;
      }
    }

    this.indent--;
    p.push(`${this.i()}}\n`);
    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('');
  }

  _genIfAssign(node, targetVar) {
    // Block-scoped if expression that assigns to targetVar instead of wrapping in IIFE
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyAssign(node.consequent, targetVar));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyAssign(alt.body, targetVar));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyAssign(node.elseBody, targetVar));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  // IIFE-free match/if that emits direct returns (for function body last expression)
  _genMatchReturn(node) {
    const subject = this.genExpression(node.subject);
    const tempVar = `__match`;
    const p = [];
    p.push(`${this.i()}{\n`);
    this.indent++;
    p.push(`${this.i()}const ${tempVar} = ${subject};\n`);

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          if (idx > 0) {
            p.push(` else {\n`);
            this.indent++;
          }
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`${this.i()}const ${arm.pattern.name} = ${tempVar};\n`);
          }
          if (arm.body.type === 'BlockStatement') {
            p.push(this._genBlockBodyReturns(arm.body) + '\n');
          } else {
            p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
          }
          if (idx > 0) {
            this.indent--;
            p.push(`${this.i()}}\n`);
          }
          break;
        }
      }

      if (idx === 0) {
        p.push(`${this.i()}if (${condition}) {\n`);
      } else {
        p.push(` else if (${condition}) {\n`);
      }
      this.indent++;
      p.push(this.genPatternBindings(arm.pattern, tempVar));
      if (arm.body.type === 'BlockStatement') {
        p.push(this._genBlockBodyReturns(arm.body) + '\n');
      } else {
        p.push(`${this.i()}return ${this.genExpression(arm.body)};\n`);
      }
      this.indent--;
      p.push(`${this.i()}}`);
    }
    p.push('\n');
    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('');
  }

  _genIfReturn(node) {
    const p = [];
    p.push(`${this.i()}if (${this.genExpression(node.condition)}) {\n`);
    p.push(this._genBlockBodyReturns(node.consequent));
    p.push(`\n${this.i()}}`);

    for (const alt of node.alternates) {
      p.push(` else if (${this.genExpression(alt.condition)}) {\n`);
      p.push(this._genBlockBodyReturns(alt.body));
      p.push(`\n${this.i()}}`);
    }

    if (node.elseBody) {
      p.push(` else {\n`);
      p.push(this._genBlockBodyReturns(node.elseBody));
      p.push(`\n${this.i()}}`);
    }

    return p.join('');
  }

  // Check if a match/if expression would need IIFE (not simple ternary)
  _needsIIFE(node) {
    if (node.type === 'MatchExpression') {
      return !this._isSimpleMatch(node);
    }
    if (node.type === 'IfExpression') {
      const isSingleExpr = (block) =>
        block.type === 'BlockStatement' && block.body.length === 1 && block.body[0].type === 'ExpressionStatement';
      // Simple if/elif → ternary (no IIFE)
      if (node.alternates.length === 0 && isSingleExpr(node.consequent) && isSingleExpr(node.elseBody)) return false;
      if (node.alternates.length > 0 && node.elseBody &&
          isSingleExpr(node.consequent) && isSingleExpr(node.elseBody) &&
          node.alternates.every(alt => isSingleExpr(alt.body))) return false;
      // Otherwise needs IIFE (or our new assign path)
      return true;
    }
    return false;
  }

  // Check if a match has any pattern bindings that would conflict with the target variable
  _matchBindingsConflict(node, targetVar) {
    if (node.type !== 'MatchExpression') return false;
    for (const arm of node.arms) {
      if (this._patternBindsName(arm.pattern, targetVar)) return true;
    }
    return false;
  }

  _patternBindsName(pattern, name) {
    switch (pattern.type) {
      case 'BindingPattern':
        return pattern.name === name;
      case 'VariantPattern':
        return pattern.fields.some(f => {
          if (typeof f === 'string') return f === name;
          if (f && f.type) return this._patternBindsName(f, name);
          return false;
        });
      case 'ArrayPattern':
      case 'TuplePattern':
        return pattern.elements.some(el => el && this._patternBindsName(el, name));
      case 'StringConcatPattern':
        return pattern.rest && pattern.rest.type === 'BindingPattern' && pattern.rest.name === name;
      default:
        return false;
    }
  }

  genPatternCondition(pattern, subject, guard) {
    let cond;

    switch (pattern.type) {
      case 'LiteralPattern':
        cond = `${subject} === ${JSON.stringify(pattern.value)}`;
        break;
      case 'RangePattern':
        if (pattern.inclusive) {
          cond = `${subject} >= ${pattern.start} && ${subject} <= ${pattern.end}`;
        } else {
          cond = `${subject} >= ${pattern.start} && ${subject} < ${pattern.end}`;
        }
        break;
      case 'VariantPattern': {
        const vchecks = [`${subject}?.__tag === "${pattern.name}"`];
        const declFields = this._variantFields[pattern.name] || [];
        for (let i = 0; i < pattern.fields.length; i++) {
          const f = pattern.fields[i];
          if (typeof f === 'object' && f.type && f.type !== 'WildcardPattern' && f.type !== 'BindingPattern') {
            const fieldName = f.type === 'BindingPattern' ? f.name : null;
            const propName = declFields[i] || fieldName || `value`;
            const fCond = this.genPatternCondition(f, `${subject}.${propName}`, null);
            if (fCond !== 'true') vchecks.push(fCond);
          }
        }
        cond = vchecks.join(' && ');
        break;
      }
      case 'ArrayPattern': {
        // Check it's an array with the right length, then check each element pattern
        const checks = [`Array.isArray(${subject})`, `${subject}.length === ${pattern.elements.length}`];
        for (let i = 0; i < pattern.elements.length; i++) {
          const elPat = pattern.elements[i];
          if (elPat.type !== 'WildcardPattern' && elPat.type !== 'BindingPattern') {
            const elCond = this.genPatternCondition(elPat, `${subject}[${i}]`, null);
            if (elCond !== 'true') checks.push(elCond);
          }
        }
        cond = checks.join(' && ');
        break;
      }
      case 'TuplePattern': {
        const checks = [`Array.isArray(${subject})`, `${subject}.length === ${pattern.elements.length}`];
        for (let i = 0; i < pattern.elements.length; i++) {
          const elPat = pattern.elements[i];
          if (elPat.type !== 'WildcardPattern' && elPat.type !== 'BindingPattern') {
            const elCond = this.genPatternCondition(elPat, `${subject}[${i}]`, null);
            if (elCond !== 'true') checks.push(elCond);
          }
        }
        cond = checks.join(' && ');
        break;
      }
      case 'StringConcatPattern':
        cond = `typeof ${subject} === 'string' && ${subject}.startsWith(${JSON.stringify(pattern.prefix)})`;
        break;
      case 'WildcardPattern':
        cond = 'true';
        break;
      case 'BindingPattern':
        cond = 'true';
        break;
      default:
        cond = 'true';
    }

    if (guard) {
      // For binding patterns, we need to bind first for the guard
      if (pattern.type === 'BindingPattern') {
        cond = `((${pattern.name}) => ${this.genExpression(guard)})(${subject})`;
      } else {
        // Collect bindings from sub-patterns (e.g. [1, n] if n < 2)
        const bindings = this._collectPatternBindings(pattern, subject);
        if (bindings.length > 0) {
          const params = bindings.map(b => b.name).join(', ');
          const args = bindings.map(b => b.accessor).join(', ');
          cond = `(${cond}) && ((${params}) => ${this.genExpression(guard)})(${args})`;
        } else {
          cond = `(${cond}) && (${this.genExpression(guard)})`;
        }
      }
    }

    return cond;
  }

  _collectPatternBindings(pattern, subject) {
    const bindings = [];
    switch (pattern.type) {
      case 'BindingPattern':
        bindings.push({ name: pattern.name, accessor: subject });
        break;
      case 'ArrayPattern':
      case 'TuplePattern':
        for (let i = 0; i < pattern.elements.length; i++) {
          const el = pattern.elements[i];
          if (el) bindings.push(...this._collectPatternBindings(el, `${subject}[${i}]`));
        }
        break;
      case 'VariantPattern': {
        const declaredFields = this._variantFields[pattern.name] || [];
        for (let i = 0; i < pattern.fields.length; i++) {
          const f = pattern.fields[i];
          const fieldName = typeof f === 'string' ? f : (f.type === 'BindingPattern' ? f.name : null);
          const propName = declaredFields[i] || fieldName || 'value';
          const accessor = `${subject}.${propName}`;
          if (typeof f === 'string') {
            bindings.push({ name: f, accessor });
          } else {
            bindings.push(...this._collectPatternBindings(f, accessor));
          }
        }
        break;
      }
    }
    return bindings;
  }

  genPatternBindings(pattern, subject) {
    switch (pattern.type) {
      case 'BindingPattern':
        return `${this.i()}const ${pattern.name} = ${subject};\n`;
      case 'VariantPattern': {
        const declaredFields = this._variantFields[pattern.name] || [];
        return pattern.fields.map((f, idx) => {
          // Determine field name for property access
          const fieldName = typeof f === 'string' ? f : (f.type === 'BindingPattern' ? f.name : null);
          const propName = declaredFields[idx] || fieldName || `value`;
          const accessor = `${subject}.${propName}`;
          // String fields (legacy) — simple binding
          if (typeof f === 'string') {
            return `${this.i()}const ${f} = ${accessor};\n`;
          }
          // Nested pattern — recurse for bindings
          if (f.type === 'BindingPattern') {
            return `${this.i()}const ${f.name} = ${accessor};\n`;
          }
          if (f.type === 'WildcardPattern') return '';
          // Nested variant, array, tuple patterns
          return this.genPatternBindings(f, accessor);
        }).join('');
      }
      case 'ArrayPattern':
        return pattern.elements.map((el, idx) => {
          if (el.type === 'BindingPattern') {
            return `${this.i()}const ${el.name} = ${subject}[${idx}];\n`;
          }
          return this.genPatternBindings(el, `${subject}[${idx}]`);
        }).filter(s => s).join('');
      case 'TuplePattern':
        return pattern.elements.map((el, idx) => {
          if (el.type === 'BindingPattern') {
            return `${this.i()}const ${el.name} = ${subject}[${idx}];\n`;
          }
          return this.genPatternBindings(el, `${subject}[${idx}]`);
        }).filter(s => s).join('');
      case 'StringConcatPattern':
        if (pattern.rest && pattern.rest.type === 'BindingPattern') {
          return `${this.i()}const ${pattern.rest.name} = ${subject}.slice(${pattern.prefix.length});\n`;
        }
        return '';
      default:
        return '';
    }
  }

  genArrayLiteral(node) {
    const elements = node.elements.map(e => this.genExpression(e)).join(', ');
    // In @fast mode, detect all-numeric arrays and emit TypedArrays
    if (this._fastMode && node.elements.length > 0 && node.elements.every(e => e.type === 'NumberLiteral')) {
      const hasFloat = node.elements.some(e => String(e.value).includes('.'));
      const taType = hasFloat ? 'Float64Array' : 'Int32Array';
      return `new ${taType}([${elements}])`;
    }
    return `[${elements}]`;
  }

  genObjectLiteral(node) {
    const props = node.properties.map(p => {
      if (p.spread) {
        return `...${this.genExpression(p.argument)}`;
      }
      if (p.shorthand) {
        return this.genExpression(p.key);
      }
      return `${this.genExpression(p.key)}: ${this.genExpression(p.value)}`;
    }).join(', ');
    return `{ ${props} }`;
  }

  genListComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const varName = node.variable;
    const expr = this.genExpression(node.expression);

    if (node.condition) {
      const cond = this.genExpression(node.condition);
      // Skip redundant .map() when expression is just the loop variable
      if (expr === varName) {
        return `${iter}.filter((${varName}) => ${cond})`;
      }
      // Single-pass loop avoids intermediate array from filter().map()
      return `${iter}.reduce((acc, ${varName}) => { if (${cond}) acc.push(${expr}); return acc; }, [])`;
    }
    return `${iter}.map((${varName}) => ${expr})`;
  }

  genDictComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const vars = node.variables;
    const key = this.genExpression(node.key);
    const value = this.genExpression(node.value);

    const destructure = vars.length === 2 ? `[${vars[0]}, ${vars[1]}]` : vars[0];

    let code = `Object.fromEntries(${iter}`;
    if (node.condition) {
      code += `.filter((${destructure}) => ${this.genExpression(node.condition)})`;
    }
    code += `.map((${destructure}) => [${key}, ${value}]))`;
    return code;
  }

  genRangeExpression(node) {
    const start = this.genExpression(node.start);
    const end = this.genExpression(node.end);
    // Use stdlib range() — handles step and direction, avoids Array.from overhead
    this._trackBuiltin('range');
    if (node.inclusive) {
      return `range(${start}, (${end}) + 1)`;
    }
    return `range(${start}, ${end})`;
  }

  genSliceExpression(node) {
    const obj = this.genExpression(node.object);
    const start = node.start ? this.genExpression(node.start) : '';
    const end = node.end ? this.genExpression(node.end) : '';

    if (node.step) {
      const step = this.genExpression(node.step);
      const s = node.start ? this.genExpression(node.start) : 'null';
      const e = node.end ? this.genExpression(node.end) : 'null';
      // Handles both positive and negative step directions
      return `((a, s, e, st) => { const r = []; if (st > 0) { for (let i = s !== null ? s : 0; i < (e !== null ? e : a.length); i += st) r.push(a[i]); } else { for (let i = s !== null ? s : a.length - 1; i > (e !== null ? e : -1); i += st) r.push(a[i]); } return r; })(${obj}, ${s}, ${e}, ${step})`;
    }

    if (!start && !end) return `${obj}.slice()`;
    if (!start) return `${obj}.slice(0, ${end})`;
    if (!end) return `${obj}.slice(${start})`;
    return `${obj}.slice(${start}, ${end})`;
  }

  _declareDestructureVars(pattern) {
    if (pattern.type === 'ObjectPattern') {
      for (const p of pattern.properties) this.declareVar(p.value);
    } else if (pattern.type === 'ArrayPattern') {
      for (const e of pattern.elements) if (e) this.declareVar(e);
    }
  }

  genGuardStatement(node) {
    const p = [];
    p.push(`${this.i()}if (!(${this.genExpression(node.condition)})) {\n`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.elseBody));
    this.popScope();
    this.indent--;
    p.push(`\n${this.i()}}`);
    return p.join('');
  }

  genInterfaceDeclaration(node) {
    // Interfaces are compile-time only — generate as a documentation comment
    const exportStr = node.isPublic ? 'export ' : '';
    const methods = node.methods.map(m => {
      const params = m.params.map(p => {
        let s = p.name;
        if (p.typeAnnotation) s += `: ${p.typeAnnotation.name || 'any'}`;
        return s;
      }).join(', ');
      const ret = m.returnType ? ` -> ${m.returnType.name || 'any'}` : '';
      return `${this.i()} *   fn ${m.name}(${params})${ret}`;
    }).join('\n');
    return `${this.i()}/* ${exportStr}interface ${node.name} {\n${methods}\n${this.i()} * } */`;
  }

  genTypeDeclaration(node) {
    const lines = [];
    const exportPrefix = node.isPublic ? 'export ' : '';

    const hasVariants = node.variants.some(v => v.type === 'TypeVariant');

    if (hasVariants) {
      for (const variant of node.variants) {
        if (variant.type === 'TypeVariant') {
          this.declareVar(variant.name);
          const rawFieldNames = variant.fields.map(f => f.name);
          // Deduplicate field names: Add(Expr, Expr) → _0, _1 (prevents property collision)
          const nameCount = {};
          rawFieldNames.forEach(n => nameCount[n] = (nameCount[n] || 0) + 1);
          const hasDupes = Object.values(nameCount).some(c => c > 1);
          const fieldNames = hasDupes ? rawFieldNames.map((_, i) => `_${i}`) : rawFieldNames;
          this._variantFields[variant.name] = fieldNames;
          if (variant.fields.length === 0) {
            lines.push(`${this.i()}${exportPrefix}const ${variant.name} = Object.freeze({ __tag: "${variant.name}" });`);
          } else {
            const params = fieldNames.join(', ');
            const obj = fieldNames.map(f => `${f}`).join(', ');
            lines.push(`${this.i()}${exportPrefix}function ${variant.name}(${params}) { return { __tag: "${variant.name}", ${obj} }; }`);
          }
        }
      }
    } else {
      this.declareVar(node.name);
      const fieldNames = node.variants.map(f => f.name);
      const params = fieldNames.join(', ');
      const obj = fieldNames.map(f => `${f}`).join(', ');
      lines.push(`${this.i()}${exportPrefix}function ${node.name}(${params}) { return Object.assign(Object.create(${node.name}.prototype), { ${obj} }); }`);
    }

    // Derive clause: generate methods
    if (node.derive && node.derive.length > 0) {
      const targetName = hasVariants ? null : node.name;
      const fieldNames = hasVariants ? [] : node.variants.map(f => f.name);

      const builtinTraits = new Set(['Eq', 'Show', 'JSON']);
      for (const trait of node.derive) {
        if (trait === 'Eq' && targetName) {
          // Deep equality: compare all fields
          const checks = fieldNames.map(f => `a.${f} === b.${f}`).join(' && ');
          lines.push(`${this.i()}${targetName}.__eq = function(a, b) { return ${checks || 'true'}; };`);
        }
        if (trait === 'Show' && targetName) {
          const fields = fieldNames.map(f => `${f}: \${JSON.stringify(obj.${f})}`).join(', ');
          lines.push(`${this.i()}${targetName}.__show = function(obj) { return \`${targetName}(${fields})\`; };`);
        }
        if (trait === 'JSON' && targetName) {
          lines.push(`${this.i()}${targetName}.toJSON = function(obj) { return JSON.stringify(obj); };`);
          lines.push(`${this.i()}${targetName}.fromJSON = function(str) { const d = JSON.parse(str); return ${targetName}(${fieldNames.map(f => `d.${f}`).join(', ')}); };`);
        }

        // Extensible derive: user-defined traits
        if (!builtinTraits.has(trait) && targetName) {
          const traitDecl = this._traitDecls.get(trait);
          if (traitDecl) {
            for (const method of traitDecl.methods) {
              if (method.body) {
                // Trait has a default implementation — use it
                lines.push(`${this.i()}${targetName}.prototype.${method.name} = __trait_${trait}_${method.name};`);
              }
            }
          }
        }
      }

      // For variant types with derive
      if (hasVariants) {
        for (const trait of node.derive) {
          if (trait === 'Eq') {
            lines.push(`${this.i()}function __eq_${node.name}(a, b) { if (a === b) return true; if (!a || !b || a.__tag !== b.__tag) return false; for (const k of Object.keys(a)) { if (k === '__tag') continue; if (a[k] !== b[k]) { if (typeof a[k] === 'object' && typeof b[k] === 'object' && a[k]?.__tag && b[k]?.__tag) { if (!__eq_${node.name}(a[k], b[k])) return false; } else return false; } } return true; }`);
          }
          if (trait === 'Show') {
            lines.push(`${this.i()}function __show_${node.name}(obj) { return obj.__tag + "(" + Object.entries(obj).filter(([k]) => k !== "__tag").map(([k, v]) => k + ": " + JSON.stringify(v)).join(", ") + ")"; }`);
          }
          if (trait === 'JSON') {
            lines.push(`${this.i()}function __toJSON_${node.name}(obj) { return JSON.stringify(obj); }`);
          }
        }
      }
    }

    return lines.join('\n');
  }

  genImplDeclaration(node) {
    // Register trait impl for extensible derive
    if (node.traitName) {
      this._traitImpls.set(`${node.traitName}:${node.typeName}`, node);
    }

    const lines = [];
    for (const method of node.methods) {
      const hasSelf = method.params.some(p => p.name === 'self');
      const params = method.params.filter(p => p.name !== 'self');
      const paramStr = this.genParams(params);
      const hasPropagate = this._containsPropagate(method.body);
      const asyncPrefix = method.isAsync ? 'async ' : '';
      this.pushScope();
      if (hasSelf) this.declareVar('self');
      for (const p of params) {
        if (p.destructure) this._declareDestructureVars(p.destructure);
        else this.declareVar(p.name);
      }
      const body = this.genBlockBody(method.body);
      this.popScope();

      if (hasSelf) {
        // Instance method → prototype
        const selfBinding = `\n${this.i()}  const self = this;`;
        if (hasPropagate) {
          lines.push(`${this.i()}${node.typeName}.prototype.${method.name} = ${asyncPrefix}function(${paramStr}) {${selfBinding}\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}};`);
        } else {
          lines.push(`${this.i()}${node.typeName}.prototype.${method.name} = ${asyncPrefix}function(${paramStr}) {${selfBinding}\n${body}\n${this.i()}};`);
        }
      } else {
        // Associated function → constructor namespace (callable as Type.method())
        if (hasPropagate) {
          lines.push(`${this.i()}${node.typeName}.${method.name} = ${asyncPrefix}function(${paramStr}) {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}};`);
        } else {
          lines.push(`${this.i()}${node.typeName}.${method.name} = ${asyncPrefix}function(${paramStr}) {\n${body}\n${this.i()}};`);
        }
      }
    }
    return lines.join('\n');
  }

  genTraitDeclaration(node) {
    // Register trait for extensible derive
    this._traitDecls.set(node.name, { methods: node.methods });

    // Traits are mostly compile-time, but generate default implementations as functions
    const lines = [];
    const defaultMethods = node.methods.filter(m => m.body);
    if (defaultMethods.length > 0) {
      lines.push(`${this.i()}/* trait ${node.name} */`);
      for (const method of defaultMethods) {
        const params = this.genParams(method.params);
        this.pushScope();
        for (const p of method.params) {
          if (p.destructure) this._declareDestructureVars(p.destructure);
          else if (p.name) this.declareVar(p.name);
        }
        const body = this.genBlockBody(method.body);
        this.popScope();
        lines.push(`${this.i()}function __trait_${node.name}_${method.name}(${params}) {\n${body}\n${this.i()}}`);
      }
    } else {
      lines.push(`${this.i()}/* trait ${node.name} { ${node.methods.map(m => `fn ${m.name}()`).join(', ')} } */`);
    }
    return lines.join('\n');
  }

  genTypeAlias(node) {
    // Type aliases are compile-time only
    const exportStr = node.isPublic ? 'export ' : '';
    const typeParams = node.typeParams && node.typeParams.length > 0 ? `<${node.typeParams.join(', ')}>` : '';
    const typeStr = this._typeAnnotationToString(node.typeExpr);
    return `${this.i()}/* ${exportStr}type alias: ${node.name}${typeParams} = ${typeStr} */`;
  }

  _typeAnnotationToString(ann) {
    if (!ann) return 'any';
    if (ann.type === 'UnionTypeAnnotation') {
      return ann.members.map(m => this._typeAnnotationToString(m)).join(' | ');
    }
    if (ann.type === 'ArrayTypeAnnotation') {
      return `[${this._typeAnnotationToString(ann.elementType)}]`;
    }
    if (ann.type === 'TupleTypeAnnotation') {
      return `(${ann.elementTypes.map(t => this._typeAnnotationToString(t)).join(', ')})`;
    }
    if (ann.type === 'FunctionTypeAnnotation') {
      const params = ann.paramTypes.map(t => this._typeAnnotationToString(t)).join(', ');
      return `(${params}) -> ${this._typeAnnotationToString(ann.returnType)}`;
    }
    if (ann.typeParams && ann.typeParams.length > 0) {
      const params = ann.typeParams.map(t => this._typeAnnotationToString(t)).join(', ');
      return `${ann.name}<${params}>`;
    }
    return ann.name || 'any';
  }

  genRefinementType(node) {
    // Refinement types compile to validator functions
    // type Email = String where { it |> contains("@") }
    // → function __validate_Email(it) { return it.includes("@"); }
    const predExpr = this.genExpression(node.predicate);
    return `${this.i()}function __validate_${node.name}(it) {\n${this.i()}  if (!(${predExpr})) throw new Error("Refinement type ${node.name} validation failed");\n${this.i()}  return it;\n${this.i()}}`;
  }

  genDeferStatement(node) {
    // Defer is handled by genBlockBody which collects defers and wraps in try/finally.
    // If called outside genBlockBody (e.g., via genBlockStatements), generate a no-op comment.
    // The actual defer logic is emitted correctly when genBlockBody processes the enclosing function.
    return `${this.i()}/* defer */`;
  }

  genWithStatement(node) {
    const expr = this.genExpression(node.expression);
    const name = node.name;
    this.declareVar(name);
    const p = [];
    p.push(`${this.i()}const ${name} = ${expr};`);
    p.push(`${this.i()}try {`);
    this.indent++;
    this.pushScope();
    p.push(this.genBlockStatements(node.body));
    this.popScope();
    this.indent--;
    p.push(`${this.i()}} finally {`);
    this.indent++;
    p.push(`${this.i()}if (${name} != null && typeof ${name}.close === 'function') ${name}.close();`);
    p.push(`${this.i()}else if (${name} != null && typeof ${name}.dispose === 'function') ${name}.dispose();`);
    p.push(`${this.i()}else if (${name} != null && typeof ${name}[Symbol.dispose] === 'function') ${name}[Symbol.dispose]();`);
    this.indent--;
    p.push(`${this.i()}}`);
    return p.join('\n');
  }

  genConcurrentBlock(node) {
    const lines = [];
    const tasks = [];       // { callCode, calleeName, spawn, isWasm }
    const assignments = [];

    // Collect spawn tasks from body, preserving spawn node info
    for (const stmt of node.body) {
      if (stmt.type === 'Assignment' && stmt.values && stmt.values[0] && stmt.values[0].type === 'SpawnExpression') {
        const spawn = stmt.values[0];
        const calleeName = spawn.callee && spawn.callee.type === 'Identifier' ? spawn.callee.name : null;
        const callCode = `${this.genExpression(spawn.callee)}(${spawn.arguments.map(a => this.genExpression(a)).join(', ')})`;
        const isWasm = calleeName && this._wasmFunctions.has(calleeName);
        tasks.push({ callCode, calleeName, spawn, isWasm });
        assignments.push(stmt.targets[0]); // string variable name
      } else if (stmt.type === 'ExpressionStatement' && stmt.expression && stmt.expression.type === 'SpawnExpression') {
        const spawn = stmt.expression;
        const calleeName = spawn.callee && spawn.callee.type === 'Identifier' ? spawn.callee.name : null;
        const callCode = `${this.genExpression(spawn.callee)}(${spawn.arguments.map(a => this.genExpression(a)).join(', ')})`;
        const isWasm = calleeName && this._wasmFunctions.has(calleeName);
        tasks.push({ callCode, calleeName, spawn, isWasm });
        assignments.push(null); // fire-and-forget
      } else {
        // Non-spawn statement — generate normally
        lines.push(this.generateStatement(stmt));
      }
    }

    this._needsResultOption = true;

    if (tasks.length === 0) {
      return lines.join('\n');
    }

    const base = this._concurrentCounter = (this._concurrentCounter || 0) + 1;
    const tempVars = tasks.map((_, i) => `__c${base}_${i}`);

    // Classify tasks
    const wasmTasks = tasks.filter(t => t.isWasm);
    const allWasm = wasmTasks.length === tasks.length;
    const hasWasm = wasmTasks.length > 0;

    // Check if all WASM tasks share the same function (shared module optimization)
    const allSameWasm = allWasm && wasmTasks.every(t => t.calleeName === wasmTasks[0].calleeName);

    // --- WASM path: all tasks are @wasm functions ---
    if (allWasm && (node.mode === 'all' || node.mode === 'first' || node.mode === 'cancel_on_error' || (node.mode === 'timeout' && node.timeout))) {
      this._needsRuntimeBridge = true;
      const rtVar = `__tova_rt`;
      // Build task descriptors
      const taskDescs = tasks.map(t => {
        const argsCode = t.spawn.arguments.map(a => this.genExpression(a)).join(', ');
        return `{ wasm: __wasm_bytes_${t.calleeName}, func: ${JSON.stringify(t.calleeName)}, args: [${argsCode}] }`;
      });
      const taskArrayCode = `[${taskDescs.join(', ')}]`;

      // Choose runtime function based on mode
      let rtFunc;
      let rtCallSuffix = '';
      if (node.mode === 'first') {
        rtFunc = 'concurrentWasmFirst';
      } else if (node.mode === 'cancel_on_error') {
        rtFunc = 'concurrentWasmCancelOnError';
      } else if (node.mode === 'timeout' && node.timeout) {
        rtFunc = 'concurrentWasmTimeout';
        rtCallSuffix = `, ${this.genExpression(node.timeout)}`;
      } else {
        rtFunc = allSameWasm ? 'concurrentWasmShared' : 'concurrentWasm';
      }

      if (node.mode === 'first') {
        // First mode: single result from WASM, fallback to Promise.race
        const firstVar = `__first${base}`;
        lines.push(`${this.i()}let ${firstVar};`);
        lines.push(`${this.i()}if (typeof ${rtVar} !== 'undefined' && ${rtVar} && ${rtVar}.isRuntimeAvailable()) {`);
        lines.push(`${this.i()}  ${firstVar} = { __result: new Ok(await ${rtVar}.${rtFunc}(${taskArrayCode})) };`);
        lines.push(`${this.i()}} else {`);
        // Fallback: Promise.race
        const acVar = `__ac${base}`;
        lines.push(`${this.i()}  const ${acVar} = new AbortController();`);
        const fallbackFirst = tasks.map((t, i) =>
          `(async () => { try { const __r = await ${t.callCode}; ${acVar}.abort(); return { __idx: ${i}, __result: new Ok(__r) }; } catch(__e) { return { __idx: ${i}, __result: new Err(__e) }; } })()`
        );
        lines.push(`${this.i()}  ${firstVar} = await Promise.race([`);
        for (let i = 0; i < fallbackFirst.length; i++) {
          lines.push(`${this.i()}    ${fallbackFirst[i]}${i < fallbackFirst.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}  ]);`);
        lines.push(`${this.i()}}`);
        // Assign winner to all named variables
        for (let i = 0; i < assignments.length; i++) {
          if (assignments[i]) {
            this.declareVar(assignments[i]);
            lines.push(`${this.i()}const ${assignments[i]} = ${firstVar}.__result;`);
          }
        }
        return lines.join('\n');
      }

      // All other WASM modes: array result
      lines.push(`${this.i()}let ${tempVars.join(', ')};`);
      lines.push(`${this.i()}if (typeof ${rtVar} !== 'undefined' && ${rtVar} && ${rtVar}.isRuntimeAvailable()) {`);
      lines.push(`${this.i()}  const __wasm_results = await ${rtVar}.${rtFunc}(${taskArrayCode}${rtCallSuffix});`);
      lines.push(`${this.i()}  [${tempVars.join(', ')}] = __wasm_results.map(__v => new Ok(__v));`);
      lines.push(`${this.i()}} else {`);
      // Fallback: standard Promise.all path
      if (node.mode === 'cancel_on_error') {
        const acVar = `__ac${base}`;
        lines.push(`${this.i()}  const ${acVar} = new AbortController();`);
        const fallbackExprs = tasks.map(t =>
          `(async () => { try { return new Ok(await ${t.callCode}); } catch(__e) { ${acVar}.abort(); return new Err(__e); } })()`
        );
        lines.push(`${this.i()}  [${tempVars.join(', ')}] = await Promise.all([`);
        for (let i = 0; i < fallbackExprs.length; i++) {
          lines.push(`${this.i()}    ${fallbackExprs[i]}${i < fallbackExprs.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}  ]);`);
      } else if (node.mode === 'timeout' && node.timeout) {
        const timeoutMs = this.genExpression(node.timeout);
        const fallbackExprs = tasks.map(t =>
          `(async () => { try { return new Ok(await ${t.callCode}); } catch(__e) { return new Err(__e); } })()`
        );
        lines.push(`${this.i()}  [${tempVars.join(', ')}] = await Promise.race([`);
        lines.push(`${this.i()}    Promise.all([`);
        for (let i = 0; i < fallbackExprs.length; i++) {
          lines.push(`${this.i()}      ${fallbackExprs[i]}${i < fallbackExprs.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}    ]),`);
        lines.push(`${this.i()}    new Promise((_, reject) => setTimeout(() => reject(new Error('concurrent timeout')), ${timeoutMs}))`);
        lines.push(`${this.i()}  ]);`);
      } else {
        const fallbackExprs = tasks.map(t =>
          `(async () => { try { return new Ok(await ${t.callCode}); } catch(__e) { return new Err(__e); } })()`
        );
        lines.push(`${this.i()}  [${tempVars.join(', ')}] = await Promise.all([`);
        for (let i = 0; i < fallbackExprs.length; i++) {
          lines.push(`${this.i()}    ${fallbackExprs[i]}${i < fallbackExprs.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}  ]);`);
      }
      lines.push(`${this.i()}}`);
    } else {
      // --- JS path (with per-task WASM routing for mixed blocks) ---
      const taskExprs = tasks.map(t => {
        if (t.isWasm && hasWasm) {
          // Route individual WASM task through runtime with fallback
          this._needsRuntimeBridge = true;
          const argsCode = t.spawn.arguments.map(a => this.genExpression(a)).join(', ');
          return `(async () => { try { if (typeof __tova_rt !== 'undefined' && __tova_rt.isRuntimeAvailable()) { return new Ok(await __tova_rt.execWasm(__wasm_bytes_${t.calleeName}, ${JSON.stringify(t.calleeName)}, [${argsCode}])); } return new Ok(await ${t.callCode}); } catch(__e) { return new Err(__e); } })()`;
        }
        return `(async () => { try { return new Ok(await ${t.callCode}); } catch(__e) { return new Err(__e); } })()`;
      });

      if (node.mode === 'timeout' && node.timeout) {
        const timeoutMs = this.genExpression(node.timeout);
        lines.push(`${this.i()}const [${tempVars.join(', ')}] = await Promise.race([`);
        lines.push(`${this.i()}  Promise.all([`);
        for (let i = 0; i < taskExprs.length; i++) {
          lines.push(`${this.i()}    ${taskExprs[i]}${i < taskExprs.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}  ]),`);
        lines.push(`${this.i()}  new Promise((_, reject) => setTimeout(() => reject(new Error('concurrent timeout')), ${timeoutMs}))`);
        lines.push(`${this.i()}]);`);
      } else if (node.mode === 'cancel_on_error') {
        const acVar = `__ac${base}`;
        lines.push(`${this.i()}const ${acVar} = new AbortController();`);
        const taskExprsAbort = tasks.map(t => {
          if (t.isWasm && hasWasm) {
            this._needsRuntimeBridge = true;
            const argsCode = t.spawn.arguments.map(a => this.genExpression(a)).join(', ');
            return `(async () => { try { if (typeof __tova_rt !== 'undefined' && __tova_rt.isRuntimeAvailable()) { return new Ok(await __tova_rt.execWasm(__wasm_bytes_${t.calleeName}, ${JSON.stringify(t.calleeName)}, [${argsCode}])); } return new Ok(await ${t.callCode}); } catch(__e) { ${acVar}.abort(); return new Err(__e); } })()`;
          }
          return `(async () => { try { return new Ok(await ${t.callCode}); } catch(__e) { ${acVar}.abort(); return new Err(__e); } })()`;
        });
        lines.push(`${this.i()}const [${tempVars.join(', ')}] = await Promise.all([`);
        for (let i = 0; i < taskExprsAbort.length; i++) {
          lines.push(`${this.i()}  ${taskExprsAbort[i]}${i < taskExprsAbort.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}]);`);
      } else if (node.mode === 'first') {
        const acVar = `__ac${base}`;
        const firstVar = `__first${base}`;
        lines.push(`${this.i()}const ${acVar} = new AbortController();`);
        const taskExprsFirst = tasks.map((t, i) => {
          if (t.isWasm && hasWasm) {
            this._needsRuntimeBridge = true;
            const argsCode = t.spawn.arguments.map(a => this.genExpression(a)).join(', ');
            return `(async () => { try { let __r; if (typeof __tova_rt !== 'undefined' && __tova_rt.isRuntimeAvailable()) { __r = await __tova_rt.execWasm(__wasm_bytes_${t.calleeName}, ${JSON.stringify(t.calleeName)}, [${argsCode}]); } else { __r = await ${t.callCode}; } ${acVar}.abort(); return { __idx: ${i}, __result: new Ok(__r) }; } catch(__e) { return { __idx: ${i}, __result: new Err(__e) }; } })()`;
          }
          return `(async () => { try { const __r = await ${t.callCode}; ${acVar}.abort(); return { __idx: ${i}, __result: new Ok(__r) }; } catch(__e) { return { __idx: ${i}, __result: new Err(__e) }; } })()`;
        });
        lines.push(`${this.i()}const ${firstVar} = await Promise.race([`);
        for (let i = 0; i < taskExprsFirst.length; i++) {
          lines.push(`${this.i()}  ${taskExprsFirst[i]}${i < taskExprsFirst.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}]);`);
        // For first mode, assign the winner's result to all named variables
        for (let i = 0; i < assignments.length; i++) {
          if (assignments[i]) {
            this.declareVar(assignments[i]);
            lines.push(`${this.i()}const ${assignments[i]} = ${firstVar}.__result;`);
          }
        }
        return lines.join('\n'); // early return — skip the normal assignment loop
      } else {
        lines.push(`${this.i()}const [${tempVars.join(', ')}] = await Promise.all([`);
        for (let i = 0; i < taskExprs.length; i++) {
          lines.push(`${this.i()}  ${taskExprs[i]}${i < taskExprs.length - 1 ? ',' : ''}`);
        }
        lines.push(`${this.i()}]);`);
      }
    }

    // Assign results to named variables
    for (let i = 0; i < assignments.length; i++) {
      if (assignments[i]) {
        this.declareVar(assignments[i]);
        lines.push(`${this.i()}const ${assignments[i]} = ${tempVars[i]};`);
      }
    }

    return lines.join('\n');
  }

  genSelectStatement(node) {
    this._needsResultOption = true; // for Some/None in _tryReceive
    const base = this._selectCounter = (this._selectCounter || 0) + 1;

    const hasDefault = node.cases.some(c => c.kind === 'default');

    if (hasDefault) {
      return this._genSelectWithDefault(node, base);
    }
    return this._genSelectWithRace(node, base);
  }

  _genSelectWithRace(node, base) {
    const lines = [];
    const selVar = `__sel${base}`;
    const promises = [];

    for (let i = 0; i < node.cases.length; i++) {
      const c = node.cases[i];
      if (c.kind === 'receive') {
        const ch = this.genExpression(c.channel);
        promises.push(`${ch}.receive().then(__v => ({ __case: ${i}, __value: __v }))`);
      } else if (c.kind === 'send') {
        const ch = this.genExpression(c.channel);
        const val = this.genExpression(c.value);
        promises.push(`${ch}.send(${val}).then(() => ({ __case: ${i} }))`);
      } else if (c.kind === 'timeout') {
        const ms = this.genExpression(c.value);
        promises.push(`new Promise(__r => setTimeout(() => __r({ __case: ${i} }), ${ms}))`);
      }
    }

    lines.push(`${this.i()}const ${selVar} = await Promise.race([`);
    for (let i = 0; i < promises.length; i++) {
      lines.push(`${this.i()}  ${promises[i]}${i < promises.length - 1 ? ',' : ''}`);
    }
    lines.push(`${this.i()}]);`);

    // Generate if/else chain (NOT switch — avoids break conflicts in loops)
    for (let i = 0; i < node.cases.length; i++) {
      const c = node.cases[i];
      const prefix = i === 0 ? 'if' : ' else if';
      lines.push(`${this.i()}${prefix} (${selVar}.__case === ${i}) {`);
      this.indent++;
      if (c.kind === 'receive' && c.binding) {
        this.declareVar(c.binding);
        lines.push(`${this.i()}const ${c.binding} = ${selVar}.__value.value;`);
      }
      for (const stmt of c.body) {
        lines.push(this.generateStatement(stmt));
      }
      this.indent--;
      lines.push(`${this.i()}}`);
    }

    return lines.join('\n');
  }

  _genSelectWithDefault(node, base) {
    const lines = [];
    const nonDefault = node.cases.filter(c => c.kind !== 'default');
    const defaultCase = node.cases.find(c => c.kind === 'default');

    lines.push(`${this.i()}{`);
    this.indent++;

    let depth = 0;
    for (let i = 0; i < nonDefault.length; i++) {
      const c = nonDefault[i];
      const tryVar = `__try${base}_${i}`;

      if (c.kind === 'receive') {
        const ch = this.genExpression(c.channel);
        lines.push(`${this.i()}const ${tryVar} = ${ch}._tryReceive();`);
        lines.push(`${this.i()}if (${tryVar}.__tag === 'Some') {`);
        this.indent++;
        if (c.binding) {
          this.declareVar(c.binding);
          lines.push(`${this.i()}const ${c.binding} = ${tryVar}.value;`);
        }
        for (const stmt of c.body) {
          lines.push(this.generateStatement(stmt));
        }
        this.indent--;
        lines.push(`${this.i()}} else {`);
        this.indent++;
        depth++;
      } else if (c.kind === 'send') {
        const ch = this.genExpression(c.channel);
        const val = this.genExpression(c.value);
        lines.push(`${this.i()}const ${tryVar} = ${ch}._trySend(${val});`);
        lines.push(`${this.i()}if (${tryVar}) {`);
        this.indent++;
        for (const stmt of c.body) {
          lines.push(this.generateStatement(stmt));
        }
        this.indent--;
        lines.push(`${this.i()}} else {`);
        this.indent++;
        depth++;
      }
    }

    // Default case body
    for (const stmt of defaultCase.body) {
      lines.push(this.generateStatement(stmt));
    }

    // Close all else blocks
    for (let i = 0; i < depth; i++) {
      this.indent--;
      lines.push(`${this.i()}}`);
    }

    this.indent--;
    lines.push(`${this.i()}}`);

    return lines.join('\n');
  }

  genSpawnExpression(node) {
    // Standalone spawn expression (not inside concurrent block codegen path)
    // This happens when spawn is used directly in an expression context
    const callCode = `${this.genExpression(node.callee)}(${node.arguments.map(a => this.genExpression(a)).join(', ')})`;
    return `(async () => { try { return new Ok(await ${callCode}); } catch(__e) { return new Err(__e); } })()`;
  }

  // Check if a function body contains yield expressions (for generator detection)
  _containsYield(node) {
    if (!node) return false;
    if (node.type === 'YieldExpression') return true;
    if (node.type === 'FunctionDeclaration' || node.type === 'LambdaExpression') return false;
    const cached = this._yieldCache.get(node);
    if (cached !== undefined) return cached;
    let result = false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsYield(item)) { result = true; break; }
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsYield(val)) { result = true; break; }
      }
      if (result) break;
    }
    this._yieldCache.set(node, result);
    return result;
  }

  // ─── Scalar replacement codegen for Result/Option ───────────
  // Generates boolean+value pairs instead of allocating Result/Option objects.

  /**
   * Generates scalar-replaced code for an assignment like:
   *   r = if cond { Ok(val) } else { Err(err) }
   * Output: let r__ok, r__v; if (cond) { r__ok = true; r__v = val; } else { ... }
   */
  _genScalarAssignment(node, info) {
    const varName = node.targets[0];
    const okVar = `${varName}__ok`;
    const vVar = `${varName}__v`;
    const ifExpr = node.values[0];

    // Mark all three names as declared so later code doesn't redeclare
    this.declareVar(varName);
    this.declareVar(okVar);
    this.declareVar(vVar);

    const parts = [];
    parts.push(`${this.i()}let ${okVar}, ${vVar};`);

    // Build if/else chain
    let ifCode = `${this.i()}if (${this.genExpression(ifExpr.condition)}) {\n`;
    this.indent++;
    ifCode += this._genScalarBranch(ifExpr.consequent, okVar, vVar, info.kind);
    this.indent--;
    ifCode += `\n${this.i()}}`;

    if (ifExpr.alternates) {
      for (const alt of ifExpr.alternates) {
        ifCode += ` else if (${this.genExpression(alt.condition)}) {\n`;
        this.indent++;
        ifCode += this._genScalarBranch(alt.body, okVar, vVar, info.kind);
        this.indent--;
        ifCode += `\n${this.i()}}`;
      }
    }

    if (ifExpr.elseBody) {
      ifCode += ` else {\n`;
      this.indent++;
      ifCode += this._genScalarBranch(ifExpr.elseBody, okVar, vVar, info.kind);
      this.indent--;
      ifCode += `\n${this.i()}}`;
    }

    parts.push(ifCode);
    return parts.join('\n');
  }

  /**
   * Generates scalar assignments for one branch of an if expression.
   * Extracts the Ok/Err/Some/None constructor call from the last expression
   * and emits okVar = true/false; vVar = value;
   */
  _genScalarBranch(block, okVar, vVar, kind) {
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    const lines = [];

    // Generate any statements before the last one (side effects)
    for (let i = 0; i < stmts.length - 1; i++) {
      lines.push(this.generateStatement(stmts[i]));
    }

    // Last statement has the constructor
    const last = stmts[stmts.length - 1];
    let expr = last;
    if (last.type === 'ExpressionStatement') expr = last.expression;
    if (last.type === 'ReturnStatement' && last.value) expr = last.value;

    if (expr.type === 'CallExpression' && expr.callee && expr.callee.type === 'Identifier') {
      const name = expr.callee.name;
      if (name === 'Ok' || name === 'Some') {
        lines.push(`${this.i()}${okVar} = true; ${vVar} = ${this.genExpression(expr.arguments[0])};`);
      } else if (name === 'Err') {
        lines.push(`${this.i()}${okVar} = false; ${vVar} = ${this.genExpression(expr.arguments[0])};`);
      }
    } else if (expr.type === 'Identifier' && expr.name === 'None') {
      lines.push(`${this.i()}${okVar} = false; ${vVar} = undefined;`);
    }

    return lines.join('\n');
  }

  // ─── Scalar replacement analysis for Result/Option ──────────
  // Detects local variables assigned from if-expressions that produce
  // Ok/Err or Some/None, where all subsequent usages are safe method
  // calls (isOk, unwrap, unwrapOr, etc.). Such variables can be
  // replaced with a boolean + value pair (zero allocation).

  /**
   * Scans an array of statements for scalar-replaceable Result/Option
   * assignments. Returns Map<varName, {kind, assignIdx}>.
   */
  _preAnalyzeScalarResults(stmts) {
    const map = new Map();
    for (let i = 0; i < stmts.length; i++) {
      const stmt = stmts[i];
      // Must be a single-target, single-value assignment
      if (stmt.type !== 'Assignment' || stmt.targets.length !== 1 || stmt.values.length !== 1) continue;
      const target = stmt.targets[0];
      if (typeof target !== 'string') continue; // skip MemberExpression targets
      const value = stmt.values[0];
      // Value must be an IfExpression (or IfStatement used as expression)
      if (value.type !== 'IfExpression' && value.type !== 'IfStatement') continue;
      const kind = this._detectResultOptionIf(value);
      if (kind === null) continue;
      // Check all subsequent statements for safe usage
      let allSafe = true;
      let anyUsed = false;
      for (let j = i + 1; j < stmts.length; j++) {
        const usage = this._checkScalarSafeUsage(stmts[j], target, kind);
        if (usage === 'unsafe') { allSafe = false; break; }
        if (usage === 'used') anyUsed = true;
      }
      if (allSafe && anyUsed) {
        map.set(target, { kind, assignIdx: i });
      }
    }
    return map;
  }

  /**
   * Checks if ALL branches of an if expression return Ok/Err or Some/None.
   * Returns 'result' | 'option' | null.
   */
  _detectResultOptionIf(ifExpr) {
    // Must have an else branch (otherwise result could be undefined)
    if (!ifExpr.elseBody) return null;

    const types = [];

    // Check consequent block
    types.push(this._getBlockResultType(ifExpr.consequent));

    // Check elif alternates
    if (ifExpr.alternates) {
      for (const alt of ifExpr.alternates) {
        types.push(this._getBlockResultType(alt.body));
      }
    }

    // Check else block
    types.push(this._getBlockResultType(ifExpr.elseBody));

    // All must be non-null
    if (types.some(t => t === null)) return null;

    // Check if all are Result constructors (Ok/Err)
    if (types.every(t => t === 'Ok' || t === 'Err')) return 'result';

    // Check if all are Option constructors (Some/None)
    if (types.every(t => t === 'Some' || t === 'None')) return 'option';

    return null;
  }

  /**
   * Gets the constructor name from the last expression in a block.
   * Returns 'Ok' | 'Err' | 'Some' | 'None' | null.
   */
  _getBlockResultType(block) {
    if (!block) return null;
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    if (stmts.length === 0) return null;
    const last = stmts[stmts.length - 1];
    // Could be ExpressionStatement or bare expression (implicit return)
    let expr = last;
    if (last.type === 'ExpressionStatement') expr = last.expression;
    if (last.type === 'ReturnStatement' && last.value) expr = last.value;
    // Check for Ok(val), Err(val), Some(val) call
    if (expr.type === 'CallExpression' && expr.callee && expr.callee.type === 'Identifier') {
      const name = expr.callee.name;
      if (['Ok', 'Err', 'Some'].includes(name) && expr.arguments.length === 1) return name;
    }
    // Check for bare None identifier
    if (expr.type === 'Identifier' && expr.name === 'None') return 'None';
    return null;
  }

  /**
   * Walks a statement checking all references to varName.
   * Returns 'used' | 'unsafe' | 'none'.
   */
  _checkScalarSafeUsage(stmt, varName, kind) {
    let found = false;
    let safe = true;

    const SAFE_RESULT = new Set(['isOk', 'isErr', 'unwrap', 'unwrapOr', 'expect']);
    const SAFE_OPTION = new Set(['isSome', 'isNone', 'unwrap', 'unwrapOr', 'expect']);
    const safeSet = kind === 'result' ? SAFE_RESULT : SAFE_OPTION;

    // Custom expression walker that handles method calls specially
    const walkExpr = (expr) => {
      if (!expr || !safe) return;
      // Check for varName.method() pattern FIRST
      if (expr.type === 'CallExpression' &&
          expr.callee && expr.callee.type === 'MemberExpression' &&
          !expr.callee.computed &&
          expr.callee.object && expr.callee.object.type === 'Identifier' &&
          expr.callee.object.name === varName) {
        if (safeSet.has(expr.callee.property)) {
          found = true;
          // Walk only the arguments (NOT the callee.object to avoid bare ref detection)
          for (const arg of expr.arguments) walkExpr(arg);
          return;
        }
        // Unsafe method call on the variable
        safe = false;
        return;
      }
      // Check for bare varName reference (not part of a safe method call)
      if (expr.type === 'Identifier' && expr.name === varName) {
        safe = false;
        return;
      }
      // Walk children
      switch (expr.type) {
        case 'BinaryExpression':
        case 'LogicalExpression':
          walkExpr(expr.left);
          walkExpr(expr.right);
          break;
        case 'UnaryExpression':
          walkExpr(expr.operand);
          break;
        case 'CallExpression':
          walkExpr(expr.callee);
          for (const arg of expr.arguments) walkExpr(arg);
          break;
        case 'MemberExpression':
          walkExpr(expr.object);
          if (expr.computed) walkExpr(expr.property);
          break;
        case 'ConditionalExpression':
          walkExpr(expr.condition);
          walkExpr(expr.consequent);
          walkExpr(expr.alternate);
          break;
        case 'ArrayLiteral':
          if (expr.elements) for (const el of expr.elements) walkExpr(el);
          break;
        case 'ObjectLiteral':
          if (expr.properties) for (const prop of expr.properties) walkExpr(prop.value);
          break;
        case 'TemplateLiteral':
          if (expr.expressions) for (const e of expr.expressions) walkExpr(e);
          break;
        // Lambdas/functions — don't descend (separate scope)
        case 'FunctionExpression':
        case 'ArrowFunction':
        case 'LambdaExpression':
          break;
        // Assignment expression
        case 'AssignmentExpression':
          walkExpr(expr.right);
          break;
      }
    };

    // Walk statement dispatching to expression walker
    this._walkStmtForScalar(stmt, walkExpr);

    if (!safe) return 'unsafe';
    return found ? 'used' : 'none';
  }

  /**
   * Walks all expressions within a statement, calling walkExpr for each
   * top-level expression found. Used by _checkScalarSafeUsage.
   */
  _walkStmtForScalar(stmt, walkExpr) {
    if (!stmt) return;
    switch (stmt.type) {
      case 'ExpressionStatement':
        walkExpr(stmt.expression);
        break;
      case 'Assignment':
      case 'VarDeclaration':
        if (stmt.values) for (const v of stmt.values) walkExpr(v);
        if (stmt.targets) {
          for (const t of stmt.targets) {
            if (typeof t === 'object') walkExpr(t);
          }
        }
        break;
      case 'ReturnStatement':
        if (stmt.value) walkExpr(stmt.value);
        break;
      case 'IfStatement':
      case 'IfExpression':
        walkExpr(stmt.condition);
        this._walkBlockForScalar(stmt.consequent, walkExpr);
        if (stmt.alternates) {
          for (const alt of stmt.alternates) {
            walkExpr(alt.condition);
            this._walkBlockForScalar(alt.body, walkExpr);
          }
        }
        if (stmt.elseBody) this._walkBlockForScalar(stmt.elseBody, walkExpr);
        break;
      case 'ForStatement':
        walkExpr(stmt.iterable);
        this._walkBlockForScalar(stmt.body, walkExpr);
        break;
      case 'WhileStatement':
        walkExpr(stmt.condition);
        this._walkBlockForScalar(stmt.body, walkExpr);
        break;
      case 'CallExpression':
        walkExpr(stmt);
        break;
      default:
        if (stmt.expression) walkExpr(stmt.expression);
        break;
    }
  }

  /**
   * Walks all statements in a block, dispatching to _walkStmtForScalar.
   */
  _walkBlockForScalar(block, walkExpr) {
    if (!block) return;
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    for (const s of stmts) this._walkStmtForScalar(s, walkExpr);
  }

  /**
   * General-purpose expression walker. Calls callback(node) for every
   * expression node in the tree.
   */
  _walkExpressions(node, callback) {
    if (!node) return;
    callback(node);
    switch (node.type) {
      case 'BinaryExpression':
      case 'LogicalExpression':
        this._walkExpressions(node.left, callback);
        this._walkExpressions(node.right, callback);
        break;
      case 'UnaryExpression':
        this._walkExpressions(node.operand, callback);
        break;
      case 'CallExpression':
        this._walkExpressions(node.callee, callback);
        for (const arg of node.arguments) this._walkExpressions(arg, callback);
        break;
      case 'MemberExpression':
        this._walkExpressions(node.object, callback);
        if (node.computed) this._walkExpressions(node.property, callback);
        break;
      case 'ConditionalExpression':
        this._walkExpressions(node.condition, callback);
        this._walkExpressions(node.consequent, callback);
        this._walkExpressions(node.alternate, callback);
        break;
      case 'ArrayLiteral':
        if (node.elements) for (const el of node.elements) this._walkExpressions(el, callback);
        break;
      case 'ObjectLiteral':
        if (node.properties) for (const prop of node.properties) this._walkExpressions(prop.value, callback);
        break;
      case 'TemplateLiteral':
        if (node.expressions) for (const expr of node.expressions) this._walkExpressions(expr, callback);
        break;
      // Lambdas/functions — don't descend (separate scope)
      case 'FunctionExpression':
      case 'ArrowFunction':
      case 'LambdaExpression':
        break;
      // Leaf nodes — no children
      case 'Identifier':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        break;
    }
  }

  /**
   * Walks all expressions within a statement.
   */
  _walkStatementExpressions(stmt, callback) {
    if (!stmt) return;
    switch (stmt.type) {
      case 'ExpressionStatement':
        this._walkExpressions(stmt.expression, callback);
        break;
      case 'Assignment':
      case 'VarDeclaration':
        if (stmt.values) for (const v of stmt.values) this._walkExpressions(v, callback);
        if (stmt.targets) {
          for (const t of stmt.targets) {
            if (typeof t === 'object') this._walkExpressions(t, callback);
          }
        }
        break;
      case 'ReturnStatement':
        if (stmt.value) this._walkExpressions(stmt.value, callback);
        break;
      case 'IfStatement':
      case 'IfExpression':
        this._walkExpressions(stmt.condition, callback);
        this._walkStatementBlock(stmt.consequent, callback);
        if (stmt.alternates) {
          for (const alt of stmt.alternates) {
            this._walkExpressions(alt.condition, callback);
            this._walkStatementBlock(alt.body, callback);
          }
        }
        if (stmt.elseBody) this._walkStatementBlock(stmt.elseBody, callback);
        break;
      case 'ForStatement':
        this._walkExpressions(stmt.iterable, callback);
        this._walkStatementBlock(stmt.body, callback);
        break;
      case 'WhileStatement':
        this._walkExpressions(stmt.condition, callback);
        this._walkStatementBlock(stmt.body, callback);
        break;
      case 'CallExpression':
        this._walkExpressions(stmt, callback);
        break;
      default:
        if (stmt.expression) this._walkExpressions(stmt.expression, callback);
        break;
    }
  }

  /**
   * Walks all statements in a block for _walkStatementExpressions.
   */
  _walkStatementBlock(block, callback) {
    if (!block) return;
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    for (const s of stmts) this._walkStatementExpressions(s, callback);
  }
}

// ─── src/codegen/shared-codegen.js ─────────────────────

class SharedCodegen extends BaseCodegen {
  generate(block) {
    const code = block.body.map(stmt => this.generateStatement(stmt)).join('\n');
    return code;
  }

  // Generate any needed helpers (called after all code is generated)
  generateHelpers() {
    const helpers = [];
    // Runtime bridge for WASM-Tokio concurrent execution
    if (this._needsRuntimeBridge) {
      // Try multiple paths: relative to script, package require, absolute from process.cwd()
      helpers.push(`let __tova_rt = null; try { const __p = require('path'); const __d = __p.dirname(typeof __filename !== 'undefined' ? __filename : process.argv[1] || ''); const __candidates = [__p.join(__d, '..', 'src', 'stdlib', 'runtime-bridge.js'), __p.join(process.cwd(), 'src', 'stdlib', 'runtime-bridge.js')]; for (const __c of __candidates) { try { __tova_rt = require(__c); break; } catch(_) {} } } catch(_) {}`);
    }
    helpers.push(this.getStringProtoHelper());
    // Only include Result/Option if Ok/Err/Some/None are used
    if (this._needsResultOption) {
      helpers.push(this.getResultOptionHelper());
    }
    if (this._needsContainsHelper) {
      helpers.push(this.getContainsHelper());
    }
    if (this._needsPropagateHelper) {
      helpers.push(this.getPropagateHelper());
    }
    // Include only used builtin functions
    const selectiveStdlib = buildSelectiveStdlib(this.getUsedBuiltins());
    if (selectiveStdlib) helpers.push(selectiveStdlib);
    return helpers.join('\n');
  }
}

// ─── src/codegen/form-codegen.js ───────────────────────

// Form codegen helper functions for the Tova language
// Generates the revealing-module IIFE pattern for form { } blocks.

/**
 * Generate the validator function body for a single field.
 * @param {string} fieldName - The field name (e.g., "email")
 * @param {Array} validators - Array of FormValidator AST nodes
 * @param {Function} genExpression - The codegen's genExpression method (bound)
 * @param {string} indent - Current indentation string
 * @returns {string} The complete validator function source
 */
function generateValidatorFn(fieldName, validators, genExpression, indent) {
  if (!validators || validators.length === 0) {
    return `${indent}function __validate_${fieldName}(v) { return null; }\n`;
  }

  const lines = [];
  lines.push(`${indent}function __validate_${fieldName}(v) {`);

  for (const v of validators) {
    const msg = v.args.length > 0 ? genExpression(v.args[v.args.length - 1]) : '"Validation failed"';

    switch (v.name) {
      case 'required':
        lines.push(`${indent}  if (v === undefined || v === null || v === "") return ${msg};`);
        break;

      case 'minLength': {
        const len = v.args.length >= 2 ? genExpression(v.args[0]) : '0';
        lines.push(`${indent}  if (typeof v === "string" && v.length < ${len}) return ${msg};`);
        break;
      }

      case 'maxLength': {
        const len = v.args.length >= 2 ? genExpression(v.args[0]) : 'Infinity';
        lines.push(`${indent}  if (typeof v === "string" && v.length > ${len}) return ${msg};`);
        break;
      }

      case 'min': {
        const threshold = v.args.length >= 2 ? genExpression(v.args[0]) : '0';
        lines.push(`${indent}  if (typeof v === "number" && v < ${threshold}) return ${msg};`);
        break;
      }

      case 'max': {
        const threshold = v.args.length >= 2 ? genExpression(v.args[0]) : 'Infinity';
        lines.push(`${indent}  if (typeof v === "number" && v > ${threshold}) return ${msg};`);
        break;
      }

      case 'pattern': {
        const regex = v.args.length >= 2 ? genExpression(v.args[0]) : '/./';
        lines.push(`${indent}  if (typeof v === "string" && !${regex}.test(v)) return ${msg};`);
        break;
      }

      case 'email':
        lines.push(`${indent}  if (typeof v === "string" && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v)) return ${msg};`);
        break;

      case 'matches': {
        const siblingField = v.args[0];
        const siblingName = siblingField && (siblingField.name || siblingField);
        const matchMsg = v.args.length >= 2 ? genExpression(v.args[1]) : '"Fields do not match"';
        if (siblingName) {
          lines.push(`${indent}  if (v !== __${siblingName}_value()) return ${matchMsg};`);
        }
        break;
      }

      case 'validate': {
        // Custom validator: validate(fn(v) ...) — the first arg is a lambda/function
        const fn = v.args.length > 0 ? genExpression(v.args[0]) : '(() => null)';
        if (v.isAsync) {
          // Async validators are handled in a later task — emit a comment placeholder
          lines.push(`${indent}  // async validate: ${fn} (deferred to async validation)`);
        } else {
          lines.push(`${indent}  { const __r = ${fn}(v); if (__r) return __r; }`);
        }
        break;
      }

      default:
        // Unknown validator — emit as custom function call for extensibility
        if (v.args.length > 0) {
          const allArgs = v.args.map(a => genExpression(a)).join(', ');
          lines.push(`${indent}  // custom validator: ${v.name}(${allArgs})`);
        }
        break;
    }
  }

  lines.push(`${indent}  return null;`);
  lines.push(`${indent}}`);
  return lines.join('\n') + '\n';
}

/**
 * Generate the three signal pairs + initial const for a field.
 * @param {string} fieldName - The field name
 * @param {string} initialExpr - The generated JS expression for the initial value
 * @param {string} indent - Current indentation string
 * @returns {string} The signal declarations
 */
function generateFieldSignals(fieldName, initialExpr, indent) {
  const lines = [];
  lines.push(`${indent}const __${fieldName}_initial = ${initialExpr};`);
  lines.push(`${indent}const [__${fieldName}_value, __set_${fieldName}_value] = createSignal(${initialExpr});`);
  lines.push(`${indent}const [__${fieldName}_error, __set_${fieldName}_error] = createSignal(null);`);
  lines.push(`${indent}const [__${fieldName}_touched, __set_${fieldName}_touched] = createSignal(false);`);
  return lines.join('\n') + '\n';
}

/**
 * Generate the field accessor object for a single field.
 * @param {string} fieldName - The field name (may include prefix, e.g., "shipping_street")
 * @param {string} indent - Current indentation string
 * @returns {string} The field accessor object source
 */
function generateFieldAccessor(fieldName, indent) {
  const lines = [];
  lines.push(`${indent}const ${fieldName} = {`);
  lines.push(`${indent}  get value() { return __${fieldName}_value(); },`);
  lines.push(`${indent}  get error() { return __${fieldName}_error(); },`);
  lines.push(`${indent}  get touched() { return __${fieldName}_touched(); },`);
  lines.push(`${indent}  set(v) { __set_${fieldName}_value(v); if (__${fieldName}_touched()) __set_${fieldName}_error(__validate_${fieldName}(v)); },`);
  lines.push(`${indent}  blur() { __set_${fieldName}_touched(true); __set_${fieldName}_error(__validate_${fieldName}(__${fieldName}_value())); },`);
  lines.push(`${indent}  validate() { const e = __validate_${fieldName}(__${fieldName}_value()); __set_${fieldName}_error(e); return e === null; },`);
  lines.push(`${indent}  reset() { __set_${fieldName}_value(__${fieldName}_initial); __set_${fieldName}_error(null); __set_${fieldName}_touched(false); },`);
  lines.push(`${indent}};`);
  return lines.join('\n') + '\n';
}

/**
 * Generate a conditional guard line for a validator function.
 * When the group condition is false, skip validation (return null).
 * @param {string|null} conditionGuardExpr - JS expression that, when true, means "skip validation"
 * @param {string} indent - Current indentation string
 * @returns {string} The guard line, or empty string if no condition
 */
function generateConditionGuard(conditionGuardExpr, indent) {
  if (!conditionGuardExpr) return '';
  return `${indent}  if (${conditionGuardExpr}) return null;\n`;
}

/**
 * Generate the validator function with an optional condition guard for groups.
 * @param {string} fieldName - The prefixed field name (e.g., "shipping_street")
 * @param {Array} validators - Array of FormValidator AST nodes
 * @param {Function} genExpression - The codegen's genExpression method (bound)
 * @param {string} indent - Current indentation string
 * @param {string|null} conditionGuardExpr - If non-null, JS expression to guard (skip when truthy)
 * @returns {string} The complete validator function source
 */
function generateGuardedValidatorFn(fieldName, validators, genExpression, indent, conditionGuardExpr) {
  if (!validators || validators.length === 0) {
    if (conditionGuardExpr) {
      const lines = [];
      lines.push(`${indent}function __validate_${fieldName}(v) {`);
      lines.push(`${indent}  if (${conditionGuardExpr}) return null;`);
      lines.push(`${indent}  return null;`);
      lines.push(`${indent}}`);
      return lines.join('\n') + '\n';
    }
    return `${indent}function __validate_${fieldName}(v) { return null; }\n`;
  }

  const lines = [];
  lines.push(`${indent}function __validate_${fieldName}(v) {`);

  // Insert condition guard before validators
  if (conditionGuardExpr) {
    lines.push(`${indent}  if (${conditionGuardExpr}) return null;`);
  }

  for (const v of validators) {
    const msg = v.args.length > 0 ? genExpression(v.args[v.args.length - 1]) : '"Validation failed"';

    switch (v.name) {
      case 'required':
        lines.push(`${indent}  if (v === undefined || v === null || v === "") return ${msg};`);
        break;

      case 'minLength': {
        const len = v.args.length >= 2 ? genExpression(v.args[0]) : '0';
        lines.push(`${indent}  if (typeof v === "string" && v.length < ${len}) return ${msg};`);
        break;
      }

      case 'maxLength': {
        const len = v.args.length >= 2 ? genExpression(v.args[0]) : 'Infinity';
        lines.push(`${indent}  if (typeof v === "string" && v.length > ${len}) return ${msg};`);
        break;
      }

      case 'min': {
        const threshold = v.args.length >= 2 ? genExpression(v.args[0]) : '0';
        lines.push(`${indent}  if (typeof v === "number" && v < ${threshold}) return ${msg};`);
        break;
      }

      case 'max': {
        const threshold = v.args.length >= 2 ? genExpression(v.args[0]) : 'Infinity';
        lines.push(`${indent}  if (typeof v === "number" && v > ${threshold}) return ${msg};`);
        break;
      }

      case 'pattern': {
        const regex = v.args.length >= 2 ? genExpression(v.args[0]) : '/./';
        lines.push(`${indent}  if (typeof v === "string" && !${regex}.test(v)) return ${msg};`);
        break;
      }

      case 'email':
        lines.push(`${indent}  if (typeof v === "string" && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v)) return ${msg};`);
        break;

      case 'matches': {
        const siblingField = v.args[0];
        const siblingName = siblingField && (siblingField.name || siblingField);
        const matchMsg = v.args.length >= 2 ? genExpression(v.args[1]) : '"Fields do not match"';
        if (siblingName) {
          lines.push(`${indent}  if (v !== __${siblingName}_value()) return ${matchMsg};`);
        }
        break;
      }

      case 'validate': {
        const fn = v.args.length > 0 ? genExpression(v.args[0]) : '(() => null)';
        if (v.isAsync) {
          lines.push(`${indent}  // async validate: ${fn} (deferred to async validation)`);
        } else {
          lines.push(`${indent}  { const __r = ${fn}(v); if (__r) return __r; }`);
        }
        break;
      }

      default:
        if (v.args.length > 0) {
          const allArgs = v.args.map(a => genExpression(a)).join(', ');
          lines.push(`${indent}  // custom validator: ${v.name}(${allArgs})`);
        }
        break;
    }
  }

  lines.push(`${indent}  return null;`);
  lines.push(`${indent}}`);
  return lines.join('\n') + '\n';
}

/**
 * Generate the group accessor object.
 * @param {string} groupName - The group name (e.g., "shipping")
 * @param {Array<{name: string, prefixedName: string}>} childFields - Fields in this group with their prefixed signal names
 * @param {Array<string>} childGroupNames - Names of nested sub-group accessors
 * @param {string} indent - Current indentation string
 * @returns {string} The group accessor object source
 */
function generateGroupAccessor(groupName, childFields, childGroupNames, indent) {
  const lines = [];
  lines.push(`${indent}const ${groupName} = {`);

  // Named field accessors as properties
  for (const f of childFields) {
    lines.push(`${indent}  ${f.name}: ${f.prefixedName},`);
  }

  // Nested group accessors as properties (reference the group's local variable name)
  for (const g of childGroupNames) {
    lines.push(`${indent}  ${g.localName}: ${g.localName},`);
  }

  // get values() — returns object with field values
  const valuesEntries = childFields.map(f => `${f.name}: __${f.prefixedName}_value()`).join(', ');
  lines.push(`${indent}  get values() { return { ${valuesEntries} }; },`);

  // get isValid() — true when all child fields have null errors
  const isValidParts = childFields.map(f => `__${f.prefixedName}_error() === null`);
  const isValidExpr = isValidParts.length > 0 ? isValidParts.join(' && ') : 'true';
  lines.push(`${indent}  get isValid() { return ${isValidExpr}; },`);

  // get isDirty() — true when any child field differs from initial
  const isDirtyParts = childFields.map(f => `__${f.prefixedName}_value() !== __${f.prefixedName}_initial`);
  const isDirtyExpr = isDirtyParts.length > 0 ? isDirtyParts.join(' || ') : 'false';
  lines.push(`${indent}  get isDirty() { return ${isDirtyExpr}; },`);

  // reset() — resets all child fields
  const resetCalls = childFields.map(f => `${f.prefixedName}.reset()`).join('; ');
  lines.push(`${indent}  reset() { ${resetCalls}; },`);

  lines.push(`${indent}};`);
  return lines.join('\n') + '\n';
}

/**
 * Generate a condition expression where form field identifiers are replaced
 * with their signal value calls (__fieldName_value()).
 * @param {Object} condNode - The condition AST node
 * @param {Function} genExpression - The codegen's genExpression method (bound)
 * @param {Set<string>} formFieldNames - Set of all known form field names (top-level)
 * @returns {string} The JS expression with field references replaced by signal calls
 */
function generateConditionExpr(condNode, genExpression, formFieldNames) {
  if (!condNode) return 'true';

  // For identifier nodes that reference form fields, generate signal value calls
  if (condNode.type === 'Identifier' && formFieldNames.has(condNode.name)) {
    return `__${condNode.name}_value()`;
  }

  // For unary not: recurse into the operand
  if (condNode.type === 'UnaryExpression' && (condNode.operator === 'not' || condNode.operator === '!')) {
    const operand = generateConditionExpr(condNode.operand, genExpression, formFieldNames);
    return `(!${operand})`;
  }

  // For binary/logical expressions: recurse into both sides
  if (condNode.type === 'BinaryExpression' || condNode.type === 'LogicalExpression') {
    const left = generateConditionExpr(condNode.left, genExpression, formFieldNames);
    const right = generateConditionExpr(condNode.right, genExpression, formFieldNames);
    const op = condNode.operator === 'and' ? '&&' : condNode.operator === 'or' ? '||' : condNode.operator;
    return `(${left} ${op} ${right})`;
  }

  // Fallback: use the standard genExpression
  return genExpression(condNode);
}

/**
 * Recursively generate all code for a form group (signals, validators, accessors, group accessor).
 * Collects all prefixed field names into the provided allFields array for form-level computeds.
 * @param {Object} group - FormGroupDeclaration AST node
 * @param {string} prefix - Current prefix (e.g., "shipping_" or "billing_address_")
 * @param {Function} genExpression - The codegen's genExpression method (bound)
 * @param {string} indent - Current indentation string
 * @param {Array<string>} allPrefixedNames - Accumulator for all prefixed field names (for form-level isValid/isDirty)
 * @param {string|null} conditionGuardExpr - JS expression to guard validators (from conditional group)
 * @param {Array<{groupName: string, condExpr: string|null}>} conditionalGroups - Accumulator for conditional group info
 * @param {Set<string>} formFieldNames - Set of all top-level form field names (for condition expression resolution)
 * @returns {string} The complete generated code for this group
 */
function generateGroupCode(group, prefix, genExpression, indent, allPrefixedNames, conditionGuardExpr, conditionalGroups, formFieldNames) {
  const p = [];
  const groupPrefix = prefix + group.name + '_';

  // Determine condition guard for this group's validators
  let guardExpr = conditionGuardExpr || null;
  if (group.condition) {
    // Generate the condition expression with field references resolved to signal value calls
    const condExpr = generateConditionExpr(group.condition, genExpression, formFieldNames || new Set());
    // Guard: when condition is false, skip validation
    const thisGuard = `!(${condExpr})`;
    // Combine with parent guard if any
    guardExpr = conditionGuardExpr ? `${conditionGuardExpr} || ${thisGuard}` : thisGuard;

    // Track this conditional group for form-level isValid
    conditionalGroups.push({ groupPrefix, condExpr });
  }

  // Child field info for the group accessor
  const childFields = [];

  // Generate signals, validators, and accessors for each field
  for (const field of group.fields) {
    const prefixedName = groupPrefix + field.name;
    const init = field.initialValue ? genExpression(field.initialValue) : 'null';

    p.push(generateFieldSignals(prefixedName, init, indent));
    p.push(generateGuardedValidatorFn(prefixedName, field.validators, genExpression, indent, guardExpr));
    p.push(generateFieldAccessor(prefixedName, indent));

    allPrefixedNames.push(prefixedName);
    childFields.push({ name: field.name, prefixedName });
  }

  // Recurse into nested groups
  const childGroupNames = [];
  for (const subGroup of (group.groups || [])) {
    p.push(generateGroupCode(subGroup, groupPrefix, genExpression, indent, allPrefixedNames, guardExpr, conditionalGroups, formFieldNames));
    childGroupNames.push({ localName: subGroup.name, prefixedName: groupPrefix + subGroup.name });
  }

  // Generate the group accessor object
  p.push(generateGroupAccessor(group.name, childFields, childGroupNames, indent));

  return p.join('');
}

/**
 * Generate the complete code for a form array declaration.
 * Produces:
 *   - Items list signal (createSignal([]))
 *   - Auto-increment ID counter
 *   - Item factory function (with signal-backed fields, validators, accessors)
 *   - Array accessor object (items, length, add, remove, move)
 *
 * @param {Object} arrayDecl - FormArrayDeclaration AST node
 * @param {Function} genExpression - The codegen's genExpression method (bound)
 * @param {string} indent - Current indentation string
 * @returns {string} The complete generated code for this array
 */
function generateArrayCode(arrayDecl, genExpression, indent) {
  const name = arrayDecl.name;
  const fields = arrayDecl.fields || [];
  const p = [];

  // Items list signal
  p.push(`${indent}const [__${name}, __set_${name}] = createSignal([]);\n`);
  p.push(`${indent}let __${name}_nextId = 0;\n\n`);

  // Item factory function
  p.push(`${indent}function __create${capitalize(name)}Item(defaults) {\n`);
  const fi = indent + '  '; // factory indent

  p.push(`${fi}const __id = __${name}_nextId++;\n`);

  // For each field: initial value, signals, validator, accessor
  for (const field of fields) {
    const fname = field.name;
    const defaultVal = field.initialValue ? genExpression(field.initialValue) : 'null';

    // Initial value (from defaults param or field default)
    p.push(`${fi}const __${fname}_initial = (defaults && defaults.${fname} !== undefined) ? defaults.${fname} : ${defaultVal};\n`);

    // Signals
    p.push(`${fi}const [__${fname}_value, __set_${fname}_value] = createSignal(__${fname}_initial);\n`);
    p.push(`${fi}const [__${fname}_error, __set_${fname}_error] = createSignal(null);\n`);
    p.push(`${fi}const [__${fname}_touched, __set_${fname}_touched] = createSignal(false);\n`);
    p.push(`\n`);
  }

  // Validator functions for each field
  for (const field of fields) {
    p.push(generateValidatorFn(field.name, field.validators, genExpression, fi));
  }

  // Return the item object with field accessors
  p.push(`${fi}return {\n`);
  const ri = fi + '  '; // return indent

  p.push(`${ri}__id,\n`);

  for (const field of fields) {
    const fname = field.name;
    p.push(`${ri}${fname}: {\n`);
    const ai = ri + '  '; // accessor indent
    p.push(`${ai}get value() { return __${fname}_value(); },\n`);
    p.push(`${ai}get error() { return __${fname}_error(); },\n`);
    p.push(`${ai}get touched() { return __${fname}_touched(); },\n`);
    p.push(`${ai}set(v) { __set_${fname}_value(v); if (__${fname}_touched()) __set_${fname}_error(__validate_${fname}(v)); },\n`);
    p.push(`${ai}blur() { __set_${fname}_touched(true); __set_${fname}_error(__validate_${fname}(__${fname}_value())); },\n`);
    p.push(`${ai}validate() { const e = __validate_${fname}(__${fname}_value()); __set_${fname}_error(e); return e === null; },\n`);
    p.push(`${ai}reset() { __set_${fname}_value(__${fname}_initial); __set_${fname}_error(null); __set_${fname}_touched(false); },\n`);
    p.push(`${ri}},\n`);
  }

  // Item-level values getter
  const valuesEntries = fields.map(f => `${f.name}: __${f.name}_value()`).join(', ');
  p.push(`${ri}get values() { return { ${valuesEntries} }; },\n`);

  // Item-level isValid getter
  const isValidParts = fields.map(f => `__${f.name}_error() === null`);
  const isValidExpr = isValidParts.length > 0 ? isValidParts.join(' && ') : 'true';
  p.push(`${ri}get isValid() { return ${isValidExpr}; },\n`);

  p.push(`${fi}};\n`);
  p.push(`${indent}}\n\n`);

  // Array accessor object
  p.push(`${indent}const ${name} = {\n`);
  const oi = indent + '  '; // object indent

  p.push(`${oi}get items() { return __${name}(); },\n`);
  p.push(`${oi}get length() { return __${name}().length; },\n`);

  // add(defaults)
  p.push(`${oi}add(defaults) {\n`);
  p.push(`${oi}  const item = __create${capitalize(name)}Item(defaults);\n`);
  p.push(`${oi}  __set_${name}(prev => [...prev, item]);\n`);
  p.push(`${oi}  return item;\n`);
  p.push(`${oi}},\n`);

  // remove(item)
  p.push(`${oi}remove(item) {\n`);
  p.push(`${oi}  __set_${name}(prev => prev.filter(i => i.__id !== item.__id));\n`);
  p.push(`${oi}},\n`);

  // move(from, to)
  p.push(`${oi}move(from, to) {\n`);
  p.push(`${oi}  __set_${name}(prev => {\n`);
  p.push(`${oi}    const arr = [...prev];\n`);
  p.push(`${oi}    const [moved] = arr.splice(from, 1);\n`);
  p.push(`${oi}    arr.splice(to, 0, moved);\n`);
  p.push(`${oi}    return arr;\n`);
  p.push(`${oi}  });\n`);
  p.push(`${oi}},\n`);

  p.push(`${indent}};\n`);

  return p.join('');
}

/**
 * Generate a createEffect that debounces an async validator for a form field.
 * The effect:
 * 1. Watches the field's value signal
 * 2. Debounces with setTimeout (300ms)
 * 3. Runs the async validation function
 * 4. Uses a version counter to discard stale results
 * 5. Sets the error signal with the result
 *
 * @param {string} fieldName - The field name (e.g., "email")
 * @param {Object} asyncValidator - The FormValidator AST node with isAsync: true
 * @param {Function} genExpression - The codegen's genExpression method (bound)
 * @param {string} indent - Current indentation string
 * @returns {string} The complete async validator effect source
 */
function generateAsyncValidatorEffect(fieldName, asyncValidator, genExpression, indent = '  ') {
  const fn = genExpression(asyncValidator.args[0]); // The async validation function
  const lines = [];
  lines.push(`${indent}let __${fieldName}_asyncVersion = 0;`);
  lines.push(`${indent}let __${fieldName}_asyncTimer = null;`);
  lines.push(`${indent}createEffect(() => {`);
  lines.push(`${indent}  const v = __${fieldName}_value();`);
  lines.push(`${indent}  if (__${fieldName}_asyncTimer) clearTimeout(__${fieldName}_asyncTimer);`);
  lines.push(`${indent}  const version = ++__${fieldName}_asyncVersion;`);
  lines.push(`${indent}  __${fieldName}_asyncTimer = setTimeout(async () => {`);
  lines.push(`${indent}    try {`);
  lines.push(`${indent}      const err = await (${fn})(v);`);
  lines.push(`${indent}      if (version === __${fieldName}_asyncVersion) {`);
  lines.push(`${indent}        __set_${fieldName}_error(err || null);`);
  lines.push(`${indent}      }`);
  lines.push(`${indent}    } catch(e) {`);
  lines.push(`${indent}      if (version === __${fieldName}_asyncVersion) {`);
  lines.push(`${indent}        __set_${fieldName}_error(e.message || "Validation error");`);
  lines.push(`${indent}      }`);
  lines.push(`${indent}    }`);
  lines.push(`${indent}  }, 300);`);
  lines.push(`${indent}});`);
  return lines.join('\n');
}

/**
 * Capitalize the first letter of a string.
 * @param {string} str
 * @returns {string}
 */
function capitalize(str) {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ─── src/codegen/server-codegen.js ─────────────────────

class ServerCodegen extends BaseCodegen {
  _astUsesIdentifier(blocks, name) {
    const search = (node) => {
      if (!node || typeof node !== 'object') return false;
      if (node.type === 'Identifier' && node.name === name) return true;
      if (node.type === 'MemberExpression' && node.object && node.object.type === 'Identifier' && node.object.name === name) return true;
      for (const key of Object.keys(node)) {
        if (key === 'loc' || key === 'type') continue;
        const val = node[key];
        if (Array.isArray(val)) {
          for (const item of val) {
            if (search(item)) return true;
          }
        } else if (val && typeof val === 'object' && val.type) {
          if (search(val)) return true;
        }
      }
      return false;
    };
    for (const block of blocks) {
      if (search(block)) return true;
    }
    return false;
  }

  _genValidationCode(params, indent = '  ') {
    const checks = [];
    for (const p of params) {
      const name = p.name;
      const ta = p.typeAnnotation;
      if (!ta) continue;
      const hasRequiredCheck = !p.defaultValue;
      if (hasRequiredCheck) {
        checks.push(`${indent}if (${name} === undefined || ${name} === null) __validationErrors.push("${name} is required");`);
      }
      const typeCheckPrefix = hasRequiredCheck ? 'else if' : 'if';
      if (ta.type === 'TypeAnnotation') {
        switch (ta.name) {
          case 'String':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "string") __validationErrors.push("${name} must be a string");`);
            break;
          case 'Int':
            checks.push(`${indent}${typeCheckPrefix} (!Number.isInteger(${name})) __validationErrors.push("${name} must be an integer");`);
            break;
          case 'Float':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "number") __validationErrors.push("${name} must be a number");`);
            break;
          case 'Bool':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "boolean") __validationErrors.push("${name} must be a boolean");`);
            break;
        }
      } else if (ta.type === 'ArrayTypeAnnotation') {
        checks.push(`${indent}${typeCheckPrefix} (!Array.isArray(${name})) __validationErrors.push("${name} must be an array");`);
      }
    }
    return checks;
  }

  _genAdvancedValidationCode(schemaExpr, indent = '  ') {
    const checks = [];
    if (schemaExpr.type !== 'ObjectLiteral') return checks;
    for (const prop of schemaExpr.properties) {
      const fieldName = prop.key.type === 'Identifier' ? prop.key.name : (prop.key.type === 'StringLiteral' ? prop.key.value : null);
      if (!fieldName) continue;
      const rules = prop.value;
      if (rules.type !== 'ObjectLiteral') continue;
      for (const rule of rules.properties) {
        const ruleKey = rule.key.type === 'Identifier' ? rule.key.name : (rule.key.type === 'StringLiteral' ? rule.key.value : null);
        if (!ruleKey) continue;
        const ruleVal = this.genExpression(rule.value);
        switch (ruleKey) {
          case 'required':
            checks.push(`${indent}if (${ruleVal} && (__body.${fieldName} === undefined || __body.${fieldName} === null || __body.${fieldName} === "")) __validationErrors.push("${fieldName} is required");`);
            break;
          case 'min_length':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && String(__body.${fieldName}).length < ${ruleVal}) __validationErrors.push("${fieldName} must be at least ${ruleVal} characters");`);
            break;
          case 'max_length':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && String(__body.${fieldName}).length > ${ruleVal}) __validationErrors.push("${fieldName} must be at most ${ruleVal} characters");`);
            break;
          case 'min':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && Number(__body.${fieldName}) < ${ruleVal}) __validationErrors.push("${fieldName} must be at least ${ruleVal}");`);
            break;
          case 'max':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && Number(__body.${fieldName}) > ${ruleVal}) __validationErrors.push("${fieldName} must be at most ${ruleVal}");`);
            break;
          case 'pattern':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && !new RegExp(${ruleVal}).test(String(__body.${fieldName}))) __validationErrors.push("${fieldName} does not match required pattern");`);
            break;
          case 'one_of':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && !${ruleVal}.includes(__body.${fieldName})) __validationErrors.push("${fieldName} must be one of: " + ${ruleVal}.join(", "));`);
            break;
        }
      }
    }
    return checks;
  }

  // Generate nested validation checks for a type, recursing into nested types
  _genNestedTypeValidation(sharedTypes, objExpr, typeInfo, prefix, indent = '  ') {
    const checks = [];
    for (const f of typeInfo.fields) {
      if (f.name === 'id') continue;
      const fieldPath = prefix ? `${prefix}.${f.name}` : f.name;
      const fieldAccess = `${objExpr}.${f.name}`;
      // Check if this field type references another shared type (nested object)
      if (sharedTypes.has(f.type)) {
        const nestedType = sharedTypes.get(f.type);
        checks.push(`${indent}if (${fieldAccess} !== undefined && ${fieldAccess} !== null) {`);
        checks.push(`${indent}  if (typeof ${fieldAccess} !== "object" || Array.isArray(${fieldAccess})) __bodyTypeErrors.push("${fieldPath} must be an object");`);
        checks.push(`${indent}  else {`);
        const nestedChecks = this._genNestedTypeValidation(sharedTypes, fieldAccess, nestedType, fieldPath, indent + '    ');
        checks.push(...nestedChecks);
        checks.push(`${indent}  }`);
        checks.push(`${indent}}`);
      } else {
        switch (f.type) {
          case 'String':
            checks.push(`${indent}if (${fieldAccess} !== undefined && typeof ${fieldAccess} !== "string") __bodyTypeErrors.push("${fieldPath} must be a string");`);
            break;
          case 'Int':
            checks.push(`${indent}if (${fieldAccess} !== undefined && !Number.isInteger(${fieldAccess})) __bodyTypeErrors.push("${fieldPath} must be an integer");`);
            break;
          case 'Float':
            checks.push(`${indent}if (${fieldAccess} !== undefined && typeof ${fieldAccess} !== "number") __bodyTypeErrors.push("${fieldPath} must be a number");`);
            break;
          case 'Bool':
            checks.push(`${indent}if (${fieldAccess} !== undefined && typeof ${fieldAccess} !== "boolean") __bodyTypeErrors.push("${fieldPath} must be a boolean");`);
            break;
        }
      }
    }
    return checks;
  }

  // Generate validation checks from type-level validators (Phase 3)
  // Returns an array of JS code lines for inline validation
  _genTypeValidatorCode(paramName, typeInfo, indent = '  ') {
    const checks = [];
    for (const field of typeInfo.fields) {
      if (!field.validators || field.validators.length === 0) continue;
      const accessor = `${paramName}.${field.name}`;
      for (const v of field.validators) {
        // The last argument is typically the error message
        const msgArg = v.args.length > 0 ? this.genExpression(v.args[v.args.length - 1]) : null;
        switch (v.name) {
          case 'required': {
            const msg = msgArg || `"${field.name} is required"`;
            checks.push(`${indent}if (${accessor} === undefined || ${accessor} === null || ${accessor} === "") __validationErrors.push({ field: "${field.name}", message: ${msg} });`);
            break;
          }
          case 'email': {
            const msg = msgArg || `"${field.name} must be a valid email"`;
            checks.push(`${indent}if (${accessor} && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(${accessor})) __validationErrors.push({ field: "${field.name}", message: ${msg} });`);
            break;
          }
          case 'min': {
            const minVal = this.genExpression(v.args[0]);
            const minMsg = v.args.length >= 2 ? this.genExpression(v.args[1]) : `"${field.name} must be at least ${v.args[0].value || v.args[0].name}"`;
            checks.push(`${indent}if (typeof ${accessor} === "number" && ${accessor} < ${minVal}) __validationErrors.push({ field: "${field.name}", message: ${minMsg} });`);
            break;
          }
          case 'max': {
            const maxVal = this.genExpression(v.args[0]);
            const maxMsg = v.args.length >= 2 ? this.genExpression(v.args[1]) : `"${field.name} must be at most ${v.args[0].value || v.args[0].name}"`;
            checks.push(`${indent}if (typeof ${accessor} === "number" && ${accessor} > ${maxVal}) __validationErrors.push({ field: "${field.name}", message: ${maxMsg} });`);
            break;
          }
          case 'minLength': {
            const minLen = this.genExpression(v.args[0]);
            const minLenMsg = v.args.length >= 2 ? this.genExpression(v.args[1]) : `"${field.name} is too short"`;
            checks.push(`${indent}if (typeof ${accessor} === "string" && ${accessor}.length < ${minLen}) __validationErrors.push({ field: "${field.name}", message: ${minLenMsg} });`);
            break;
          }
          case 'maxLength': {
            const maxLen = this.genExpression(v.args[0]);
            const maxLenMsg = v.args.length >= 2 ? this.genExpression(v.args[1]) : `"${field.name} is too long"`;
            checks.push(`${indent}if (typeof ${accessor} === "string" && ${accessor}.length > ${maxLen}) __validationErrors.push({ field: "${field.name}", message: ${maxLenMsg} });`);
            break;
          }
          case 'pattern': {
            const regex = this.genExpression(v.args[0]);
            const patMsg = v.args.length >= 2 ? this.genExpression(v.args[1]) : `"${field.name} has invalid format"`;
            checks.push(`${indent}if (typeof ${accessor} === "string" && !${regex}.test(${accessor})) __validationErrors.push({ field: "${field.name}", message: ${patMsg} });`);
            break;
          }
          case 'oneOf': {
            const vals = this.genExpression(v.args[0]);
            const oneOfMsg = v.args.length >= 2 ? this.genExpression(v.args[1]) : `"${field.name} has invalid value"`;
            checks.push(`${indent}if (!${vals}.includes(${accessor})) __validationErrors.push({ field: "${field.name}", message: ${oneOfMsg} });`);
            break;
          }
        }
      }
    }
    return checks;
  }

  // Emit handler call, optionally wrapped in Promise.race for timeout
  _emitHandlerCall(lines, callExpr, timeoutMs) {
    if (timeoutMs) {
      lines.push(`  let __result;`);
      lines.push(`  try {`);
      lines.push(`    __result = await Promise.race([`);
      lines.push(`      ${callExpr},`);
      lines.push(`      new Promise((_, rej) => setTimeout(() => rej(new Error("__timeout__")), ${timeoutMs}))`);
      lines.push(`    ]);`);
      lines.push(`  } catch (__err) {`);
      lines.push(`    if (__err.message === "__timeout__") return __errorResponse(504, "GATEWAY_TIMEOUT", "Gateway Timeout");`);
      lines.push(`    throw __err;`);
      lines.push(`  }`);
    } else {
      lines.push(`  const __result = await ${callExpr};`);
    }
  }

  generate(serverBlocks, sharedCode, blockName = null, peerBlocks = null, sharedBlocks = [], securityConfig = null) {
    const lines = [];

    // Generate security code fragments if security block is present
    let securityFragments = null;
    if (securityConfig) {
      const secGen = new SecurityCodegen();
      securityFragments = secGen.generateServerSecurity(securityConfig);
    }

    // Shared code
    if (sharedCode.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedCode);
      lines.push('');
    }

    // Collect all declarations from blocks (including route group flattening)
    const routes = [];
    const functions = [];
    const middlewares = [];
    const otherStatements = [];
    let healthPath = null;
    let healthChecks = null;
    let corsConfig = null;
    let errorHandler = null;
    let wsDecl = null;
    let staticDecl = null;
    let authConfig = null;
    let maxBodyLimit = null;
    const discoverMap = new Map();
    let rateLimitConfig = null;
    const onStartHooks = [];
    const onStopHooks = [];
    const subscriptions = [];
    const envDecls = [];
    const schedules = [];
    let uploadConfig = null;
    let sessionConfig = null;
    let dbConfig = null;
    let tlsConfig = null;
    let compressionConfig = null;
    const backgroundJobs = [];
    let cacheConfig = null;
    const sseDecls = [];
    const modelDecls = [];
    const aiConfigs = []; // { name: string|null, config: object }

    const collectFromBody = (stmts, groupPrefix = null, groupMiddlewares = [], groupVersion = null) => {
      for (const stmt of stmts) {
        if (stmt.type === 'RouteDeclaration') {
          const route = stmt;
          if (groupPrefix) {
            const prefixedRoute = {
              ...route,
              path: groupPrefix + route.path,
              _groupMiddlewares: groupMiddlewares.length > 0 ? [...groupMiddlewares] : undefined,
              _version: groupVersion || undefined,
            };
            routes.push(prefixedRoute);
          } else {
            routes.push(route);
          }
        } else if (stmt.type === 'FunctionDeclaration') {
          functions.push(stmt);
        } else if (stmt.type === 'MiddlewareDeclaration') {
          if (groupPrefix !== null) {
            groupMiddlewares.push(stmt.name);
          }
          middlewares.push(stmt);
        } else if (stmt.type === 'HealthCheckDeclaration') {
          healthPath = stmt.path;
          if (stmt.checks && stmt.checks.length > 0) {
            if (!healthChecks) healthChecks = [];
            healthChecks.push(...stmt.checks);
          }
        } else if (stmt.type === 'CorsDeclaration') {
          corsConfig = stmt.config;
        } else if (stmt.type === 'ErrorHandlerDeclaration') {
          errorHandler = stmt;
        } else if (stmt.type === 'WebSocketDeclaration') {
          wsDecl = stmt;
        } else if (stmt.type === 'StaticDeclaration') {
          staticDecl = stmt;
        } else if (stmt.type === 'AuthDeclaration') {
          authConfig = stmt.config;
        } else if (stmt.type === 'MaxBodyDeclaration') {
          maxBodyLimit = stmt.limit;
        } else if (stmt.type === 'DiscoverDeclaration') {
          discoverMap.set(stmt.peerName, stmt);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          const prefix = groupPrefix ? groupPrefix + stmt.prefix : stmt.prefix;
          const grpMw = [...groupMiddlewares]; // inherit parent group middlewares
          const ver = stmt.version || groupVersion; // inherit or override version
          collectFromBody(stmt.body, prefix, grpMw, ver);
        } else if (stmt.type === 'RateLimitDeclaration') {
          rateLimitConfig = stmt.config;
        } else if (stmt.type === 'LifecycleHookDeclaration') {
          if (stmt.hook === 'start') onStartHooks.push(stmt);
          else if (stmt.hook === 'stop') onStopHooks.push(stmt);
        } else if (stmt.type === 'SubscribeDeclaration') {
          subscriptions.push(stmt);
        } else if (stmt.type === 'EnvDeclaration') {
          envDecls.push(stmt);
        } else if (stmt.type === 'ScheduleDeclaration') {
          schedules.push(stmt);
        } else if (stmt.type === 'UploadDeclaration') {
          uploadConfig = stmt.config;
        } else if (stmt.type === 'SessionDeclaration') {
          sessionConfig = stmt.config;
        } else if (stmt.type === 'DbDeclaration') {
          dbConfig = stmt.config;
        } else if (stmt.type === 'TlsDeclaration') {
          tlsConfig = stmt.config;
        } else if (stmt.type === 'CompressionDeclaration') {
          compressionConfig = stmt.config;
        } else if (stmt.type === 'BackgroundJobDeclaration') {
          backgroundJobs.push(stmt);
        } else if (stmt.type === 'CacheDeclaration') {
          cacheConfig = stmt.config;
        } else if (stmt.type === 'SseDeclaration') {
          sseDecls.push(stmt);
        } else if (stmt.type === 'ModelDeclaration') {
          modelDecls.push(stmt);
        } else if (stmt.type === 'AiConfigDeclaration') {
          aiConfigs.push(stmt);
        } else {
          otherStatements.push(stmt);
        }
      }
    };

    for (const block of serverBlocks) {
      collectFromBody(block.body);
    }

    // Security block overrides: security block takes precedence over inline declarations
    if (securityFragments) {
      if (securityFragments.authConfig && !authConfig) {
        authConfig = securityFragments.authConfig;
      }
      if (securityFragments.corsConfig && !corsConfig) {
        corsConfig = securityFragments.corsConfig;
      }
      if (securityFragments.rateLimitConfig && !rateLimitConfig) {
        rateLimitConfig = securityFragments.rateLimitConfig;
      }
    }

    // Collect type declarations from shared blocks for model/ORM generation
    const sharedTypes = new Map(); // typeName -> { fields: [{ name, type, validators? }] }
    const _collectTypes = (stmts) => {
      for (const stmt of stmts) {
        if (stmt.type === 'TypeDeclaration' && stmt.variants) {
          const fields = [];
          for (const v of stmt.variants) {
            if (v.type === 'TypeField' && v.typeAnnotation) {
              const fieldInfo = { name: v.name, type: v.typeAnnotation.name || (v.typeAnnotation.type === 'ArrayTypeAnnotation' ? 'Array' : 'Any') };
              // Capture type-level validators (Phase 3) if present
              if (v.validators && v.validators.length > 0) {
                fieldInfo.validators = v.validators;
              }
              fields.push(fieldInfo);
            }
          }
          if (fields.length > 0) {
            sharedTypes.set(stmt.name, { fields });
          }
        }
      }
    };
    for (const sb of sharedBlocks) {
      _collectTypes(sb.body);
    }
    // Also collect types from server blocks (for body: Type validation)
    for (const block of serverBlocks) {
      _collectTypes(block.body);
    }

    // Separate group-only middlewares from global middlewares
    const globalMiddlewares = [];
    const allMiddlewareNames = new Set();
    for (const block of serverBlocks) {
      for (const stmt of block.body) {
        if (stmt.type === 'MiddlewareDeclaration') {
          globalMiddlewares.push(stmt);
        }
      }
    }
    for (const mw of middlewares) {
      allMiddlewareNames.add(mw.name);
    }

    // Build function param lookup map
    const fnParamMap = new Map();
    const fnDeclMap = new Map();
    for (const fn of functions) {
      fnParamMap.set(fn.name, fn.params.map(p => p.name));
      fnDeclMap.set(fn.name, fn);
    }

    // Check if 'db' is used
    const usesDb = this._astUsesIdentifier(serverBlocks, 'db');

    // Check if rate limiting is needed
    const hasSecurityProtectRateLimit = securityConfig && securityConfig.protects && securityConfig.protects.some(p => p.config.rate_limit);
    const needsRateLimitStore = !!rateLimitConfig || routes.some(r => (r.decorators || []).some(d => d.name === 'rate_limit')) || hasSecurityProtectRateLimit;

    // Fast mode: emit a minimal request handler when no complex features are used
    const allRoutesStatic = routes.every(r => !r.path.includes(':') && !r.path.includes('*'));
    const hasDynamicRoutes = !allRoutesStatic;
    const isFastMode = !corsConfig && !authConfig && !sessionConfig && !rateLimitConfig &&
      !errorHandler && !wsDecl && !staticDecl && !compressionConfig && !securityFragments &&
      middlewares.length === 0 && !dbConfig && subscriptions.length === 0 &&
      backgroundJobs.length === 0 && sseDecls.length === 0 && !cacheConfig &&
      routes.every(r => !(r.decorators || []).length && !r._groupMiddlewares?.length && !r._version);

    // ════════════════════════════════════════════════════════════
    // 1. Distributed Tracing
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
    lines.push('// ── Distributed Tracing ──');
    lines.push('import { AsyncLocalStorage } from "node:async_hooks";');
    lines.push('const __requestContext = new AsyncLocalStorage();');
    lines.push('function __getRequestId() {');
    lines.push('  const store = __requestContext.getStore();');
    lines.push('  return store ? store.rid : null;');
    lines.push('}');
    lines.push('function __getLocals() {');
    lines.push('  const store = __requestContext.getStore();');
    lines.push('  return store ? store.locals : {};');
    lines.push('}');
    lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 2. Env Validation (F6) — fail fast
    // ════════════════════════════════════════════════════════════
    if (envDecls.length > 0) {
      lines.push('// ── Env Validation ──');
      // Collect all required env vars without defaults and validate presence before any exit
      const requiredEnvs = envDecls.filter(d => !d.defaultValue);
      if (requiredEnvs.length > 0) {
        lines.push(`const __envErrors = [];`);
        for (const decl of requiredEnvs) {
          lines.push(`if (process.env.${decl.name} === undefined || process.env.${decl.name} === "") __envErrors.push("${decl.name}");`);
        }
        lines.push(`if (__envErrors.length > 0) { console.error("Missing required env vars: " + __envErrors.join(", ")); process.exit(1); }`);
      }
      for (const decl of envDecls) {
        const envName = decl.name;
        const ta = decl.typeAnnotation;
        const typeName = ta ? ta.name : 'String';
        lines.push(`const ${envName} = (() => {`);
        lines.push(`  const __raw = process.env.${envName};`);
        if (decl.defaultValue) {
          const defaultExpr = this.genExpression(decl.defaultValue);
          lines.push(`  if (__raw === undefined || __raw === "") return ${defaultExpr};`);
        }
        switch (typeName) {
          case 'Int':
            lines.push(`  const __val = parseInt(__raw, 10);`);
            lines.push(`  if (isNaN(__val)) { console.error("env ${envName}: expected Int, got " + __raw); process.exit(1); }`);
            lines.push(`  return __val;`);
            break;
          case 'Float':
            lines.push(`  const __val = parseFloat(__raw);`);
            lines.push(`  if (isNaN(__val)) { console.error("env ${envName}: expected Float, got " + __raw); process.exit(1); }`);
            lines.push(`  return __val;`);
            break;
          case 'Bool':
            lines.push(`  return __raw === "true" || __raw === "1";`);
            break;
          default:
            lines.push(`  return __raw;`);
            break;
        }
        lines.push(`})();`);
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 3. Database (multi-driver: sqlite, postgres, mysql)
    // ════════════════════════════════════════════════════════════
    const dbDriver = dbConfig && dbConfig.driver ? (dbConfig.driver.value || 'sqlite') : 'sqlite';
    if (dbConfig || usesDb) {
      lines.push('// ── Database ──');
      if (dbDriver === 'postgres') {
        lines.push('import postgres from "postgres";');
        const urlExpr = dbConfig && dbConfig.url ? this.genExpression(dbConfig.url) : 'process.env.DATABASE_URL || "postgres://localhost:5432/app"';
        lines.push(`const __pg = postgres(${urlExpr});`);
        lines.push('const db = {');
        lines.push('  async query(sql, ...params) {');
        lines.push('    if (params.length > 0) { return __pg.unsafe(sql, params); }');
        lines.push('    return __pg.unsafe(sql);');
        lines.push('  },');
        lines.push('  async run(sql, ...params) {');
        lines.push('    if (params.length > 0) { return __pg.unsafe(sql, params); }');
        lines.push('    return __pg.unsafe(sql);');
        lines.push('  },');
        lines.push('  async get(sql, ...params) {');
        lines.push('    const rows = params.length > 0 ? await __pg.unsafe(sql, params) : await __pg.unsafe(sql);');
        lines.push('    return rows[0] || null;');
        lines.push('  },');
        lines.push('  async exec(sql) { return __pg.unsafe(sql); },');
        lines.push('  async transaction(fn) {');
        lines.push('    return __pg.begin(sql => fn({ query: (s, ...p) => sql.unsafe(s, p), run: (s, ...p) => sql.unsafe(s, p), get: async (s, ...p) => { const r = await sql.unsafe(s, p); return r[0] || null; }, exec: (s) => sql.unsafe(s) }));');
        lines.push('  },');
        lines.push('  async migrate(migrations) {');
        lines.push('    await __pg.unsafe(`CREATE TABLE IF NOT EXISTS __migrations (id SERIAL PRIMARY KEY, name TEXT NOT NULL UNIQUE, applied_at TIMESTAMPTZ DEFAULT NOW())`);');
        lines.push('    const applied = new Set((await __pg.unsafe("SELECT name FROM __migrations")).map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!applied.has(m.name)) {');
        lines.push('        await __pg.unsafe(m.up);');
        lines.push('        await __pg.unsafe("INSERT INTO __migrations (name) VALUES ($1)", [m.name]);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  async close() { await __pg.end(); },');
        lines.push('};');
      } else if (dbDriver === 'mysql') {
        lines.push('import mysql from "mysql2/promise";');
        const urlExpr = dbConfig && dbConfig.url ? this.genExpression(dbConfig.url) : 'process.env.DATABASE_URL || "mysql://localhost:3306/app"';
        lines.push(`const __mysqlPool = mysql.createPool(${urlExpr});`);
        lines.push('const db = {');
        lines.push('  async query(sql, ...params) {');
        lines.push('    const [rows] = await __mysqlPool.execute(sql, params);');
        lines.push('    return rows;');
        lines.push('  },');
        lines.push('  async run(sql, ...params) {');
        lines.push('    const [result] = await __mysqlPool.execute(sql, params);');
        lines.push('    return result;');
        lines.push('  },');
        lines.push('  async get(sql, ...params) {');
        lines.push('    const [rows] = await __mysqlPool.execute(sql, params);');
        lines.push('    return rows[0] || null;');
        lines.push('  },');
        lines.push('  async exec(sql) { const [r] = await __mysqlPool.query(sql); return r; },');
        lines.push('  async transaction(fn) {');
        lines.push('    const conn = await __mysqlPool.getConnection();');
        lines.push('    await conn.beginTransaction();');
        lines.push('    try {');
        lines.push('      const result = await fn({ query: async (s, ...p) => { const [r] = await conn.execute(s, p); return r; }, run: async (s, ...p) => { const [r] = await conn.execute(s, p); return r; }, get: async (s, ...p) => { const [r] = await conn.execute(s, p); return r[0] || null; }, exec: async (s) => { const [r] = await conn.query(s); return r; } });');
        lines.push('      await conn.commit();');
        lines.push('      return result;');
        lines.push('    } catch (e) { await conn.rollback(); throw e; }');
        lines.push('    finally { conn.release(); }');
        lines.push('  },');
        lines.push('  async migrate(migrations) {');
        lines.push('    await __mysqlPool.query(`CREATE TABLE IF NOT EXISTS __migrations (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL UNIQUE, applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);');
        lines.push('    const [applied] = await __mysqlPool.query("SELECT name FROM __migrations");');
        lines.push('    const appliedSet = new Set(applied.map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!appliedSet.has(m.name)) {');
        lines.push('        await __mysqlPool.query(m.up);');
        lines.push('        await __mysqlPool.execute("INSERT INTO __migrations (name) VALUES (?)", [m.name]);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  async close() { await __mysqlPool.end(); },');
        lines.push('};');
      } else {
        // Default: SQLite
        lines.push('import { Database } from "bun:sqlite";');
        const pathExpr = dbConfig && dbConfig.path ? this.genExpression(dbConfig.path) : '":memory:"';
        lines.push(`const __db = new Database(${pathExpr});`);
        const walEnabled = dbConfig && dbConfig.wal ? this.genExpression(dbConfig.wal) : 'true';
        lines.push(`if (${walEnabled}) __db.exec("PRAGMA journal_mode=WAL");`);
        lines.push('__db.exec("PRAGMA foreign_keys=ON");');
        lines.push('const db = {');
        lines.push('  query(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.all(...params);');
        lines.push('  },');
        lines.push('  run(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.run(...params);');
        lines.push('  },');
        lines.push('  get(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.get(...params);');
        lines.push('  },');
        lines.push('  exec(sql) { return __db.exec(sql); },');
        lines.push('  transaction(fn) {');
        lines.push('    return __db.transaction(fn)();');
        lines.push('  },');
        lines.push('  migrate(migrations) {');
        lines.push('    __db.exec(`CREATE TABLE IF NOT EXISTS __migrations (');
        lines.push('      id INTEGER PRIMARY KEY, name TEXT NOT NULL UNIQUE, applied_at TEXT DEFAULT (datetime(\'now\'))');
        lines.push('    )`);');
        lines.push('    const applied = new Set(__db.prepare("SELECT name FROM __migrations").all().map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!applied.has(m.name)) {');
        lines.push('        __db.exec(m.up);');
        lines.push('        __db.prepare("INSERT INTO __migrations (name) VALUES (?)").run(m.name);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  close() { __db.close(); },');
        lines.push('};');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 3b. AI Client Initialization
    // ════════════════════════════════════════════════════════════
    if (aiConfigs.length > 0) {
      lines.push('// ── AI Clients ──');
      lines.push(this._getAiRuntime());
      lines.push('');

      let hasDefaultAi = false;
      for (const aiConf of aiConfigs) {
        const configParts = [];
        for (const [key, valueNode] of Object.entries(aiConf.config)) {
          configParts.push(`  ${key}: ${this.genExpression(valueNode)}`);
        }
        const configStr = `{\n${configParts.join(',\n')}\n}`;

        if (aiConf.name) {
          // Named provider: ai "claude" { ... } → const claude = __createAI({...})
          lines.push(`const ${aiConf.name} = __createAI(${configStr});`);
        } else {
          // Default provider: ai { ... } → const ai = __createAI({...})
          lines.push(`const ai = __createAI(${configStr});`);
          hasDefaultAi = true;
        }
      }
      // If no default ai config, create a default for one-off calls
      if (!hasDefaultAi) {
        lines.push('const ai = __createAI({});');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 4. Peer Server RPC Proxies (with circuit breaker + retry)
    // ════════════════════════════════════════════════════════════
    if (peerBlocks && peerBlocks.size > 0) {
      lines.push('// ── Circuit Breaker + Retry ──');
      lines.push('class __CircuitBreaker {');
      lines.push('  constructor(name, threshold = 5, resetTimeout = 30000) {');
      lines.push('    this.name = name;');
      lines.push('    this.state = "CLOSED";');
      lines.push('    this.failures = 0;');
      lines.push('    this.threshold = threshold;');
      lines.push('    this.resetTimeout = resetTimeout;');
      lines.push('    this.nextAttempt = 0;');
      lines.push('  }');
      lines.push('  async call(fn) {');
      lines.push('    if (this.state === "OPEN") {');
      lines.push('      if (Date.now() < this.nextAttempt) {');
      lines.push('        throw new Error(`Circuit breaker OPEN for ${this.name}`);');
      lines.push('      }');
      lines.push('      this.state = "HALF_OPEN";');
      lines.push('    }');
      lines.push('    try {');
      lines.push('      const result = await fn();');
      lines.push('      this.failures = 0;');
      lines.push('      this.state = "CLOSED";');
      lines.push('      return result;');
      lines.push('    } catch (err) {');
      lines.push('      this.failures++;');
      lines.push('      if (this.failures >= this.threshold) {');
      lines.push('        this.state = "OPEN";');
      lines.push('        this.nextAttempt = Date.now() + this.resetTimeout;');
      lines.push('      }');
      lines.push('      throw err;');
      lines.push('    }');
      lines.push('  }');
      lines.push('}');
      lines.push('');
      lines.push('async function __retryWithBackoff(fn, retries = 2, baseDelay = 100) {');
      lines.push('  for (let i = 0; i <= retries; i++) {');
      lines.push('    try { return await fn(); } catch (err) {');
      lines.push('      if (i === retries) throw err;');
      lines.push('      await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, i)));');
      lines.push('    }');
      lines.push('  }');
      lines.push('}');
      lines.push('');

      lines.push('// ── Peer Server RPC Proxies ──');
      for (const [peerName, peerFunctions] of peerBlocks) {
        const portVar = `PORT_${peerName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}`;
        const disc = discoverMap.get(peerName);
        const cbThreshold = disc && disc.config && disc.config.threshold ? this.genExpression(disc.config.threshold) : '5';
        const cbReset = disc && disc.config && disc.config.reset_timeout ? this.genExpression(disc.config.reset_timeout) : '30000';
        const rpcTimeout = disc && disc.config && disc.config.timeout ? this.genExpression(disc.config.timeout) : '10000';
        lines.push(`const __cb_${peerName} = new __CircuitBreaker("${peerName}", ${cbThreshold}, ${cbReset});`);

        let baseUrlExpr;
        if (disc) {
          baseUrlExpr = this.genExpression(disc.urlExpression);
        } else {
          baseUrlExpr = `(process.env.${portVar} ? \`http://localhost:\${process.env.${portVar}}\` : "http://localhost:3000")`;
        }

        lines.push(`const ${peerName} = {`);
        lines.push(`  __baseUrl: ${baseUrlExpr},`);
        for (const fnName of peerFunctions) {
          lines.push(`  async ${fnName}(...args) {`);
          lines.push(`    return __cb_${peerName}.call(() => __retryWithBackoff(async () => {`);
          lines.push(`      const __controller = new AbortController();`);
          lines.push(`      const __timeout = setTimeout(() => __controller.abort(), ${rpcTimeout});`);
          lines.push(`      try {`);
          lines.push(`        const __res = await fetch(\`\${${peerName}.__baseUrl}/rpc/${fnName}\`, {`);
          lines.push(`          method: 'POST',`);
          lines.push(`          headers: { 'Content-Type': 'application/json', 'X-Request-Id': __getRequestId() || '' },`);
          lines.push(`          body: JSON.stringify({ __args: args }),`);
          lines.push(`          signal: __controller.signal,`);
          lines.push(`        });`);
          lines.push(`        if (!__res.ok) throw new Error(\`RPC ${peerName}.${fnName} failed: \${__res.status}\`);`);
          lines.push(`        return (await __res.json()).result;`);
          lines.push(`      } catch (__err) {`);
          lines.push(`        if (__err.name === 'AbortError') throw new Error(\`RPC ${peerName}.${fnName} timed out\`);`);
          lines.push(`        throw __err;`);
          lines.push(`      } finally {`);
          lines.push(`        clearTimeout(__timeout);`);
          lines.push(`      }`);
          lines.push(`    }));`);
          lines.push(`  },`);
        }
        lines.push(`};`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 5. Runtime Helpers (respond, cookies)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Runtime Helpers ──');
    lines.push('function respond(status, body, headers = {}) {');
    lines.push('  const __hasContentType = Object.keys(headers).some(k => k.toLowerCase() === "content-type");');
    lines.push('  if (__hasContentType) {');
    lines.push('    const data = typeof body === "string" ? body : JSON.stringify(body);');
    lines.push('    return new Response(data, { status, headers });');
    lines.push('  }');
    lines.push('  return new Response(JSON.stringify(body), {');
    lines.push('    status,');
    lines.push('    headers: { "Content-Type": "application/json", ...headers },');
    lines.push('  });');
    lines.push('}');
    lines.push('');

    lines.push('function __parseQuery(searchParams) {');
    lines.push('  const q = {};');
    lines.push('  for (const [k, v] of searchParams) {');
    lines.push('    if (q[k] !== undefined) {');
    lines.push('      if (!Array.isArray(q[k])) q[k] = [q[k]];');
    lines.push('      q[k].push(v);');
    lines.push('    } else { q[k] = v; }');
    lines.push('  }');
    lines.push('  return q;');
    lines.push('}');
    lines.push('function __parseCookies(str) {');
    lines.push('  const c = {};');
    lines.push('  if (!str) return c;');
    lines.push('  for (const pair of str.split(";")) {');
    lines.push('    const [k, ...v] = pair.trim().split("=");');
    lines.push('    if (k) c[k.trim()] = v.join("=").trim();');
    lines.push('  }');
    lines.push('  return c;');
    lines.push('}');
    lines.push('');
    lines.push('async function __readBodyBytes(req) {');
    lines.push('  if (!req.body) return new Uint8Array(0);');
    lines.push('  const reader = req.body.getReader();');
    lines.push('  const chunks = [];');
    lines.push('  let totalBytes = 0;');
    lines.push('  while (true) {');
    lines.push('    const { done, value } = await reader.read();');
    lines.push('    if (done) break;');
    lines.push('    totalBytes += value.byteLength;');
    lines.push('    if (totalBytes > __maxBodySize) throw new Error("__BODY_TOO_LARGE__");');
    lines.push('    chunks.push(value);');
    lines.push('  }');
    lines.push('  const result = new Uint8Array(totalBytes);');
    lines.push('  let offset = 0;');
    lines.push('  for (const chunk of chunks) { result.set(chunk, offset); offset += chunk.byteLength; }');
    lines.push('  return result;');
    lines.push('}');
    lines.push('async function __parseBody(req) {');
    lines.push('  const ct = (req.headers.get("content-type") || "").toLowerCase();');
    lines.push('  if (ct.includes("multipart/form-data")) {');
    lines.push('    try {');
    lines.push('      const fd = await req.formData();');
    lines.push('      const obj = {};');
    lines.push('      for (const [k, v] of fd) {');
    lines.push('        if (obj[k] !== undefined) {');
    lines.push('          if (!Array.isArray(obj[k])) obj[k] = [obj[k]];');
    lines.push('          obj[k].push(v);');
    lines.push('        } else { obj[k] = v; }');
    lines.push('      }');
    lines.push('      return obj;');
    lines.push('    } catch { return null; }');
    lines.push('  }');
    lines.push('  const raw = await __readBodyBytes(req);');
    lines.push('  const text = new TextDecoder().decode(raw);');
    lines.push('  if (ct.includes("application/x-www-form-urlencoded")) {');
    lines.push('    try {');
    lines.push('      const sp = new URLSearchParams(text);');
    lines.push('      const obj = {};');
    lines.push('      for (const [k, v] of sp) {');
    lines.push('        if (obj[k] !== undefined) {');
    lines.push('          if (!Array.isArray(obj[k])) obj[k] = [obj[k]];');
    lines.push('          obj[k].push(v);');
    lines.push('        } else { obj[k] = v; }');
    lines.push('      }');
    lines.push('      return obj;');
    lines.push('    } catch { return null; }');
    lines.push('  }');
    lines.push('  try { return __sanitizeBody(JSON.parse(text)); } catch { return null; }');
    lines.push('}');
    lines.push('function __sanitizeBody(obj) {');
    lines.push('  if (obj === null || typeof obj !== "object") return obj;');
    lines.push('  if (Array.isArray(obj)) return obj.map(__sanitizeBody);');
    lines.push('  const clean = {};');
    lines.push('  for (const key of Object.keys(obj)) {');
    lines.push('    if (key === "__proto__" || key === "constructor" || key === "prototype") continue;');
    lines.push('    clean[key] = __sanitizeBody(obj[key]);');
    lines.push('  }');
    lines.push('  return clean;');
    lines.push('}');

    // ════════════════════════════════════════════════════════════
    // 6. Response Helpers (F4) — redirect, set_cookie, stream
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Response Helpers ──');
    lines.push('function redirect(url, status = 302) {');
    lines.push('  return new Response(null, { status, headers: { Location: url } });');
    lines.push('}');
    lines.push('function set_cookie(name, value, options = {}) {');
    lines.push('  let cookie = `${name}=${encodeURIComponent(value)}`;');
    lines.push('  if (options.maxAge) cookie += `; Max-Age=${options.maxAge}`;');
    lines.push('  if (options.path) cookie += `; Path=${options.path}`;');
    lines.push('  if (options.domain) cookie += `; Domain=${options.domain}`;');
    lines.push('  if (options.httpOnly) cookie += "; HttpOnly";');
    lines.push('  if (options.secure) cookie += "; Secure";');
    lines.push('  if (options.sameSite) cookie += `; SameSite=${options.sameSite}`;');
    lines.push('  return cookie;');
    lines.push('}');
    lines.push('function stream(fn) {');
    lines.push('  const readable = new ReadableStream({');
    lines.push('    start(controller) {');
    lines.push('      const send = (data) => controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(data)}\\n\\n`));');
    lines.push('      const close = () => controller.close();');
    lines.push('      fn(send, close);');
    lines.push('    }');
    lines.push('  });');
    lines.push('  return new Response(readable, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });');
    lines.push('}');
    lines.push('function sse(fn) {');
    lines.push('  let cancelled = false;');
    lines.push('  const readable = new ReadableStream({');
    lines.push('    async start(controller) {');
    lines.push('      const send = (data, event) => {');
    lines.push('        if (cancelled) return;');
    lines.push('        let msg = "";');
    lines.push('        if (event) msg += `event: ${event}\\n`;');
    lines.push('        msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
    lines.push('        controller.enqueue(new TextEncoder().encode(msg));');
    lines.push('      };');
    lines.push('      const close = () => { cancelled = true; controller.close(); };');
    lines.push('      await fn(send, close);');
    lines.push('    },');
    lines.push('    cancel() { cancelled = true; }');
    lines.push('  });');
    lines.push('  return new Response(readable, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });');
    lines.push('}');
    lines.push('function html(body, status = 200, headers = {}) {');
    lines.push('  return new Response(body, { status, headers: { "Content-Type": "text/html", ...headers } });');
    lines.push('}');
    lines.push('function text(body, status = 200, headers = {}) {');
    lines.push('  return new Response(body, { status, headers: { "Content-Type": "text/plain", ...headers } });');
    lines.push('}');
    lines.push('function with_headers(response, headers) {');
    lines.push('  const h = new Headers(response.headers);');
    lines.push('  for (const [k, v] of Object.entries(headers)) h.set(k, v);');
    lines.push('  return new Response(response.body, { status: response.status, headers: h });');
    lines.push('}');
    lines.push('');

    // ── Structured Error Response ──
    lines.push('function __errorResponse(status, code, message, details, headers) {');
    lines.push('  const body = { error: { code, message } };');
    lines.push('  if (details !== undefined && details !== null) body.error.details = details;');
    lines.push('  return Response.json(body, { status, headers: headers || {} });');
    lines.push('}');
    lines.push('');

    // ── Auth Builtins: sign_jwt, hash_password, verify_password ──
    lines.push('// ── Auth Builtins ──');
    lines.push('let __jwtSignKey = null;');
    lines.push('async function sign_jwt(payload, secret, options = {}) {');
    lines.push('  const __secret = secret || (typeof __authSecret !== "undefined" ? __authSecret : (process.env.AUTH_SECRET || process.env.JWT_SECRET || ""));');
    lines.push('  if (!__jwtSignKey || __secret !== (typeof __authSecret !== "undefined" ? __authSecret : "")) {');
    lines.push('    __jwtSignKey = await crypto.subtle.importKey(');
    lines.push('      "raw", new TextEncoder().encode(__secret),');
    lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign"]');
    lines.push('    );');
    lines.push('  }');
    lines.push('  const header = { alg: "HS256", typ: "JWT" };');
    lines.push('  const now = Math.floor(Date.now() / 1000);');
    lines.push('  const claims = { ...payload, iat: now };');
    lines.push('  if (options.expires_in) claims.exp = now + options.expires_in;');
    lines.push('  if (options.exp) claims.exp = options.exp;');
    // Fix 2: Auto-include iss/aud from auth config when not explicitly set
    if (authConfig && authConfig.issuer) {
      lines.push(`  if (!claims.iss) claims.iss = ${this.genExpression(authConfig.issuer)};`);
    }
    if (authConfig && authConfig.audience) {
      lines.push(`  if (!claims.aud) claims.aud = ${this.genExpression(authConfig.audience)};`);
    }
    lines.push('  const __b64url = (obj) => btoa(JSON.stringify(obj)).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
    lines.push('  const __headerB64 = __b64url(header);');
    lines.push('  const __payloadB64 = __b64url(claims);');
    lines.push('  const __sigData = __headerB64 + "." + __payloadB64;');
    lines.push('  const __sig = await crypto.subtle.sign("HMAC", __jwtSignKey, new TextEncoder().encode(__sigData));');
    lines.push('  const __sigB64 = btoa(String.fromCharCode(...new Uint8Array(__sig))).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
    lines.push('  return __sigData + "." + __sigB64;');
    lines.push('}');
    lines.push('');
    lines.push('async function hash_password(password) {');
    lines.push('  const salt = crypto.getRandomValues(new Uint8Array(16));');
    lines.push('  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]);');
    lines.push('  const hash = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, key, 256);');
    lines.push('  const saltHex = [...salt].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  const hashHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  return `pbkdf2:100000:${saltHex}:${hashHex}`;');
    lines.push('}');
    lines.push('');
    lines.push('async function verify_password(password, stored) {');
    lines.push('  const parts = stored.split(":");');
    lines.push('  if (parts[0] !== "pbkdf2" || parts.length !== 4) return false;');
    lines.push('  const iterations = parseInt(parts[1], 10);');
    lines.push('  const salt = new Uint8Array(parts[2].match(/.{2}/g).map(b => parseInt(b, 16)));');
    lines.push('  const expectedHash = parts[3];');
    lines.push('  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]);');
    lines.push('  const hash = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: "SHA-256" }, key, 256);');
    lines.push('  const hashHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  if (hashHex.length !== expectedHash.length) return false;');
    lines.push('  const __a = Buffer.from(hashHex);');
    lines.push('  const __b = Buffer.from(expectedHash);');
    lines.push('  return require("crypto").timingSafeEqual(__a, __b);');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 7. Router
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Router ──');
    lines.push('const __routes = [];');
    lines.push('const __staticRoutes = new Map();');  // Fast lookup for static routes
    lines.push('function __addRoute(method, path, handler, version) {');
    lines.push('  const isStatic = !path.includes(":") && !path.includes("*");');
    lines.push('  if (isStatic) {');
    lines.push('    const key = method + " " + path;');
    lines.push('    __staticRoutes.set(key, { method, handler, _path: path, _version: version || null });');
    lines.push('  }');
    lines.push('  let pattern = path');
    lines.push('    .replace(/\\*([a-zA-Z_][a-zA-Z0-9_]*)/g, "(?<$1>.+)")');
    lines.push('    .replace(/\\*$/g, "(.*)")');
    lines.push('    .replace(/:([^/]+)/g, "(?<$1>[^/]+)");');
    lines.push('  __routes.push({ method, regex: new RegExp(`^${pattern}$`), handler, _path: path, _version: version || null, _isStatic: isStatic });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 8. CORS
    // ════════════════════════════════════════════════════════════
    if (corsConfig) {
      const origins = corsConfig.origins ? this.genExpression(corsConfig.origins) : '["*"]';
      const methods = corsConfig.methods ? this.genExpression(corsConfig.methods) : '["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]';
      const headers = corsConfig.headers ? this.genExpression(corsConfig.headers) : '["Content-Type", "Authorization"]';
      const credentials = corsConfig.credentials ? this.genExpression(corsConfig.credentials) : 'false';
      const maxAge = corsConfig.max_age ? this.genExpression(corsConfig.max_age) : '"86400"';
      // Compile-time warning: credentials + wildcard origin is a CORS spec violation
      if (credentials === 'true' && (origins === '["*"]' || (corsConfig.origins && corsConfig.origins.type === 'ArrayExpression' && corsConfig.origins.elements.some(e => e.value === '*')))) {
        lines.push('console.warn("[tova] CORS warning: credentials: true with wildcard origin \\"*\\" violates the CORS spec. Browsers will reject these responses. Use explicit origins instead.");');
      }
      lines.push('// ── CORS ──');
      lines.push(`const __corsOrigins = ${origins};`);
      lines.push(`const __corsCredentials = ${credentials};`);
      lines.push(`const __corsMaxAge = String(${maxAge});`);
      lines.push('function __getCorsHeaders(req) {');
      lines.push('  const origin = req.headers.get("Origin") || "*";');
      lines.push('  const allowed = __corsOrigins.includes("*") || __corsOrigins.includes(origin);');
      lines.push('  const h = {');
      lines.push(`    "Access-Control-Allow-Origin": allowed ? (__corsCredentials ? origin : (origin === "*" ? "*" : origin)) : "",`);
      lines.push(`    "Access-Control-Allow-Methods": ${methods}.join(", "),`);
      lines.push(`    "Access-Control-Allow-Headers": ${headers}.join(", "),`);
      lines.push('    "Access-Control-Max-Age": __corsMaxAge,');
      lines.push('  };');
      lines.push('  if (__corsCredentials) h["Access-Control-Allow-Credentials"] = "true";');
      lines.push('  if (!__corsOrigins.includes("*")) h["Vary"] = "Origin";');
      lines.push('  return h;');
      lines.push('}');
    } else if (authConfig || sessionConfig) {
      // When auth or sessions are configured but no explicit CORS, restrict to same-origin
      lines.push('// ── CORS (restricted — auth/sessions enabled) ──');
      lines.push('const __corsHeadersConst = Object.freeze({');
      lines.push('  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",');
      lines.push('  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Tova-CSRF",');
      lines.push('  "Access-Control-Max-Age": "86400",');
      lines.push('});');
      lines.push('function __getCorsHeaders(req) {');
      lines.push('  const origin = req && req.headers ? req.headers.get("Origin") : null;');
      lines.push('  if (!origin) return __corsHeadersConst;');
      lines.push('  const reqUrl = req.url ? new URL(req.url) : null;');
      lines.push('  if (reqUrl && origin === reqUrl.origin) {');
      lines.push('    return { ...__corsHeadersConst, "Access-Control-Allow-Origin": origin, "Access-Control-Allow-Credentials": "true", "Vary": "Origin" };');
      lines.push('  }');
      lines.push('  return __corsHeadersConst;');
      lines.push('}');
    } else {
      lines.push('// ── CORS ──');
      lines.push('const __corsHeadersConst = Object.freeze({');
      lines.push('  "Access-Control-Allow-Origin": "*",');
      lines.push('  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",');
      lines.push('  "Access-Control-Allow-Headers": "Content-Type, Authorization",');
      lines.push('  "Access-Control-Max-Age": "86400",');
      lines.push('});');
      lines.push('function __getCorsHeaders() { return __corsHeadersConst; }');
    }
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 8b. Security Headers — OWASP recommended
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
      lines.push('// ── Security Headers ──');
      lines.push('const __securityHeaders = Object.freeze({');
      lines.push('  "X-Content-Type-Options": "nosniff",');
      lines.push('  "X-Frame-Options": "DENY",');
      lines.push('  "X-XSS-Protection": "0",');
      lines.push('  "Referrer-Policy": "strict-origin-when-cross-origin",');
      lines.push('  "Permissions-Policy": "camera=(), microphone=(), geolocation=()",');
      lines.push('});');
      // HSTS: explicit security block config, auto-enable with auth, or TLS config
      const hstsConf = securityFragments && securityFragments.hstsConfig;
      const hstsExplicitlyDisabled = hstsConf && hstsConf.enabled && hstsConf.enabled.type === 'BooleanLiteral' && hstsConf.enabled.value === false;
      const needsHsts = !hstsExplicitlyDisabled && (tlsConfig || hstsConf);
      if (needsHsts) {
        if (hstsConf && !hstsConf.__autoEnabled && hstsConf.max_age) {
          // Custom HSTS from security block
          const maxAge = hstsConf.max_age.value || 31536000;
          const inclSub = hstsConf.include_subdomains ? (hstsConf.include_subdomains.value !== false) : true;
          const preload = hstsConf.preload ? hstsConf.preload.value === true : false;
          let hstsVal = `max-age=${maxAge}`;
          if (inclSub) hstsVal += '; includeSubDomains';
          if (preload) hstsVal += '; preload';
          lines.push(`const __hstsHeader = { "Strict-Transport-Security": ${JSON.stringify(hstsVal)} };`);
        } else {
          lines.push('const __hstsHeader = { "Strict-Transport-Security": "max-age=31536000; includeSubDomains" };');
        }
      }
      lines.push('function __applySecurityHeaders(headers) {');
      lines.push('  for (const [k, v] of Object.entries(__securityHeaders)) headers.set(k, v);');
      if (needsHsts) {
        lines.push('  headers.set("Strict-Transport-Security", __hstsHeader["Strict-Transport-Security"]);');
      }
      if (securityFragments && securityFragments.cspCode) {
        lines.push('  if (typeof __getCspHeader === "function") headers.set("Content-Security-Policy", __getCspHeader());');
      }
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 9. Auth (F1) — fixed JWT / API key
    // ════════════════════════════════════════════════════════════
    if (authConfig) {
      lines.push('// ── Auth ──');
      const authType = authConfig.type ? authConfig.type.value : 'jwt';

      if (authType === 'api_key') {
        const keysExpr = authConfig.keys ? this.genExpression(authConfig.keys) : '[]';
        const headerExpr = authConfig.header ? this.genExpression(authConfig.header) : '"X-API-Key"';
        lines.push(`const __validApiKeys = new Set(${keysExpr});`);
        lines.push(`const __apiKeyHeader = ${headerExpr};`);
        lines.push('function __authenticate(req) {');
        lines.push('  const key = req.headers.get(__apiKeyHeader);');
        lines.push('  if (!key || !__validApiKeys.has(key)) return null;');
        lines.push('  return { authenticated: true };');
        lines.push('}');
      } else {
        // JWT auth (default)
        const secretExpr = authConfig.secret ? this.genExpression(authConfig.secret) : 'process.env.AUTH_SECRET || process.env.JWT_SECRET';
        const isCookieAuth = authConfig.storage && authConfig.storage.type === 'StringLiteral' && authConfig.storage.value === 'cookie';
        lines.push(`const __authSecret = ${secretExpr};`);
        if (!authConfig.secret) {
          lines.push('if (!process.env.AUTH_SECRET && !process.env.JWT_SECRET) console.warn("[tova] WARNING: No auth secret configured. Set AUTH_SECRET or JWT_SECRET env var, or use auth { secret: \\"...\\" }");');
        }
        if (isCookieAuth) {
          const expiresExpr = authConfig.expires ? this.genExpression(authConfig.expires) : '86400';
          lines.push(`const __authCookieMaxAge = ${expiresExpr};`);
          lines.push('function __setAuthCookie(res, token) {');
          lines.push('  const h = new Headers(res.headers);');
          lines.push('  h.set("Set-Cookie", `__tova_auth=${token}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=${__authCookieMaxAge}`);');
          lines.push('  return new Response(res.body, { status: res.status, headers: h });');
          lines.push('}');
          lines.push('function __clearAuthCookie(res) {');
          lines.push('  const h = new Headers(res.headers);');
          lines.push('  h.set("Set-Cookie", "__tova_auth=; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=0");');
          lines.push('  return new Response(res.body, { status: res.status, headers: h });');
          lines.push('}');
        }
        lines.push('let __authKey = null;');
        lines.push('async function __authenticate(req) {');
        if (isCookieAuth) {
          // Read token from cookie first, fall back to Authorization header
          lines.push('  let token = null;');
          lines.push('  const __cookieStr = req.headers.get("Cookie") || "";');
          lines.push('  const __authCookie = __cookieStr.split(";").map(s => s.trim()).find(s => s.startsWith("__tova_auth="));');
          lines.push('  if (__authCookie) token = __authCookie.slice("__tova_auth=".length);');
          lines.push('  if (!token) {');
          lines.push('    const authHeader = req.headers.get("Authorization");');
          lines.push('    if (authHeader && authHeader.startsWith("Bearer ")) token = authHeader.slice(7);');
          lines.push('  }');
          lines.push('  if (!token) return null;');
        } else {
          lines.push('  const authHeader = req.headers.get("Authorization");');
          lines.push('  if (!authHeader || !authHeader.startsWith("Bearer ")) return null;');
          lines.push('  const token = authHeader.slice(7);');
        }
        lines.push('  try {');
        lines.push('    const parts = token.split(".");');
        lines.push('    if (parts.length !== 3) return null;');
        lines.push('    const __header = JSON.parse(atob(parts[0].replace(/-/g, "+").replace(/_/g, "/")));');
        lines.push('    if (__header.alg !== "HS256") return null;');
        lines.push('    if (!__authKey) {');
        lines.push('      __authKey = await crypto.subtle.importKey(');
        lines.push('        "raw", new TextEncoder().encode(__authSecret),');
        lines.push('        { name: "HMAC", hash: "SHA-256" }, false, ["sign"]');
        lines.push('      );');
        lines.push('    }');
        lines.push('    const __sigData = parts[0] + "." + parts[1];');
        lines.push('    const __sig = await crypto.subtle.sign("HMAC", __authKey, new TextEncoder().encode(__sigData));');
        lines.push('    const __expectedSig = btoa(String.fromCharCode(...new Uint8Array(__sig)))');
        lines.push('      .replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
        lines.push('    const __sigBuf = Buffer.from(__expectedSig);');
        lines.push('    const __tokBuf = Buffer.from(parts[2]);');
        lines.push('    if (__sigBuf.length !== __tokBuf.length || !require("crypto").timingSafeEqual(__sigBuf, __tokBuf)) return null;');
        lines.push('    const __payload = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));');
        lines.push('    if (__payload.exp && __payload.exp < Math.floor(Date.now() / 1000)) return null;');
        lines.push('    if (__payload.nbf && __payload.nbf > Math.floor(Date.now() / 1000)) return null;');
        // Fix 2: JWT iss/aud claim validation
        if (authConfig.issuer) {
          lines.push(`    if (__payload.iss !== ${this.genExpression(authConfig.issuer)}) return null;`);
        }
        if (authConfig.audience) {
          lines.push(`    if (__payload.aud !== ${this.genExpression(authConfig.audience)}) return null;`);
        }
        lines.push('    return __payload;');
        lines.push('  } catch { return null; }');
        lines.push('}');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 9b. Security Block — roles, protection, CSP, sensitive, audit
    // ════════════════════════════════════════════════════════════
    if (securityFragments) {
      if (securityFragments.roleDefinitions) {
        lines.push(securityFragments.roleDefinitions);
        lines.push('');
      }
      if (securityFragments.protectCode) {
        lines.push(securityFragments.protectCode);
        lines.push('');
      }
      if (securityFragments.cspCode) {
        lines.push(securityFragments.cspCode);
        lines.push('');
      }
      if (securityFragments.sensitiveCode) {
        lines.push(securityFragments.sensitiveCode);
        lines.push('');
      }
      if (securityFragments.auditCode) {
        lines.push(securityFragments.auditCode);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 9c. Client IP Helper — trust_proxy aware
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
      lines.push('// ── Client IP ──');
      const trustProxy = securityFragments && securityFragments.trustProxyConfig;
      if (trustProxy === true) {
        lines.push('function __getClientIp(req) {');
        lines.push('  const xff = req.headers.get("x-forwarded-for");');
        lines.push('  if (xff) return xff.split(",")[0].trim();');
        lines.push('  return req.headers.get("x-real-ip") || __server.requestIP(req)?.address || "unknown";');
        lines.push('}');
      } else if (trustProxy === 'loopback') {
        lines.push('function __getClientIp(req) {');
        lines.push('  const direct = req.headers.get("x-real-ip") || __server.requestIP(req)?.address || "unknown";');
        lines.push('  if (direct === "127.0.0.1" || direct === "::1" || direct === "::ffff:127.0.0.1") {');
        lines.push('    const xff = req.headers.get("x-forwarded-for");');
        lines.push('    if (xff) return xff.split(",")[0].trim();');
        lines.push('  }');
        lines.push('  return direct;');
        lines.push('}');
      } else {
        // Default: do not trust x-forwarded-for
        lines.push('function __getClientIp(req) {');
        lines.push('  return req.headers.get("x-real-ip") || __server.requestIP(req)?.address || "unknown";');
        lines.push('}');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 10. Max Body Size
    // ════════════════════════════════════════════════════════════
    if (maxBodyLimit) {
      lines.push('// ── Max Body Size ──');
      lines.push(`const __maxBodySize = ${this.genExpression(maxBodyLimit)};`);
      lines.push('');
    } else {
      lines.push('// ── Max Body Size ──');
      lines.push('const __maxBodySize = 1048576;');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11. Rate Limiting (F2) — store + checker
    // ════════════════════════════════════════════════════════════
    if (needsRateLimitStore) {
      lines.push('// ── Rate Limiting ──');
      if (rateLimitConfig) {
        const maxExpr = rateLimitConfig.max ? this.genExpression(rateLimitConfig.max) : '100';
        const windowExpr = rateLimitConfig.window ? this.genExpression(rateLimitConfig.window) : '60';
        lines.push(`const __rateLimitMax = ${maxExpr};`);
        lines.push(`const __rateLimitWindow = ${windowExpr};`);
      }
      lines.push('const __rateLimitStore = new Map();');
      lines.push('const __rateLimitMaxKeys = 100000;');
      lines.push('function __checkRateLimit(key, max, windowSec) {');
      lines.push('  const now = Date.now();');
      lines.push('  const windowMs = windowSec * 1000;');
      lines.push('  let entry = __rateLimitStore.get(key);');
      lines.push('  if (!entry) {');
      lines.push('    if (__rateLimitStore.size >= __rateLimitMaxKeys) {');
      lines.push('      const oldest = __rateLimitStore.keys().next().value;');
      lines.push('      __rateLimitStore.delete(oldest);');
      lines.push('    }');
      lines.push('    entry = { prevCount: 0, currCount: 0, windowStart: now };');
      lines.push('    __rateLimitStore.set(key, entry);');
      lines.push('  }');
      lines.push('  if (now - entry.windowStart >= windowMs) {');
      lines.push('    entry.prevCount = entry.currCount;');
      lines.push('    entry.currCount = 0;');
      lines.push('    entry.windowStart = now;');
      lines.push('  }');
      lines.push('  const elapsed = (now - entry.windowStart) / windowMs;');
      lines.push('  const estimate = entry.prevCount * (1 - elapsed) + entry.currCount;');
      lines.push('  if (estimate >= max) {');
      lines.push('    const retryAfter = Math.ceil(windowSec * (1 - elapsed));');
      lines.push('    return { limited: true, retryAfter: retryAfter || 1 };');
      lines.push('  }');
      lines.push('  entry.currCount++;');
      lines.push('  return { limited: false };');
      lines.push('}');
      lines.push('setInterval(() => {');
      lines.push('  const now = Date.now();');
      lines.push('  for (const [key, entry] of __rateLimitStore) {');
      lines.push('    if (now - entry.windowStart > 120000) __rateLimitStore.delete(key);');
      lines.push('  }');
      lines.push('}, 60000);');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11b. File Upload Helpers
    // ════════════════════════════════════════════════════════════
    if (uploadConfig || routes.some(r => (r.decorators || []).some(d => d.name === 'upload'))) {
      lines.push('// ── File Upload Helpers ──');
      const maxSizeExpr = uploadConfig && uploadConfig.max_size ? this.genExpression(uploadConfig.max_size) : '10485760';
      const allowedTypesExpr = uploadConfig && uploadConfig.allowed_types ? this.genExpression(uploadConfig.allowed_types) : '[]';
      lines.push(`const __uploadMaxSize = ${maxSizeExpr};`);
      lines.push(`const __uploadAllowedTypes = ${allowedTypesExpr};`);
      lines.push('function __validateFile(file, fieldName) {');
      lines.push('  if (!file || (typeof file !== "object") || typeof file.size !== "number") {');
      lines.push('    return { valid: false, error: `${fieldName}: not a valid file` };');
      lines.push('  }');
      lines.push('  if (file.size > __uploadMaxSize) {');
      lines.push('    return { valid: false, error: `${fieldName}: file too large (max ${__uploadMaxSize} bytes)` };');
      lines.push('  }');
      lines.push('  if (__uploadAllowedTypes.length > 0 && !__uploadAllowedTypes.includes(file.type)) {');
      lines.push('    return { valid: false, error: `${fieldName}: file type ${file.type} not allowed` };');
      lines.push('  }');
      lines.push('  return { valid: true };');
      lines.push('}');
      lines.push('async function save_file(file, dir) {');
      lines.push('  const fs = await import("node:fs/promises");');
      lines.push('  const path = await import("node:path");');
      lines.push('  await fs.mkdir(dir, { recursive: true });');
      lines.push('  let name = file.name || "upload_" + Date.now();');
      lines.push('  name = path.basename(name).replace(/[\\0]/g, "");');
      lines.push('  if (!name || name === "." || name === "..") name = "upload_" + Date.now();');
      lines.push('  const dest = path.join(dir, name);');
      lines.push('  const resolved = path.resolve(dest);');
      lines.push('  const resolvedDir = path.resolve(dir);');
      lines.push('  if (!resolved.startsWith(resolvedDir + path.sep) && resolved !== resolvedDir) {');
      lines.push('    throw new Error("Invalid file path: directory traversal detected");');
      lines.push('  }');
      lines.push('  await Bun.write(dest, file);');
      lines.push('  return dest;');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11c. Session Management
    // ════════════════════════════════════════════════════════════
    if (sessionConfig) {
      lines.push('// ── Session Management ──');
      const secretExpr = sessionConfig.secret ? this.genExpression(sessionConfig.secret) : 'process.env.SESSION_SECRET';
      const maxAgeExpr = sessionConfig.max_age ? this.genExpression(sessionConfig.max_age) : '3600';
      const cookieNameExpr = sessionConfig.cookie_name ? this.genExpression(sessionConfig.cookie_name) : '"__sid"';
      lines.push(`const __sessionSecret = ${secretExpr};`);
      if (!sessionConfig.secret) {
        lines.push('if (!process.env.SESSION_SECRET) console.warn("[tova] WARNING: No session secret configured. Set SESSION_SECRET env var, or use session { secret: \\"...\\" }");');
      }
      lines.push(`const __sessionMaxAge = ${maxAgeExpr};`);
      lines.push(`const __sessionCookieName = ${cookieNameExpr};`);
      lines.push('let __sessionKey = null;');
      lines.push('async function __getSessionKey() {');
      lines.push('  if (!__sessionKey) {');
      lines.push('    __sessionKey = await crypto.subtle.importKey(');
      lines.push('      "raw", new TextEncoder().encode(__sessionSecret),');
      lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]');
      lines.push('    );');
      lines.push('  }');
      lines.push('  return __sessionKey;');
      lines.push('}');
      lines.push('async function __signSessionId(id) {');
      lines.push('  const key = await __getSessionKey();');
      lines.push('  const sig = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(id));');
      lines.push('  const b64 = btoa(String.fromCharCode(...new Uint8Array(sig))).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
      lines.push('  return id + "." + b64;');
      lines.push('}');
      lines.push('async function __verifySessionId(signed) {');
      lines.push('  const dot = signed.lastIndexOf(".");');
      lines.push('  if (dot === -1) return null;');
      lines.push('  const id = signed.slice(0, dot);');
      lines.push('  const expected = await __signSessionId(id);');
      lines.push('  const __eBuf = new TextEncoder().encode(expected);');
      lines.push('  const __sBuf = new TextEncoder().encode(signed);');
      lines.push('  if (__eBuf.length !== __sBuf.length) return null;');
      lines.push('  let __m = 0;');
      lines.push('  for (let i = 0; i < __eBuf.length; i++) __m |= __eBuf[i] ^ __sBuf[i];');
      lines.push('  return __m === 0 ? id : null;');
      lines.push('}');

      // Use SQLite-backed sessions when db is available
      if (dbConfig || usesDb) {
        lines.push('// SQLite-backed session store');
        lines.push('__db.exec(`CREATE TABLE IF NOT EXISTS __sessions (');
        lines.push("  id TEXT PRIMARY KEY, data TEXT NOT NULL DEFAULT '{}', created_at INTEGER NOT NULL, updated_at INTEGER NOT NULL");
        lines.push(')`);');
        lines.push('const __sessionStmts = {');
        lines.push('  get: __db.prepare("SELECT data, created_at FROM __sessions WHERE id = ? AND created_at > ?"),');
        lines.push('  upsert: __db.prepare("INSERT INTO __sessions (id, data, created_at, updated_at) VALUES (?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET data = excluded.data, updated_at = excluded.updated_at"),');
        lines.push('  del: __db.prepare("DELETE FROM __sessions WHERE id = ?"),');
        lines.push('  cleanup: __db.prepare("DELETE FROM __sessions WHERE created_at <= ?"),');
        lines.push('};');
        lines.push('function __createSession(id) {');
        lines.push('  const cutoff = Date.now() - __sessionMaxAge * 1000;');
        lines.push('  const row = __sessionStmts.get.get(id, cutoff);');
        lines.push('  let __data = row ? JSON.parse(row.data) : {};');
        lines.push('  let __dirty = !row;');
        lines.push('  return {');
        lines.push('    get(key) { return __data[key]; },');
        lines.push('    set(key, value) { __data[key] = value; __dirty = true; },');
        lines.push('    delete(key) { delete __data[key]; __dirty = true; },');
        lines.push('    destroy() { __sessionStmts.del.run(id); __data = {}; },');
        lines.push('    get data() { return { ...__data }; },');
        lines.push('    __flush() { if (__dirty) { const now = Date.now(); __sessionStmts.upsert.run(id, JSON.stringify(__data), now, now); __dirty = false; } },');
        lines.push('  };');
        lines.push('}');
        lines.push('setInterval(() => {');
        lines.push('  const cutoff = Date.now() - __sessionMaxAge * 1000;');
        lines.push('  __sessionStmts.cleanup.run(cutoff);');
        lines.push('}, 60000);');
      } else {
        lines.push('// In-memory session store');
        lines.push('const __sessionStore = new Map();');
        lines.push('const __sessionMaxKeys = 50000;');
        lines.push('function __createSession(id) {');
        lines.push('  if (!__sessionStore.has(id)) {');
        lines.push('    if (__sessionStore.size >= __sessionMaxKeys) {');
        lines.push('      const oldest = __sessionStore.keys().next().value;');
        lines.push('      __sessionStore.delete(oldest);');
        lines.push('    }');
        lines.push('    __sessionStore.set(id, { data: {}, createdAt: Date.now() });');
        lines.push('  }');
        lines.push('  const entry = __sessionStore.get(id);');
        lines.push('  return {');
        lines.push('    get(key) { return entry.data[key]; },');
        lines.push('    set(key, value) { entry.data[key] = value; },');
        lines.push('    delete(key) { delete entry.data[key]; },');
        lines.push('    destroy() { __sessionStore.delete(id); },');
        lines.push('    get data() { return { ...entry.data }; },');
        lines.push('    __flush() {},');
        lines.push('  };');
        lines.push('}');
        lines.push('setInterval(() => {');
        lines.push('  const now = Date.now();');
        lines.push('  for (const [id, entry] of __sessionStore) {');
        lines.push('    if (now - entry.createdAt > __sessionMaxAge * 1000) __sessionStore.delete(id);');
        lines.push('  }');
        lines.push('}, 60000);');
      }
      // Fix 8: Session regeneration helper
      lines.push('function __regenerateSession(req) {');
      lines.push('  const oldData = req.__session ? { ...req.__session.data } : {};');
      lines.push('  const newId = crypto.randomUUID();');
      lines.push('  if (req.__session && req.__session.destroy) req.__session.destroy();');
      lines.push('  req.__session = __createSession(newId);');
      lines.push('  for (const [k, v] of Object.entries(oldData)) req.__session.set(k, v);');
      lines.push('  req.__sessionRegenerated = true;');
      lines.push('  req.__newSessionId = newId;');
      lines.push('  return newId;');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11d. CSRF Protection — server-side token generation + validation
    // ════════════════════════════════════════════════════════════
    // Check if CSRF is explicitly disabled via security block: csrf { enabled: false }
    const csrfExplicitlyDisabled = securityFragments && securityFragments.csrfConfig &&
      securityFragments.csrfConfig.enabled &&
      ((securityFragments.csrfConfig.enabled.type === 'BooleanLiteral' && securityFragments.csrfConfig.enabled.value === false) ||
       (securityFragments.csrfConfig.enabled === false));
    const needsCsrf = !isFastMode && !csrfExplicitlyDisabled && (sessionConfig || authConfig);
    if (needsCsrf) {
      lines.push('// ── CSRF Protection ──');
      lines.push('let __csrfKey = null;');
      lines.push('async function __getCSRFKey() {');
      lines.push('  if (!__csrfKey) {');
      lines.push('    const secret = typeof __sessionSecret !== "undefined" ? __sessionSecret : (typeof __authSecret !== "undefined" ? __authSecret : (process.env.CSRF_SECRET || process.env.AUTH_SECRET || ""));');
      lines.push('    __csrfKey = await crypto.subtle.importKey(');
      lines.push('      "raw", new TextEncoder().encode(secret + ":csrf"),');
      lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]');
      lines.push('    );');
      lines.push('  }');
      lines.push('  return __csrfKey;');
      lines.push('}');
      lines.push('async function __generateCSRFToken(bindingId) {');
      lines.push('  const key = await __getCSRFKey();');
      lines.push('  const timestamp = Date.now().toString(36);');
      lines.push('  const nonce = crypto.getRandomValues(new Uint8Array(8));');
      lines.push('  const nonceHex = [...nonce].map(b => b.toString(16).padStart(2, "0")).join("");');
      lines.push('  const data = timestamp + ":" + nonceHex + ":" + (bindingId || "anon");');
      lines.push('  const sig = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(data));');
      lines.push('  const sigHex = [...new Uint8Array(sig)].map(b => b.toString(16).padStart(2, "0")).join("");');
      lines.push('  return data + ":" + sigHex;');
      lines.push('}');
      lines.push('async function __validateCSRFToken(token, bindingId) {');
      lines.push('  if (!token || typeof token !== "string") return false;');
      lines.push('  const parts = token.split(":");');
      lines.push('  if (parts.length !== 4) return false;');
      lines.push('  const [timestamp, nonce, binding, sig] = parts;');
      lines.push('  if (binding !== (bindingId || "anon")) return false;');
      lines.push('  const age = Date.now() - parseInt(timestamp, 36);');
      lines.push('  if (isNaN(age) || age < 0 || age > 86400000) return false;');
      lines.push('  const key = await __getCSRFKey();');
      lines.push('  const data = timestamp + ":" + nonce + ":" + binding;');
      lines.push('  const expectedSig = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(data));');
      lines.push('  const expectedBytes = new Uint8Array(expectedSig);');
      lines.push('  let sigBytes; try { sigBytes = new Uint8Array(Buffer.from(sig, "hex")); } catch { return false; }');
      lines.push('  if (sigBytes.length !== expectedBytes.length) return false;');
      lines.push('  return require("crypto").timingSafeEqual(sigBytes, expectedBytes);');
      lines.push('}');
      // Fix 9: CSRF exempt patterns
      const csrfExempt = securityFragments && securityFragments.csrfConfig && securityFragments.csrfConfig.exempt;
      if (csrfExempt) {
        lines.push('const __csrfExemptPatterns = [');
        // csrfExempt is an AST node (ArrayLiteral/ArrayExpression)
        if (csrfExempt.elements) {
          for (const elem of csrfExempt.elements) {
            if (elem.type === 'StringLiteral' || elem.value) {
              const pattern = elem.value;
              const regexPattern = pattern
                .replace(/\*\*/g, '\x00GLOBSTAR\x00')
                .replace(/\*/g, '\x00STAR\x00')
                .replace(/[.+?^${}()|[\]\\/]/g, '\\$&')
                .replace(/\x00STAR\x00/g, '[^/]*')
                .replace(/\x00GLOBSTAR\x00/g, '.*');
              lines.push(`  /^${regexPattern}$/,`);
            }
          }
        }
        lines.push('];');
        lines.push('function __isCsrfExempt(path) {');
        lines.push('  for (const p of __csrfExemptPatterns) { if (p.test(path)) return true; }');
        lines.push('  return false;');
        lines.push('}');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12. Event Bus (F5) — if subscriptions exist
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0) {
      lines.push('// ── Event Bus ──');
      lines.push('const __eventBus = new Map();');
      lines.push('function __subscribe(event, handler) {');
      lines.push('  if (!__eventBus.has(event)) __eventBus.set(event, []);');
      lines.push('  __eventBus.get(event).push(handler);');
      lines.push('}');
      lines.push('async function publish(event, data) {');
      lines.push('  const handlers = __eventBus.get(event) || [];');
      lines.push('  await Promise.all(handlers.map(h => h(data)));');
      if (peerBlocks && peerBlocks.size > 0) {
        lines.push('  const __peerUrls = [');
        for (const [peerName] of peerBlocks) {
          lines.push(`    ${peerName}.__baseUrl,`);
        }
        lines.push('  ];');
        lines.push('  for (const __peerUrl of __peerUrls) {');
        lines.push('    try {');
        lines.push('      await fetch(`${__peerUrl}/rpc/__event`, {');
        lines.push('        method: "POST",');
        lines.push('        headers: { "Content-Type": "application/json" },');
        lines.push('        body: JSON.stringify({ event, data }),');
        lines.push('      });');
        lines.push('    } catch {}');
        lines.push('  }');
      }
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12b. Background Jobs
    // ════════════════════════════════════════════════════════════
    if (backgroundJobs.length > 0) {
      lines.push('// ── Background Jobs ──');
      lines.push('const __jobQueue = [];');
      lines.push('let __jobProcessing = false;');
      lines.push('const __JOB_BASE_DELAY = 1000;');
      lines.push('const __JOB_MAX_DELAY = 30000;');
      lines.push('function __jobBackoffDelay(attempt) {');
      lines.push('  const exp = Math.min(__JOB_BASE_DELAY * Math.pow(2, attempt), __JOB_MAX_DELAY);');
      lines.push('  const jitter = exp * (0.5 + Math.random() * 0.5);');
      lines.push('  return Math.round(jitter);');
      lines.push('}');
      lines.push('async function __processJobQueue() {');
      lines.push('  if (__jobProcessing) return;');
      lines.push('  __jobProcessing = true;');
      lines.push('  while (__jobQueue.length > 0) {');
      lines.push('    const job = __jobQueue.shift();');
      lines.push('    try { await job.fn(...job.args); } catch (err) {');
      lines.push('      __log("error", `Background job ${job.name} failed (attempt ${job.attempt + 1}/${job.maxRetries + 1})`, { error: err.message });');
      lines.push('      if (job.attempt < job.maxRetries) {');
      lines.push('        const delay = __jobBackoffDelay(job.attempt);');
      lines.push('        job.attempt++;');
      lines.push('        setTimeout(() => { __jobQueue.push(job); __processJobQueue(); }, delay);');
      lines.push('      }');
      lines.push('    }');
      lines.push('  }');
      lines.push('  __jobProcessing = false;');
      lines.push('}');
      for (const job of backgroundJobs) {
        const fnName = job.name;
        const params = job.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of job.params) this.declareVar(p.name);
        const body = this.genBlockBody(job.body);
        this.popScope();
        lines.push(`async function __bg_${fnName}(${params}) {`);
        lines.push(body);
        lines.push('}');
      }
      lines.push('function spawn_job(name, ...args) {');
      lines.push('  const __jobFns = {');
      for (const job of backgroundJobs) {
        lines.push(`    "${job.name}": __bg_${job.name},`);
      }
      lines.push('  };');
      lines.push('  const fn = __jobFns[name];');
      lines.push('  if (!fn) throw new Error(`Unknown background job: ${name}`);');
      lines.push('  __jobQueue.push({ name, fn, args, attempt: 0, maxRetries: 3 });');
      lines.push('  setTimeout(__processJobQueue, 0);');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12c. Response Compression
    // ════════════════════════════════════════════════════════════
    if (compressionConfig) {
      const minSizeExpr = compressionConfig.min_size ? this.genExpression(compressionConfig.min_size) : '1024';
      lines.push('// ── Compression ──');
      lines.push(`const __compressionMinSize = ${minSizeExpr};`);
      lines.push('async function __compressResponse(req, res) {');
      lines.push('  const accept = req.headers.get("Accept-Encoding") || "";');
      lines.push('  const ct = res.headers.get("Content-Type") || "";');
      lines.push('  if (!ct.match(/text|json|javascript|xml|svg/)) return res;');
      lines.push('  const body = await res.arrayBuffer();');
      lines.push('  if (body.byteLength < __compressionMinSize) {');
      lines.push('    return new Response(body, { status: res.status, headers: res.headers });');
      lines.push('  }');
      lines.push('  const h = new Headers(res.headers);');
      lines.push('  if (accept.includes("gzip")) {');
      lines.push('    const compressed = Bun.gzipSync(new Uint8Array(body));');
      lines.push('    h.set("Content-Encoding", "gzip");');
      lines.push('    h.set("Content-Length", String(compressed.length));');
      lines.push('    return new Response(compressed, { status: res.status, headers: h });');
      lines.push('  }');
      lines.push('  if (accept.includes("deflate")) {');
      lines.push('    const compressed = Bun.deflateSync(new Uint8Array(body));');
      lines.push('    h.set("Content-Encoding", "deflate");');
      lines.push('    h.set("Content-Length", String(compressed.length));');
      lines.push('    return new Response(compressed, { status: res.status, headers: h });');
      lines.push('  }');
      lines.push('  return new Response(body, { status: res.status, headers: res.headers });');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12d. Response Caching Helpers
    // ════════════════════════════════════════════════════════════
    if (cacheConfig) {
      const maxAgeExpr = cacheConfig.max_age ? this.genExpression(cacheConfig.max_age) : '0';
      const staleExpr = cacheConfig.stale_while_revalidate ? this.genExpression(cacheConfig.stale_while_revalidate) : '0';
      lines.push('// ── Cache Helpers ──');
      lines.push(`const __cacheMaxAge = ${maxAgeExpr};`);
      lines.push(`const __cacheStale = ${staleExpr};`);
      lines.push('');
    }
    // Always emit cache helpers
    lines.push('function cache_control(res, maxAge, options = {}) {');
    lines.push('  const h = new Headers(res.headers);');
    lines.push('  let directive = options.private ? "private" : "public";');
    lines.push('  directive += `, max-age=${maxAge}`;');
    lines.push('  if (options.stale_while_revalidate) directive += `, stale-while-revalidate=${options.stale_while_revalidate}`;');
    lines.push('  if (options.no_cache) directive = "no-cache";');
    lines.push('  if (options.no_store) directive = "no-store";');
    lines.push('  h.set("Cache-Control", directive);');
    lines.push('  return new Response(res.body, { status: res.status, headers: h });');
    lines.push('}');
    lines.push('function etag(res, tag) {');
    lines.push('  const h = new Headers(res.headers);');
    lines.push('  h.set("ETag", `"${tag}"`);');
    lines.push('  return new Response(res.body, { status: res.status, headers: h });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12e. Model / ORM Layer — auto-generate CRUD from shared types
    // ════════════════════════════════════════════════════════════
    if (modelDecls.length > 0 && (dbConfig || usesDb)) {
      lines.push('// ── Model / ORM Layer ──');
      const isAsync = dbDriver !== 'sqlite';
      const aw = isAsync ? 'await ' : '';
      for (const modelDecl of modelDecls) {
        const typeName = modelDecl.name;
        let typeInfo = sharedTypes.get(typeName);
        // Fall back to model declaration fields if shared type not in this file (multi-file)
        if (!typeInfo && modelDecl.config) {
          const fields = [{ name: 'id', type: 'Int' }];
          for (const [key, value] of Object.entries(modelDecl.config)) {
            if (key === 'table' || key === 'timestamps' || key === 'belongs_to' || key === 'has_many') continue;
            const fieldType = value.name || (value.type === 'ArrayTypeAnnotation' ? 'Array' : 'Any');
            fields.push({ name: key, type: fieldType });
          }
          if (fields.length > 0) typeInfo = { fields };
        }
        if (!typeInfo) continue;
        const tableName = modelDecl.config && modelDecl.config.table
          ? this.genExpression(modelDecl.config.table).replace(/"/g, '')
          : typeName.toLowerCase() + 's';
        const hasTimestamps = modelDecl.config && modelDecl.config.timestamps;
        const fields = typeInfo.fields;
        const fieldNames = fields.map(f => f.name);
        const hasId = fieldNames.includes('id');

        // Extract relations from config
        const belongsToNames = [];
        const hasManyNames = [];
        if (modelDecl.config) {
          const extractRelNames = (val) => {
            if (!val) return [];
            if (val.type === 'Identifier') return [val.name];
            if (val.type === 'ArrayLiteral') return val.elements.filter(e => e.type === 'Identifier').map(e => e.name);
            return [];
          };
          belongsToNames.push(...extractRelNames(modelDecl.config.belongs_to));
          hasManyNames.push(...extractRelNames(modelDecl.config.has_many));
        }

        // Map Tova types to SQL types
        const sqlType = (tovaType) => {
          if (dbDriver === 'postgres') {
            switch (tovaType) {
              case 'Int': return 'INTEGER';
              case 'Float': return 'DOUBLE PRECISION';
              case 'Bool': return 'BOOLEAN';
              case 'String': return 'TEXT';
              default: return 'TEXT';
            }
          }
          switch (tovaType) {
            case 'Int': return 'INTEGER';
            case 'Float': return 'REAL';
            case 'Bool': return 'INTEGER';
            case 'String': return 'TEXT';
            default: return 'TEXT';
          }
        };

        // Generate CREATE TABLE
        const colDefs = [];
        for (const f of fields) {
          if (f.name === 'id') {
            if (dbDriver === 'postgres') {
              colDefs.push('id SERIAL PRIMARY KEY');
            } else {
              colDefs.push('id INTEGER PRIMARY KEY AUTOINCREMENT');
            }
          } else {
            colDefs.push(`${f.name} ${sqlType(f.type)}`);
          }
        }
        // Add FK columns for belongs_to relations
        for (const parentName of belongsToNames) {
          const fkCol = parentName.toLowerCase() + '_id';
          if (!fieldNames.includes(fkCol)) {
            const parentTable = parentName.toLowerCase() + 's';
            colDefs.push(`${fkCol} INTEGER REFERENCES ${parentTable}(id)`);
          }
        }
        if (hasTimestamps) {
          colDefs.push('created_at TEXT DEFAULT (datetime(\'now\'))');
          colDefs.push('updated_at TEXT DEFAULT (datetime(\'now\'))');
        }

        const placeholder = dbDriver === 'postgres' ? (i) => `$${i}` : () => '?';
        const insertFields = fields.filter(f => f.name !== 'id');
        const insertCols = insertFields.map(f => f.name).join(', ');
        const insertPlaceholders = insertFields.map((_, i) => placeholder(i + 1)).join(', ');
        const updateSets = insertFields.map((f, i) => `${f.name} = ${placeholder(i + 1)}`).join(', ');
        const returningClause = dbDriver === 'postgres' ? ' RETURNING *' : '';

        lines.push(`// Model: ${typeName} -> ${tableName}`);
        lines.push(`${aw}db.exec(\`CREATE TABLE IF NOT EXISTS ${tableName} (${colDefs.join(', ')})\`);`);
        lines.push('');

        // Embed valid column whitelist for SQL injection prevention
        const allColNames = [...fieldNames];
        for (const parentName of belongsToNames) {
          const fkCol = parentName.toLowerCase() + '_id';
          if (!allColNames.includes(fkCol)) allColNames.push(fkCol);
        }
        if (hasTimestamps) {
          allColNames.push('created_at', 'updated_at');
        }
        const colWhitelistJson = JSON.stringify(allColNames);

        // Generate the model object
        lines.push(`const ${typeName}Model = {`);
        lines.push(`  __validCols: new Set(${colWhitelistJson}),`);
        lines.push(`  __assertCols(keys) {`);
        lines.push(`    for (const k of keys) {`);
        lines.push(`      if (!this.__validCols.has(k)) throw new Error(\`Invalid column: \${k}\`);`);
        lines.push(`    }`);
        lines.push(`  },`);

        // find(id)
        lines.push(`  ${isAsync ? 'async ' : ''}find(id) {`);
        lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ${placeholder(1)}", id);`);
        lines.push('  },');

        // all()
        lines.push(`  ${isAsync ? 'async ' : ''}all() {`);
        lines.push(`    return ${aw}db.query("SELECT * FROM ${tableName}");`);
        lines.push('  },');

        // where(conditions)
        lines.push(`  ${isAsync ? 'async ' : ''}where(conditions) {`);
        lines.push('    const keys = Object.keys(conditions);');
        lines.push('    this.__assertCols(keys);');
        lines.push('    const vals = Object.values(conditions);');
        if (dbDriver === 'postgres') {
          lines.push('    const clauses = keys.map((k, i) => `${k} = $${i + 1}`).join(" AND ");');
        } else {
          lines.push('    const clauses = keys.map(k => `${k} = ?`).join(" AND ");');
        }
        lines.push(`    return ${aw}db.query(\`SELECT * FROM ${tableName} WHERE \${clauses}\`, ...vals);`);
        lines.push('  },');

        // create(data)
        lines.push(`  ${isAsync ? 'async ' : ''}create(data) {`);
        lines.push(`    const cols = Object.keys(data).filter(k => k !== 'id');`);
        lines.push('    this.__assertCols(cols);');
        lines.push(`    const vals = cols.map(k => data[k]);`);
        if (dbDriver === 'postgres') {
          lines.push('    const placeholders = cols.map((_, i) => `$${i + 1}`).join(", ");');
          lines.push(`    const rows = ${aw}db.query(\`INSERT INTO ${tableName} (\${cols.join(", ")}) VALUES (\${placeholders}) RETURNING *\`, ...vals);`);
          lines.push('    return rows[0];');
        } else {
          lines.push('    const placeholders = cols.map(() => "?").join(", ");');
          lines.push(`    const result = ${aw}db.run(\`INSERT INTO ${tableName} (\${cols.join(", ")}) VALUES (\${placeholders})\`, ...vals);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", result.lastInsertRowid);`);
        }
        lines.push('  },');

        // update(id, data)
        lines.push(`  ${isAsync ? 'async ' : ''}update(id, data) {`);
        lines.push(`    const cols = Object.keys(data).filter(k => k !== 'id');`);
        lines.push('    this.__assertCols(cols);');
        lines.push(`    const vals = cols.map(k => data[k]);`);
        if (dbDriver === 'postgres') {
          lines.push('    const sets = cols.map((k, i) => `${k} = $${i + 1}`).join(", ");');
          lines.push(`    const rows = ${aw}db.query(\`UPDATE ${tableName} SET \${sets} WHERE id = $\${cols.length + 1} RETURNING *\`, ...vals, id);`);
          lines.push('    return rows[0];');
        } else {
          lines.push('    const sets = cols.map(k => `${k} = ?`).join(", ");');
          lines.push(`    ${aw}db.run(\`UPDATE ${tableName} SET \${sets} WHERE id = ?\`, ...vals, id);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", id);`);
        }
        lines.push('  },');

        // delete(id)
        lines.push(`  ${isAsync ? 'async ' : ''}delete(id) {`);
        lines.push(`    return ${aw}db.run("DELETE FROM ${tableName} WHERE id = ${placeholder(1)}", id);`);
        lines.push('  },');

        // count()
        lines.push(`  ${isAsync ? 'async ' : ''}count(conditions) {`);
        lines.push('    if (!conditions) {');
        lines.push(`      const row = ${aw}db.get("SELECT COUNT(*) as count FROM ${tableName}");`);
        lines.push('      return row ? row.count : 0;');
        lines.push('    }');
        lines.push('    const keys = Object.keys(conditions);');
        lines.push('    this.__assertCols(keys);');
        lines.push('    const vals = Object.values(conditions);');
        if (dbDriver === 'postgres') {
          lines.push('    const clauses = keys.map((k, i) => `${k} = $${i + 1}`).join(" AND ");');
        } else {
          lines.push('    const clauses = keys.map(k => `${k} = ?`).join(" AND ");');
        }
        lines.push(`    const row = ${aw}db.get(\`SELECT COUNT(*) as count FROM ${tableName} WHERE \${clauses}\`, ...vals);`);
        lines.push('    return row ? row.count : 0;');
        lines.push('  },');

        // paginate(page, perPage) — returns { data, page, perPage, total, totalPages }
        lines.push(`  ${isAsync ? 'async ' : ''}paginate(page = 1, perPage = 20) {`);
        lines.push('    const p = Math.max(1, Math.floor(page));');
        lines.push('    const pp = Math.max(1, Math.min(100, Math.floor(perPage)));');
        lines.push('    const offset = (p - 1) * pp;');
        if (dbDriver === 'postgres') {
          lines.push(`    const rows = ${aw}db.query("SELECT * FROM ${tableName} ORDER BY id LIMIT $1 OFFSET $2", pp, offset);`);
        } else {
          lines.push(`    const rows = ${aw}db.query("SELECT * FROM ${tableName} ORDER BY id LIMIT ? OFFSET ?", pp, offset);`);
        }
        lines.push(`    const countRow = ${aw}db.get("SELECT COUNT(*) as count FROM ${tableName}");`);
        lines.push('    const total = countRow ? countRow.count : 0;');
        lines.push('    return { data: rows, page: p, perPage: pp, total, totalPages: Math.ceil(total / pp) };');
        lines.push('  },');

        // soft_delete(id) — sets deleted_at timestamp instead of removing row
        lines.push(`  ${isAsync ? 'async ' : ''}soft_delete(id) {`);
        if (dbDriver === 'postgres') {
          lines.push(`    const rows = ${aw}db.query("UPDATE ${tableName} SET deleted_at = NOW() WHERE id = $1 RETURNING *", id);`);
          lines.push('    return rows[0];');
        } else {
          lines.push(`    ${aw}db.run("UPDATE ${tableName} SET deleted_at = datetime('now') WHERE id = ?", id);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", id);`);
        }
        lines.push('  },');

        // restore(id) — clears deleted_at to restore a soft-deleted row
        lines.push(`  ${isAsync ? 'async ' : ''}restore(id) {`);
        if (dbDriver === 'postgres') {
          lines.push(`    const rows = ${aw}db.query("UPDATE ${tableName} SET deleted_at = NULL WHERE id = $1 RETURNING *", id);`);
          lines.push('    return rows[0];');
        } else {
          lines.push(`    ${aw}db.run("UPDATE ${tableName} SET deleted_at = NULL WHERE id = ?", id);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", id);`);
        }
        lines.push('  },');

        // active() — returns only non-soft-deleted rows
        lines.push(`  ${isAsync ? 'async ' : ''}active() {`);
        lines.push(`    return ${aw}db.query("SELECT * FROM ${tableName} WHERE deleted_at IS NULL");`);
        lines.push('  },');

        // belongs_to accessors: PostModel.user(user_id) → single parent record
        for (const parentName of belongsToNames) {
          const parentTable = parentName.toLowerCase() + 's';
          const accessorName = parentName.toLowerCase();
          lines.push(`  ${isAsync ? 'async ' : ''}${accessorName}(${accessorName}_id) {`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${parentTable} WHERE id = ${placeholder(1)}", ${accessorName}_id);`);
          lines.push('  },');
        }

        // has_many accessors: UserModel.posts(id) → array of child records
        for (const childName of hasManyNames) {
          const childTable = childName.toLowerCase() + 's';
          const accessorName = childName.toLowerCase() + 's';
          const fkCol = typeName.toLowerCase() + '_id';
          lines.push(`  ${isAsync ? 'async ' : ''}${accessorName}(id) {`);
          lines.push(`    return ${aw}db.query("SELECT * FROM ${childTable} WHERE ${fkCol} = ${placeholder(1)}", id);`);
          lines.push('  },');
        }

        lines.push('};');
        // Alias so server functions can reference the model by its original type name
        // Use var so it works both when Task is already declared (single-file shared block)
        // and when it isn't (multi-file: server in separate file from shared types)
        lines.push(`var ${typeName} = ${typeName}Model;`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 12f. SSE (Server-Sent Events) Support
    // ════════════════════════════════════════════════════════════
    if (sseDecls.length > 0) {
      lines.push('// ── SSE (Server-Sent Events) ──');
      lines.push('let __sseEventId = 0;');
      lines.push('class __SSEChannel {');
      lines.push('  constructor() { this.clients = new Set(); }');
      lines.push('  subscribe(controller) {');
      lines.push('    this.clients.add(controller);');
      lines.push('    // Send retry directive so browser reconnects after 3s');
      lines.push('    try { controller.enqueue(new TextEncoder().encode("retry: 3000\\n\\n")); } catch {}');
      lines.push('  }');
      lines.push('  unsubscribe(controller) { this.clients.delete(controller); }');
      lines.push('  send(data, event = null) {');
      lines.push('    let msg = "";');
      lines.push('    msg += `id: ${++__sseEventId}\\n`;');
      lines.push('    if (event) msg += `event: ${event}\\n`;');
      lines.push('    msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
      lines.push('    const encoded = new TextEncoder().encode(msg);');
      lines.push('    for (const c of this.clients) { try { c.enqueue(encoded); } catch { this.clients.delete(c); } }');
      lines.push('  }');
      lines.push('  get count() { return this.clients.size; }');
      lines.push('}');
      // Periodic heartbeat to detect dead connections
      lines.push('setInterval(() => {');
      lines.push('  const hb = new TextEncoder().encode(": heartbeat\\n\\n");');
      lines.push('  for (const [, ch] of __sseChannels) {');
      lines.push('    for (const c of ch.clients) { try { c.enqueue(hb); } catch { ch.clients.delete(c); } }');
      lines.push('  }');
      lines.push('}, 30000);');
      lines.push('const __sseChannels = new Map();');
      lines.push('function sse_channel(name) {');
      lines.push('  if (!__sseChannels.has(name)) __sseChannels.set(name, new __SSEChannel());');
      lines.push('  return __sseChannels.get(name);');
      lines.push('}');
      lines.push('');

      for (const sse of sseDecls) {
        const params = sse.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sse.params) this.declareVar(p.name);
        const body = this.genBlockBody(sse.body);
        this.popScope();

        lines.push(`__addRoute("GET", ${JSON.stringify(sse.path)}, async (req) => {`);
        lines.push('  const __lastEventId = req.headers.get("Last-Event-ID");');
        lines.push('  const stream = new ReadableStream({');
        lines.push(`    start(controller) {`);
        lines.push('      controller.enqueue(new TextEncoder().encode("retry: 3000\\n\\n"));');
        lines.push('      const send = (data, event) => {');
        lines.push('        let msg = `id: ${++__sseEventId}\\n`;');
        lines.push('        if (event) msg += `event: ${event}\\n`;');
        lines.push('        msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
        lines.push('        controller.enqueue(new TextEncoder().encode(msg));');
        lines.push('      };');
        lines.push('      const close = () => controller.close();');
        lines.push(`      (async (${params || 'send, close'}) => {`);
        lines.push(body);
        lines.push(`      })(${params || 'send, close'});`);
        lines.push('    }');
        lines.push('  });');
        lines.push('  return new Response(stream, {');
        lines.push('    headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" }');
        lines.push('  });');
        lines.push('});');
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 12g. Content Negotiation Helper
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Content Negotiation ──');
    lines.push('function negotiate(req, data, options = {}) {');
    lines.push('  const accept = (req.headers.get("Accept") || "application/json").toLowerCase();');
    lines.push('  if (accept.includes("text/html") && options.html) {');
    lines.push('    const body = typeof options.html === "function" ? options.html(data) : options.html;');
    lines.push('    return new Response(body, { status: options.status || 200, headers: { "Content-Type": "text/html" } });');
    lines.push('  }');
    lines.push('  if (accept.includes("text/xml") || accept.includes("application/xml")) {');
    lines.push('    if (options.xml) {');
    lines.push('      const body = typeof options.xml === "function" ? options.xml(data) : options.xml;');
    lines.push('      return new Response(body, { status: options.status || 200, headers: { "Content-Type": "application/xml" } });');
    lines.push('    }');
    lines.push('  }');
    lines.push('  if (accept.includes("text/plain")) {');
    lines.push('    const body = typeof data === "string" ? data : JSON.stringify(data, null, 2);');
    lines.push('    return new Response(body, { status: options.status || 200, headers: { "Content-Type": "text/plain" } });');
    lines.push('  }');
    lines.push('  return Response.json(data, { status: options.status || 200 });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12h. Race Condition Protection — Async Mutex for shared state
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Async Mutex (Named) ──');
    lines.push('class __Mutex {');
    lines.push('  constructor() { this._queue = []; this._locked = false; }');
    lines.push('  async acquire() {');
    lines.push('    if (!this._locked) { this._locked = true; return; }');
    lines.push('    return new Promise(resolve => this._queue.push(resolve));');
    lines.push('  }');
    lines.push('  release() {');
    lines.push('    if (this._queue.length > 0) { this._queue.shift()(); }');
    lines.push('    else { this._locked = false; }');
    lines.push('  }');
    lines.push('}');
    lines.push('const __locks = new Map();');
    lines.push('function __getLock(name) {');
    lines.push('  if (!__locks.has(name)) __locks.set(name, new __Mutex());');
    lines.push('  return __locks.get(name);');
    lines.push('}');
    lines.push('async function withLock(nameOrFn, fn) {');
    lines.push('  if (typeof nameOrFn === "function") { fn = nameOrFn; nameOrFn = "default"; }');
    lines.push('  const lock = __getLock(nameOrFn);');
    lines.push('  await lock.acquire();');
    lines.push('  try { return await fn(); } finally { lock.release(); }');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12i. Idempotency Key Support
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
      lines.push('// ── Idempotency Key Cache ──');
      lines.push('const __idempotencyCache = new Map();');
      lines.push('const __idempotencyMaxKeys = 10000;');
      lines.push('const __idempotencyTTL = 86400000;'); // 24h default
      lines.push('function __checkIdempotencyKey(key) {');
      lines.push('  const entry = __idempotencyCache.get(key);');
      lines.push('  if (!entry) return null;');
      lines.push('  if (Date.now() - entry.timestamp > __idempotencyTTL) { __idempotencyCache.delete(key); return null; }');
      lines.push('  return entry;');
      lines.push('}');
      lines.push('function __storeIdempotencyResult(key, status, body, headers) {');
      lines.push('  if (__idempotencyCache.size >= __idempotencyMaxKeys) {');
      lines.push('    const oldest = __idempotencyCache.keys().next().value;');
      lines.push('    __idempotencyCache.delete(oldest);');
      lines.push('  }');
      lines.push('  __idempotencyCache.set(key, { status, body, headers, timestamp: Date.now() });');
      lines.push('}');
      lines.push('setInterval(() => {');
      lines.push('  const now = Date.now();');
      lines.push('  for (const [key, entry] of __idempotencyCache) {');
      lines.push('    if (now - entry.timestamp > __idempotencyTTL) __idempotencyCache.delete(key);');
      lines.push('  }');
      lines.push('}, 3600000);'); // cleanup every hour
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 13. Other statements + Server Functions
    // ════════════════════════════════════════════════════════════
    for (const stmt of otherStatements) {
      lines.push(this.generateStatement(stmt));
    }

    if (functions.length > 0) {
      lines.push('// ── Server Functions ──');
      for (const fn of functions) {
        lines.push(this.generateStatement(fn));
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 14. Subscribe registrations (F5)
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0) {
      lines.push('// ── Event Subscriptions ──');
      for (const sub of subscriptions) {
        const params = sub.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sub.params) this.declareVar(p.name);
        const body = this.genBlockBody(sub.body);
        this.popScope();
        lines.push(`__subscribe(${JSON.stringify(sub.event)}, async (${params}) => {`);
        lines.push(body);
        lines.push('});');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 15. Middleware, Error handler, Health check, RPC endpoints
    // ════════════════════════════════════════════════════════════
    if (middlewares.length > 0) {
      lines.push('// ── Middleware ──');
      for (const mw of middlewares) {
        const params = mw.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of mw.params) this.declareVar(p.name);
        const body = this.genBlockBody(mw.body);
        this.popScope();
        lines.push(`async function ${mw.name}(${params}) {`);
        lines.push(body);
        lines.push('}');
        lines.push('');
      }
    }

    if (errorHandler) {
      const params = errorHandler.params.map(p => p.name).join(', ');
      this.pushScope();
      for (const p of errorHandler.params) this.declareVar(p.name);
      const body = this.genBlockBody(errorHandler.body);
      this.popScope();
      lines.push('// ── Error Handler ──');
      lines.push(`async function __errorHandler(${params}) {`);
      lines.push(body);
      lines.push('}');
      lines.push('');
    }

    if (healthPath) {
      lines.push('// ── Health Check ──');
      lines.push(`__addRoute("GET", ${JSON.stringify(healthPath)}, async () => {`);
      if (healthChecks && healthChecks.length > 0) {
        lines.push('  const __checks = {};');
        lines.push('  let __overallStatus = "healthy";');
        // check_memory: report heap usage
        if (healthChecks.includes('check_memory')) {
          lines.push('  const __mem = process.memoryUsage();');
          lines.push('  const __heapPct = __mem.heapUsed / __mem.heapTotal;');
          lines.push('  __checks.memory = { status: __heapPct > 0.9 ? "degraded" : "healthy", heapUsed: __mem.heapUsed, heapTotal: __mem.heapTotal, rss: __mem.rss };');
          lines.push('  if (__heapPct > 0.9) __overallStatus = "degraded";');
        }
        // check_db: ping database
        if (healthChecks.includes('check_db') && (dbConfig || usesDb)) {
          lines.push('  try {');
          if (dbDriver === 'postgres') {
            lines.push('    await db.query("SELECT 1");');
          } else if (dbDriver === 'mysql') {
            lines.push('    await db.query("SELECT 1");');
          } else {
            lines.push('    db.query("SELECT 1");');
          }
          lines.push('    __checks.db = { status: "healthy" };');
          lines.push('  } catch (__dbErr) {');
          lines.push('    __checks.db = { status: "unhealthy", error: __dbErr.message };');
          lines.push('    __overallStatus = "unhealthy";');
          lines.push('  }');
        }
        // Always include uptime
        lines.push('  __checks.uptime = { seconds: Math.floor(process.uptime()) };');
        lines.push('  return Response.json({ status: __overallStatus, checks: __checks, timestamp: new Date().toISOString() });');
      } else {
        lines.push('  return Response.json({ status: "ok", uptime: process.uptime() });');
      }
      lines.push('});');
      lines.push('');
    }

    // CSRF Token Endpoint
    if (needsCsrf) {
      lines.push('// ── CSRF Token Endpoint ──');
      if (sessionConfig) {
        lines.push('__addRoute("GET", "/csrf-token", async (req) => {');
        lines.push('  const __bindingId = req.__session ? req.__session.get("__sid") || "anon" : "anon";');
        lines.push('  const token = await __generateCSRFToken(__bindingId);');
      } else {
        lines.push('__addRoute("GET", "/csrf-token", async () => {');
        lines.push('  const token = await __generateCSRFToken();');
      }
      lines.push('  return Response.json({ token });');
      lines.push('});');
      lines.push('');
    }

    // RPC Endpoints (auto-wired)
    if (functions.length > 0) {
      lines.push('// ── RPC Endpoints ──');
      for (const fn of functions) {
        const name = fn.name;
        const paramNames = fn.params.map(p => p.name);
        lines.push(`__addRoute("POST", "/rpc/${name}", async (req) => {`);
        lines.push(`  const body = await req.json();`);
        if (paramNames.length > 0) {
          for (let pi = 0; pi < paramNames.length; pi++) {
            lines.push(`  const ${paramNames[pi]} = body.__args ? body.__args[${pi}] : body.${paramNames[pi]};`);
          }
          const validationChecks = this._genValidationCode(fn.params);
          // Phase 3: Also generate type-level validator checks for typed parameters
          const typeValidatorChecks = [];
          for (const p of fn.params) {
            if (p.typeAnnotation && p.typeAnnotation.type === 'TypeAnnotation' && sharedTypes.has(p.typeAnnotation.name)) {
              const typeInfo = sharedTypes.get(p.typeAnnotation.name);
              const tvChecks = this._genTypeValidatorCode(p.name, typeInfo);
              typeValidatorChecks.push(...tvChecks);
            }
          }
          const allChecks = [...validationChecks, ...typeValidatorChecks];
          if (allChecks.length > 0) {
            lines.push(`  const __validationErrors = [];`);
            for (const check of allChecks) {
              lines.push(check);
            }
            lines.push(`  if (__validationErrors.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed", __validationErrors);`);
          }
          lines.push(`  const result = await ${name}(${paramNames.join(', ')});`);
        } else {
          lines.push(`  const result = await ${name}();`);
        }
        if (securityFragments && securityFragments.hasAutoSanitize) {
          const userRef = authConfig ? 'await __authenticate(req)' : 'null';
          lines.push(`  return Response.json({ result: __autoSanitize(result, ${userRef}) });`);
        } else {
          lines.push(`  return Response.json({ result });`);
        }
        lines.push(`});`);
        lines.push('');
      }
    }

    // Cookie auth logout endpoint
    if (authConfig) {
      const isCookieAuth = authConfig.storage && authConfig.storage.type === 'StringLiteral' && authConfig.storage.value === 'cookie';
      if (isCookieAuth) {
        lines.push('// ── Cookie Auth Logout ──');
        lines.push('__addRoute("POST", "/rpc/__logout", async (req) => {');
        lines.push('  return __clearAuthCookie(Response.json({ ok: true }));');
        lines.push('});');
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 16. Event RPC endpoint (F5) — if multi-server + subscriptions
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0 && peerBlocks && peerBlocks.size > 0) {
      lines.push('// ── Event RPC Endpoint ──');
      lines.push('__addRoute("POST", "/rpc/__event", async (req) => {');
      lines.push('  const { event, data } = await req.json();');
      lines.push('  const handlers = __eventBus.get(event) || [];');
      lines.push('  await Promise.all(handlers.map(h => h(data)));');
      lines.push('  return Response.json({ ok: true });');
      lines.push('});');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 17. Explicit Routes — with timeout (F7) + per-route rate_limit (F2)
    // ════════════════════════════════════════════════════════════
    if (routes.length > 0) {
      // Sort routes by specificity: static > :param > *wildcard, longer paths first
      const segWeight = (seg) => {
        if (seg.startsWith('*')) return 2; // wildcard — least specific
        if (seg.startsWith(':')) return 1; // param
        return 0; // static — most specific
      };
      routes.sort((a, b) => {
        const segsA = a.path.split('/').filter(Boolean);
        const segsB = b.path.split('/').filter(Boolean);
        // More segments = more specific (but wildcards are inherently less specific)
        const aHasWild = segsA.some(s => s.startsWith('*'));
        const bHasWild = segsB.some(s => s.startsWith('*'));
        if (aHasWild !== bHasWild) return aHasWild ? 1 : -1;
        if (segsA.length !== segsB.length) return segsB.length - segsA.length;
        // Compare segment by segment: static beats dynamic beats wildcard
        for (let i = 0; i < Math.min(segsA.length, segsB.length); i++) {
          const wa = segWeight(segsA[i]);
          const wb = segWeight(segsB[i]);
          if (wa !== wb) return wa - wb;
        }
        // Stable sort: same path, order by method (deterministic)
        const methodOrder = { HEAD: 0, GET: 1, POST: 2, PUT: 3, PATCH: 4, DELETE: 5, OPTIONS: 6 };
        return (methodOrder[a.method.toUpperCase()] || 9) - (methodOrder[b.method.toUpperCase()] || 9);
      });
      lines.push('// ── Routes ──');
      for (const route of routes) {
        const method = route.method.toUpperCase();
        const path = route.path;
        const handlerRaw = this.genExpression(route.handler);
        // Wrap inline lambda handlers in parens so they can be called as IIFEs
        const handlerIsInline = route.handler.type !== 'Identifier';
        const handler = handlerIsInline ? `(${handlerRaw})` : handlerRaw;

        const handlerName = route.handler.type === 'Identifier' ? route.handler.name : null;
        const handlerParams = handlerName ? fnParamMap.get(handlerName) : null;
        const handlerDecl = handlerName ? fnDeclMap.get(handlerName) : null;

        const decorators = route.decorators || [];
        const groupMws = route._groupMiddlewares || [];
        const hasAuth = decorators.some(d => d.name === 'auth');
        const roleDecorator = decorators.find(d => d.name === 'role');
        const rateLimitDec = decorators.find(d => d.name === 'rate_limit');
        const timeoutDec = decorators.find(d => d.name === 'timeout');
        const timeoutMs = timeoutDec && timeoutDec.args[0] ? this.genExpression(timeoutDec.args[0]) : null;
        const validateDec = decorators.find(d => d.name === 'validate');
        const uploadDec = decorators.find(d => d.name === 'upload');

        // T9-5: Version info for route
        const routeVersion = route._version;
        const versionArg = routeVersion ? `, ${JSON.stringify(String(routeVersion.version || ''))}` : '';

        lines.push(`__addRoute(${JSON.stringify(method)}, ${JSON.stringify(path)}, async (req, params) => {`);

        // Auth decorator check
        if (hasAuth && authConfig) {
          lines.push(`  const __user = await __authenticate(req);`);
          lines.push(`  if (!__user) return __errorResponse(401, "AUTH_REQUIRED", "Unauthorized");`);
          if (roleDecorator && roleDecorator.args.length > 0) {
            const roleExpr = this.genExpression(roleDecorator.args[0]);
            lines.push(`  if (__user.role !== ${roleExpr}) return __errorResponse(403, "FORBIDDEN", "Forbidden");`);
          }
        }

        // Per-route rate limit check
        if (rateLimitDec && needsRateLimitStore) {
          const rlMax = rateLimitDec.args[0] ? this.genExpression(rateLimitDec.args[0]) : '100';
          const rlWindow = rateLimitDec.args[1] ? this.genExpression(rateLimitDec.args[1]) : '60';
          lines.push(`  const __rlIp = __getClientIp(req);`);
          lines.push(`  const __rlRoute = __checkRateLimit(\`route:${path}:\${__rlIp}\`, ${rlMax}, ${rlWindow});`);
          lines.push(`  if (__rlRoute.limited) return __errorResponse(429, "RATE_LIMITED", "Too Many Requests", null, { "Retry-After": String(__rlRoute.retryAfter) });`);
        }

        // Upload decorator — parse multipart body, validate file field
        if (uploadDec) {
          const fieldExpr = uploadDec.args[0] ? this.genExpression(uploadDec.args[0]) : '"file"';
          lines.push(`  const __body = (await __parseBody(req)) || {};`);
          lines.push(`  const __uploadField = ${fieldExpr};`);
          lines.push(`  const __uploadFile = __body[__uploadField];`);
          lines.push(`  const __uploadCheck = __validateFile(__uploadFile, __uploadField);`);
          lines.push(`  if (!__uploadCheck.valid) return __errorResponse(400, "VALIDATION_FAILED", __uploadCheck.error);`);
        }

        // Validate decorator — advanced field validation on body
        if (validateDec && validateDec.args[0]) {
          if (!uploadDec) {
            lines.push(`  const __body = (await __parseBody(req)) || {};`);
          }
          lines.push(`  const __validationErrors = [];`);
          const advChecks = this._genAdvancedValidationCode(validateDec.args[0]);
          for (const check of advChecks) lines.push(check);
          lines.push(`  if (__validationErrors.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed", __validationErrors);`);
        }

        // T9-1: Route-level body type validation — route POST "/api/users" body: User => handler
        if (route.bodyType && ['POST', 'PUT', 'PATCH'].includes(method)) {
          const typeName = route.bodyType.name || (route.bodyType.elementType && route.bodyType.elementType.name);
          if (typeName && sharedTypes.has(typeName)) {
            const typeInfo = sharedTypes.get(typeName);
            if (!uploadDec && !validateDec) {
              lines.push(`  const __body = (await __parseBody(req)) || {};`);
            }
            const isArray = route.bodyType.type === 'ArrayTypeAnnotation';
            if (isArray) {
              lines.push(`  if (!Array.isArray(__body)) return __errorResponse(400, "VALIDATION_FAILED", "Request body must be an array of ${typeName}");`);
              lines.push(`  const __bodyTypeErrors = [];`);
              lines.push(`  for (let __i = 0; __i < __body.length; __i++) {`);
              lines.push(`    const __item = __body[__i];`);
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                switch (f.type) {
                  case 'String':
                    lines.push(`    if (__item.${f.name} !== undefined && typeof __item.${f.name} !== "string") __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be a string\`);`);
                    break;
                  case 'Int':
                    lines.push(`    if (__item.${f.name} !== undefined && !Number.isInteger(__item.${f.name})) __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be an integer\`);`);
                    break;
                  case 'Float':
                    lines.push(`    if (__item.${f.name} !== undefined && typeof __item.${f.name} !== "number") __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be a number\`);`);
                    break;
                  case 'Bool':
                    lines.push(`    if (__item.${f.name} !== undefined && typeof __item.${f.name} !== "boolean") __bodyTypeErrors.push(\`[${f.name}] at index \${__i} must be a boolean\`);`);
                    break;
                }
              }
              lines.push(`  }`);
              lines.push(`  if (__bodyTypeErrors.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed for ${typeName}[]", __bodyTypeErrors);`);
            } else {
              lines.push(`  const __bodyTypeErrors = [];`);
              // Recursive nested validation for body type fields
              const nestedChecks = this._genNestedTypeValidation(sharedTypes, '__body', typeInfo, '');
              for (const check of nestedChecks) lines.push(check);
              // Check for required fields (non-id fields without defaults)
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                lines.push(`  if (__body.${f.name} === undefined || __body.${f.name} === null) __bodyTypeErrors.push("${f.name} is required");`);
              }
              lines.push(`  if (__bodyTypeErrors.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed for type ${typeName}", __bodyTypeErrors);`);
            }
          }
        }

        // Type-safe body deserialization: if a param has a shared type annotation, auto-validate
        if (handlerDecl && ['POST', 'PUT', 'PATCH'].includes(method)) {
          for (const p of handlerDecl.params) {
            if (p.typeAnnotation && p.typeAnnotation.type === 'TypeAnnotation' && sharedTypes.has(p.typeAnnotation.name) && p.name !== 'req') {
              const typeInfo = sharedTypes.get(p.typeAnnotation.name);
              if (!uploadDec && !validateDec) {
                lines.push(`  if (!__body) { var __body = (await __parseBody(req)) || {}; }`);
              }
              lines.push(`  // Type-safe validation for ${p.name}: ${p.typeAnnotation.name}`);
              lines.push(`  const __tsErrors_${p.name} = [];`);
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                switch (f.type) {
                  case 'String':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "string") __tsErrors_${p.name}.push("${f.name} must be a string");`);
                    break;
                  case 'Int':
                    lines.push(`  if (__body.${f.name} !== undefined && !Number.isInteger(__body.${f.name})) __tsErrors_${p.name}.push("${f.name} must be an integer");`);
                    break;
                  case 'Float':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "number") __tsErrors_${p.name}.push("${f.name} must be a number");`);
                    break;
                  case 'Bool':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "boolean") __tsErrors_${p.name}.push("${f.name} must be a boolean");`);
                    break;
                }
              }
              lines.push(`  if (__tsErrors_${p.name}.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed", __tsErrors_${p.name});`);
            }
          }
        }

        if (handlerParams !== null && handlerParams !== undefined) {
          if (handlerParams.length === 0) {
            if (groupMws.length > 0) {
              this._emitGroupMiddlewareChain(lines, groupMws, handler, '()', timeoutMs);
            } else {
              this._emitHandlerCall(lines, `${handler}()`, timeoutMs);
            }
          } else if (handlerParams[0] === 'req') {
            lines.push(`  const __url = new URL(req.url);`);
            lines.push(`  const __ctx = {`);
            lines.push(`    method: req.method, path: __url.pathname, params,`);
            lines.push(`    query: __parseQuery(__url.searchParams),`);
            lines.push(`    headers: Object.fromEntries(req.headers),`);
            lines.push(`    cookies: __parseCookies(req.headers.get("cookie")),`);
            lines.push(`    body: null, raw: req, locals: __getLocals(),`);
            lines.push(`  };`);
            if (sessionConfig) {
              lines.push(`  if (req.__session) __ctx.session = req.__session;`);
            }
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
              lines.push(`  __ctx.body = await __parseBody(req);`);
            }
            const remainingParams = handlerParams.slice(1);
            if (remainingParams.length > 0) {
              if (['POST', 'PUT', 'PATCH'].includes(method)) {
                lines.push(`  const __body = __ctx.body || {};`);
                for (const pn of remainingParams) {
                  lines.push(`  const ${pn} = params.${pn} ?? __body.${pn};`);
                }
              } else {
                for (const pn of remainingParams) {
                  lines.push(`  const ${pn} = params.${pn} ?? __ctx.query.${pn};`);
                }
              }
              if (handlerDecl) {
                const validationChecks = this._genValidationCode(handlerDecl.params.slice(1));
                if (validationChecks.length > 0) {
                  lines.push(`  const __validationErrors = [];`);
                  for (const check of validationChecks) lines.push(check);
                  lines.push(`  if (__validationErrors.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed", __validationErrors);`);
                }
              }
              if (groupMws.length > 0) {
                this._emitGroupMiddlewareChain(lines, groupMws, handler, `(__ctx, ${remainingParams.join(', ')})`, timeoutMs);
              } else {
                this._emitHandlerCall(lines, `${handler}(__ctx, ${remainingParams.join(', ')})`, timeoutMs);
              }
            } else {
              if (groupMws.length > 0) {
                this._emitGroupMiddlewareChain(lines, groupMws, handler, '(__ctx)', timeoutMs);
              } else {
                this._emitHandlerCall(lines, `${handler}(__ctx)`, timeoutMs);
              }
            }
          } else {
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
              lines.push(`  const __body = (await __parseBody(req)) || {};`);
              for (const pn of handlerParams) {
                lines.push(`  const ${pn} = params.${pn} ?? __body.${pn};`);
              }
            } else {
              lines.push(`  const __url = new URL(req.url);`);
              for (const pn of handlerParams) {
                lines.push(`  const ${pn} = params.${pn} ?? __url.searchParams.get(${JSON.stringify(pn)});`);
              }
            }
            if (handlerDecl) {
              const validationChecks = this._genValidationCode(handlerDecl.params);
              if (validationChecks.length > 0) {
                lines.push(`  const __validationErrors = [];`);
                for (const check of validationChecks) lines.push(check);
                lines.push(`  if (__validationErrors.length > 0) return __errorResponse(400, "VALIDATION_FAILED", "Validation failed", __validationErrors);`);
              }
            }
            if (groupMws.length > 0) {
              this._emitGroupMiddlewareChain(lines, groupMws, handler, `(${handlerParams.join(', ')})`, timeoutMs);
            } else {
              this._emitHandlerCall(lines, `${handler}(${handlerParams.join(', ')})`, timeoutMs);
            }
          }
        } else {
          this._emitHandlerCall(lines, `${handler}(req, params)`, timeoutMs);
        }

        // T9-3: Detect generator-based streaming — if handler uses yield, wrap in streaming response
        const isGeneratorHandler = route.handler.type === 'Identifier'
          ? (handlerDecl && this._containsYield(handlerDecl.body))
          : (route.handler.type === 'FunctionDeclaration' || route.handler.type === 'LambdaExpression')
            ? this._containsYield(route.handler.body || route.handler)
            : false;

        if (isGeneratorHandler) {
          lines.push(`  if (__result && typeof __result[Symbol.asyncIterator] === "function") {`);
          lines.push(`    const __encoder = new TextEncoder();`);
          lines.push(`    const __stream = new ReadableStream({`);
          lines.push(`      async start(controller) {`);
          lines.push(`        try {`);
          lines.push(`          for await (const __chunk of __result) {`);
          lines.push(`            const __data = typeof __chunk === "string" ? __chunk : JSON.stringify(__chunk);`);
          lines.push(`            controller.enqueue(__encoder.encode(\`data: \${__data}\\n\\n\`));`);
          lines.push(`          }`);
          lines.push(`        } finally { controller.close(); }`);
          lines.push(`      }`);
          lines.push(`    });`);
          lines.push(`    return new Response(__stream, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });`);
          lines.push(`  }`);
          lines.push(`  if (__result && typeof __result[Symbol.iterator] === "function" && typeof __result !== "string") {`);
          lines.push(`    const __encoder = new TextEncoder();`);
          lines.push(`    const __chunks = [...__result];`);
          lines.push(`    const __stream = new ReadableStream({`);
          lines.push(`      start(controller) {`);
          lines.push(`        for (const __chunk of __chunks) {`);
          lines.push(`          const __data = typeof __chunk === "string" ? __chunk : JSON.stringify(__chunk);`);
          lines.push(`          controller.enqueue(__encoder.encode(\`data: \${__data}\\n\\n\`));`);
          lines.push(`        }`);
          lines.push(`        controller.close();`);
          lines.push(`      }`);
          lines.push(`    });`);
          lines.push(`    return new Response(__stream, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });`);
          lines.push(`  }`);
        }
        // T9-5: API versioning — add version headers to responses
        if (routeVersion) {
          const ver = JSON.stringify(String(routeVersion.version || ''));
          lines.push(`  const __addVersionHeaders = (res) => {`);
          lines.push(`    const h = new Headers(res.headers);`);
          lines.push(`    h.set("API-Version", ${ver});`);
          if (routeVersion.deprecated) {
            lines.push(`    h.set("Deprecation", "true");`);
            if (routeVersion.sunset) {
              lines.push(`    h.set("Sunset", ${JSON.stringify(String(routeVersion.sunset))});`);
            }
            lines.push(`    h.set("Link", '</api/v' + (parseInt(${ver}) + 1) + req.url.replace(/\\/api\\/v\\d+/, "") + '>; rel="successor-version"');`);
          }
          lines.push(`    return new Response(res.body, { status: res.status, headers: h });`);
          lines.push(`  };`);
          lines.push(`  if (__result instanceof Response) return __addVersionHeaders(__result);`);
          if (securityFragments && securityFragments.hasAutoSanitize) {
            const userRef = (hasAuth && authConfig) ? '__user' : (authConfig ? 'await __authenticate(req)' : 'null');
            lines.push(`  return __addVersionHeaders(Response.json(__autoSanitize(__result, ${userRef})));`);
          } else {
            lines.push(`  return __addVersionHeaders(Response.json(__result));`);
          }
        } else {
          lines.push(`  if (__result instanceof Response) return __result;`);
          if (securityFragments && securityFragments.hasAutoSanitize) {
            const userRef = (hasAuth && authConfig) ? '__user' : (authConfig ? 'await __authenticate(req)' : 'null');
            lines.push(`  return Response.json(__autoSanitize(__result, ${userRef}));`);
          } else {
            lines.push(`  return Response.json(__result);`);
          }
        }
        lines.push(`}${versionArg});`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 17b. OpenAPI Spec Generation — auto-generate from routes + types
    // ════════════════════════════════════════════════════════════
    if (routes.length > 0) {
      const tovaTypeToJsonSchema = (typeName) => {
        switch (typeName) {
          case 'Int': return '{ "type": "integer" }';
          case 'Float': return '{ "type": "number" }';
          case 'Bool': return '{ "type": "boolean" }';
          case 'String': return '{ "type": "string" }';
          default: return `{ "$ref": "#/components/schemas/${typeName}" }`;
        }
      };

      lines.push('// ── OpenAPI Spec ──');
      lines.push('const __openApiSpec = {');
      lines.push('  openapi: "3.0.3",');
      lines.push(`  info: { title: ${JSON.stringify(blockName || 'Tova API')}, version: "1.0.0" },`);
      lines.push('  paths: {},');
      lines.push('  components: { schemas: {}, securitySchemes: {} },');
      lines.push('};');

      // Standard error response schema
      lines.push('__openApiSpec.components.schemas.ErrorResponse = {');
      lines.push('  type: "object",');
      lines.push('  properties: {');
      lines.push('    error: { type: "object", properties: {');
      lines.push('      code: { type: "string", description: "Machine-readable error code" },');
      lines.push('      message: { type: "string", description: "Human-readable error message" },');
      lines.push('      details: { type: "array", items: { type: "string" }, description: "Validation error details", nullable: true },');
      lines.push('    }, required: ["code", "message"] },');
      lines.push('  },');
      lines.push('};');

      // Add auth security schemes to OpenAPI spec
      if (authConfig) {
        const authType = authConfig.type ? authConfig.type.value : 'jwt';
        if (authType === 'api_key') {
          const headerExpr = authConfig.header ? this.genExpression(authConfig.header) : '"X-API-Key"';
          lines.push(`__openApiSpec.components.securitySchemes.ApiKeyAuth = { type: "apiKey", in: "header", name: ${headerExpr} };`);
        } else {
          lines.push('__openApiSpec.components.securitySchemes.BearerAuth = { type: "http", scheme: "bearer", bearerFormat: "JWT" };');
        }
      }

      // Generate schemas from shared types
      for (const [typeName, typeInfo] of sharedTypes) {
        const props = typeInfo.fields.map(f => {
          let jsonType;
          switch (f.type) {
            case 'Int': jsonType = '"integer"'; break;
            case 'Float': jsonType = '"number"'; break;
            case 'Bool': jsonType = '"boolean"'; break;
            case 'String': jsonType = '"string"'; break;
            case 'Array': jsonType = '"array"'; break;
            default: jsonType = '"string"'; break;
          }
          return `${f.name}: { type: ${jsonType} }`;
        }).join(', ');
        lines.push(`__openApiSpec.components.schemas[${JSON.stringify(typeName)}] = { type: "object", properties: { ${props} } };`);
      }

      // Generate paths from routes
      for (const route of routes) {
        const method = route.method.toLowerCase();
        const path = route.path.replace(/:([^/]+)/g, '{$1}');
        const handlerName = route.handler.type === 'Identifier' ? route.handler.name : null;
        const handlerDecl = handlerName ? fnDeclMap.get(handlerName) : null;

        lines.push(`if (!__openApiSpec.paths[${JSON.stringify(path)}]) __openApiSpec.paths[${JSON.stringify(path)}] = {};`);
        lines.push(`__openApiSpec.paths[${JSON.stringify(path)}][${JSON.stringify(method)}] = {`);

        // Summary from handler name
        if (handlerName) {
          lines.push(`  summary: ${JSON.stringify(handlerName.replace(/_/g, ' '))},`);
        }

        // Parameters from path params and handler params
        const pathParams = (route.path.match(/:([^/]+)/g) || []).map(p => p.slice(1));
        if (pathParams.length > 0) {
          lines.push('  parameters: [');
          for (const pp of pathParams) {
            lines.push(`    { name: ${JSON.stringify(pp)}, in: "path", required: true, schema: { type: "string" } },`);
          }
          lines.push('  ],');
        }

        // Request body schema for POST/PUT/PATCH — prefer route-level bodyType, fall back to handler params
        if (['post', 'put', 'patch'].includes(method)) {
          if (route.bodyType) {
            // T9-1: Route-level body type annotation
            const bt = route.bodyType;
            if (bt.type === 'ArrayTypeAnnotation' && bt.elementType) {
              const elName = bt.elementType.name;
              if (sharedTypes.has(elName)) {
                lines.push(`  requestBody: { required: true, content: { "application/json": { schema: { type: "array", items: { "$ref": "#/components/schemas/${elName}" } } } } },`);
              } else {
                lines.push(`  requestBody: { required: true, content: { "application/json": { schema: { type: "array", items: ${tovaTypeToJsonSchema(elName)} } } } },`);
              }
            } else if (bt.type === 'TypeAnnotation' && sharedTypes.has(bt.name)) {
              lines.push(`  requestBody: { required: true, content: { "application/json": { schema: { "$ref": "#/components/schemas/${bt.name}" } } } },`);
            } else if (bt.type === 'TypeAnnotation') {
              lines.push(`  requestBody: { required: true, content: { "application/json": { schema: ${tovaTypeToJsonSchema(bt.name)} } } },`);
            }
          } else if (handlerDecl) {
            const bodyParams = handlerDecl.params.filter(p => p.name !== 'req' && !pathParams.includes(p.name));
            if (bodyParams.length > 0) {
              lines.push('  requestBody: {');
              lines.push('    content: { "application/json": { schema: { type: "object", properties: {');
              for (const bp of bodyParams) {
                const ta = bp.typeAnnotation;
                if (ta && ta.name && sharedTypes.has(ta.name)) {
                  lines.push(`      ${bp.name}: { "$ref": "#/components/schemas/${ta.name}" },`);
                } else if (ta) {
                  let jsonType;
                  switch (ta.name) {
                    case 'Int': jsonType = '"integer"'; break;
                    case 'Float': jsonType = '"number"'; break;
                    case 'Bool': jsonType = '"boolean"'; break;
                    default: jsonType = '"string"'; break;
                  }
                  lines.push(`      ${bp.name}: { type: ${jsonType} },`);
                } else {
                  lines.push(`      ${bp.name}: { type: "string" },`);
                }
              }
              lines.push('    } } } },');
              lines.push('  },');
            }
          }
        }

        // Response schema — prefer route-level responseType (T9-2), fall back to handler return type
        const responseType = route.responseType || (handlerDecl && handlerDecl.returnType);
        if (responseType) {
          const rt = responseType;
          if (rt.type === 'ArrayTypeAnnotation' && rt.elementType) {
            const elName = rt.elementType.name;
            if (sharedTypes.has(elName)) {
              lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { type: "array", items: { "$ref": "#/components/schemas/${elName}" } } } } } },`);
            } else {
              lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { type: "array", items: ${tovaTypeToJsonSchema(elName)} } } } } },`);
            }
          } else if (rt.type === 'TypeAnnotation' && sharedTypes.has(rt.name)) {
            lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { "$ref": "#/components/schemas/${rt.name}" } } } } },`);
          } else if (rt.type === 'TypeAnnotation') {
            lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: ${tovaTypeToJsonSchema(rt.name)} } } } },`);
          } else {
            lines.push('  responses: { "200": { description: "Success" } },');
          }
        } else {
          lines.push('  responses: { "200": { description: "Success" } },');
        }

        // Close the OpenAPI path entry object
        lines.push('};');

        // Auto-generate error responses based on route context
        const routeHasAuth = (route.decorators || []).some(d => d.name === 'auth');
        const routeHasRateLimit = (route.decorators || []).some(d => d.name === 'rate_limit');
        const routeHasValidation = (route.decorators || []).some(d => d.name === 'validate') || route.bodyType;
        const routeHasTimeout = (route.decorators || []).some(d => d.name === 'timeout');
        const errRef = '{ "$ref": "#/components/schemas/ErrorResponse" }';

        // Merge error responses into existing 200 response (wrapped in block scope to avoid __r redeclaration)
        lines.push('{');
        lines.push(`const __r = __openApiSpec.paths[${JSON.stringify(path)}][${JSON.stringify(method)}].responses;`);
        if (routeHasValidation || ['post', 'put', 'patch'].includes(method)) {
          lines.push(`__r["400"] = { description: "Validation Failed", content: { "application/json": { schema: ${errRef} } } };`);
        }
        if (routeHasAuth && authConfig) {
          const authType = authConfig.type ? authConfig.type.value : 'jwt';
          const schemeName = authType === 'api_key' ? 'ApiKeyAuth' : 'BearerAuth';
          lines.push(`__openApiSpec.paths[${JSON.stringify(path)}][${JSON.stringify(method)}].security = [{ "${schemeName}": [] }];`);
          lines.push(`__r["401"] = { description: "Unauthorized", content: { "application/json": { schema: ${errRef} } } };`);
          if ((route.decorators || []).some(d => d.name === 'role')) {
            lines.push(`__r["403"] = { description: "Forbidden", content: { "application/json": { schema: ${errRef} } } };`);
          }
        }
        if (pathParams.length > 0) {
          lines.push(`__r["404"] = { description: "Not Found", content: { "application/json": { schema: ${errRef} } } };`);
        }
        if (routeHasRateLimit || rateLimitConfig) {
          lines.push(`__r["429"] = { description: "Too Many Requests", content: { "application/json": { schema: ${errRef} } } };`);
        }
        if (routeHasTimeout) {
          lines.push(`__r["504"] = { description: "Gateway Timeout", content: { "application/json": { schema: ${errRef} } } };`);
        }
        lines.push(`__r["500"] = { description: "Internal Server Error", content: { "application/json": { schema: ${errRef} } } };`);
        lines.push('}');
      }

      // Add the /docs endpoint
      lines.push('__addRoute("GET", "/openapi.json", async () => {');
      lines.push('  return Response.json(__openApiSpec);');
      lines.push('});');
      lines.push('__addRoute("GET", "/docs", async () => {');
      lines.push('  const html = `<!DOCTYPE html><html><head><title>API Docs</title>');
      lines.push('    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"></head>');
      lines.push('    <body><div id="swagger-ui"></div>');
      lines.push('    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"><\\/script>');
      lines.push('    <script>SwaggerUIBundle({ url: "/openapi.json", dom_id: "#swagger-ui" });<\\/script>');
      lines.push('    </body></html>`;');
      lines.push('  return new Response(html, { headers: { "Content-Type": "text/html" } });');
      lines.push('});');
      lines.push('');
    }

    // T9-5: API versions endpoint — list available versions
    const versionedRoutes = routes.filter(r => r._version);
    if (versionedRoutes.length > 0) {
      const versionMap = new Map();
      for (const r of versionedRoutes) {
        const v = String(r._version.version || '');
        if (!versionMap.has(v)) {
          versionMap.set(v, { version: v, deprecated: !!r._version.deprecated, sunset: r._version.sunset || null });
        }
      }
      lines.push('// ── API Versions ──');
      lines.push('__addRoute("GET", "/api/versions", async () => {');
      lines.push('  return Response.json({');
      lines.push('    versions: [');
      for (const [, info] of versionMap) {
        const parts = [`version: ${JSON.stringify(info.version)}`];
        if (info.deprecated) parts.push('deprecated: true');
        if (info.sunset) parts.push(`sunset: ${JSON.stringify(info.sunset)}`);
        lines.push(`      { ${parts.join(', ')} },`);
      }
      lines.push('    ]');
      lines.push('  });');
      lines.push('});');
      lines.push('');
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 18. Logging, Static files, WebSocket
    // ════════════════════════════════════════════════════════════
    if (!isFastMode) {
    lines.push('// ── Structured Logging ──');
    lines.push('let __reqCounter = 0;');
    lines.push('const __validRequestId = /^[a-zA-Z0-9\\-_.]{1,128}$/;');
    lines.push('function __genRequestId() {');
    lines.push('  return `${Date.now().toString(36)}-${(++__reqCounter).toString(36)}`;');
    lines.push('}');
    lines.push('function __sanitizeRequestId(raw) {');
    lines.push('  if (raw && __validRequestId.test(raw)) return raw;');
    lines.push('  return __genRequestId();');
    lines.push('}');
    lines.push('const __logLevels = { debug: 0, info: 1, warn: 2, error: 3 };');
    lines.push('const __logMinLevel = __logLevels[process.env.LOG_LEVEL || "info"] || 1;');
    lines.push('let __logFile = null;');
    lines.push('if (process.env.LOG_FILE) {');
    lines.push('  const __fs = await import("node:fs");');
    lines.push('  __logFile = __fs.createWriteStream(process.env.LOG_FILE, { flags: "a" });');
    lines.push('}');
    lines.push('function __log(level, msg, meta = {}) {');
    lines.push('  if ((__logLevels[level] || 0) < __logMinLevel) return;');
    lines.push('  const entry = JSON.stringify({ timestamp: new Date().toISOString(), level, msg, ...meta });');
    lines.push('  console.log(entry);');
    lines.push('  if (__logFile) __logFile.write(entry + "\\n");');
    lines.push('}');
    lines.push('');
    }

    if (staticDecl) {
      lines.push('// ── Static File Serving ──');
      lines.push(`const __staticPrefix = ${JSON.stringify(staticDecl.path)};`);
      lines.push(`const __staticDir = ${JSON.stringify(staticDecl.dir)};`);
      if (staticDecl.fallback) {
        lines.push(`const __staticFallback = ${JSON.stringify(staticDecl.fallback)};`);
      }
      lines.push('const __path = await import("node:path");');
      lines.push('const __resolvedStaticDir = __path.resolve(__staticDir);');
      lines.push('async function __serveStatic(pathname, req) {');
      lines.push('  const relative = pathname.slice(__staticPrefix.length);');
      lines.push('  const filePath = __path.join(__staticDir, relative);');
      lines.push('  const resolved = __path.resolve(filePath);');
      lines.push('  if (!resolved.startsWith(__resolvedStaticDir + __path.sep) && resolved !== __resolvedStaticDir) return null;');
      lines.push('  try {');
      lines.push('    const file = Bun.file(filePath);');
      lines.push('    if (await file.exists()) {');
      lines.push('      const stat = { size: file.size, lastModified: file.lastModified };');
      lines.push('      const etagVal = `"${stat.size.toString(36)}-${stat.lastModified.toString(36)}"`;');
      lines.push('      if (req && req.headers.get("If-None-Match") === etagVal) {');
      lines.push('        return new Response(null, { status: 304 });');
      lines.push('      }');
      const staticCacheAge = cacheConfig && cacheConfig.max_age ? this.genExpression(cacheConfig.max_age) : '3600';
      lines.push(`      return new Response(file, { headers: { ETag: etagVal, "Cache-Control": "public, max-age=${staticCacheAge}" } });`);
      lines.push('    }');
      lines.push('  } catch {}');
      if (staticDecl.fallback) {
        lines.push('  try {');
        lines.push('    const fb = Bun.file(__staticDir + "/" + __staticFallback);');
        lines.push('    if (await fb.exists()) return new Response(fb, { headers: { "Content-Type": "text/html" } });');
        lines.push('  } catch {}');
      }
      lines.push('  return null;');
      lines.push('}');
      lines.push('');
    }

    if (wsDecl) {
      lines.push('// ── WebSocket Handlers ──');
      lines.push('const __wsClients = new Set();');
      lines.push('const __wsRooms = new Map();');
      // Per-client message rate limiting
      lines.push('const __wsRateLimit = new Map();');
      lines.push('const __wsRateLimitMax = 100;');  // max messages per window
      lines.push('const __wsRateLimitWindow = 10000;'); // 10 second window
      lines.push('function __wsCheckRate(ws) {');
      lines.push('  const now = Date.now();');
      lines.push('  let entry = __wsRateLimit.get(ws);');
      lines.push('  if (!entry || now - entry.windowStart >= __wsRateLimitWindow) {');
      lines.push('    entry = { count: 0, windowStart: now };');
      lines.push('    __wsRateLimit.set(ws, entry);');
      lines.push('  }');
      lines.push('  entry.count++;');
      lines.push('  return entry.count <= __wsRateLimitMax;');
      lines.push('}');
      lines.push('function broadcast(data, exclude = null) {');
      lines.push('  const msg = typeof data === "string" ? data : JSON.stringify(data);');
      lines.push('  for (const c of __wsClients) { if (c !== exclude) c.send(msg); }');
      lines.push('}');
      lines.push('function join(ws, room) {');
      lines.push('  if (!__wsRooms.has(room)) __wsRooms.set(room, new Set());');
      lines.push('  __wsRooms.get(room).add(ws);');
      lines.push('}');
      lines.push('function leave(ws, room) {');
      lines.push('  const r = __wsRooms.get(room);');
      lines.push('  if (r) { r.delete(ws); if (r.size === 0) __wsRooms.delete(room); }');
      lines.push('}');
      lines.push('function broadcast_to(room, data, exclude = null) {');
      lines.push('  const r = __wsRooms.get(room);');
      lines.push('  if (!r) return;');
      lines.push('  const msg = typeof data === "string" ? data : JSON.stringify(data);');
      lines.push('  for (const c of r) { if (c !== exclude) c.send(msg); }');
      lines.push('}');
      lines.push('const __wsHandlers = {};');
      for (const [event, handler] of Object.entries(wsDecl.handlers)) {
        if (!handler) continue;
        const params = handler.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of handler.params) this.declareVar(p.name);
        const body = this.genBlockBody(handler.body);
        this.popScope();
        lines.push(`__wsHandlers.${event} = function(${params}) {`);
        lines.push(body);
        lines.push('};');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 19. Schedule helpers (F8) — interval/cron parser
    // ════════════════════════════════════════════════════════════
    if (schedules.length > 0) {
      lines.push('// ── Schedule Helpers ──');
      lines.push('function __parseInterval(pattern) {');
      lines.push('  const m = pattern.match(/^(\\d+)(s|m|h)$/);');
      lines.push('  if (!m) return null;');
      lines.push('  const val = parseInt(m[1], 10);');
      lines.push('  switch (m[2]) {');
      lines.push('    case "s": return val * 1000;');
      lines.push('    case "m": return val * 60 * 1000;');
      lines.push('    case "h": return val * 60 * 60 * 1000;');
      lines.push('  }');
      lines.push('}');
      lines.push('function __cronFieldMatches(field, value) {');
      lines.push('  if (field === "*") return true;');
      lines.push('  for (const part of field.split(",")) {');
      lines.push('    if (part.includes("/")) {');
      lines.push('      const [range, stepStr] = part.split("/");');
      lines.push('      const step = parseInt(stepStr, 10);');
      lines.push('      if (range === "*") { if (value % step === 0) return true; }');
      lines.push('      else if (range.includes("-")) {');
      lines.push('        const [lo, hi] = range.split("-").map(Number);');
      lines.push('        if (value >= lo && value <= hi && (value - lo) % step === 0) return true;');
      lines.push('      }');
      lines.push('    } else if (part.includes("-")) {');
      lines.push('      const [lo, hi] = part.split("-").map(Number);');
      lines.push('      if (value >= lo && value <= hi) return true;');
      lines.push('    } else { if (parseInt(part, 10) === value) return true; }');
      lines.push('  }');
      lines.push('  return false;');
      lines.push('}');
      lines.push('function __cronMatches(parts, date) {');
      lines.push('  const fields = [date.getMinutes(), date.getHours(), date.getDate(), date.getMonth() + 1, date.getDay()];');
      lines.push('  for (let i = 0; i < 5; i++) {');
      lines.push('    if (!__cronFieldMatches(parts[i], fields[i])) return false;');
      lines.push('  }');
      lines.push('  return true;');
      lines.push('}');
      lines.push('const __scheduleIntervals = [];');

      for (let si = 0; si < schedules.length; si++) {
        const sched = schedules[si];
        const fnName = sched.name || `__scheduled_${si}`;
        const params = sched.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sched.params) this.declareVar(p.name);
        const body = this.genBlockBody(sched.body);
        this.popScope();
        lines.push(`async function ${fnName}(${params}) {`);
        lines.push(body);
        lines.push('}');
        const pattern = sched.pattern;
        // Check if it's a simple interval (no spaces) or cron (has spaces)
        if (pattern.includes(' ')) {
          // Cron expression
          const cronParts = JSON.stringify(pattern.split(/\s+/));
          lines.push(`__scheduleIntervals.push(setInterval(() => {`);
          lines.push(`  if (__cronMatches(${cronParts}, new Date())) ${fnName}();`);
          lines.push(`}, 60000));`);
        } else {
          // Simple interval
          lines.push(`__scheduleIntervals.push(setInterval(${fnName}, __parseInterval(${JSON.stringify(pattern)})));`);
        }
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 20. Middleware chain, Graceful Drain
    // ════════════════════════════════════════════════════════════
    if (globalMiddlewares.length > 0) {
      lines.push('// ── Middleware Chain ──');
      const mwNames = globalMiddlewares.map(m => m.name);
      lines.push(`const __middlewares = [${mwNames.join(', ')}];`);
      lines.push('');
    }

    if (!isFastMode) {
    lines.push('// ── Graceful Drain ──');
    lines.push('let __activeRequests = 0;');
    lines.push('let __shuttingDown = false;');
    lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 21. Request Handler — with global rate limit check (F2)
    // ════════════════════════════════════════════════════════════
    if (isFastMode) {
      // Build combined list of all static routes (declared routes + RPC endpoints)
      const rpcRoutes = functions.map(fn => ({ method: 'POST', path: `/rpc/${fn.name}` }));
      const allFastRoutes = [...routes, ...rpcRoutes];
      const allFastStatic = allFastRoutes.every(r => !r.path.includes(':') && !r.path.includes('*'));

      // Fast mode: emit direct handler references for static routes
      if (allFastStatic && allFastRoutes.length <= 16) {
        for (let ri = 0; ri < allFastRoutes.length; ri++) {
          const method = allFastRoutes[ri].method.toUpperCase();
          const path = allFastRoutes[ri].path;
          lines.push(`const __fh${ri} = __staticRoutes.get(${JSON.stringify(method + ' ' + path)}).handler;`);
        }
      }
      // Fast mode: minimal handler with no AsyncLocalStorage, no logging, no request IDs
      lines.push('// ── Request Handler (fast mode) ──');
      lines.push('function __handleRequest(req) {');
      lines.push('  const __rawUrl = req.url;');
      lines.push('  const __pStart = __rawUrl.indexOf("/", 12);');
      lines.push('  const __qIdx = __rawUrl.indexOf("?", __pStart);');
      lines.push('  let __pathname = __qIdx === -1 ? __rawUrl.slice(__pStart) : __rawUrl.slice(__pStart, __qIdx);');
      lines.push('  try { __pathname = decodeURIComponent(__pathname); } catch {}');
      lines.push('  __pathname = __pathname.replace(/\\/\\/+/g, "/");');
      lines.push('  if (__pathname.length > 1 && __pathname.endsWith("/")) __pathname = __pathname.slice(0, -1);');
      lines.push('  const __method = req.method;');

      // OPTIONS fast path
      lines.push('  if (__method === "OPTIONS") return new Response(null, { status: 204, headers: __corsHeadersConst });');

      // Static route dispatch — emit direct if/else chain using named handler refs
      if (allFastStatic && allFastRoutes.length <= 16) {
        for (let ri = 0; ri < allFastRoutes.length; ri++) {
          const method = allFastRoutes[ri].method.toUpperCase();
          const path = allFastRoutes[ri].path;
          const handlerVar = `__fh${ri}`;
          lines.push(`  if (__method === ${JSON.stringify(method)} && __pathname === ${JSON.stringify(path)}) return ${handlerVar}(req, {});`);
        }
        // HEAD fallback for GET routes
        for (let ri = 0; ri < allFastRoutes.length; ri++) {
          if (allFastRoutes[ri].method.toUpperCase() === 'GET') {
            const handlerVar = `__fh${ri}`;
            lines.push(`  if (__method === "HEAD" && __pathname === ${JSON.stringify(allFastRoutes[ri].path)}) return ${handlerVar}(req, {});`);
          }
        }
      } else {
        // Fallback to Map lookup for larger route sets or dynamic routes
        lines.push('  const __staticKey = __method + " " + __pathname;');
        lines.push('  const __sr = __staticRoutes.get(__staticKey);');
        lines.push('  if (__sr) return __sr.handler(req, {});');
        if (hasDynamicRoutes) {
          lines.push('  for (const route of __routes) {');
          lines.push('    if (route._isStatic) continue;');
          lines.push('    if (__method === route.method || (route.method === "GET" && __method === "HEAD")) {');
          lines.push('      const match = __pathname.match(route.regex);');
          lines.push('      if (match) return route.handler(req, match.groups || {});');
          lines.push('    }');
          lines.push('  }');
        }
      }

      // Client HTML fallback
      lines.push('  if (__pathname === "/" && typeof __clientHTML !== "undefined") {');
      lines.push('    return new Response(__clientHTML, { status: 200, headers: { "Content-Type": "text/html" } });');
      lines.push('  }');
      lines.push('  return new Response("Not Found", { status: 404 });');
      lines.push('}');
      lines.push('');
    } else {
    // Full mode: original handler with all features
    lines.push('// ── Request Handler ──');
    lines.push('async function __handleRequest(req) {');

    lines.push('  if (__shuttingDown) {');
    lines.push('    return new Response("Service Unavailable", { status: 503 });');
    lines.push('  }');
    lines.push('  __activeRequests++;');

    lines.push('  const __rawUrl = req.url;');
    lines.push('  const __pStart = __rawUrl.indexOf("/", 12);');  // skip "http://x:p" or "https://x:p"
    lines.push('  const __qIdx = __rawUrl.indexOf("?", __pStart);');
    lines.push('  let __pathname = __qIdx === -1 ? __rawUrl.slice(__pStart) : __rawUrl.slice(__pStart, __qIdx);');
    lines.push('  try { __pathname = decodeURIComponent(__pathname); } catch {}');
    lines.push('  __pathname = __pathname.replace(/\\/\\/+/g, "/");');
    // Resolve ../ sequences to prevent path traversal
    lines.push('  if (__pathname.includes("..")) {');
    lines.push('    const __parts = __pathname.split("/");');
    lines.push('    const __resolved = [];');
    lines.push('    for (const __seg of __parts) {');
    lines.push('      if (__seg === "..") { __resolved.pop(); }');
    lines.push('      else if (__seg !== ".") { __resolved.push(__seg); }');
    lines.push('    }');
    lines.push('    __pathname = __resolved.join("/") || "/";');
    lines.push('  }');
    lines.push('  if (__pathname.length > 1 && __pathname.endsWith("/")) __pathname = __pathname.slice(0, -1);');
    lines.push('  const __rid = __sanitizeRequestId(req.headers.get("X-Request-Id"));');
    lines.push('  const __startTime = Date.now();');
    lines.push('  const __cors = __getCorsHeaders(req);');

    lines.push('  return __requestContext.run({ rid: __rid, locals: {} }, async () => {');
    lines.push('  try {');

    // WebSocket upgrade
    if (wsDecl) {
      // Determine if WS auth is needed:
      // - If ws has auth: false, skip auth even if authConfig exists
      // - If ws has auth: true or authConfig exists (and ws doesn't disable), require auth
      const wsAuthExplicitlyDisabled = wsDecl.config && wsDecl.config.auth &&
        wsDecl.config.auth.type === 'BooleanLiteral' && wsDecl.config.auth.value === false;
      const wsNeedsAuth = !wsAuthExplicitlyDisabled && (authConfig || (wsDecl.config && wsDecl.config.auth &&
        !(wsDecl.config.auth.type === 'BooleanLiteral' && wsDecl.config.auth.value === false)));

      lines.push('  if (req.headers.get("upgrade") === "websocket") {');
      if (wsNeedsAuth) {
        lines.push('    try {');
        lines.push('      const __wsUser = await __authenticate(req);');
        lines.push('      const upgraded = __server.upgrade(req, { data: { rid: __rid, user: __wsUser } });');
        lines.push('      if (upgraded) return undefined;');
        lines.push('      return new Response("WebSocket upgrade failed", { status: 400 });');
        lines.push('    } catch (__authErr) {');
        lines.push('      return __errorResponse(401, "AUTH_REQUIRED", "Unauthorized");');
        lines.push('    }');
      } else {
        lines.push('    const upgraded = __server.upgrade(req, { data: { rid: __rid } });');
        lines.push('    if (upgraded) return undefined;');
        lines.push('    return new Response("WebSocket upgrade failed", { status: 400 });');
      }
      lines.push('  }');
    }

    lines.push('  if (req.method === "OPTIONS") {');
    lines.push('    return new Response(null, { status: 204, headers: __cors });');
    lines.push('  }');

    // Max body size check
    lines.push('  const __contentLength = parseInt(req.headers.get("Content-Length") || "0", 10);');
    lines.push('  if (__contentLength > __maxBodySize) {');
    lines.push('    return __errorResponse(413, "PAYLOAD_TOO_LARGE", "Payload Too Large", null, __cors);');
    lines.push('  }');

    // Global rate limit check (F2)
    if (rateLimitConfig) {
      lines.push('  const __clientIp = __getClientIp(req);');
      lines.push('  const __rl = __checkRateLimit(__clientIp, __rateLimitMax, __rateLimitWindow);');
      lines.push('  if (__rl.limited) {');
      lines.push('    return __errorResponse(429, "RATE_LIMITED", "Too Many Requests", null, { ...__cors, "Retry-After": String(__rl.retryAfter) });');
      lines.push('  }');
    }

    // Session loading
    if (sessionConfig) {
      lines.push('  let __sessionId = null;');
      lines.push('  let __sessionIsNew = false;');
      lines.push('  const __cookies = __parseCookies(req.headers.get("cookie"));');
      lines.push('  const __signedSid = __cookies[__sessionCookieName];');
      lines.push('  if (__signedSid) {');
      lines.push('    __sessionId = await __verifySessionId(__signedSid);');
      lines.push('  }');
      lines.push('  if (!__sessionId) {');
      lines.push('    __sessionId = crypto.randomUUID();');
      lines.push('    __sessionIsNew = true;');
      lines.push('  }');
      lines.push('  req.__session = __createSession(__sessionId);');
    }

    // CSRF validation on state-mutating requests
    if (needsCsrf) {
      const hasCsrfExempt = securityFragments && securityFragments.csrfConfig && securityFragments.csrfConfig.exempt;
      lines.push('  if (req.method !== "GET" && req.method !== "HEAD" && req.method !== "OPTIONS") {');
      if (hasCsrfExempt) {
        lines.push('   if (!__isCsrfExempt(__pathname)) {');
      }
      lines.push('    const __csrfToken = req.headers.get("X-Tova-CSRF") || req.headers.get("x-tova-csrf");');
      if (sessionConfig) {
        lines.push('    const __csrfBindingId = req.__session ? req.__session.get("__sid") || "anon" : "anon";');
        lines.push('    const __csrfValid = await __validateCSRFToken(__csrfToken, __csrfBindingId);');
      } else {
        lines.push('    const __csrfValid = await __validateCSRFToken(__csrfToken);');
      }
      lines.push('    if (!__csrfValid) {');
      lines.push('      __log("warn", "CSRF validation failed", { rid: __rid, method: req.method, path: __pathname });');
      lines.push('      return __errorResponse(403, "CSRF_INVALID", "CSRF token invalid or missing", null, __cors);');
      lines.push('    }');
      if (hasCsrfExempt) {
        lines.push('   }');
      }
      lines.push('  }');
    }

    // Security block: route protection check
    if (securityFragments && securityFragments.protectCode) {
      lines.push('  // Security block: route protection');
      if (authConfig) {
        lines.push('  const __secUser = await __authenticate(req);');
      } else {
        lines.push('  const __secUser = null;');
      }
      lines.push('  const __protection = __checkProtection(__pathname, __secUser);');
      lines.push('  if (!__protection.allowed) {');
      lines.push('    const __statusCode = __secUser ? 403 : 401;');
      lines.push('    const __errorCode = __secUser ? "FORBIDDEN" : "AUTH_REQUIRED";');
      lines.push('    return __errorResponse(__statusCode, __errorCode, __protection.reason, null, __cors);');
      lines.push('  }');
      lines.push('  if (__protection.rateLimit && __protection.rateLimit.max) {');
      lines.push('    const __protectIp = __getClientIp(req);');
      lines.push('    const __protectRl = __checkRateLimit("protect:" + __pathname + ":" + __protectIp, __protection.rateLimit.max, __protection.rateLimit.window || 60);');
      lines.push('    if (__protectRl.limited) {');
      lines.push('      return __errorResponse(429, "RATE_LIMITED", "Too Many Requests", null, { ...__cors, "Retry-After": String(__protectRl.retryAfter) });');
      lines.push('    }');
      lines.push('  }');
    }

    // Idempotency key check
    lines.push('  const __idempotencyKey = req.headers.get("Idempotency-Key");');
    lines.push('  if (__idempotencyKey && req.method !== "GET" && req.method !== "HEAD" && req.method !== "OPTIONS") {');
    lines.push('    const __cached = __checkIdempotencyKey(__idempotencyKey);');
    lines.push('    if (__cached) {');
    lines.push('      const __cachedHeaders = { ...__cors, ...(__cached.headers || {}), "X-Idempotent-Replayed": "true" };');
    lines.push('      return new Response(JSON.stringify(__cached.body), { status: __cached.status, headers: { "Content-Type": "application/json", ...__cachedHeaders } });');
    lines.push('    }');
    lines.push('  }');

    // Static file serving
    if (staticDecl) {
      lines.push(`  if (__pathname.startsWith(__staticPrefix)) {`);
      lines.push('    const __staticRes = await __serveStatic(__pathname, req);');
      lines.push('    if (__staticRes) return __staticRes;');
      lines.push('  }');
    }

    // Route matching — fast path for static routes (no params/wildcards)
    lines.push('  const __staticKey = req.method + " " + __pathname;');
    lines.push('  const __staticRoute = __staticRoutes.get(__staticKey) || (req.method === "HEAD" && __staticRoutes.get("GET " + __pathname));');
    lines.push('  if (__staticRoute) {');
    lines.push('    const route = __staticRoute;');
    lines.push('    const match = { groups: {} };');

    // Emit static route handler (same structure as dynamic)
    if (globalMiddlewares.length > 0) {
      lines.push('    const __handler = async (__req) => route.handler(__req, {});');
      lines.push('    const __chain = __middlewares.reduceRight(');
      lines.push('      (next, mw) => async (__req) => mw(__req, next),');
      lines.push('      __handler');
      lines.push('    );');
      lines.push('    try {');
      lines.push('      const res = await __chain(req);');
      lines.push('      __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('      const headers = new Headers(res.headers);');
      lines.push('      for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
      lines.push('      return new Response(res.body, { status: res.status, headers });');
      lines.push('    } catch (err) {');
      lines.push('      if (err.message === "__BODY_TOO_LARGE__") return __errorResponse(413, "PAYLOAD_TOO_LARGE", "Payload Too Large", null, __cors);');
      if (errorHandler) {
        lines.push('      try {');
        lines.push('        const errRes = await __errorHandler(err, req);');
        lines.push('        if (errRes instanceof Response) {');
        lines.push('          const headers = new Headers(errRes.headers);');
        lines.push('          for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
        lines.push('          return new Response(errRes.body, { status: errRes.status, headers });');
        lines.push('        }');
        lines.push('        return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('      } catch { /**/ }');
      }
      lines.push('      __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('      return __errorResponse(500, "INTERNAL_ERROR", "Internal Server Error", null, __cors);');
      lines.push('    }');
    } else {
      lines.push('    try {');
      lines.push('      const res = await route.handler(req, {});');
      lines.push('      __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('      for (const [k, v] of Object.entries(__cors)) res.headers.set(k, v);');
      lines.push('      return res;');
      lines.push('    } catch (err) {');
      lines.push('      if (err.message === "__BODY_TOO_LARGE__") return __errorResponse(413, "PAYLOAD_TOO_LARGE", "Payload Too Large", null, __cors);');
      if (errorHandler) {
        lines.push('      try {');
        lines.push('        const errRes = await __errorHandler(err, req);');
        lines.push('        if (errRes instanceof Response) {');
        lines.push('          for (const [k, v] of Object.entries(__cors)) errRes.headers.set(k, v);');
        lines.push('          return errRes;');
        lines.push('        }');
        lines.push('        return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('      } catch { /**/ }');
      }
      lines.push('      __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('      return __errorResponse(500, "INTERNAL_ERROR", "Internal Server Error", null, __cors);');
      lines.push('    }');
    }
    lines.push('  }');

    // Fallback: regex-based matching for dynamic routes
    lines.push('  for (const route of __routes) {');
    lines.push('    if (route._isStatic) continue;');  // Skip static routes already handled
    lines.push('    if (req.method === route.method || (route.method === "GET" && req.method === "HEAD" && !__routes.some(r => r.method === "HEAD" && r.regex.source === route.regex.source))) {');
    lines.push('      const match = __pathname.match(route.regex);');
    lines.push('      if (match) {');

    if (globalMiddlewares.length > 0) {
      lines.push('        const __handler = async (__req) => route.handler(__req, match.groups || {});');
      lines.push('        const __chain = __middlewares.reduceRight(');
      lines.push('          (next, mw) => async (__req) => mw(__req, next),');
      lines.push('          __handler');
      lines.push('        );');
      lines.push('        try {');
      lines.push('          const res = await __chain(req);');
      lines.push('          __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('          for (const [k, v] of Object.entries(__cors)) res.headers.set(k, v);');
      lines.push('          return res;');
      lines.push('        } catch (err) {');
      lines.push('          if (err.message === "__BODY_TOO_LARGE__") return __errorResponse(413, "PAYLOAD_TOO_LARGE", "Payload Too Large", null, __cors);');
      if (errorHandler) {
        lines.push('          try {');
        lines.push('            const errRes = await __errorHandler(err, req);');
        lines.push('            if (errRes instanceof Response) {');
        lines.push('              for (const [k, v] of Object.entries(__cors)) errRes.headers.set(k, v);');
        lines.push('              return errRes;');
        lines.push('            }');
        lines.push('            return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('          } catch { /**/ }');
      }
      lines.push('          __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('          return __errorResponse(500, "INTERNAL_ERROR", "Internal Server Error", null, __cors);');
      lines.push('        }');
    } else {
      lines.push('        try {');
      lines.push('          const res = await route.handler(req, match.groups || {});');
      lines.push('          __log("info", `${req.method} ${__pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('          for (const [k, v] of Object.entries(__cors)) res.headers.set(k, v);');
      lines.push('          return res;');
      lines.push('        } catch (err) {');
      lines.push('          if (err.message === "__BODY_TOO_LARGE__") return __errorResponse(413, "PAYLOAD_TOO_LARGE", "Payload Too Large", null, __cors);');
      if (errorHandler) {
        lines.push('          try {');
        lines.push('            const errRes = await __errorHandler(err, req);');
        lines.push('            if (errRes instanceof Response) {');
        lines.push('              for (const [k, v] of Object.entries(__cors)) errRes.headers.set(k, v);');
        lines.push('              return errRes;');
        lines.push('            }');
        lines.push('            return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('          } catch { /**/ }');
      }
      lines.push('          __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('          return __errorResponse(500, "INTERNAL_ERROR", "Internal Server Error", null, __cors);');
      lines.push('        }');
    }

    lines.push('      }');
    lines.push('    }');
    lines.push('  }');

    // Serve client HTML at root
    lines.push('  if (__pathname === "/" && typeof __clientHTML !== "undefined") {');
    lines.push('    return new Response(__clientHTML, { status: 200, headers: { "Content-Type": "text/html", ...(__cors) } });');
    lines.push('  }');
    lines.push('  const __notFound = __errorResponse(404, "NOT_FOUND", "Not Found", null, __cors);');
    lines.push('  __log("warn", "Not Found", { rid: __rid, method: req.method, path: __pathname, status: 404, ms: Date.now() - __startTime });');
    lines.push('  return __notFound;');

    if (sessionConfig) {
      lines.push('  } catch (__e) { throw __e; }');
      lines.push('  }).then(async (__res) => {');
      lines.push('    if (req.__session && req.__session.__flush) await req.__session.__flush();');
      lines.push('    if (__res && (__sessionIsNew || req.__sessionRegenerated)) {');
      lines.push('      const __sid = req.__newSessionId || __sessionId;');
      lines.push('      const __signed = await __signSessionId(__sid);');
      lines.push('      const __h = new Headers(__res.headers);');
      lines.push('      __h.set("Set-Cookie", `${__sessionCookieName}=${__signed}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=${__sessionMaxAge}`);');
      lines.push('      return new Response(__res.body, { status: __res.status, headers: __h });');
      lines.push('    }');
      lines.push('    return __res;');
      lines.push('  }, async (__e) => {');
      lines.push('    if (req.__session && req.__session.__flush) await req.__session.__flush();');
      lines.push('    throw __e;');
      lines.push('  }).finally(() => { __activeRequests--; });');
    } else {
      lines.push('  } finally {');
      lines.push('    __activeRequests--;');
      lines.push('  }');
      lines.push('  });');
    }
    lines.push('}');
    lines.push('');
    } // end else (full mode)

    // ════════════════════════════════════════════════════════════
    // 22. Bun.serve()
    // ════════════════════════════════════════════════════════════
    const label = blockName ? ` [${blockName}]` : '';
    const portVar = blockName ? `PORT_${blockName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}` : 'PORT';
    lines.push('// ── Start Server ──');
    lines.push(`const __port = process.env.${portVar} || process.env.PORT || 3000;`);
    // Idempotency + Compression wrapper
    if (!isFastMode) {
      lines.push('const __idempotentFetch = async (req) => {');
      if (compressionConfig) {
        lines.push('  const __rawRes = await __handleRequest(req);');
        lines.push('  if (!__rawRes) return __rawRes;');
        lines.push('  const res = await __compressResponse(req, __rawRes);');
      } else {
        lines.push('  const res = await __handleRequest(req);');
      }
      lines.push('  const __idk = req.headers.get("Idempotency-Key");');
      lines.push('  if (__idk && res && req.method !== "GET" && req.method !== "HEAD" && req.method !== "OPTIONS") {');
      lines.push('    try {');
      lines.push('      const __cloned = res.clone();');
      lines.push('      const __resBody = await __cloned.json();');
      lines.push('      __storeIdempotencyResult(__idk, res.status, __resBody, {});');
      lines.push('    } catch {}');
      lines.push('  }');
      lines.push('  if (res) __applySecurityHeaders(res.headers);');
      lines.push('  return res;');
      lines.push('};');
    } else if (compressionConfig) {
      lines.push('const __idempotentFetch = async (req) => {');
      lines.push('  const res = await __handleRequest(req);');
      lines.push('  if (!res) return res;');
      lines.push('  return __compressResponse(req, res);');
      lines.push('};');
    }
    const fetchHandler = (!isFastMode || compressionConfig) ? '__idempotentFetch' : '__handleRequest';
    lines.push(`const __server = Bun.serve({`);
    lines.push(`  port: __port,`);
    lines.push(`  maxRequestBodySize: __maxBodySize,`);
    lines.push(`  fetch: ${fetchHandler},`);
    if (tlsConfig) {
      const certExpr = tlsConfig.cert ? this.genExpression(tlsConfig.cert) : 'undefined';
      const keyExpr = tlsConfig.key ? this.genExpression(tlsConfig.key) : 'undefined';
      lines.push(`  tls: {`);
      lines.push(`    cert: Bun.file(${certExpr}),`);
      lines.push(`    key: Bun.file(${keyExpr}),`);
      if (tlsConfig.ca) {
        lines.push(`    ca: Bun.file(${this.genExpression(tlsConfig.ca)}),`);
      }
      lines.push(`  },`);
    }
    if (wsDecl) {
      lines.push(`  websocket: {`);
      lines.push(`    idleTimeout: 120,`);  // 2 minute idle timeout with auto-ping
      if (wsDecl.handlers.on_open) {
        lines.push(`    open(ws) { __wsClients.add(ws); __wsHandlers.on_open(ws); },`);
      } else {
        lines.push(`    open(ws) { __wsClients.add(ws); },`);
      }
      if (wsDecl.handlers.on_message) {
        // Rate limit check before dispatching to user handler
        lines.push(`    message(ws, message) {`);
        lines.push(`      if (!__wsCheckRate(ws)) { ws.send(JSON.stringify({ error: "RATE_LIMITED", message: "Too many messages" })); return; }`);
        lines.push(`      __wsHandlers.on_message(ws, message);`);
        lines.push(`    },`);
      }
      if (wsDecl.handlers.on_close) {
        lines.push(`    close(ws, code, reason) { __wsClients.delete(ws); __wsRateLimit.delete(ws); for (const [,r] of __wsRooms) r.delete(ws); __wsHandlers.on_close(ws, code, reason); },`);
      } else {
        lines.push(`    close(ws) { __wsClients.delete(ws); __wsRateLimit.delete(ws); for (const [,r] of __wsRooms) r.delete(ws); },`);
      }
      if (wsDecl.handlers.on_error) {
        lines.push(`    error(ws, error) { __wsHandlers.on_error(ws, error); },`);
      }
      lines.push(`  },`);
    }
    lines.push(`});`);
    lines.push(`console.log(\`Tova server${label} running on \${__server.url}\`);`);
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 23. on_start hooks (F3) + schedule intervals (F8)
    // ════════════════════════════════════════════════════════════
    if (onStartHooks.length > 0) {
      lines.push('// ── Lifecycle: on_start ──');
      for (let hi = 0; hi < onStartHooks.length; hi++) {
        const hook = onStartHooks[hi];
        const params = hook.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of hook.params) this.declareVar(p.name);
        const body = this.genBlockBody(hook.body);
        this.popScope();
        lines.push(`(async (${params}) => {`);
        lines.push(body);
        lines.push('})();');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 24. Graceful Shutdown — on_stop hooks (F3) + clearInterval (F8)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Graceful Shutdown ──');
    if (isFastMode) {
      lines.push('function __shutdown() { __server.stop(); process.exit(0); }');
    } else {
    lines.push('async function __shutdown() {');
    lines.push(`  console.log(\`Tova server${label} shutting down...\`);`);
    lines.push('  __shuttingDown = true;');
    lines.push('  __server.stop();');
    lines.push('  const __drainStart = Date.now();');
    lines.push('  while (__activeRequests > 0 && Date.now() - __drainStart < 10000) {');
    lines.push('    await new Promise(r => setTimeout(r, 50));');
    lines.push('  }');

    // on_stop hooks
    if (onStopHooks.length > 0) {
      for (let hi = 0; hi < onStopHooks.length; hi++) {
        const hook = onStopHooks[hi];
        const params = hook.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of hook.params) this.declareVar(p.name);
        const body = this.genBlockBody(hook.body);
        this.popScope();
        lines.push(`  await (async (${params}) => {`);
        lines.push(body);
        lines.push('  })();');
      }
    }

    // Schedule cleanup
    if (schedules.length > 0) {
      lines.push('  for (const __iv of __scheduleIntervals) clearInterval(__iv);');
    }

    if (dbConfig || usesDb) {
      if (dbDriver !== 'sqlite') {
        lines.push('  await db.close();');
      } else {
        lines.push('  db.close();');
      }
    }
    if (backgroundJobs.length > 0) {
      lines.push('  // Wait for in-flight background jobs');
      lines.push('  const __bgDrainStart = Date.now();');
      lines.push('  while (__jobProcessing && Date.now() - __bgDrainStart < 5000) {');
      lines.push('    await new Promise(r => setTimeout(r, 50));');
      lines.push('  }');
    }
    lines.push('  if (__logFile) __logFile.end();');
    lines.push('  process.exit(0);');
    lines.push('}');
    } // end else (full shutdown)
    lines.push('process.on("SIGINT", __shutdown);');
    lines.push('process.on("SIGTERM", __shutdown);');

    return lines.join('\n');
  }

  // Helper: emit group middleware chain wrapping a handler call
  _emitGroupMiddlewareChain(lines, groupMws, handler, callArgs, timeoutMs) {
    lines.push(`  const __grpHandler = async (__req) => ${handler}${callArgs};`);
    lines.push(`  const __grpChain = [${groupMws.join(', ')}].reduceRight(`);
    lines.push(`    (next, mw) => async (__req) => mw(__req, next),`);
    lines.push(`    __grpHandler`);
    lines.push(`  );`);
    this._emitHandlerCall(lines, `__grpChain(req)`, timeoutMs);
  }

  generateTests(testBlocks, sharedCode) {
    const lines = [];
    lines.push('import { describe, test, expect } from "bun:test";');
    lines.push('');
    lines.push('// ── Test Helpers ──');
    lines.push('async function request(method, path, options = {}) {');
    lines.push('  const url = new URL(path, "http://localhost");');
    lines.push('  const init = { method };');
    lines.push('  if (options.headers) init.headers = new Headers(options.headers);');
    lines.push('  else init.headers = new Headers();');
    lines.push('  if (options.body) {');
    lines.push('    init.headers.set("Content-Type", "application/json");');
    lines.push('    init.body = JSON.stringify(options.body);');
    lines.push('  }');
    lines.push('  const req = new Request(url.toString(), init);');
    lines.push('  const res = await __handleRequest(req);');
    lines.push('  let data = null;');
    lines.push('  try { data = await res.clone().json(); } catch {}');
    lines.push('  return { status: res.status, headers: Object.fromEntries(res.headers), data, raw: res };');
    lines.push('}');
    lines.push('function assert(condition, message) {');
    lines.push('  if (!condition) throw new Error(message || "Assertion failed");');
    lines.push('}');
    lines.push('');
    // Include top-level definitions (functions, variables) so tests can reference them
    if (sharedCode && sharedCode.trim()) {
      lines.push('// ── Module Code ──');
      lines.push(sharedCode);
      lines.push('');
    }

    for (const block of testBlocks) {
      const name = block.name || 'Tests';
      const blockTimeout = block.timeout || null;
      lines.push(`describe(${JSON.stringify(name)}, () => {`);

      // Emit beforeEach if defined
      if (block.beforeEach && block.beforeEach.length > 0) {
        lines.push('  beforeEach(async () => {');
        this.pushScope();
        for (const s of block.beforeEach) {
          lines.push('    ' + this.generateStatement(s));
        }
        this.popScope();
        lines.push('  });');
      }

      // Emit afterEach if defined
      if (block.afterEach && block.afterEach.length > 0) {
        lines.push('  afterEach(async () => {');
        this.pushScope();
        for (const s of block.afterEach) {
          lines.push('    ' + this.generateStatement(s));
        }
        this.popScope();
        lines.push('  });');
      }

      const hasFnTests = block.body.some(s => s.type === 'FunctionDeclaration');

      if (hasFnTests) {
        // Function declarations become individual test cases
        for (const stmt of block.body) {
          if (stmt.type === 'FunctionDeclaration') {
            const fnName = stmt.name;
            const displayName = fnName.replace(/_/g, ' ');
            this.pushScope();
            for (const p of (stmt.params || [])) {
              const pName = typeof p === 'string' ? p : (p.name || p.identifier);
              if (pName) this.declareVar(pName);
            }
            const body = this.genBlockBody(stmt.body);
            this.popScope();
            const timeoutArg = blockTimeout ? `, ${blockTimeout}` : '';
            lines.push(`  test(${JSON.stringify(displayName)}, async () => {`);
            lines.push(body);
            lines.push(`  }${timeoutArg});`);
          } else {
            lines.push('  ' + this.generateStatement(stmt));
          }
        }
      } else {
        // No function declarations — wrap all statements in a single test case
        const timeoutArg = blockTimeout ? `, ${blockTimeout}` : '';
        lines.push(`  test(${JSON.stringify(name)}, async () => {`);
        for (const stmt of block.body) {
          lines.push('    ' + this.generateStatement(stmt));
        }
        lines.push(`  }${timeoutArg});`);
      }
      lines.push('});');
      lines.push('');
    }

    return lines.join('\n');
  }

  generateBench(benchBlocks, sharedCode) {
    const lines = [];
    lines.push('// ── Tova Benchmark Runner ──');
    lines.push('');
    // Include top-level definitions (functions, variables) so benchmarks can reference them
    if (sharedCode && sharedCode.trim()) {
      lines.push('// ── Module Code ──');
      lines.push(sharedCode);
      lines.push('');
    }
    lines.push('async function __runBench(name, fn, runs) {');
    lines.push('  runs = runs || 100;');
    lines.push('  // Warmup');
    lines.push('  for (let i = 0; i < Math.min(10, runs); i++) await fn();');
    lines.push('  const times = [];');
    lines.push('  for (let i = 0; i < runs; i++) {');
    lines.push('    const start = performance.now();');
    lines.push('    await fn();');
    lines.push('    times.push(performance.now() - start);');
    lines.push('  }');
    lines.push('  times.sort((a, b) => a - b);');
    lines.push('  const sum = times.reduce((a, b) => a + b, 0);');
    lines.push('  const mean = sum / times.length;');
    lines.push('  const p50 = times[Math.floor(times.length * 0.5)];');
    lines.push('  const p99 = times[Math.floor(times.length * 0.99)];');
    lines.push('  console.log(`bench ${JSON.stringify(name)}: mean=${mean.toFixed(2)}ms p50=${p50.toFixed(2)}ms p99=${p99.toFixed(2)}ms (${runs} runs)`);');
    lines.push('}');
    lines.push('');
    lines.push('(async () => {');

    for (const block of benchBlocks) {
      const name = block.name || 'Benchmark';
      lines.push(`  console.log("── ${name.replace(/"/g, '\\"')} ──");`);
      for (const stmt of block.body) {
        if (stmt.type === 'FunctionDeclaration') {
          const fnName = stmt.name;
          const displayName = fnName.replace(/_/g, ' ');
          this.pushScope();
          for (const p of (stmt.params || [])) {
            const pName = typeof p === 'string' ? p : (p.name || p.identifier);
            if (pName) this.declareVar(pName);
          }
          const body = this.genBlockBody(stmt.body);
          this.popScope();
          lines.push(`  await __runBench(${JSON.stringify(displayName)}, async () => {`);
          lines.push(body);
          lines.push('  });');
        } else {
          lines.push('  ' + this.generateStatement(stmt));
        }
      }
      lines.push('');
    }

    lines.push('})();');
    return lines.join('\n');
  }

  _getAiRuntime() {
    return `// AI Client Runtime
function __createAI(config) {
  const providerName = config.provider || 'custom';
  async function __aiRequest(method, args, callOpts = {}) {
    const cfg = { ...config, ...callOpts };
    const baseUrl = cfg.base_url || (providerName === 'anthropic' ? 'https://api.anthropic.com' : providerName === 'ollama' ? 'http://localhost:11434' : 'https://api.openai.com');
    const headers = { 'Content-Type': 'application/json', ...(cfg.headers || {}) };
    if (providerName === 'anthropic') {
      headers['x-api-key'] = cfg.api_key;
      headers['anthropic-version'] = '2023-06-01';
    } else if (cfg.api_key) {
      headers['Authorization'] = 'Bearer ' + cfg.api_key;
    }
    const timeout = cfg.timeout || 60000;

    if (method === 'ask') {
      const [prompt, opts] = args;
      let body, url;
      if (providerName === 'anthropic') {
        body = { model: cfg.model, max_tokens: opts?.max_tokens || cfg.max_tokens || 4096, messages: [{ role: 'user', content: prompt }] };
        if (opts?.temperature ?? cfg.temperature) body.temperature = opts?.temperature ?? cfg.temperature;
        if (opts?.tools) body.tools = opts.tools.map(t => ({ name: t.name, description: t.description, input_schema: { type: 'object', properties: t.params ? Object.fromEntries(Object.entries(t.params).map(([k, v]) => [k, { type: typeof v === 'string' ? v.toLowerCase() : 'string' }])) : {} } }));
        url = baseUrl + '/v1/messages';
      } else if (providerName === 'ollama') {
        body = { model: cfg.model, messages: [{ role: 'user', content: prompt }], stream: false };
        url = baseUrl + '/api/chat';
      } else {
        body = { model: cfg.model, messages: [{ role: 'user', content: prompt }] };
        if (opts?.max_tokens || cfg.max_tokens) body.max_tokens = opts?.max_tokens || cfg.max_tokens;
        if (opts?.temperature ?? cfg.temperature) body.temperature = opts?.temperature ?? cfg.temperature;
        if (opts?.tools) body.tools = opts.tools.map(t => ({ type: 'function', function: { name: t.name, description: t.description, parameters: { type: 'object', properties: t.params ? Object.fromEntries(Object.entries(t.params).map(([k, v]) => [k, { type: typeof v === 'string' ? v.toLowerCase() : 'string' }])) : {} } } }));
        url = baseUrl + '/v1/chat/completions';
      }
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: AbortSignal.timeout(timeout) });
      if (!res.ok) throw new Error(providerName + ' API error ' + res.status + ': ' + (await res.text()));
      const data = await res.json();
      if (providerName === 'anthropic') {
        if (opts?.tools && data.content?.some(c => c.type === 'tool_use')) return { text: data.content.filter(c => c.type === 'text').map(c => c.text).join(''), tool_calls: data.content.filter(c => c.type === 'tool_use') };
        return data.content.map(c => c.text).join('');
      }
      if (providerName === 'ollama') return data.message.content;
      const choice = data.choices[0];
      if (opts?.tools && choice.message.tool_calls) return { text: choice.message.content || '', tool_calls: choice.message.tool_calls };
      return choice.message.content;
    }

    if (method === 'chat') {
      const [messages, opts] = args;
      let body, url;
      if (providerName === 'anthropic') {
        const sys = messages.filter(m => m.role === 'system');
        const msgs = messages.filter(m => m.role !== 'system');
        body = { model: cfg.model, max_tokens: opts?.max_tokens || cfg.max_tokens || 4096, messages: msgs };
        if (sys.length > 0) body.system = sys.map(m => m.content).join('\\n');
        url = baseUrl + '/v1/messages';
      } else if (providerName === 'ollama') {
        body = { model: cfg.model, messages, stream: false };
        url = baseUrl + '/api/chat';
      } else {
        body = { model: cfg.model, messages };
        if (opts?.max_tokens || cfg.max_tokens) body.max_tokens = opts?.max_tokens || cfg.max_tokens;
        url = baseUrl + '/v1/chat/completions';
      }
      if (opts?.temperature ?? cfg.temperature) body.temperature = opts?.temperature ?? cfg.temperature;
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: AbortSignal.timeout(timeout) });
      if (!res.ok) throw new Error(providerName + ' API error ' + res.status + ': ' + (await res.text()));
      const data = await res.json();
      if (providerName === 'anthropic') return data.content.map(c => c.text).join('');
      if (providerName === 'ollama') return data.message.content;
      return data.choices[0].message.content;
    }

    if (method === 'embed') {
      const [input, opts] = args;
      let body, url;
      if (providerName === 'ollama') {
        url = baseUrl + '/api/embeddings';
        if (Array.isArray(input)) {
          const results = [];
          for (const text of input) {
            const r = await fetch(url, { method: 'POST', headers, body: JSON.stringify({ model: cfg.model, prompt: text }) });
            results.push((await r.json()).embedding);
          }
          return results;
        }
        body = { model: cfg.model, prompt: input };
      } else {
        body = { model: cfg.model || 'text-embedding-3-small', input };
        url = baseUrl + '/v1/embeddings';
      }
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: AbortSignal.timeout(timeout) });
      if (!res.ok) throw new Error(providerName + ' API error ' + res.status + ': ' + (await res.text()));
      const data = await res.json();
      if (providerName === 'ollama') return data.embedding;
      if (Array.isArray(input)) return data.data.map(d => d.embedding);
      return data.data[0].embedding;
    }

    if (method === 'extract') {
      const [prompt, schema, opts] = args;
      const extractPrompt = prompt + '\\n\\nRespond with a JSON object matching this schema: ' + JSON.stringify(schema);
      const text = await __aiRequest('ask', [extractPrompt, opts]);
      try { return JSON.parse(text); } catch { return JSON.parse(text.match(/\\{[\\s\\S]*\\}/)?.[0] || '{}'); }
    }

    if (method === 'classify') {
      const [text, categories, opts] = args;
      const catList = Array.isArray(categories) ? categories : Object.keys(categories);
      const classifyPrompt = 'Classify into one of: ' + catList.join(', ') + '\\n\\nText: "' + text + '"\\n\\nRespond with only the category name.';
      const result = (await __aiRequest('ask', [classifyPrompt, { ...opts, max_tokens: 100 }])).trim();
      return catList.find(c => c.toLowerCase() === result.toLowerCase()) || result;
    }

    throw new Error('Unknown AI method: ' + method);
  }

  return {
    ask(prompt, opts) { return __aiRequest('ask', [prompt, opts || {}], opts); },
    chat(messages, opts) { return __aiRequest('chat', [messages, opts || {}], opts); },
    embed(input, opts) { return __aiRequest('embed', [input, opts || {}], opts); },
    extract(prompt, schema, opts) { return __aiRequest('extract', [prompt, schema, opts || {}], opts); },
    classify(text, categories, opts) { return __aiRequest('classify', [text, categories, opts || {}], opts); },
  };
}
`;
  }
}

// ─── src/codegen/browser-codegen.js ────────────────────

class BrowserCodegen extends BaseCodegen {
  constructor() {
    super();
    this.stateNames = new Set(); // Track state variable names for setter transforms
    this.computedNames = new Set(); // Track computed variable names for getter transforms
    this.componentNames = new Set(); // Track component names for JSX
    this.storeNames = new Set(); // Track store names
    this.formNames = new Set(); // Track form names
    this._asyncContext = false; // When true, server.xxx() calls emit `await`
    this._rpcCache = new WeakMap(); // Memoize _containsRPC() results
    this._signalCache = new WeakMap(); // Memoize _exprReadsSignal() results
  }

  // AST-walk to check if a subtree contains server.xxx() RPC calls (memoized)
  _containsRPC(node) {
    if (!node) return false;
    const cached = this._rpcCache.get(node);
    if (cached !== undefined) return cached;
    const result = this._containsRPCImpl(node);
    this._rpcCache.set(node, result);
    return result;
  }

  _containsRPCImpl(node) {
    if (node.type === 'CallExpression' && this._isRPCCall(node)) return true;
    if (node.type === 'BlockStatement') return node.body.some(s => this._containsRPC(s));
    if (node.type === 'ExpressionStatement') return this._containsRPC(node.expression);
    if (node.type === 'Assignment') return node.values.some(v => this._containsRPC(v));
    if (node.type === 'VarDeclaration') return node.values.some(v => this._containsRPC(v));
    if (node.type === 'ReturnStatement') return this._containsRPC(node.value);
    if (node.type === 'IfStatement') {
      return this._containsRPC(node.condition) || this._containsRPC(node.consequent) ||
        node.alternates.some(a => this._containsRPC(a.body)) ||
        this._containsRPC(node.elseBody);
    }
    if (node.type === 'IfExpression') {
      return this._containsRPC(node.condition) || this._containsRPC(node.consequent) ||
        (node.alternates && node.alternates.some(a => this._containsRPC(a.condition) || this._containsRPC(a.body))) ||
        this._containsRPC(node.elseBody);
    }
    if (node.type === 'ForStatement') return this._containsRPC(node.iterable) || this._containsRPC(node.body);
    if (node.type === 'WhileStatement') return this._containsRPC(node.condition) || this._containsRPC(node.body);
    if (node.type === 'CallExpression') {
      return this._containsRPC(node.callee) || node.arguments.some(a => this._containsRPC(a));
    }
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
      return this._containsRPC(node.left) || this._containsRPC(node.right);
    }
    if (node.type === 'MemberExpression') return this._containsRPC(node.object);
    if (node.type === 'CompoundAssignment') return this._containsRPC(node.value);
    if (node.type === 'LambdaExpression') return this._containsRPC(node.body);
    if (node.type === 'NamedArgument') return this._containsRPC(node.value);
    if (node.type === 'MatchExpression') {
      return this._containsRPC(node.subject) || node.arms.some(a => this._containsRPC(a.body));
    }
    if (node.type === 'TryCatchStatement') {
      return (node.tryBody && node.tryBody.some(s => this._containsRPC(s))) ||
        (node.catchBody && node.catchBody.some(s => this._containsRPC(s))) ||
        (node.finallyBody && node.finallyBody.some(s => this._containsRPC(s)));
    }
    if (node.type === 'PipeExpression') {
      return this._containsRPC(node.left) || this._containsRPC(node.right);
    }
    if (node.type === 'GuardStatement') {
      return this._containsRPC(node.condition) || this._containsRPC(node.elseBody);
    }
    if (node.type === 'LetDestructure') return this._containsRPC(node.value);
    if (node.type === 'ArrayLiteral') return node.elements.some(e => this._containsRPC(e));
    if (node.type === 'ObjectLiteral') return node.properties.some(p => this._containsRPC(p.value));
    if (node.type === 'SpreadExpression') return this._containsRPC(node.argument);
    if (node.type === 'AwaitExpression') return this._containsRPC(node.argument);
    if (node.type === 'PropagateExpression') return this._containsRPC(node.expression);
    if (node.type === 'UnaryExpression') return this._containsRPC(node.operand);
    if (node.type === 'TemplateLiteral') return node.parts.some(p => p.type === 'expr' && this._containsRPC(p.value));
    if (node.type === 'ChainedComparison') return node.operands.some(o => this._containsRPC(o));
    if (node.type === 'RangeExpression') return this._containsRPC(node.start) || this._containsRPC(node.end);
    if (node.type === 'SliceExpression') return this._containsRPC(node.object) || this._containsRPC(node.start) || this._containsRPC(node.end) || this._containsRPC(node.step);
    if (node.type === 'ListComprehension') return this._containsRPC(node.iterable) || this._containsRPC(node.expression) || this._containsRPC(node.condition);
    if (node.type === 'DictComprehension') return this._containsRPC(node.iterable) || this._containsRPC(node.key) || this._containsRPC(node.value) || this._containsRPC(node.condition);
    if (node.type === 'DeferStatement') return this._containsRPC(node.body);
    return false;
  }

  _isRPCCall(node) {
    return node.type === 'CallExpression' &&
      node.callee.type === 'MemberExpression' &&
      node.callee.object.type === 'Identifier' &&
      node.callee.object.name === 'server';
  }

  // Override genCallExpression to add await for server.xxx() in async context
  genCallExpression(node) {
    const isRPC = this._isRPCCall(node);
    const base = super.genCallExpression(node);
    if (isRPC && this._asyncContext) {
      return `await ${base}`;
    }
    return base;
  }

  // Override to add () for signal/computed reads
  genExpression(node) {
    if (node && node.type === 'Identifier' &&
        (this.stateNames.has(node.name) || this.computedNames.has(node.name))) {
      return `${node.name}()`;
    }
    return super.genExpression(node);
  }

  // Override to transform state assignments to setter calls
  generateStatement(node) {
    if (!node) return '';

    // Intercept compound assignments to state variables: count += 1 → setCount(prev => prev + 1)
    if (node.type === 'CompoundAssignment' && node.target.type === 'Identifier' && this.stateNames.has(node.target.name)) {
      const name = node.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.operator[0]; // += → +, -= → -, etc.
      const val = this.genExpression(node.value);
      return `${this.i()}${setter}(__tova_p => __tova_p ${op} ${val});`;
    }

    // Intercept assignments to state variables: count = 0 → setCount(0)
    if (node.type === 'Assignment' && node.targets.length === 1 && this.stateNames.has(node.targets[0])) {
      const name = node.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.values[0]);
      return `${this.i()}${setter}(${val});`;
    }

    return super.generateStatement(node);
  }

  // Override lambda expression to handle state mutations in lambda bodies
  genLambdaExpression(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const asyncPrefix = node.isAsync ? 'async ' : '';

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      const body = this.genBlockBody(node.body);
      this.popScope();
      if (hasPropagate) {
        return `${asyncPrefix}(${params}) => {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
      }
      return `${asyncPrefix}(${params}) => {\n${body}\n${this.i()}}`;
    }

    // Compound assignment in lambda body: fn() count += 1
    if (node.body.type === 'CompoundAssignment' && node.body.target.type === 'Identifier' && this.stateNames.has(node.body.target.name)) {
      const name = node.body.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.body.operator[0];
      const val = this.genExpression(node.body.value);
      return `${asyncPrefix}(${params}) => { ${setter}(__tova_p => __tova_p ${op} ${val}); }`;
    }

    // Assignment in lambda body: fn() count = 0
    if (node.body.type === 'Assignment' && node.body.targets.length === 1 && this.stateNames.has(node.body.targets[0])) {
      const name = node.body.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.body.values[0]);
      return `${asyncPrefix}(${params}) => { ${setter}(${val}); }`;
    }

    // Non-state statement bodies
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      this.indent++;
      const stmt = super.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `${asyncPrefix}(${params}) => { ${stmt.trim()} }`;
    }

    if (hasPropagate) {
      return `${asyncPrefix}(${params}) => { try { return ${this.genExpression(node.body)}; } catch (__e) { if (__e && __e.__tova_propagate) return __e.value; throw __e; } }`;
    }
    return `${asyncPrefix}(${params}) => ${this.genExpression(node.body)}`;
  }

  generate(browserBlocks, sharedCode, sharedBuiltins = null, securityConfig = null, typeValidatorsMap = null) {
    this._sharedBuiltins = sharedBuiltins || new Set();
    this._typeValidators = typeValidatorsMap || {};
    const lines = [];

    // Runtime imports
    lines.push(`import { createSignal, createEffect, createComputed, mount, hydrate, tova_el, tova_fragment, tova_keyed, tova_transition, tova_inject_css, batch, onMount, onUnmount, onCleanup, onBeforeUpdate, createRef, createContext, provide, inject, createErrorBoundary, ErrorBoundary, ErrorInfo, createRoot, watch, untrack, Dynamic, Portal, lazy, Suspense, Head, createResource, __tova_action, TransitionGroup, createForm, configureCSP } from './runtime/reactivity.js';`);
    lines.push(`import { rpc, configureRPC, addRPCInterceptor, setCSRFToken } from './runtime/rpc.js';`);
    lines.push(`import { navigate, getCurrentRoute, getParams, getPath, getQuery, defineRoutes, onRouteChange, beforeNavigate, afterNavigate, Router, Outlet, Link, Redirect } from './runtime/router.js';`);

    // Hoist import lines from shared code to the top of the module
    let sharedRest = sharedCode;
    if (sharedCode.trim()) {
      const sharedLines = sharedCode.split('\n');
      const importLines = [];
      const nonImportLines = [];
      for (const line of sharedLines) {
        if (/^\s*import\s+/.test(line)) {
          importLines.push(line);
        } else {
          nonImportLines.push(line);
        }
      }
      if (importLines.length > 0) {
        for (const imp of importLines) {
          lines.push(imp);
        }
      }
      sharedRest = nonImportLines.join('\n');
    }

    lines.push('');

    // Shared code (non-import lines)
    if (sharedRest.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedRest);
      lines.push('');
    }

    // Stdlib placeholder — filled after all client code is generated so tree-shaking sees all usages
    const stdlibPlaceholderIdx = lines.length;
    lines.push('// ── Stdlib ──');
    lines.push('__STDLIB_PLACEHOLDER__');
    lines.push('');

    // Server RPC proxy
    lines.push('// ── Server RPC Proxy ──');
    lines.push('const server = new Proxy({}, {');
    lines.push('  get(_, name) {');
    lines.push('    return (...args) => rpc(name, args);');
    lines.push('  }');
    lines.push('});');
    lines.push('');

    // Security block: auth token injection and role helpers
    if (securityConfig) {
      const secGen = new SecurityCodegen();
      const clientSecurity = secGen.generateBrowserSecurity(securityConfig);
      if (clientSecurity.trim()) {
        lines.push(clientSecurity);
        lines.push('');
      }
    }

    const states = [];
    const computeds = [];
    const effects = [];
    const components = [];
    const stores = [];
    const forms = [];
    const imports = [];
    const other = [];

    for (const block of browserBlocks) {
      for (const stmt of block.body) {
        switch (stmt.type) {
          case 'StateDeclaration': states.push(stmt); break;
          case 'ComputedDeclaration': computeds.push(stmt); break;
          case 'EffectDeclaration': effects.push(stmt); break;
          case 'ComponentDeclaration': components.push(stmt); break;
          case 'StoreDeclaration': stores.push(stmt); break;
          case 'FormDeclaration': forms.push(stmt); break;
          case 'ImportDeclaration': imports.push(stmt); break;
          case 'ImportDefault': imports.push(stmt); break;
          case 'ImportWildcard': imports.push(stmt); break;
          default: other.push(stmt); break;
        }
      }
    }

    // Generate client block imports (hoisted after runtime imports)
    if (imports.length > 0) {
      lines.push('// ── Client Imports ──');
      for (const stmt of imports) {
        lines.push(this.generateStatement(stmt));
      }
      lines.push('');
    }

    // Register state names for setter transforms
    for (const s of states) {
      this.stateNames.add(s.name);
    }

    // Register computed names for getter transforms
    for (const c of computeds) {
      this.computedNames.add(c.name);
    }

    // Register component names
    for (const comp of components) {
      this.componentNames.add(comp.name);
    }

    // Register store names
    for (const store of stores) {
      this.storeNames.add(store.name);
    }

    // Register form names
    for (const form of forms) {
      this.formNames.add(form.name);
    }

    // Generate state signals
    if (states.length > 0) {
      lines.push('// ── Reactive State ──');
      for (const s of states) {
        const init = this.genExpression(s.initialValue);
        lines.push(`const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});`);
      }
      lines.push('');
    }

    // Generate computed values
    if (computeds.length > 0) {
      lines.push('// ── Computed Values ──');
      for (const c of computeds) {
        const expr = this.genExpression(c.expression);
        lines.push(`const ${c.name} = createComputed(() => ${expr});`);
      }
      lines.push('');
    }

    // Generate stores
    if (stores.length > 0) {
      lines.push('// ── Stores ──');
      for (const store of stores) {
        lines.push(this.generateStore(store));
        lines.push('');
      }
    }

    // Generate forms
    if (forms.length > 0) {
      lines.push('// ── Forms ──');
      for (const form of forms) {
        lines.push(this.generateForm(form));
        lines.push('');
      }
    }

    // Generate other statements
    for (const stmt of other) {
      lines.push(this.generateStatement(stmt));
    }

    // Generate components
    if (components.length > 0) {
      lines.push('// ── Components ──');
      for (const comp of components) {
        lines.push(this.generateComponent(comp));
        lines.push('');
      }
    }

    // Generate effects
    if (effects.length > 0) {
      lines.push('// ── Effects ──');
      for (const e of effects) {
        lines.push(this._generateEffect(e.body));
        lines.push('');
      }
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push('// ── Runtime Helpers ──');
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // Auto-mount the App component if it exists
    // Auto-detect SSR: if the container already has children, hydrate instead of mount
    const hasApp = components.some(c => c.name === 'App');
    if (hasApp) {
      lines.push('// ── Mount ──');
      lines.push('document.addEventListener("DOMContentLoaded", () => {');
      lines.push('  const container = document.getElementById("app") || document.body;');
      lines.push('  if (container.children.length > 0) {');
      lines.push('    hydrate(App, container);');
      lines.push('  } else {');
      lines.push('    mount(App, container);');
      lines.push('  }');
      lines.push('});');
    }

    // Replace stdlib placeholder now that all client code has been generated
    lines[stdlibPlaceholderIdx + 1] = this.getStdlibCore();

    return lines.join('\n');
  }

  _generateEffect(body) {
    const hasRPC = this._containsRPC(body);
    const p = [];
    if (hasRPC) {
      p.push(`createEffect(() => {\n`);
      p.push(`${this.i()}  (async () => {\n`);
      this.indent += 2;
      const prevAsync = this._asyncContext;
      this._asyncContext = true;
      p.push(this.genBlockStatements(body));
      this._asyncContext = prevAsync;
      this.indent -= 2;
      p.push(`\n${this.i()}  })();\n`);
      p.push(`${this.i()}});`);
    } else {
      p.push(`createEffect(() => {\n`);
      this.indent++;
      p.push(this.genBlockStatements(body));
      this.indent--;
      p.push(`\n${this.i()}});`);
    }
    return p.join('');
  }

  // Generate a scope hash from component name + CSS content (for CSS scoping)
  // Uses FNV-1a for better distribution and 8-char output to reduce collision risk.
  _genScopeId(name, css) {
    const str = name + ':' + (css || '');
    let h = 0x811c9dc5; // FNV offset basis
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 0x01000193); // FNV prime
    }
    return (h >>> 0).toString(36).padStart(8, '0').slice(0, 8);
  }

  // Scope CSS selectors by appending [data-tova-HASH] to each selector
  // Uses a lightweight tokenizer to properly handle:
  // - @media, @keyframes, @layer blocks (don't scope their content selectors)
  // - :is(), :where(), :has() pseudo-functions
  // - :global() escape hatch (strip wrapper, don't scope)
  // - CSS comments /* */
  // - Nested CSS
  // - Multiple rules in sequence
  _scopeCSS(css, scopeAttr) {
    const result = [];
    let i = 0;
    let depth = 0;
    let buf = '';
    const noScopeDepths = new Set(); // Depths where we DON'T scope (property decls, @keyframes, @font-face)

    while (i < css.length) {
      // Skip CSS comments
      if (css[i] === '/' && css[i + 1] === '*') {
        const end = css.indexOf('*/', i + 2);
        if (end === -1) { buf += css.slice(i); break; }
        buf += css.slice(i, end + 2);
        i = end + 2;
        continue;
      }

      // Skip quoted strings
      if (css[i] === '"' || css[i] === "'") {
        const q = css[i];
        buf += css[i++];
        while (i < css.length && css[i] !== q) {
          if (css[i] === '\\') buf += css[i++];
          buf += css[i++];
        }
        if (i < css.length) buf += css[i++];
        continue;
      }

      // Opening brace — process accumulated buf as selector or pass through
      if (css[i] === '{') {
        const trimmed = buf.trim();

        if (noScopeDepths.has(depth)) {
          // Inside a no-scope context (property declarations, @keyframes) — pass through
          result.push(buf + '{');
        } else if (trimmed.startsWith('@')) {
          // @keyframes, @font-face: mark inner as no-scope
          if (/^@keyframes\s/.test(trimmed) || /^@font-face/.test(trimmed)) {
            noScopeDepths.add(depth + 1);
          }
          // @media, @supports, @layer: keep scoping inside (don't mark)
          result.push(buf + '{');
        } else {
          // Regular selector — scope it and mark inner depth as no-scope (property declarations)
          const scopedSelectors = buf.split(',').map(s => {
            s = s.trim();
            if (!s || s === 'from' || s === 'to' || /^\d+%$/.test(s)) return s;
            return this._scopeSelector(s, scopeAttr);
          }).join(', ');
          result.push(scopedSelectors + '{');
          noScopeDepths.add(depth + 1);
        }

        depth++;
        buf = '';
        i++;
        continue;
      }

      // Closing brace
      if (css[i] === '}') {
        result.push(buf + '}');
        buf = '';
        noScopeDepths.delete(depth);
        depth--;
        i++;
        continue;
      }

      // Accumulate character
      buf += css[i];
      i++;
    }

    if (buf) result.push(buf);
    return result.join('');
  }

  // Scope a single CSS selector
  _scopeSelector(selector, scopeAttr) {
    let s = selector.trim();

    // :global() escape hatch — strip wrapper, don't scope
    if (s.startsWith(':global(') && s.endsWith(')')) {
      return s.slice(8, -1);
    }
    // Inline :global() in the middle of a selector
    s = s.replace(/:global\(([^)]+)\)/g, '$1');

    // Handle pseudo-elements (::before, ::after, ::placeholder, etc.)
    const pseudoElMatch = s.match(/(::[\w-]+(?:\([^)]*\))?)$/);
    if (pseudoElMatch) {
      return s.slice(0, -pseudoElMatch[0].length) + scopeAttr + pseudoElMatch[0];
    }
    // Handle pseudo-classes with functions (:is(), :where(), :has(), :not(), :hover, etc.)
    const pseudoClsMatch = s.match(/((?::[\w-]+(?:\([^)]*\))?)+)$/);
    if (pseudoClsMatch) {
      const pseudoPart = pseudoClsMatch[0];
      const basePart = s.slice(0, -pseudoPart.length);
      if (basePart.trim()) {
        return basePart + scopeAttr + pseudoPart;
      }
    }
    return s + scopeAttr;
  }

  generateComponent(comp) {
    const hasParams = comp.params.length > 0;
    const paramStr = hasParams ? '__props' : '';

    // Save state/computed names so component-local names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);

    const p = [];
    p.push(`function ${comp.name}(${paramStr}) {\n`);
    this.indent++;

    // Generate reactive prop accessors — each prop is accessed through __props getter
    // This ensures parent signal changes propagate reactively to the child
    if (hasParams) {
      for (const param of comp.params) {
        this.computedNames.add(param.name);
        const def = param.default || param.defaultValue;
        if (def) {
          const defaultExpr = this.genExpression(def);
          p.push(`${this.i()}const ${param.name} = () => __props.${param.name} !== undefined ? __props.${param.name} : ${defaultExpr};\n`);
        } else {
          p.push(`${this.i()}const ${param.name} = () => __props.${param.name};\n`);
        }
      }
    }

    // Separate JSX elements, style blocks, and statements
    const jsxElements = [];
    const styleBlocks = [];
    const bodyItems = [];

    for (const node of comp.body) {
      if (node.type === 'JSXElement' || node.type === 'JSXFragment' || node.type === 'JSXFor' || node.type === 'JSXIf') {
        jsxElements.push(node);
      } else if (node.type === 'ComponentStyleBlock') {
        styleBlocks.push(node);
      } else {
        bodyItems.push(node);
      }
    }

    // Set up scoped CSS if style blocks exist
    const savedScopeId = this._currentScopeId;
    if (styleBlocks.length > 0) {
      const rawCSS = styleBlocks.map(s => s.css).join('\n');
      const scopeId = this._genScopeId(comp.name, rawCSS);
      this._currentScopeId = scopeId;
      const scopedCSS = this._scopeCSS(rawCSS, `[data-tova-${scopeId}]`);
      p.push(`${this.i()}tova_inject_css(${JSON.stringify(scopeId)}, ${JSON.stringify(scopedCSS)});\n`);
    }

    // Generate body items in order (state, computed, effect, other statements)
    for (const node of bodyItems) {
      if (node.type === 'StateDeclaration') {
        this.stateNames.add(node.name);
        const init = this.genExpression(node.initialValue);
        p.push(`${this.i()}const [${node.name}, set${capitalize(node.name)}] = createSignal(${init});\n`);
      } else if (node.type === 'ComputedDeclaration') {
        this.computedNames.add(node.name);
        const expr = this.genExpression(node.expression);
        p.push(`${this.i()}const ${node.name} = createComputed(() => ${expr});\n`);
      } else if (node.type === 'EffectDeclaration') {
        this.indent++;
        const effectCode = this._generateEffect(node.body);
        this.indent--;
        p.push(`${this.i()}${effectCode}\n`);
      } else if (node.type === 'FormDeclaration') {
        this.formNames.add(node.name);
        p.push(`${this.i()}${this.generateForm(node)}\n`);
      } else if (node.type === 'StoreDeclaration') {
        this.storeNames.add(node.name);
        p.push(`${this.i()}${this.generateStore(node)}\n`);
      } else {
        p.push(this.generateStatement(node) + '\n');
      }
    }

    // Generate JSX return
    if (jsxElements.length === 1) {
      p.push(`${this.i()}return ${this.genJSX(jsxElements[0])};\n`);
    } else if (jsxElements.length > 1) {
      const children = jsxElements.map(el => this.genJSX(el)).join(', ');
      p.push(`${this.i()}return tova_fragment([${children}]);\n`);
    }

    this.indent--;
    p.push(`}`);

    // Restore scoped names and scope id
    this.stateNames = savedState;
    this.computedNames = savedComputed;
    this._currentScopeId = savedScopeId;

    return p.join('');
  }

  generateStore(store) {
    // Save/restore state and computed names so store-internal names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);

    // Collect store-local state and computed names
    const storeStates = [];
    const storeComputeds = [];
    const storeFunctions = [];

    for (const node of store.body) {
      if (node.type === 'StateDeclaration') {
        storeStates.push(node);
        this.stateNames.add(node.name);
      } else if (node.type === 'ComputedDeclaration') {
        storeComputeds.push(node);
        this.computedNames.add(node.name);
      } else if (node.type === 'FunctionDeclaration') {
        storeFunctions.push(node);
      }
    }

    const p = [];
    p.push(`const ${store.name} = (() => {\n`);
    this.indent++;

    // Generate state signals
    for (const s of storeStates) {
      const init = this.genExpression(s.initialValue);
      p.push(`${this.i()}const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});\n`);
    }

    // Generate computed values
    for (const c of storeComputeds) {
      const expr = this.genExpression(c.expression);
      p.push(`${this.i()}const ${c.name} = createComputed(() => ${expr});\n`);
    }

    // Generate functions
    for (const fn of storeFunctions) {
      p.push(this.genFunctionDeclaration(fn) + '\n');
    }

    // Build return object with getters/setters
    p.push(`${this.i()}return {\n`);
    this.indent++;

    for (const s of storeStates) {
      p.push(`${this.i()}get ${s.name}() { return ${s.name}(); },\n`);
      p.push(`${this.i()}set ${s.name}(v) { set${capitalize(s.name)}(v); },\n`);
    }

    for (const c of storeComputeds) {
      p.push(`${this.i()}get ${c.name}() { return ${c.name}(); },\n`);
    }

    for (const fn of storeFunctions) {
      p.push(`${this.i()}${fn.name},\n`);
    }

    this.indent--;
    p.push(`${this.i()}};\n`);

    this.indent--;
    p.push(`${this.i()}})();`);

    // Restore state/computed names
    this.stateNames = savedState;
    this.computedNames = savedComputed;

    return p.join('');
  }

  generateForm(form) {
    // Save/restore state and computed names so form-internal names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);
    const savedFormNames = new Set(this.formNames);

    const genExpr = (node) => this.genExpression(node);
    const fields = form.fields || [];
    const groups = form.groups || [];
    const arrays = form.arrays || [];
    const fieldNames = fields.map(f => f.name);

    // Build merged validators map: field name -> validators array
    // If form has a type annotation, inherit validators from the type definition.
    // Form-level validators override type-level for the same validator name;
    // additional type validators (with different names) are appended.
    const mergedValidatorsMap = {};
    for (const field of fields) {
      mergedValidatorsMap[field.name] = [...(field.validators || [])];
    }
    if (form.typeAnnotation && this._typeValidators) {
      const typeName = form.typeAnnotation.name;
      const typeInfo = this._typeValidators[typeName];
      if (typeInfo) {
        for (const typeField of typeInfo.fields) {
          if (mergedValidatorsMap[typeField.name] !== undefined) {
            const existingNames = new Set(mergedValidatorsMap[typeField.name].map(v => v.name));
            for (const tv of typeField.validators) {
              if (!existingNames.has(tv.name)) {
                mergedValidatorsMap[typeField.name].push(tv);
              }
            }
          }
        }
      }
    }

    const p = [];
    p.push(`const ${form.name} = (() => {\n`);
    this.indent++;

    // Field signals (top-level fields)
    for (const field of fields) {
      const init = field.initialValue ? this.genExpression(field.initialValue) : 'null';
      p.push(generateFieldSignals(field.name, init, this.i()));
    }
    if (fields.length > 0) p.push('\n');

    // Validator functions (top-level fields) — use merged validators
    for (const field of fields) {
      p.push(generateValidatorFn(field.name, mergedValidatorsMap[field.name] || [], genExpr, this.i()));
    }
    if (fields.length > 0) p.push('\n');

    // Field accessors (top-level fields)
    for (const field of fields) {
      p.push(generateFieldAccessor(field.name, this.i()));
    }
    if (fields.length > 0) p.push('\n');

    // Generate groups (signals, validators, accessors, group accessors)
    const allGroupPrefixedNames = []; // Collects ALL prefixed field names from groups
    const conditionalGroups = []; // Tracks conditional groups for form-level isValid
    const groupNames = [];
    const formFieldNameSet = new Set(fieldNames); // For condition expression resolution
    for (const group of groups) {
      p.push(generateGroupCode(group, '', genExpr, this.i(), allGroupPrefixedNames, null, conditionalGroups, formFieldNameSet));
      p.push('\n');
      groupNames.push(group.name);
    }

    // Generate arrays (signal-backed item lists)
    const arrayNames = [];
    for (const arr of arrays) {
      p.push(generateArrayCode(arr, genExpr, this.i()));
      p.push('\n');
      arrayNames.push({ name: arr.name, fields: (arr.fields || []).map(f => f.name) });
    }

    // Cross-field re-validation effects (e.g., matches() validator) — use merged validators
    for (const field of fields) {
      const validators = mergedValidatorsMap[field.name] || [];
      for (const v of validators) {
        if (v.name === 'matches') {
          const sourceField = v.args[0] && (v.args[0].name || v.args[0]);
          const depField = field.name;
          if (sourceField) {
            p.push(`${this.i()}createEffect(() => {\n`);
            p.push(`${this.i()}  __${sourceField}_value();\n`);
            p.push(`${this.i()}  if (__${depField}_touched()) {\n`);
            p.push(`${this.i()}    const e = __validate_${depField}(__${depField}_value());\n`);
            p.push(`${this.i()}    __set_${depField}_error(e);\n`);
            p.push(`${this.i()}  }\n`);
            p.push(`${this.i()}});\n`);
          }
        }
      }
    }

    // Async validator effects (debounced, versioned) — use merged validators
    for (const field of fields) {
      const validators = mergedValidatorsMap[field.name] || [];
      for (const v of validators) {
        if (v.isAsync && v.name === 'validate') {
          p.push(generateAsyncValidatorEffect(
            field.name, v, (expr) => this.genExpression(expr), this.i()
          ));
          p.push('\n');
        }
      }
    }

    // Form-level signals — include both top-level fields and group-prefixed fields
    const allFieldNamesForValid = [...fieldNames, ...allGroupPrefixedNames];
    const isValidParts = allFieldNamesForValid.map(n => `__${n}_error() === null`);
    // Include array items in isValid: every item in every array must be valid
    const arrayIsValidParts = arrayNames.map(a => `__${a.name}().every(i => i.isValid)`);
    const allIsValidParts = [...isValidParts, ...arrayIsValidParts];
    const isValidExpr = allIsValidParts.length > 0 ? allIsValidParts.join(' && ') : 'true';
    p.push(`${this.i()}const isValid = createComputed(() => ${isValidExpr});\n`);

    const isDirtyParts = allFieldNamesForValid.map(n => `__${n}_value() !== __${n}_initial`);
    // Include arrays in isDirty: any items added = dirty
    const arrayIsDirtyParts = arrayNames.map(a => `__${a.name}().length > 0`);
    const allIsDirtyParts = [...isDirtyParts, ...arrayIsDirtyParts];
    const isDirtyExpr = allIsDirtyParts.length > 0 ? allIsDirtyParts.join(' || ') : 'false';
    p.push(`${this.i()}const isDirty = createComputed(() => ${isDirtyExpr});\n`);

    p.push(`${this.i()}const [__submitting, __set_submitting] = createSignal(false);\n`);
    p.push(`${this.i()}const [__submitError, __set_submitError] = createSignal(null);\n`);
    p.push(`${this.i()}const [__submitCount, __set_submitCount] = createSignal(0);\n`);
    p.push('\n');

    // Wizard steps (only when form has steps block)
    const hasSteps = form.steps && form.steps.steps && form.steps.steps.length > 0;
    if (hasSteps) {
      const fieldNameSet = new Set(fieldNames);
      const groupNameSet = new Set(groupNames);
      const arrayNameSet = new Set(arrayNames.map(a => a.name));

      p.push(`${this.i()}const [__currentStep, __set_currentStep] = createSignal(0);\n`);
      p.push(`${this.i()}const __steps = [\n`);
      this.indent++;
      for (const step of form.steps.steps) {
        const validateParts = step.members.map(member => {
          if (fieldNameSet.has(member)) return `${member}.validate()`;
          if (groupNameSet.has(member)) return `${member}.isValid`;
          if (arrayNameSet.has(member)) return `${member}.items.every(i => i.isValid)`;
          // Default to field validate
          return `${member}.validate()`;
        });
        const validateExpr = validateParts.length === 1
          ? validateParts[0]
          : validateParts.join(' && ');
        p.push(`${this.i()}{ label: ${JSON.stringify(step.label)}, validate: () => ${validateExpr} },\n`);
      }
      this.indent--;
      p.push(`${this.i()}];\n`);

      p.push(`${this.i()}const canNext = createComputed(() => {\n`);
      this.indent++;
      p.push(`${this.i()}const step = __steps[__currentStep()];\n`);
      p.push(`${this.i()}return step ? step.validate() : false;\n`);
      this.indent--;
      p.push(`${this.i()}});\n`);

      p.push(`${this.i()}const canPrev = createComputed(() => __currentStep() > 0);\n`);
      p.push(`${this.i()}const progress = createComputed(() => (__currentStep() + 1) / __steps.length);\n`);
      p.push('\n');

      p.push(`${this.i()}function next() {\n`);
      this.indent++;
      p.push(`${this.i()}if (canNext()) __set_currentStep(__tova_p => __tova_p + 1);\n`);
      this.indent--;
      p.push(`${this.i()}}\n`);

      p.push(`${this.i()}function prev() {\n`);
      this.indent++;
      p.push(`${this.i()}if (canPrev()) __set_currentStep(__tova_p => __tova_p - 1);\n`);
      this.indent--;
      p.push(`${this.i()}}\n`);
      p.push('\n');
    }

    // Reset function — include both top-level and group-prefixed fields + arrays
    p.push(`${this.i()}function reset() {\n`);
    this.indent++;
    for (const name of fieldNames) {
      p.push(`${this.i()}${name}.reset();\n`);
    }
    for (const name of allGroupPrefixedNames) {
      p.push(`${this.i()}${name}.reset();\n`);
    }
    for (const arr of arrayNames) {
      p.push(`${this.i()}__set_${arr.name}([]); __${arr.name}_nextId = 0;\n`);
    }
    p.push(`${this.i()}__set_submitError(null);\n`);
    this.indent--;
    p.push(`${this.i()}}\n\n`);

    // Submit function
    p.push(`${this.i()}async function submit(e) {\n`);
    this.indent++;
    p.push(`${this.i()}if (e && e.preventDefault) e.preventDefault();\n`);

    // Touch all fields to show errors (top-level + group fields)
    for (const name of fieldNames) {
      p.push(`${this.i()}${name}.blur();\n`);
    }
    for (const name of allGroupPrefixedNames) {
      p.push(`${this.i()}${name}.blur();\n`);
    }
    // Touch all array item fields to show errors
    for (const arr of arrayNames) {
      const blurCalls = arr.fields.map(f => `i.${f}.blur()`).join('; ');
      p.push(`${this.i()}__${arr.name}().forEach(i => { ${blurCalls}; });\n`);
    }

    p.push(`${this.i()}if (!(isValid())) return;\n`);
    p.push(`${this.i()}__set_submitting(true);\n`);
    p.push(`${this.i()}__set_submitError(null);\n`);
    p.push(`${this.i()}__set_submitCount(__tova_p => __tova_p + 1);\n`);
    p.push(`${this.i()}try {\n`);
    this.indent++;

    // Generate the on submit body
    if (form.onSubmit) {
      p.push(this.genBlockStatements(form.onSubmit));
      p.push('\n');
    }

    this.indent--;
    p.push(`${this.i()}} catch (err) {\n`);
    this.indent++;
    p.push(`${this.i()}__set_submitError(err.message || String(err));\n`);
    this.indent--;
    p.push(`${this.i()}} finally {\n`);
    this.indent++;
    p.push(`${this.i()}__set_submitting(false);\n`);
    this.indent--;
    p.push(`${this.i()}}\n`);
    this.indent--;
    p.push(`${this.i()}}\n\n`);

    // Return object
    p.push(`${this.i()}return {\n`);
    this.indent++;

    // Top-level field accessors
    for (const name of fieldNames) {
      p.push(`${this.i()}${name},\n`);
    }

    // Group accessors
    for (const name of groupNames) {
      p.push(`${this.i()}${name},\n`);
    }

    // Array accessors
    for (const arr of arrayNames) {
      p.push(`${this.i()}${arr.name},\n`);
    }

    // Values getter — includes top-level fields, group values, and array values
    const topLevelValuesEntries = fieldNames.map(n => `${n}: __${n}_value()`);
    const groupValuesEntries = groupNames.map(n => `${n}: ${n}.values`);
    const arrayValuesEntries = arrayNames.map(a => `${a.name}: __${a.name}().map(i => i.values)`);
    const allValuesEntries = [...topLevelValuesEntries, ...groupValuesEntries, ...arrayValuesEntries];
    const valuesObj = allValuesEntries.join(', ');
    p.push(`${this.i()}get values() { return { ${valuesObj} }; },\n`);

    // Form-level getters
    p.push(`${this.i()}get isValid() { return isValid(); },\n`);
    p.push(`${this.i()}get isDirty() { return isDirty(); },\n`);
    p.push(`${this.i()}submit,\n`);
    p.push(`${this.i()}reset,\n`);
    p.push(`${this.i()}get submitting() { return __submitting(); },\n`);
    p.push(`${this.i()}get submitError() { return __submitError(); },\n`);
    p.push(`${this.i()}get submitCount() { return __submitCount(); },\n`);
    p.push(`${this.i()}setError: (msg) => __set_submitError(msg),\n`);

    // Wizard step properties in return object
    if (hasSteps) {
      p.push(`${this.i()}get currentStep() { return __currentStep(); },\n`);
      p.push(`${this.i()}next,\n`);
      p.push(`${this.i()}prev,\n`);
      p.push(`${this.i()}get canNext() { return canNext(); },\n`);
      p.push(`${this.i()}get canPrev() { return canPrev(); },\n`);
      p.push(`${this.i()}get progress() { return progress(); },\n`);
      p.push(`${this.i()}get steps() { return __steps; },\n`);
    }

    this.indent--;
    p.push(`${this.i()}};\n`);

    this.indent--;
    p.push(`${this.i()}})();`);

    // Restore state/computed/form names
    this.stateNames = savedState;
    this.computedNames = savedComputed;
    this.formNames = savedFormNames;

    return p.join('');
  }

  // Check if an AST expression references any signal/computed name (memoized)
  _exprReadsSignal(node) {
    if (!node) return false;
    // Cannot cache Identifier lookups — result depends on current stateNames/computedNames
    if (node.type === 'Identifier') return this.stateNames.has(node.name) || this.computedNames.has(node.name);
    const cached = this._signalCache.get(node);
    if (cached !== undefined) return cached;
    const result = this._exprReadsSignalImpl(node);
    this._signalCache.set(node, result);
    return result;
  }

  _exprReadsSignalImpl(node) {
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
      return this._exprReadsSignal(node.left) || this._exprReadsSignal(node.right);
    }
    if (node.type === 'UnaryExpression') return this._exprReadsSignal(node.operand);
    if (node.type === 'CallExpression') {
      return this._exprReadsSignal(node.callee) || node.arguments.some(a => this._exprReadsSignal(a));
    }
    if (node.type === 'MemberExpression') {
      if (node.object.type === 'Identifier' && this.storeNames.has(node.object.name)) {
        return true; // Store property access is reactive (getters call signals)
      }
      return this._exprReadsSignal(node.object) || (node.computed && this._exprReadsSignal(node.property));
    }
    if (node.type === 'OptionalChain') {
      return this._exprReadsSignal(node.object) || (node.computed && this._exprReadsSignal(node.property));
    }
    if (node.type === 'TemplateLiteral') {
      return node.parts.some(p => p.type === 'expr' && this._exprReadsSignal(p.value));
    }
    if (node.type === 'ChainedComparison') return node.operands.some(o => this._exprReadsSignal(o));
    if (node.type === 'PipeExpression') return this._exprReadsSignal(node.left) || this._exprReadsSignal(node.right);
    if (node.type === 'ArrayLiteral') return node.elements.some(e => this._exprReadsSignal(e));
    if (node.type === 'ObjectLiteral') return node.properties.some(p => this._exprReadsSignal(p.value));
    if (node.type === 'IfExpression') {
      return this._exprReadsSignal(node.condition) || this._exprReadsSignal(node.consequent) ||
        (node.alternates && node.alternates.some(a => this._exprReadsSignal(a.condition) || this._exprReadsSignal(a.body))) ||
        this._exprReadsSignal(node.elseBody);
    }
    if (node.type === 'MatchExpression') {
      if (this._exprReadsSignal(node.subject)) return true;
      return node.arms.some(arm => this._exprReadsSignal(arm.body));
    }
    if (node.type === 'SpreadExpression') return this._exprReadsSignal(node.argument);
    if (node.type === 'AwaitExpression') return this._exprReadsSignal(node.argument);
    if (node.type === 'RangeExpression') return this._exprReadsSignal(node.start) || this._exprReadsSignal(node.end);
    if (node.type === 'SliceExpression') return this._exprReadsSignal(node.object) || this._exprReadsSignal(node.start) || this._exprReadsSignal(node.end);
    if (node.type === 'ListComprehension') return this._exprReadsSignal(node.iterable) || this._exprReadsSignal(node.expression);
    if (node.type === 'LambdaExpression') return this._exprReadsSignal(node.body);
    if (node.type === 'PropagateExpression') return this._exprReadsSignal(node.expression);
    return false;
  }

  genJSX(node) {
    if (!node) return 'null';

    switch (node.type) {
      case 'JSXElement': return this.genJSXElement(node);
      case 'JSXFragment': return this.genJSXFragment(node);
      case 'JSXText': return this.genJSXText(node);
      case 'JSXExpression': {
        // If expression reads a signal, wrap as () => expr for fine-grained reactivity
        const expr = this.genExpression(node.expression);
        if (this._exprReadsSignal(node.expression)) {
          return `() => ${expr}`;
        }
        return expr;
      }
      case 'JSXFor': return this.genJSXFor(node);
      case 'JSXIf': return this.genJSXIf(node);
      case 'JSXMatch': return this.genJSXMatch(node);
      default: return this.genExpression(node);
    }
  }

  genJSXElement(node) {
    // <slot /> or <slot name="header" /> — render children passed from parent
    if (node.tag === 'slot') {
      const nameAttr = node.attributes.find(a => a.name === 'name');
      const slotProps = node.attributes.filter(a => a.name !== 'name');

      if (nameAttr && nameAttr.value.type === 'StringLiteral') {
        // Named slot: <slot name="header" />
        const slotName = nameAttr.value.value;
        return `(__props.${slotName} || '')`;
      }

      if (slotProps.length > 0) {
        // Scoped slot: <slot count={count()} /> — pass props to render function
        const propParts = slotProps.map(a => {
          const val = this.genExpression(a.value);
          return `${a.name}: ${val}`;
        });
        return `(typeof __props.children === 'function' ? __props.children({${propParts.join(', ')}}) : (__props.children || ''))`;
      }

      // Default slot: <slot />
      return `(__props.children || '')`;
    }

    // ── <ErrorMessage /> built-in component (compiler-time transform) ──
    if (node.tag === 'ErrorMessage') {
      return this._genErrorMessage(node, null);
    }

    // ── <FormField field={expr}> built-in component (compiler-time transform) ──
    if (node.tag === 'FormField') {
      return this._genFormField(node);
    }

    const isComponent = node.tag[0] === node.tag[0].toUpperCase() && /^[A-Z]/.test(node.tag);

    // Attributes
    const attrs = {};
    const events = {};
    const classDirectives = [];
    const spreads = []; // collected spread expressions

    for (const attr of node.attributes) {
      if (attr.type === 'JSXSpreadAttribute') {
        spreads.push(this.genExpression(attr.expression));
        continue;
      }
      if (attr.name === 'bind:value') {
        // Two-way binding: bind:value={name} → reactive value + event handler
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs.value = reactive ? `() => ${expr}` : expr;
        const exprName = attr.value.name;
        if (this.stateNames.has(exprName)) {
          // <select> fires 'change', all other inputs fire 'input'
          const eventName = node.tag === 'select' ? 'change' : 'input';
          // For number/range inputs, coerce e.target.value to Number
          const typeAttr = node.attributes.find(a => a.name === 'type');
          const typeStr = typeAttr && typeAttr.value ? (typeAttr.value.value || '') : '';
          const isNumeric = typeStr === 'number' || typeStr === 'range';
          const valueExpr = isNumeric ? 'Number(e.target.value)' : 'e.target.value';
          events[eventName] = `(e) => { set${capitalize(exprName)}(${valueExpr}); }`;
        }
      } else if (attr.name === 'bind:form') {
        // Form binding: bind:form={login} → onSubmit wires to form controller's submit()
        const formName = this.genExpression(attr.value);
        events.submit = `(e) => ${formName}.submit(e)`;
      } else if (attr.name === 'bind:checked') {
        // Two-way binding: bind:checked={flag} → reactive checked + onChange
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs.checked = reactive ? `() => ${expr}` : expr;
        const exprName = attr.value.name;
        if (this.stateNames.has(exprName)) {
          events.change = `(e) => { set${capitalize(exprName)}(e.target.checked); }`;
        }
      } else if (attr.name === 'bind:group') {
        // Radio/checkbox group binding
        // For radio: bind:group={selected} → checked = selected === value, onChange sets selected = value
        // For checkbox: bind:group={items} → checked = items.includes(value), onChange toggles value in array
        const expr = this.genExpression(attr.value);
        const exprName = attr.value.name;
        const reactive = this._exprReadsSignal(attr.value);
        // Determine type from other attributes
        const typeAttr = node.attributes.find(a => a.name === 'type');
        const typeStr = typeAttr ? (typeAttr.value.value || '') : '';
        const valueAttr = node.attributes.find(a => a.name === 'value');
        const valueExpr = valueAttr ? this.genExpression(valueAttr.value) : '""';

        if (typeStr === 'checkbox') {
          // Array-based: checked when array includes value
          attrs.checked = reactive
            ? `() => ${expr}.includes(${valueExpr})`
            : `${expr}.includes(${valueExpr})`;
          if (this.stateNames.has(exprName)) {
            events.change = `(e) => { const v = ${valueExpr}; if (e.target.checked) { set${capitalize(exprName)}(__tova_p => [...__tova_p, v]); } else { set${capitalize(exprName)}(__tova_p => __tova_p.filter(x => x !== v)); } }`;
          }
        } else {
          // Radio: single value
          attrs.checked = reactive
            ? `() => ${expr} === ${valueExpr}`
            : `${expr} === ${valueExpr}`;
          if (this.stateNames.has(exprName)) {
            events.change = `(e) => { set${capitalize(exprName)}(${valueExpr}); }`;
          }
        }
      } else if (attr.name === 'show') {
        // show={condition} → toggles display:none instead of removing from DOM
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        const displayExpr = `(${expr}) ? "" : "none"`;
        // Store show directive to merge with style later
        node._showDirective = { expr: displayExpr, reactive };
      } else if (attr.name.startsWith('class:')) {
        // Conditional class: class:active={cond}
        const className = attr.name.slice(6);
        classDirectives.push({ className, condition: this.genExpression(attr.value), node: attr.value });
      } else if (attr.name.startsWith('use:')) {
        // use:action directive: use:tooltip={params}
        const actionName = attr.name.slice(4);
        const param = attr.value.type === 'BooleanLiteral' ? 'undefined' : this.genExpression(attr.value);
        const reactive = attr.value.type !== 'BooleanLiteral' && this._exprReadsSignal(attr.value);
        if (!node._actions) node._actions = [];
        node._actions.push({ name: actionName, param, reactive });
      } else if (attr.name.startsWith('in:')) {
        // in:fade — enter-only transition
        const transName = attr.name.slice(3);
        const config = attr.value.type === 'BooleanLiteral' ? '{}' : this.genExpression(attr.value);
        node._inTransition = { name: transName, config };
      } else if (attr.name.startsWith('out:')) {
        // out:slide — leave-only transition
        const transName = attr.name.slice(4);
        const config = attr.value.type === 'BooleanLiteral' ? '{}' : this.genExpression(attr.value);
        node._outTransition = { name: transName, config };
      } else if (attr.name.startsWith('transition:')) {
        // transition:fade, transition:slide={duration: 300}, etc.
        const transName = attr.name.slice(11); // 'fade', 'slide', 'scale', 'fly'
        const builtins = new Set(['fade', 'slide', 'scale', 'fly']);
        const config = attr.value.type === 'BooleanLiteral' ? '{}' : this.genExpression(attr.value);
        // Store transition info for element wrapping
        if (!node._transitions) node._transitions = [];
        node._transitions.push({ name: transName, config, custom: !builtins.has(transName) });
      } else if (attr.name === 'bind:this') {
        // bind:this={ref} → ref: refValue (works with both ref objects and functions)
        attrs.ref = this.genExpression(attr.value);
      } else if (attr.name.startsWith('on:')) {
        const fullName = attr.name.slice(3); // e.g. "click.stop.prevent"
        const parts = fullName.split('.');
        const eventName = parts[0];
        const modifiers = parts.slice(1);
        let handler = this.genExpression(attr.value);

        if (modifiers.length > 0) {
          const guards = [];
          let useCapture = false;
          let useOnce = false;

          // Key modifier map for keydown/keyup events
          const keyMap = {
            enter: '"Enter"', escape: '"Escape"', tab: '"Tab"', space: '" "',
            up: '"ArrowUp"', down: '"ArrowDown"', left: '"ArrowLeft"', right: '"ArrowRight"',
            delete: '"Delete"', backspace: '"Backspace"',
          };

          for (const mod of modifiers) {
            if (mod === 'prevent') {
              guards.push('e.preventDefault()');
            } else if (mod === 'stop') {
              guards.push('e.stopPropagation()');
            } else if (mod === 'self') {
              guards.push('if (e.target !== e.currentTarget) return');
            } else if (mod === 'capture') {
              useCapture = true;
            } else if (mod === 'once') {
              useOnce = true;
            } else if (keyMap[mod]) {
              guards.push(`if (e.key !== ${keyMap[mod]}) return`);
            }
          }

          if (guards.length > 0) {
            handler = `(e) => { ${guards.join('; ')}; (${handler})(e); }`;
          }

          if (useCapture || useOnce) {
            const opts = [];
            if (useCapture) opts.push('capture: true');
            if (useOnce) opts.push('once: true');
            handler = `{ handler: ${handler}, options: { ${opts.join(', ')} } }`;
          }
        }

        events[eventName] = handler;
      } else {
        const attrName = attr.name === 'class' ? 'className' : attr.name;
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs[attrName] = reactive ? `() => ${expr}` : expr;
      }
    }

    // Merge class directives with className
    if (classDirectives.length > 0) {
      const parts = [];
      if (attrs.className) {
        parts.push(attrs.className);
      }
      for (const { className, condition } of classDirectives) {
        parts.push(`${condition} && "${className}"`);
      }
      const isReactive = classDirectives.some(d => this._exprReadsSignal(d.node));
      const classExpr = `[${parts.join(', ')}].filter(Boolean).join(" ")`;
      attrs.className = isReactive ? `() => ${classExpr}` : classExpr;
    }

    // Merge show directive with style (show toggles display:none)
    if (node._showDirective) {
      const { expr: displayExpr, reactive } = node._showDirective;
      if (attrs.style) {
        // Merge with existing style object
        const existing = attrs.style;
        if (reactive) {
          attrs.style = `() => Object.assign({}, ${existing}, { display: ${displayExpr} })`;
        } else {
          attrs.style = `Object.assign({}, ${existing}, { display: ${displayExpr} })`;
        }
      } else {
        attrs.style = reactive
          ? `() => ({ display: ${displayExpr} })`
          : `{ display: ${displayExpr} }`;
      }
    }

    // Add scoped CSS attribute to HTML elements (not components)
    if (this._currentScopeId && !isComponent) {
      attrs[`"data-tova-${this._currentScopeId}"`] = '""';
    }

    const propParts = [];
    const memoizedProps = []; // Computed memoization for complex expressions
    for (const [key, val] of Object.entries(attrs)) {
      // For component props, convert reactive () => wrappers to JS getter syntax
      // so the prop stays reactive through the __props access pattern
      if (isComponent && spreads.length === 0 && typeof val === 'string' && val.startsWith('() => ')) {
        const rawExpr = val.slice(6);
        // Simple signal read: just use a getter (no overhead)
        // Complex expressions: memoize with createComputed
        const isSimple = /^[a-zA-Z_$]\w*\(\)$/.test(rawExpr);
        if (isSimple) {
          propParts.push(`get ${key}() { return ${rawExpr}; }`);
        } else {
          const memoName = `__memo_${key}`;
          memoizedProps.push(`const ${memoName} = createComputed(() => ${rawExpr})`);
          propParts.push(`get ${key}() { return ${memoName}(); }`);
        }
      } else {
        propParts.push(`${key}: ${val}`);
      }
    }
    for (const [event, handler] of Object.entries(events)) {
      propParts.push(`on${capitalize(event)}: ${handler}`);
    }

    // Build props object, merging spreads if present
    let propsStr;
    if (spreads.length > 0) {
      const ownProps = `{${propParts.join(', ')}}`;
      propsStr = `Object.assign({}, ${spreads.join(', ')}, ${ownProps})`;
    } else {
      propsStr = `{${propParts.join(', ')}}`;
    }

    // Components: call as function, passing props (with children if any)
    if (isComponent) {
      if (!node.selfClosing && node.children.length > 0) {
        // Named slots: children with slot="name" become named props
        const defaultChildren = [];
        const namedSlots = {};

        for (const child of node.children) {
          if (child.type === 'JSXElement') {
            const slotAttr = child.attributes.find(a => a.name === 'slot');
            if (slotAttr && slotAttr.value.type === 'StringLiteral') {
              const slotName = slotAttr.value.value;
              if (!namedSlots[slotName]) namedSlots[slotName] = [];
              namedSlots[slotName].push(child);
              continue;
            }
          }
          defaultChildren.push(child);
        }

        // Add named slot props
        for (const [slotName, slotChildren] of Object.entries(namedSlots)) {
          const slotContent = slotChildren.map(c => this.genJSX(c)).join(', ');
          propParts.push(`${slotName}: [${slotContent}]`);
        }

        if (defaultChildren.length > 0) {
          const children = defaultChildren.map(c => this.genJSX(c)).join(', ');
          propParts.push(`children: [${children}]`);
        }

        if (spreads.length > 0) {
          propsStr = `Object.assign({}, ${spreads.join(', ')}, {${propParts.join(', ')}})`;
        } else {
          propsStr = `{${propParts.join(', ')}}`;
        }
      }
      if (memoizedProps.length > 0) {
        return `(() => { ${memoizedProps.join('; ')}; const __v = ${node.tag}(${propsStr}); if (__v && __v.__tova) __v._componentName = "${node.tag}"; return __v; })()`;
      }
      return `((__tova_v) => (__tova_v && __tova_v.__tova && (__tova_v._componentName = "${node.tag}"), __tova_v))(${node.tag}(${propsStr}))`;
    }

    const tag = JSON.stringify(node.tag);

    let result;
    if (node.selfClosing || node.children.length === 0) {
      result = `tova_el(${tag}, ${propsStr})`;
    } else {
      const children = node.children.map(c => this.genJSX(c)).join(', ');
      result = `tova_el(${tag}, ${propsStr}, [${children}])`;
    }

    // Wrap with transition directives if present
    if (node._transitions && node._transitions.length > 0) {
      for (const t of node._transitions) {
        if (t.custom) {
          result = `tova_transition(${result}, ${t.name}, ${t.config})`;
        } else {
          result = `tova_transition(${result}, "${t.name}", ${t.config})`;
        }
      }
    }

    // Wrap with directional transitions if present
    if (node._inTransition || node._outTransition) {
      const inPart = node._inTransition ? `in: { name: "${node._inTransition.name}", config: ${node._inTransition.config} }` : '';
      const outPart = node._outTransition ? `out: { name: "${node._outTransition.name}", config: ${node._outTransition.config} }` : '';
      const parts = [inPart, outPart].filter(Boolean).join(', ');
      result = `tova_transition(${result}, { ${parts} })`;
    }

    // Wrap with use: action directives if present
    if (node._actions && node._actions.length > 0) {
      for (const a of node._actions) {
        if (a.reactive) {
          result = `__tova_action(${result}, ${a.name}, () => ${a.param})`;
        } else {
          result = `__tova_action(${result}, ${a.name}, ${a.param})`;
        }
      }
    }

    return result;
  }

  // ── <ErrorMessage /> compiler transform ──
  // Standalone: <ErrorMessage field={form.email} /> or <ErrorMessage form={login} />
  // Inside FormField: <ErrorMessage /> (inherits parent field expression)
  _genErrorMessage(node, parentFieldExpr) {
    const fieldAttr = node.attributes.find(a => a.name === 'field');
    const formAttr = node.attributes.find(a => a.name === 'form');

    if (formAttr) {
      // Form-level error: show form.submitError
      const formExpr = this.genExpression(formAttr.value);
      return `() => ${formExpr}.submitError ? tova_el("span", {className: "form-error"}, [() => ${formExpr}.submitError]) : null`;
    }

    // Determine field expression: explicit attr or inherited from parent FormField
    let fieldExpr;
    if (fieldAttr) {
      fieldExpr = this.genExpression(fieldAttr.value);
    } else if (parentFieldExpr) {
      fieldExpr = parentFieldExpr;
    } else {
      // No field info — render nothing
      return 'null';
    }

    return `() => ${fieldExpr}.touched && ${fieldExpr}.error ? tova_el("span", {className: "form-error"}, [() => ${fieldExpr}.error]) : null`;
  }

  // ── <FormField field={expr}> compiler transform ──
  // Generates a wrapper div.form-field with auto-wired input/select/textarea children
  _genFormField(node) {
    const fieldAttr = node.attributes.find(a => a.name === 'field');
    if (!fieldAttr) {
      // No field attribute — fall through to normal div
      const children = (node.children || []).map(c => this.genJSX(c)).join(', ');
      return `tova_el("div", {className: "form-field"}, [${children}])`;
    }

    const fieldExpr = this.genExpression(fieldAttr.value);
    const inputTags = new Set(['input', 'select', 'textarea']);

    const childParts = [];
    for (const child of (node.children || [])) {
      if (child.type === 'JSXElement' && inputTags.has(child.tag)) {
        // Auto-wire input/select/textarea to the field
        childParts.push(this._genFormFieldInput(child, fieldExpr));
      } else if (child.type === 'JSXElement' && child.tag === 'ErrorMessage') {
        // Replace <ErrorMessage /> with conditional error display using parent field
        childParts.push(this._genErrorMessage(child, fieldExpr));
      } else {
        // Other children: generate normally
        childParts.push(this.genJSX(child));
      }
    }

    return `tova_el("div", {className: "form-field"}, [${childParts.join(', ')}])`;
  }

  // Generate an input/select/textarea element with field bindings injected
  _genFormFieldInput(node, fieldExpr) {
    // Process existing attributes normally, then inject field bindings
    const attrs = {};
    const events = {};

    for (const attr of node.attributes) {
      if (attr.name === 'class') {
        attrs.className = this.genExpression(attr.value);
      } else if (attr.name.startsWith('on:')) {
        events[attr.name.slice(3)] = this.genExpression(attr.value);
      } else {
        attrs[attr.name] = this.genExpression(attr.value);
      }
    }

    // Inject field bindings
    attrs.value = `() => ${fieldExpr}.value`;
    events.input = `(e) => ${fieldExpr}.set(e.target.value)`;
    events.blur = `() => ${fieldExpr}.blur()`;

    const propParts = [];
    for (const [key, val] of Object.entries(attrs)) {
      propParts.push(`${key}: ${val}`);
    }
    for (const [event, handler] of Object.entries(events)) {
      propParts.push(`on${event[0].toUpperCase() + event.slice(1)}: ${handler}`);
    }

    const tag = JSON.stringify(node.tag);
    if (node.selfClosing || !node.children || node.children.length === 0) {
      return `tova_el(${tag}, {${propParts.join(', ')}})`;
    }
    const children = node.children.map(c => this.genJSX(c)).join(', ');
    return `tova_el(${tag}, {${propParts.join(', ')}}, [${children}])`;
  }

  genJSXText(node) {
    if (node.value.type === 'StringLiteral') {
      return JSON.stringify(node.value.value);
    }
    if (node.value.type === 'TemplateLiteral') {
      const code = this.genTemplateLiteral(node.value);
      // Wrap in reactive closure if the template reads signals
      if (this._exprReadsSignal(node.value)) {
        return `() => ${code}`;
      }
      return code;
    }
    return this.genExpression(node.value);
  }

  _genJSXForVar(variable) {
    if (typeof variable === 'string') return variable;
    if (variable.type === 'ArrayPattern') {
      return `[${variable.elements.join(', ')}]`;
    }
    if (variable.type === 'ObjectPattern') {
      return `{${variable.properties.map(p => p.value ? `${p.key}: ${p.value}` : p.key).join(', ')}}`;
    }
    return String(variable);
  }

  genJSXFor(node) {
    const varName = this._genJSXForVar(node.variable);
    const iterable = this.genExpression(node.iterable);
    const children = node.body.map(c => this.genJSX(c));
    const needsReactive = this._exprReadsSignal(node.iterable);
    const wrap = needsReactive ? '() => ' : '';

    if (node.keyExpr) {
      const keyExpr = this.genExpression(node.keyExpr);
      if (children.length === 1) {
        return `${wrap}${iterable}.map((${varName}) => tova_keyed(${keyExpr}, ${children[0]}))`;
      }
      return `${wrap}${iterable}.map((${varName}) => tova_keyed(${keyExpr}, tova_fragment([${children.join(', ')}])))`;
    }

    if (children.length === 1) {
      return `${wrap}${iterable}.map((${varName}) => ${children[0]})`;
    }
    return `${wrap}${iterable}.map((${varName}) => tova_fragment([${children.join(', ')}]))`;
  }

  genJSXIf(node) {
    const cond = this.genExpression(node.condition);
    const consequent = node.consequent.map(c => this.genJSX(c));
    const thenPart = consequent.length === 1 ? consequent[0] : `tova_fragment([${consequent.join(', ')}])`;

    // Build chained ternary: cond1 ? a : cond2 ? b : cond3 ? c : else
    let result = `(${cond}) ? ${thenPart}`;

    // elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        const elifCond = this.genExpression(alt.condition);
        const elifBody = alt.body.map(c => this.genJSX(c));
        const elifPart = elifBody.length === 1 ? elifBody[0] : `tova_fragment([${elifBody.join(', ')}])`;
        result += ` : (${elifCond}) ? ${elifPart}`;
      }
    }

    if (node.alternate) {
      const alt = node.alternate.map(c => this.genJSX(c));
      const elsePart = alt.length === 1 ? alt[0] : `tova_fragment([${alt.join(', ')}])`;
      result += ` : ${elsePart}`;
    } else {
      result += ` : null`;
    }

    // Only wrap in reactive closure if the condition reads signals
    const needsReactive = this._exprReadsSignal(node.condition) ||
      (node.alternates && node.alternates.some(a => this._exprReadsSignal(a.condition)));
    if (needsReactive) {
      return `() => ${result}`;
    }
    return result;
  }

  genJSXMatch(node) {
    const subject = this.genExpression(node.subject);
    const p = [];
    p.push(`((__match) => { `);

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, '__match', arm.guard);
      const body = arm.body.map(c => this.genJSX(c));
      const bodyExpr = body.length === 1 ? body[0] : `tova_fragment([${body.join(', ')}])`;

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case
          if (arm.pattern.type === 'BindingPattern') {
            p.push(`const ${arm.pattern.name} = __match; `);
          }
          p.push(`return ${bodyExpr}; `);
          break;
        }
      }

      const keyword = idx === 0 ? 'if' : 'else if';
      p.push(`${keyword} (${condition}) { `);
      p.push(this.genPatternBindings(arm.pattern, '__match'));
      p.push(`return ${bodyExpr}; } `);
    }

    p.push(`})(${subject})`);
    // Only wrap in reactive closure if the subject reads signals
    if (this._exprReadsSignal(node.subject)) {
      return `() => ${p.join('')}`;
    }
    return p.join('');
  }

  genJSXFragment(node) {
    const children = node.children.map(c => this.genJSX(c)).join(', ');
    return `tova_fragment([${children}])`;
  }

  // Override to add await for piped RPC calls
  genPipeExpression(node) {
    const result = super.genPipeExpression(node);
    // If the pipe target is an RPC call and we're in async context, wrap with await
    if (this._asyncContext && this._containsRPC(node.right)) {
      return `await ${result}`;
    }
    return result;
  }

  // Override function declaration to make async if it contains server.* calls
  genFunctionDeclaration(node) {
    const hasRPC = this._containsRPC(node.body);
    const hasPropagate = this._containsPropagate(node.body);
    const isGenerator = this._containsYield(node.body);
    const exportPrefix = node.isPublic ? 'export ' : '';
    const asyncPrefix = (hasRPC || node.isAsync) ? 'async ' : '';
    const genStar = isGenerator ? '*' : '';
    const params = this.genParams(node.params);
    this.pushScope();
    for (const p of node.params) {
      if (p.destructure) {
        this._declareDestructureVars(p.destructure);
      } else {
        this.declareVar(p.name);
      }
    }
    const prevAsync = this._asyncContext;
    if (hasRPC || node.isAsync) this._asyncContext = true;
    const body = this.genBlockBody(node.body);
    this._asyncContext = prevAsync;
    this.popScope();
    if (hasPropagate) {
      return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
    }
    return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${body}\n${this.i()}}`;
  }

  getStdlibCore() {
    const parts = [];
    // Only include builtins used in client blocks that aren't already in shared code
    const clientOnly = new Set();
    for (const name of this._usedBuiltins) {
      if (!this._sharedBuiltins || !this._sharedBuiltins.has(name)) {
        clientOnly.add(name);
      }
    }
    const selectiveStdlib = buildSelectiveStdlib(clientOnly);
    if (selectiveStdlib) parts.push(selectiveStdlib);
    // Include Result/Option if Ok/Err/Some/None are used
    if (this._needsResultOption) parts.push(RESULT_OPTION);
    // Include propagate if needed
    if (this._needsPropagateHelper) parts.push(PROPAGATE);
    return parts.join('\n');
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ─── src/codegen/security-codegen.js ───────────────────

// Security code generator for the Tova language
// Produces code fragments consumed by server-codegen and browser-codegen.
class SecurityCodegen extends BaseCodegen {

  /**
   * Merge all SecurityBlock nodes into a single config object.
   * Multiple security blocks are merged (last wins on conflicts).
   */
  static mergeSecurityBlocks(securityBlocks) {
    const config = {
      auth: null,        // SecurityAuthDeclaration
      roles: [],         // Array of SecurityRoleDeclaration
      protects: [],      // Array of SecurityProtectDeclaration
      sensitives: [],    // Array of SecuritySensitiveDeclaration
      cors: null,        // SecurityCorsDeclaration
      csp: null,         // SecurityCspDeclaration
      rateLimit: null,   // SecurityRateLimitDeclaration
      csrf: null,        // SecurityCsrfDeclaration
      audit: null,       // SecurityAuditDeclaration
      trustProxy: null,  // SecurityTrustProxyDeclaration
      hsts: null,        // SecurityHstsDeclaration
    };

    for (const block of securityBlocks) {
      for (const node of block.body) {
        switch (node.type) {
          case 'SecurityAuthDeclaration':
            config.auth = node;
            break;
          case 'SecurityRoleDeclaration':
            config.roles.push(node);
            break;
          case 'SecurityProtectDeclaration':
            config.protects.push(node);
            break;
          case 'SecuritySensitiveDeclaration':
            config.sensitives.push(node);
            break;
          case 'SecurityCorsDeclaration':
            config.cors = node;
            break;
          case 'SecurityCspDeclaration':
            config.csp = node;
            break;
          case 'SecurityRateLimitDeclaration':
            config.rateLimit = node;
            break;
          case 'SecurityCsrfDeclaration':
            config.csrf = node;
            break;
          case 'SecurityAuditDeclaration':
            config.audit = node;
            break;
          case 'SecurityTrustProxyDeclaration':
            config.trustProxy = node;
            break;
          case 'SecurityHstsDeclaration':
            config.hsts = node;
            break;
        }
      }
    }

    return config;
  }

  /**
   * Generate server-side security code fragments.
   * Returns an object with code strings for each security feature.
   */
  generateServerSecurity(securityConfig) {
    const result = {
      roleDefinitions: '',
      authCode: '',
      corsConfig: null,    // config object for server-codegen to use
      cspCode: '',
      rateLimitConfig: null, // config object
      csrfConfig: null,     // config object
      protectCode: '',
      sensitiveCode: '',
      auditCode: '',
      trustProxyConfig: null, // trust_proxy value
      hstsConfig: null,       // hsts config object
      hasAutoSanitize: false, // whether __autoSanitize was generated
    };

    // Role definitions
    if (securityConfig.roles.length > 0) {
      const lines = [];
      lines.push('// ── Security Roles ──');
      lines.push('const __securityRoles = {');
      for (const role of securityConfig.roles) {
        const perms = role.permissions.map(p => JSON.stringify(p)).join(', ');
        lines.push(`  ${JSON.stringify(role.name)}: [${perms}],`);
      }
      lines.push('};');
      lines.push('function __getUserRoles(user) {');
      lines.push('  if (!user) return [];');
      lines.push('  if (Array.isArray(user.roles)) return user.roles;');
      lines.push('  if (user.role) return [user.role];');
      lines.push('  return [];');
      lines.push('}');
      lines.push('function __hasRole(user, roleName) {');
      lines.push('  return __getUserRoles(user).includes(roleName);');
      lines.push('}');
      lines.push('function __hasPermission(user, permission) {');
      lines.push('  const userRoles = __getUserRoles(user);');
      lines.push('  for (const r of userRoles) {');
      lines.push('    const perms = __securityRoles[r];');
      lines.push('    if (perms && perms.includes(permission)) return true;');
      lines.push('  }');
      lines.push('  return false;');
      lines.push('}');
      result.roleDefinitions = lines.join('\n');
    }

    // Auth config — pass through to server codegen
    if (securityConfig.auth) {
      const authNode = securityConfig.auth;
      // Convert security auth config to the format server-codegen expects
      const config = { ...authNode.config };
      // Set the auth type as a value property (server-codegen checks .type.value)
      config.type = { value: authNode.authType, type: 'StringLiteral' };
      result.authConfig = config;
    }

    // CORS config — pass through to server codegen
    if (securityConfig.cors) {
      result.corsConfig = securityConfig.cors.config;
    }

    // CSP header generation
    if (securityConfig.csp) {
      const lines = [];
      lines.push('// ── Content Security Policy ──');
      const directives = [];
      for (const [key, valueNode] of Object.entries(securityConfig.csp.config)) {
        const directive = key.replace(/_/g, '-');
        directives.push({ directive, valueNode });
      }
      lines.push('function __getCspHeader() {');
      lines.push('  const parts = [];');
      for (const { directive, valueNode } of directives) {
        lines.push(`  parts.push("${directive} " + ${this.genExpression(valueNode)}.map(v => v === "self" ? "'self'" : v === "unsafe-inline" ? "'unsafe-inline'" : v === "unsafe-eval" ? "'unsafe-eval'" : v).join(" "));`);
      }
      lines.push('  return parts.join("; ");');
      lines.push('}');
      result.cspCode = lines.join('\n');
    }

    // Rate limit config — pass through to server codegen
    if (securityConfig.rateLimit) {
      result.rateLimitConfig = securityConfig.rateLimit.config;
    }

    // CSRF config
    if (securityConfig.csrf) {
      result.csrfConfig = securityConfig.csrf.config;
    }

    // Trust proxy config
    if (securityConfig.trustProxy) {
      result.trustProxyConfig = securityConfig.trustProxy.value;
    }

    // HSTS config
    if (securityConfig.hsts) {
      result.hstsConfig = securityConfig.hsts.config;
    } else if (securityConfig.auth) {
      // Auto-enable HSTS when auth is configured (default policy)
      result.hstsConfig = { __autoEnabled: true };
    }

    // Route protection middleware
    if (securityConfig.protects.length > 0) {
      const lines = [];
      lines.push('// ── Route Protection ──');
      lines.push('const __protectRules = [');
      for (const protect of securityConfig.protects) {
        const pattern = protect.pattern;
        const requireExpr = protect.config.require;
        let requireStr = '"authenticated"';
        if (requireExpr) {
          if (requireExpr.type === 'Identifier') {
            requireStr = JSON.stringify(requireExpr.name);
          } else {
            requireStr = this.genExpression(requireExpr);
          }
        }
        // Convert glob-style pattern to regex
        // 1. Replace ** with placeholder, 2. Replace * with placeholder
        // 3. Escape all regex-special chars (including /), 4. Restore glob placeholders
        const regexPattern = pattern
          .replace(/\*\*/g, '\x00GLOBSTAR\x00')
          .replace(/\*/g, '\x00STAR\x00')
          .replace(/[.+?^${}()|[\]\\/]/g, '\\$&')   // escape all regex specials including /
          .replace(/\x00STAR\x00/g, '[^/]*')         // * matches within one path segment
          .replace(/\x00GLOBSTAR\x00/g, '.*');        // ** matches across segments

        let rlMax = 'null';
        let rlWindow = 'null';
        if (protect.config.rate_limit) {
          if (protect.config.rate_limit.max) {
            rlMax = this.genExpression(protect.config.rate_limit.max);
          }
          if (protect.config.rate_limit.window) {
            rlWindow = this.genExpression(protect.config.rate_limit.window);
          }
        }

        lines.push(`  { pattern: /^${regexPattern}$/, require: ${requireStr}, rateLimit: { max: ${rlMax}, window: ${rlWindow} } },`);
      }
      lines.push('];');
      lines.push('function __checkProtection(path, user) {');
      lines.push('  for (const rule of __protectRules) {');
      lines.push('    if (rule.pattern.test(path)) {');
      lines.push('      if (rule.require === "authenticated") {');
      lines.push('        if (!user) return { allowed: false, reason: "Authentication required" };');
      lines.push('      } else {');
      lines.push('        if (!user) return { allowed: false, reason: "Authentication required" };');
      lines.push('        if (!__hasRole(user, rule.require)) return { allowed: false, reason: "Insufficient permissions" };');
      lines.push('      }');
      lines.push('      return { allowed: true, rateLimit: rule.rateLimit };');
      lines.push('    }');
      lines.push('  }');
      lines.push('  return { allowed: true, rateLimit: null };');
      lines.push('}');
      result.protectCode = lines.join('\n');
    }

    // Sensitive field sanitization
    if (securityConfig.sensitives.length > 0) {
      const lines = [];
      lines.push('// ── Sensitive Field Sanitization ──');

      // Identity comparison helper for visible_to: ["self"]
      // Checks multiple common identity fields instead of hardcoded user.id === obj.id
      const hasVisibleTo = securityConfig.sensitives.some(s => s.config.visible_to);
      if (hasVisibleTo) {
        lines.push('function __isSameIdentity(user, obj) {');
        lines.push('  const __idFields = ["id", "_id", "userId", "user_id", "uuid"];');
        lines.push('  for (const f of __idFields) {');
        lines.push('    if (user[f] != null && obj[f] != null && user[f] === obj[f]) return true;');
        lines.push('  }');
        lines.push('  return false;');
        lines.push('}');
      }

      // Group by type
      const byType = {};
      for (const s of securityConfig.sensitives) {
        if (!byType[s.typeName]) byType[s.typeName] = [];
        byType[s.typeName].push(s);
      }

      for (const [typeName, fields] of Object.entries(byType)) {
        const fnName = `__sanitize${typeName}`;
        lines.push(`function ${fnName}(obj, user) {`);
        lines.push('  if (!obj) return obj;');
        lines.push('  const result = { ...obj };');
        for (const field of fields) {
          if (field.config.never_expose) {
            lines.push(`  delete result.${field.fieldName};`);
          } else if (field.config.visible_to) {
            const visibleExpr = this.genExpression(field.config.visible_to);
            lines.push(`  const __visibleTo = ${visibleExpr};`);
            lines.push(`  const __canSee = __visibleTo.some(v => v === "self" ? (user && __isSameIdentity(user, obj)) : __hasRole(user, v));`);
            lines.push(`  if (!__canSee) delete result.${field.fieldName};`);
          }
        }
        lines.push('  return result;');
        lines.push('}');
      }

      // Fix 6a: Auto-sanitize dispatcher
      const typeNames = Object.keys(byType);
      lines.push('function __autoSanitize(data, user) {');
      lines.push('  if (data == null) return data;');
      lines.push('  if (Array.isArray(data)) return data.map(item => __autoSanitize(item, user));');
      lines.push('  if (typeof data !== "object") return data;');
      lines.push('  const __typeName = data.__type || data.__tag || (data.constructor && data.constructor.name !== "Object" ? data.constructor.name : null);');
      for (const typeName of typeNames) {
        lines.push(`  if (__typeName === ${JSON.stringify(typeName)}) return __sanitize${typeName}(data, user);`);
      }
      // Recurse into nested objects
      lines.push('  const __out = {};');
      lines.push('  for (const [k, v] of Object.entries(data)) {');
      lines.push('    __out[k] = __autoSanitize(v, user);');
      lines.push('  }');
      lines.push('  return __out;');
      lines.push('}');

      result.sensitiveCode = lines.join('\n');
      result.hasAutoSanitize = true;
    }

    // Audit logging
    if (securityConfig.audit) {
      const lines = [];
      lines.push('// ── Audit Logging ──');
      const storeExpr = securityConfig.audit.config.store
        ? this.genExpression(securityConfig.audit.config.store)
        : '"audit_log"';
      const retainExpr = securityConfig.audit.config.retain
        ? this.genExpression(securityConfig.audit.config.retain)
        : '90';
      lines.push(`const __auditStore = ${storeExpr};`);
      lines.push('if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(__auditStore)) throw new Error("Invalid audit store table name: " + __auditStore);');
      lines.push(`const __auditRetainDays = ${retainExpr};`);

      if (securityConfig.audit.config.events) {
        lines.push(`const __auditEvents = ${this.genExpression(securityConfig.audit.config.events)};`);
      } else {
        lines.push('const __auditEvents = [];');
      }

      lines.push('async function __auditLog(event, details, user) {');
      lines.push('  const entry = {');
      lines.push('    event,');
      lines.push('    timestamp: new Date().toISOString(),');
      lines.push('    user: user ? { id: user.id, roles: __getUserRoles ? __getUserRoles(user) : (user.roles || [user.role].filter(Boolean)) } : null,');
      lines.push('    details,');
      lines.push('  };');
      lines.push('  if (typeof db !== "undefined" && db.run) {');
      lines.push(`    try { await db.run("INSERT INTO " + __auditStore + " (event, timestamp, user_id, details) VALUES (?, ?, ?, ?)", entry.event, entry.timestamp, entry.user ? entry.user.id : null, JSON.stringify(entry.details)); } catch (__auditErr) { console.error("[tova:audit] Failed to write audit log:", __auditErr.message || __auditErr); }`);
      lines.push('  }');
      lines.push('}');
      result.auditCode = lines.join('\n');
    }

    return result;
  }

  /**
   * Generate browser-side security code fragments.
   */
  generateBrowserSecurity(securityConfig) {
    const lines = [];

    // Auth token injection for RPC proxy
    if (securityConfig.auth) {
      // Check if auth storage is "cookie" (HttpOnly cookie mode)
      const storageNode = securityConfig.auth.config.storage;
      const isCookieAuth = storageNode && storageNode.type === 'StringLiteral' && storageNode.value === 'cookie';

      if (isCookieAuth) {
        // HttpOnly cookie mode: server manages tokens via Set-Cookie
        // Client just ensures credentials are included in fetch
        lines.push('// ── Security: Auth Token (HttpOnly Cookie) ──');
        lines.push('function getAuthToken() { return null; /* managed by HttpOnly cookie */ }');
        lines.push('function setAuthToken(_token) { /* no-op: server sets HttpOnly cookie */ }');
        lines.push('function clearAuthToken() {');
        lines.push('  fetch("/rpc/__logout", { method: "POST", credentials: "include" }).catch(() => {});');
        lines.push('}');
        lines.push('configureRPC({ credentials: "include" });');
        lines.push('');
      } else {
        // localStorage mode (default)
        lines.push('// ── Security: Auth Token ──');
        lines.push('function getAuthToken() {');
        lines.push('  return localStorage.getItem("__tova_auth_token");');
        lines.push('}');
        lines.push('function setAuthToken(token) {');
        lines.push('  localStorage.setItem("__tova_auth_token", token);');
        lines.push('}');
        lines.push('function clearAuthToken() {');
        lines.push('  localStorage.removeItem("__tova_auth_token");');
        lines.push('}');
        lines.push('addRPCInterceptor({');
        lines.push('  request({ options }) {');
        lines.push('    const token = getAuthToken();');
        lines.push('    if (token) options.headers["Authorization"] = "Bearer " + token;');
        lines.push('    return options;');
        lines.push('  }');
        lines.push('});');
        lines.push('');
      }
    }

    // Role definitions and can() helper (Fix 8: advisory comment)
    if (securityConfig.roles.length > 0) {
      lines.push('// ── Security: Roles ──');
      lines.push('// NOTE: Client-side role checking is for UI purposes only. All authorization is enforced server-side.');
      lines.push('const __browserRoles = {');
      for (const role of securityConfig.roles) {
        const perms = role.permissions.map(p => JSON.stringify(p)).join(', ');
        lines.push(`  ${JSON.stringify(role.name)}: [${perms}],`);
      }
      lines.push('};');
      lines.push('let __currentUserRoles = [];');
      lines.push('function setUserRole(role) { __currentUserRoles = Array.isArray(role) ? role : [role]; }');
      lines.push('function getUserRole() { return __currentUserRoles; }');
      lines.push('function can(permission) {');
      lines.push('  for (const r of __currentUserRoles) {');
      lines.push('    const perms = __browserRoles[r];');
      lines.push('    if (perms && perms.includes(permission)) return true;');
      lines.push('  }');
      lines.push('  return false;');
      lines.push('}');
      lines.push('');
    }

    return lines.join('\n');
  }
}

// ─── src/codegen/cli-codegen.js ────────────────────────

// CLI code generator for the Tova language
// Produces a complete zero-dependency CLI executable from cli { } blocks.
class CliCodegen extends BaseCodegen {

  /**
   * Merge all CliBlock nodes into a single config.
   * Multiple cli blocks are merged (last wins on config, commands accumulate).
   */
  static mergeCliBlocks(cliBlocks) {
    const config = {
      name: null,
      version: null,
      description: null,
    };
    const commands = [];

    for (const block of cliBlocks) {
      for (const field of block.config) {
        if (field.key === 'name' && field.value.type === 'StringLiteral') {
          config.name = field.value.value;
        } else if (field.key === 'version' && field.value.type === 'StringLiteral') {
          config.version = field.value.value;
        } else if (field.key === 'description' && field.value.type === 'StringLiteral') {
          config.description = field.value.value;
        }
      }
      commands.push(...block.commands);
    }

    return { config, commands };
  }

  /**
   * Generate a complete CLI executable.
   * @param {Object} cliConfig — merged config from mergeCliBlocks
   * @param {string} sharedCode — shared/top-level compiled code
   * @returns {string} — complete executable JS
   */
  generate(cliConfig, sharedCode) {
    const { config, commands } = cliConfig;
    const lines = [];

    // Emit shared code (stdlib + top-level)
    if (sharedCode && sharedCode.trim()) {
      lines.push(sharedCode);
      lines.push('');
    }

    const singleCommand = commands.length === 1;

    // Emit each command as a function
    for (const cmd of commands) {
      lines.push(this._genCommandFunction(cmd));
      lines.push('');
    }

    // Generate help functions
    lines.push(this._genMainHelp(config, commands));
    lines.push('');

    for (const cmd of commands) {
      lines.push(this._genCommandHelp(cmd, config, singleCommand));
      lines.push('');
    }

    // Generate dispatchers for each command
    for (const cmd of commands) {
      lines.push(this._genCommandDispatcher(cmd));
      lines.push('');
    }

    // Generate main entry point
    lines.push(this._genMain(config, commands, singleCommand));
    lines.push('');

    // Auto-invoke
    lines.push('__cli_main(process.argv.slice(2));');

    return lines.join('\n');
  }

  /**
   * Generate a command function: __cmd_<name>(params...)
   */
  _genCommandFunction(cmd) {
    const paramNames = cmd.params.map(p => p.name);
    const asyncPrefix = cmd.isAsync ? 'async ' : '';
    const body = this.genBlockStatements(cmd.body);
    return `${asyncPrefix}function __cmd_${cmd.name}(${paramNames.join(', ')}) {\n${body}\n}`;
  }

  /**
   * Generate overall --help output
   */
  _genMainHelp(config, commands) {
    const lines = [];
    lines.push('function __cli_help() {');
    lines.push('  const lines = [];');

    if (config.name) {
      if (config.description) {
        lines.push(`  lines.push("${config.name} — ${this._escStr(config.description)}");`);
      } else {
        lines.push(`  lines.push("${this._escStr(config.name)}");`);
      }
    }
    if (config.version) {
      lines.push(`  lines.push("Version: ${this._escStr(config.version)}");`);
    }

    lines.push('  lines.push("");');
    lines.push('  lines.push("USAGE:");');

    if (commands.length === 1) {
      const cmd = commands[0];
      const usage = this._buildUsageLine(cmd, config);
      lines.push(`  lines.push("  ${usage}");`);
    } else {
      lines.push(`  lines.push("  ${config.name || 'cli'} <command> [options]");`);
      lines.push('  lines.push("");');
      lines.push('  lines.push("COMMANDS:");');

      for (const cmd of commands) {
        const desc = this._getCommandDescription(cmd);
        lines.push(`  lines.push("  ${cmd.name.padEnd(16)}${this._escStr(desc)}");`);
      }
    }

    lines.push('  lines.push("");');
    lines.push('  lines.push("OPTIONS:");');
    lines.push('  lines.push("  --help, -h     Show help");');
    if (config.version) {
      lines.push('  lines.push("  --version, -v  Show version");');
    }

    lines.push('  console.log(lines.join("\\n"));');
    lines.push('}');
    return lines.join('\n');
  }

  /**
   * Generate per-command help: __cli_command_help_<name>()
   */
  _genCommandHelp(cmd, config, singleCommand) {
    const lines = [];
    lines.push(`function __cli_command_help_${cmd.name}() {`);
    lines.push('  const lines = [];');

    const usage = this._buildUsageLine(cmd, config);
    lines.push(`  lines.push("USAGE:");`);
    lines.push(`  lines.push("  ${usage}");`);

    const positionals = cmd.params.filter(p => !p.isFlag);
    const flags = cmd.params.filter(p => p.isFlag);

    if (positionals.length > 0) {
      lines.push('  lines.push("");');
      lines.push('  lines.push("ARGUMENTS:");');
      for (const p of positionals) {
        const typeSuffix = p.typeAnnotation ? ` <${p.typeAnnotation}>` : '';
        const optSuffix = p.isOptional ? ' (optional)' : '';
        const defSuffix = p.defaultValue ? ` (default: ${this._getDefaultStr(p)})` : '';
        lines.push(`  lines.push("  ${p.name.padEnd(16)}${this._escStr(typeSuffix + optSuffix + defSuffix)}");`);
      }
    }

    if (flags.length > 0) {
      lines.push('  lines.push("");');
      lines.push('  lines.push("OPTIONS:");');
      for (const f of flags) {
        const typePart = f.typeAnnotation === 'Bool' ? '' : (f.typeAnnotation ? ` <${f.typeAnnotation}>` : '');
        const defPart = f.defaultValue ? ` (default: ${this._getDefaultStr(f)})` : '';
        lines.push(`  lines.push("  --${f.name.padEnd(14)}${this._escStr(typePart + defPart)}");`);
      }
    }

    lines.push('  lines.push("  --help, -h".padEnd(18) + "Show help");');
    lines.push('  console.log(lines.join("\\n"));');
    lines.push('}');
    return lines.join('\n');
  }

  /**
   * Generate argv dispatcher for a command: __cli_dispatch_<name>(argv)
   */
  _genCommandDispatcher(cmd) {
    const lines = [];
    const asyncPrefix = cmd.isAsync ? 'async ' : '';
    lines.push(`${asyncPrefix}function __cli_dispatch_${cmd.name}(argv) {`);

    const positionals = cmd.params.filter(p => !p.isFlag);
    const flags = cmd.params.filter(p => p.isFlag);

    // Initialize flag variables with defaults
    for (const f of flags) {
      if (f.typeAnnotation === 'Bool') {
        lines.push(`  let __flag_${f.name} = false;`);
      } else if (f.isRepeated) {
        lines.push(`  let __flag_${f.name} = [];`);
      } else if (f.defaultValue) {
        lines.push(`  let __flag_${f.name} = ${this.genExpression(f.defaultValue)};`);
      } else {
        lines.push(`  let __flag_${f.name} = undefined;`);
      }
    }

    // Positional collector
    lines.push('  const __positionals = [];');

    // Parse argv
    lines.push('  for (let __i = 0; __i < argv.length; __i++) {');
    lines.push('    const __arg = argv[__i];');

    // Check --help
    lines.push(`    if (__arg === "--help" || __arg === "-h") { __cli_command_help_${cmd.name}(); return; }`);

    // Check each flag
    for (const f of flags) {
      if (f.typeAnnotation === 'Bool') {
        lines.push(`    if (__arg === "--${f.name}") { __flag_${f.name} = true; continue; }`);
        lines.push(`    if (__arg === "--no-${f.name}") { __flag_${f.name} = false; continue; }`);
      } else if (f.isRepeated) {
        lines.push(`    if (__arg === "--${f.name}") {`);
        lines.push(`      if (__i + 1 >= argv.length) { console.error("Error: --${f.name} requires a value"); process.exit(1); }`);
        lines.push(`      __flag_${f.name}.push(${this._genCoercion(`argv[++__i]`, f.typeAnnotation, f.name)});`);
        lines.push('      continue;');
        lines.push('    }');
      } else {
        lines.push(`    if (__arg === "--${f.name}") {`);
        lines.push(`      if (__i + 1 >= argv.length) { console.error("Error: --${f.name} requires a value"); process.exit(1); }`);
        lines.push(`      __flag_${f.name} = ${this._genCoercion(`argv[++__i]`, f.typeAnnotation, f.name)};`);
        lines.push('      continue;');
        lines.push('    }');
        // Support --flag=value syntax
        lines.push(`    if (__arg.startsWith("--${f.name}=")) {`);
        lines.push(`      __flag_${f.name} = ${this._genCoercion(`__arg.slice(${f.name.length + 3})`, f.typeAnnotation, f.name)};`);
        lines.push('      continue;');
        lines.push('    }');
      }
    }

    // Unknown flags
    lines.push('    if (__arg.startsWith("--")) { console.error("Error: Unknown flag " + __arg); process.exit(1); }');

    // Collect positionals
    lines.push('    __positionals.push(__arg);');
    lines.push('  }');

    // Validate and assign positionals
    for (let i = 0; i < positionals.length; i++) {
      const p = positionals[i];
      if (!p.isOptional && !p.defaultValue) {
        lines.push(`  if (__positionals.length <= ${i}) {`);
        lines.push(`    console.error("Error: Missing required argument <${p.name}>");`);
        lines.push(`    __cli_command_help_${cmd.name}();`);
        lines.push('    process.exit(1);');
        lines.push('  }');
      }
    }

    // Build call arguments
    const callArgs = [];
    for (const p of cmd.params) {
      if (p.isFlag) {
        callArgs.push(`__flag_${p.name}`);
      } else {
        const idx = positionals.indexOf(p);
        if (p.isOptional || p.defaultValue) {
          const def = p.defaultValue ? this.genExpression(p.defaultValue) : 'undefined';
          callArgs.push(`__positionals.length > ${idx} ? ${this._genCoercion(`__positionals[${idx}]`, p.typeAnnotation, p.name)} : ${def}`);
        } else {
          callArgs.push(this._genCoercion(`__positionals[${idx}]`, p.typeAnnotation, p.name));
        }
      }
    }

    const awaitPrefix = cmd.isAsync ? 'await ' : '';
    lines.push(`  ${awaitPrefix}__cmd_${cmd.name}(${callArgs.join(', ')});`);
    lines.push('}');
    return lines.join('\n');
  }

  /**
   * Generate main entry point
   */
  _genMain(config, commands, singleCommand) {
    const lines = [];
    lines.push('async function __cli_main(argv) {');

    if (singleCommand) {
      const cmd = commands[0];
      // Single-command mode: no subcommand routing
      lines.push('  if (argv.includes("--help") || argv.includes("-h")) { __cli_help(); return; }');
      if (config.version) {
        lines.push(`  if (argv.includes("--version") || argv.includes("-v")) { console.log("${this._escStr(config.version)}"); return; }`);
      }
      lines.push(`  await __cli_dispatch_${cmd.name}(argv);`);
    } else {
      // Multi-command: subcommand routing
      lines.push('  if (argv.length === 0 || argv[0] === "--help" || argv[0] === "-h") { __cli_help(); return; }');
      if (config.version) {
        lines.push(`  if (argv[0] === "--version" || argv[0] === "-v") { console.log("${this._escStr(config.version)}"); return; }`);
      }
      lines.push('  const __subcmd = argv[0];');
      lines.push('  const __subargv = argv.slice(1);');
      lines.push('  switch (__subcmd) {');
      for (const cmd of commands) {
        lines.push(`    case "${cmd.name}": await __cli_dispatch_${cmd.name}(__subargv); break;`);
      }
      lines.push('    default:');
      lines.push('      console.error("Error: Unknown command \\"" + __subcmd + "\\"");');
      lines.push('      __cli_help();');
      lines.push('      process.exit(1);');
      lines.push('  }');
    }

    lines.push('}');
    return lines.join('\n');
  }

  /**
   * Generate type coercion code for argv string → target type
   */
  _genCoercion(expr, type, name) {
    switch (type) {
      case 'Int':
        return `(function(v) { const n = parseInt(v, 10); if (isNaN(n)) { console.error("Error: --${name} must be an integer, got \\"" + v + "\\""); process.exit(1); } return n; })(${expr})`;
      case 'Float':
        return `(function(v) { const n = parseFloat(v); if (isNaN(n)) { console.error("Error: --${name} must be a number, got \\"" + v + "\\""); process.exit(1); } return n; })(${expr})`;
      case 'Bool':
        return `(${expr} === "true" || ${expr} === "1" || ${expr} === "yes")`;
      case 'String':
      default:
        return expr;
    }
  }

  /**
   * Build a usage line for a command
   */
  _buildUsageLine(cmd, config) {
    const prefix = config.name || 'cli';
    const parts = [prefix];
    // Only show command name if multi-command
    // (Caller should decide; we always include for per-command help)
    parts.push(cmd.name);

    for (const p of cmd.params) {
      if (p.isFlag) {
        if (p.typeAnnotation === 'Bool') {
          parts.push(`[--${p.name}]`);
        } else {
          parts.push(`[--${p.name} <${p.typeAnnotation || 'value'}>]`);
        }
      } else {
        if (p.isOptional || p.defaultValue) {
          parts.push(`[${p.name}]`);
        } else {
          parts.push(`<${p.name}>`);
        }
      }
    }
    return parts.join(' ');
  }

  _getCommandDescription(cmd) {
    // Could be extended to parse docstrings — for now, just the command name
    return '';
  }

  _getDefaultStr(param) {
    if (!param.defaultValue) return '';
    if (param.defaultValue.type === 'StringLiteral') return `"${param.defaultValue.value}"`;
    if (param.defaultValue.type === 'NumberLiteral') return String(param.defaultValue.value);
    if (param.defaultValue.type === 'BooleanLiteral') return String(param.defaultValue.value);
    return '...';
  }

  _escStr(s) {
    if (!s) return '';
    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  }
}

// ─── src/codegen/edge-codegen.js ───────────────────────

// Edge/serverless code generator for the Tova language
// Produces deployment-ready code for Cloudflare Workers, Deno Deploy, Vercel Edge, AWS Lambda, or Bun.



const DEFAULT_TARGET = 'cloudflare';
class EdgeCodegen extends BaseCodegen {

  /**
   * Merge all EdgeBlock nodes with the same name into a single config.
   */
  static mergeEdgeBlocks(edgeBlocks) {
    let target = DEFAULT_TARGET;
    const routes = [];
    const functions = [];
    const middlewares = [];
    const bindings = { kv: [], sql: [], storage: [], queue: [] };
    const envVars = [];
    const secrets = [];
    const schedules = [];
    const consumers = [];
    const miscStatements = [];
    let healthPath = null;
    let healthChecks = null;
    let corsConfig = null;
    let errorHandler = null;

    for (const block of edgeBlocks) {
      for (const stmt of block.body) {
        switch (stmt.type) {
          case 'EdgeConfigField':
            if (stmt.key === 'target' && stmt.value.type === 'StringLiteral') {
              target = stmt.value.value;
            }
            break;
          case 'EdgeKVDeclaration':
            bindings.kv.push(stmt);
            break;
          case 'EdgeSQLDeclaration':
            bindings.sql.push(stmt);
            break;
          case 'EdgeStorageDeclaration':
            bindings.storage.push(stmt);
            break;
          case 'EdgeQueueDeclaration':
            bindings.queue.push(stmt);
            break;
          case 'EdgeEnvDeclaration':
            envVars.push(stmt);
            break;
          case 'EdgeSecretDeclaration':
            secrets.push(stmt);
            break;
          case 'EdgeScheduleDeclaration':
            schedules.push(stmt);
            break;
          case 'EdgeConsumeDeclaration':
            consumers.push(stmt);
            break;
          case 'RouteDeclaration':
            routes.push(stmt);
            break;
          case 'MiddlewareDeclaration':
            middlewares.push(stmt);
            break;
          case 'FunctionDeclaration':
            functions.push(stmt);
            break;
          case 'HealthCheckDeclaration':
            healthPath = stmt.path;
            if (stmt.checks && stmt.checks.length > 0) {
              if (!healthChecks) healthChecks = [];
              healthChecks.push(...stmt.checks);
            }
            break;
          case 'CorsDeclaration':
            corsConfig = stmt.config;
            break;
          case 'ErrorHandlerDeclaration':
            errorHandler = stmt;
            break;
          default:
            miscStatements.push(stmt);
            break;
        }
      }
    }

    return { target, routes, functions, middlewares, bindings, envVars, secrets, schedules, consumers, miscStatements, healthPath, healthChecks, corsConfig, errorHandler };
  }

  /**
   * Generate edge function code for the given target.
   * @param {Object} config — merged config from mergeEdgeBlocks
   * @param {string} sharedCode — shared/top-level compiled code
   * @returns {string} — complete edge function JS
   */
  generate(config, sharedCode, securityConfig = null) {
    const { target } = config;
    switch (target) {
      case 'cloudflare': return this._generateCloudflare(config, sharedCode, securityConfig);
      case 'deno': return this._generateDeno(config, sharedCode, securityConfig);
      case 'vercel': return this._generateVercel(config, sharedCode, securityConfig);
      case 'lambda': return this._generateLambda(config, sharedCode, securityConfig);
      case 'bun': return this._generateBun(config, sharedCode, securityConfig);
      default: return this._generateCloudflare(config, sharedCode, securityConfig);
    }
  }

  // ════════════════════════════════════════════════════════════
  // CORS, Health Check, Error Handler helpers
  // ════════════════════════════════════════════════════════════

  /**
   * Emit CORS helper function. Two modes:
   * - With explicit config: origin-checking __getCorsHeaders(req)
   * - Without config (empty cors {}): wildcard __getCorsHeaders()
   */
  _emitEdgeCors(lines, corsConfig) {
    if (!corsConfig) return;

    lines.push('// ── CORS ──');

    // Check if config has any meaningful keys
    const hasOrigins = corsConfig.origins;
    const hasCredentials = corsConfig.credentials;
    const hasMethods = corsConfig.methods;
    const hasHeaders = corsConfig.headers;
    const hasMaxAge = corsConfig.max_age;
    const hasExplicitConfig = hasOrigins || hasCredentials || hasMethods || hasHeaders || hasMaxAge;

    if (hasExplicitConfig) {
      const origins = hasOrigins ? this.genExpression(corsConfig.origins) : '["*"]';
      const methods = hasMethods ? this.genExpression(corsConfig.methods) + '.join(", ")' : '"GET, POST, PUT, DELETE, PATCH, OPTIONS"';
      const headers = hasHeaders ? this.genExpression(corsConfig.headers) + '.join(", ")' : '"Content-Type, Authorization"';
      const credentials = hasCredentials ? this.genExpression(corsConfig.credentials) : 'false';
      const maxAge = hasMaxAge ? 'String(' + this.genExpression(corsConfig.max_age) + ')' : '"86400"';

      lines.push(`const __corsOrigins = ${origins};`);
      lines.push('function __getCorsHeaders(req) {');
      lines.push('  const origin = (req && req.headers && req.headers.get) ? req.headers.get("Origin") : "*";');
      lines.push('  const allowed = __corsOrigins.includes("*") || __corsOrigins.includes(origin);');
      lines.push('  return {');
      lines.push(`    "Access-Control-Allow-Origin": allowed ? origin : "",`);
      lines.push(`    "Access-Control-Allow-Methods": ${methods},`);
      lines.push(`    "Access-Control-Allow-Headers": ${headers},`);
      lines.push(`    "Access-Control-Allow-Credentials": String(${credentials}),`);
      lines.push(`    "Access-Control-Max-Age": ${maxAge},`);
      lines.push('  };');
      lines.push('}');
    } else {
      // Empty cors {} — open wildcard
      lines.push('const __corsHeaders = {');
      lines.push('  "Access-Control-Allow-Origin": "*",');
      lines.push('  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",');
      lines.push('  "Access-Control-Allow-Headers": "Content-Type, Authorization",');
      lines.push('  "Access-Control-Max-Age": "86400",');
      lines.push('};');
      lines.push('function __getCorsHeaders() { return __corsHeaders; }');
    }
    lines.push('');
  }

  /**
   * Emit health check route registration.
   * @param {string[]} lines — output lines
   * @param {Object} config — merged edge config (needs healthPath, healthChecks)
   * @param {string} format — 'response' or 'lambda'
   */
  _emitEdgeHealthCheck(lines, config, format) {
    if (!config.healthPath) return;

    lines.push('// ── Health Check ──');
    const path = config.healthPath;
    const regexStr = '^' + path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$';

    lines.push(`__routes.push({ method: "GET", pattern: new RegExp(${JSON.stringify(regexStr)}), paramNames: [], handler: async () => {`);

    if (config.healthChecks && config.healthChecks.length > 0) {
      lines.push('  const checks = {};');
      lines.push('  let status = "healthy";');
      if (config.healthChecks.includes('check_memory')) {
        lines.push('  const mem = process.memoryUsage ? process.memoryUsage() : { heapUsed: 0, heapTotal: 1 };');
        lines.push('  const heapPct = mem.heapUsed / mem.heapTotal;');
        lines.push('  checks.memory = { status: heapPct > 0.9 ? "degraded" : "healthy", heapUsed: mem.heapUsed, heapTotal: mem.heapTotal };');
        lines.push('  if (heapPct > 0.9) status = "degraded";');
      }
      if (format === 'lambda') {
        lines.push('  return { statusCode: 200, headers: { "Content-Type": "application/json" }, body: JSON.stringify({ status, checks, timestamp: new Date().toISOString() }) };');
      } else {
        lines.push('  return Response.json({ status, checks, timestamp: new Date().toISOString() });');
      }
    } else {
      if (format === 'lambda') {
        lines.push('  return { statusCode: 200, headers: { "Content-Type": "application/json" }, body: JSON.stringify({ status: "ok" }) };');
      } else {
        lines.push('  return Response.json({ status: "ok" });');
      }
    }

    lines.push('}});');
    lines.push('');
  }

  /**
   * Emit error handler function from ErrorHandlerDeclaration.
   */
  _emitEdgeErrorHandler(lines, errorHandler) {
    if (!errorHandler) return;

    const params = errorHandler.params.map(p => p.name || this.genExpression(p)).join(', ');
    this.pushScope();
    for (const p of errorHandler.params) this.declareVar(p.name);
    const body = this.genBlockBody(errorHandler.body);
    this.popScope();

    lines.push('// ── Error Handler ──');
    lines.push(`async function __errorHandler(${params}) {`);
    lines.push(body);
    lines.push('}');
    lines.push('');
  }

  /**
   * Generate catch block with optional error handler.
   * @param {string[]} lines — output lines
   * @param {boolean} hasErrorHandler — whether __errorHandler is defined
   * @param {boolean} hasCors — whether CORS headers should be merged
   * @param {string} format — 'response' or 'lambda'
   * @param {string} indent — indentation prefix
   * @param {string} reqVar — name of the request variable
   */
  _emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, format, indent, reqVar) {
    lines.push(`${indent}} catch (e) {`);

    if (hasErrorHandler) {
      lines.push(`${indent}  if (typeof __errorHandler === "function") {`);
      lines.push(`${indent}    try {`);
      lines.push(`${indent}      const __errResult = await __errorHandler(e, ${reqVar});`);

      if (format === 'lambda') {
        lines.push(`${indent}      if (__errResult && __errResult.statusCode) return __errResult;`);
        const lambdaHeaders = hasCors
          ? `{ "Content-Type": "application/json", ...__getCorsHeaders(${reqVar}) }`
          : '{ "Content-Type": "application/json" }';
        lines.push(`${indent}      return { statusCode: 500, headers: ${lambdaHeaders}, body: JSON.stringify(__errResult) };`);
      } else {
        lines.push(`${indent}      if (__errResult instanceof Response) return __errResult;`);
        const respHeaders = hasCors
          ? `{ "Content-Type": "application/json", ...__getCorsHeaders(${reqVar}) }`
          : '{ "Content-Type": "application/json" }';
        lines.push(`${indent}      return new Response(JSON.stringify(__errResult), { status: 500, headers: ${respHeaders} });`);
      }
      lines.push(`${indent}    } catch (_) {}`);
      lines.push(`${indent}  }`);
    }

    if (format === 'lambda') {
      const fallbackHeaders = hasCors
        ? `{ "Content-Type": "application/json", ...__getCorsHeaders(${reqVar}) }`
        : '{ "Content-Type": "application/json" }';
      lines.push(`${indent}  return { statusCode: 500, headers: ${fallbackHeaders}, body: JSON.stringify({ error: e.message }) };`);
    } else {
      if (hasCors) {
        lines.push(`${indent}  return new Response(JSON.stringify({ error: e.message }), {`);
        lines.push(`${indent}    status: 500,`);
        lines.push(`${indent}    headers: { "Content-Type": "application/json", ...__getCorsHeaders(${reqVar}) }`);
        lines.push(`${indent}  });`);
      } else {
        lines.push(`${indent}  return new Response(JSON.stringify({ error: e.message }), {`);
        lines.push(`${indent}    status: 500,`);
        lines.push(`${indent}    headers: { "Content-Type": "application/json" }`);
        lines.push(`${indent}  });`);
      }
    }
    lines.push(`${indent}}`);
  }

  // ════════════════════════════════════════════════════════════
  // Security helpers
  // ════════════════════════════════════════════════════════════

  /**
   * Emit security code (roles, auth, protection, sanitization) from security block config.
   * Returns { hasAuth, hasProtect, hasAutoSanitize } flags.
   */
  _emitEdgeSecurity(lines, securityConfig) {
    const noSec = { hasAuth: false, hasProtect: false, hasAutoSanitize: false };
    if (!securityConfig) return noSec;

    const _SecurityCodegen = SecurityCodegen;
    const secGen = new _SecurityCodegen();
    const fragments = secGen.generateServerSecurity(securityConfig);

    if (fragments.roleDefinitions) {
      lines.push(fragments.roleDefinitions);
      lines.push('');
    }
    if (fragments.protectCode) {
      lines.push(fragments.protectCode);
      lines.push('');
    }
    if (fragments.sensitiveCode) {
      lines.push(fragments.sensitiveCode);
      lines.push('');
    }
    if (fragments.cspCode) {
      lines.push(fragments.cspCode);
      lines.push('');
    }
    if (fragments.auditCode) {
      lines.push(fragments.auditCode);
      lines.push('');
    }

    const hasAuth = this._emitEdgeAuth(lines, securityConfig);

    return {
      hasAuth,
      hasProtect: !!fragments.protectCode,
      hasAutoSanitize: fragments.hasAutoSanitize,
    };
  }

  /**
   * Emit JWT auth verification function for edge runtimes.
   * Uses Web Crypto API (available on all edge targets).
   */
  _emitEdgeAuth(lines, securityConfig) {
    if (!securityConfig.auth) return false;

    const authType = securityConfig.auth.authType;
    if (authType !== 'jwt') return false;

    const secret = securityConfig.auth.config.secret
      ? this.genExpression(securityConfig.auth.config.secret)
      : 'undefined';

    lines.push('// ── Edge Auth (JWT) ──');
    lines.push(`const __authSecret = ${secret};`);
    lines.push('async function __authenticate(request) {');
    lines.push('  const __authHdr = (request.headers && request.headers.get) ? request.headers.get("authorization") : (request.headers && (request.headers["Authorization"] || request.headers["authorization"]));');
    lines.push('  if (!__authHdr || !__authHdr.startsWith("Bearer ")) return null;');
    lines.push('  const __token = __authHdr.slice(7);');
    lines.push('  try {');
    lines.push('    const [__hB64, __pB64, __sB64] = __token.split(".");');
    lines.push('    if (!__hB64 || !__pB64 || !__sB64) return null;');
    lines.push('    const __b64d = (s) => atob(s.replace(/-/g, "+").replace(/_/g, "/"));');
    lines.push('    const __hdr = JSON.parse(__b64d(__hB64));');
    lines.push('    if (__hdr.alg !== "HS256") return null;');
    lines.push('    const __payload = JSON.parse(__b64d(__pB64));');
    lines.push('    if (__payload.exp && __payload.exp < Date.now() / 1000) return null;');
    lines.push('    const __enc = new TextEncoder();');
    lines.push('    const __key = await crypto.subtle.importKey("raw", __enc.encode(__authSecret), { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);');
    lines.push('    const __sigBytes = Uint8Array.from(__b64d(__sB64), c => c.charCodeAt(0));');
    lines.push('    const __valid = await crypto.subtle.verify("HMAC", __key, __sigBytes, __enc.encode(__hB64 + "." + __pB64));');
    lines.push('    if (!__valid) return null;');
    lines.push('    return __payload;');
    lines.push('  } catch (_) { return null; }');
    lines.push('}');
    lines.push('');
    return true;
  }

  /**
   * Emit inline security check (auth + protection) in request handler.
   * @returns {string} The user variable name ('__user' or 'null')
   */
  _emitEdgeSecurityCheck(lines, secFlags, format, indent, reqVar, hasCors) {
    if (!secFlags.hasAuth && !secFlags.hasProtect) return 'null';

    const userVar = secFlags.hasAuth ? '__user' : 'null';

    if (secFlags.hasAuth) {
      lines.push(`${indent}const __user = await __authenticate(${reqVar});`);
    }

    if (secFlags.hasProtect) {
      lines.push(`${indent}const __prot = __checkProtection(pathname, ${userVar});`);
      lines.push(`${indent}if (!__prot.allowed) {`);
      if (format === 'lambda') {
        const hdr = hasCors
          ? `{ "Content-Type": "application/json", ...__getCorsHeaders(${reqVar}) }`
          : '{ "Content-Type": "application/json" }';
        lines.push(`${indent}  return { statusCode: ${secFlags.hasAuth ? '(__user ? 403 : 401)' : '403'}, headers: ${hdr}, body: JSON.stringify({ error: __prot.reason }) };`);
      } else {
        const hdr = hasCors
          ? `{ "Content-Type": "application/json", ...__getCorsHeaders(${reqVar}) }`
          : '{ "Content-Type": "application/json" }';
        lines.push(`${indent}  return new Response(JSON.stringify({ error: __prot.reason }), { status: ${secFlags.hasAuth ? '(__user ? 403 : 401)' : '403'}, headers: ${hdr} });`);
      }
      lines.push(`${indent}}`);
      lines.push('');
    }

    return userVar;
  }

  // ════════════════════════════════════════════════════════════
  // Binding helpers
  // ════════════════════════════════════════════════════════════

  /**
   * Generate the ` ?? defaultExpr` suffix for an env declaration.
   */
  _genDefaultSuffix(envDecl) {
    if (envDecl.defaultValue) {
      return ' ?? ' + this.genExpression(envDecl.defaultValue);
    }
    return '';
  }

  /**
   * Cloudflare bindings: module-level `let` declarations + init lines for fetch/scheduled/queue.
   * Returns { moduleLines: string[], fetchInitLines: string[] }
   */
  _emitCloudflareBindings(config) {
    const moduleLines = [];
    const fetchInitLines = [];
    const allBindings = [
      ...config.bindings.kv,
      ...config.bindings.sql,
      ...config.bindings.storage,
      ...config.bindings.queue,
    ];
    const allEnvSecrets = [...config.envVars, ...config.secrets];

    if (allBindings.length === 0 && allEnvSecrets.length === 0) {
      return { moduleLines, fetchInitLines };
    }

    // Module-level let declarations
    const names = [
      ...allBindings.map(b => b.name),
      ...allEnvSecrets.map(b => b.name),
    ];
    moduleLines.push('// ── Bindings ──');
    moduleLines.push('let ' + names.join(', ') + ';');
    moduleLines.push('');

    // Fetch init lines (inside fetch/scheduled/queue handlers)
    for (const b of allBindings) {
      fetchInitLines.push(`    ${b.name} = env.${b.name};`);
    }
    for (const e of config.envVars) {
      fetchInitLines.push(`    ${e.name} = env.${e.name}${this._genDefaultSuffix(e)};`);
    }
    for (const s of config.secrets) {
      fetchInitLines.push(`    ${s.name} = env.${s.name};`);
    }

    return { moduleLines, fetchInitLines };
  }

  /**
   * Deno bindings: top-level const declarations.
   */
  _emitDenoBindings(lines, config) {
    const hasKv = config.bindings.kv.length > 0;
    const hasAnything = hasKv || config.bindings.sql.length > 0 ||
      config.bindings.storage.length > 0 || config.bindings.queue.length > 0 ||
      config.envVars.length > 0 || config.secrets.length > 0;

    if (!hasAnything) return;

    lines.push('// ── Bindings ──');

    // KV — first one opens the store, rest share
    if (hasKv) {
      lines.push(`const ${config.bindings.kv[0].name} = await Deno.openKv();`);
      for (let i = 1; i < config.bindings.kv.length; i++) {
        lines.push(`const ${config.bindings.kv[i].name} = ${config.bindings.kv[0].name}; // shared Deno KV store`);
      }
    }

    // Unsupported stubs
    for (const b of config.bindings.sql) {
      lines.push(`const ${b.name} = null; // SQL not natively supported on Deno Deploy — use a third-party driver`);
    }
    for (const b of config.bindings.storage) {
      lines.push(`const ${b.name} = null; // Object storage not natively supported on Deno Deploy`);
    }
    for (const b of config.bindings.queue) {
      lines.push(`const ${b.name} = null; // Queues not natively supported on Deno Deploy`);
    }

    // Env/Secret
    for (const e of config.envVars) {
      lines.push(`const ${e.name} = Deno.env.get(${JSON.stringify(e.name)})${this._genDefaultSuffix(e)};`);
    }
    for (const s of config.secrets) {
      lines.push(`const ${s.name} = Deno.env.get(${JSON.stringify(s.name)});`);
    }

    lines.push('');
  }

  /**
   * Process.env-based bindings (Vercel, Lambda).
   * Only env/secret are supported; others become stubs.
   */
  _emitProcessEnvBindings(lines, config, targetName) {
    const hasAnything = config.bindings.kv.length > 0 || config.bindings.sql.length > 0 ||
      config.bindings.storage.length > 0 || config.bindings.queue.length > 0 ||
      config.envVars.length > 0 || config.secrets.length > 0;

    if (!hasAnything) return;

    lines.push('// ── Bindings ──');

    // Unsupported stubs
    for (const b of config.bindings.kv) {
      lines.push(`const ${b.name} = null; // KV not supported on ${targetName}`);
    }
    for (const b of config.bindings.sql) {
      lines.push(`const ${b.name} = null; // SQL not supported on ${targetName}`);
    }
    for (const b of config.bindings.storage) {
      lines.push(`const ${b.name} = null; // Object storage not supported on ${targetName}`);
    }
    for (const b of config.bindings.queue) {
      lines.push(`const ${b.name} = null; // Queues not supported on ${targetName}`);
    }

    // Env/Secret via process.env
    for (const e of config.envVars) {
      lines.push(`const ${e.name} = process.env.${e.name}${this._genDefaultSuffix(e)};`);
    }
    for (const s of config.secrets) {
      lines.push(`const ${s.name} = process.env.${s.name};`);
    }

    lines.push('');
  }

  /**
   * Bun bindings: SQL via bun:sqlite, env via process.env, others stub.
   * Returns { imports: string[], bindings: string[] }
   */
  _emitBunBindings(config) {
    const imports = [];
    const bindings = [];
    const hasAnything = config.bindings.kv.length > 0 || config.bindings.sql.length > 0 ||
      config.bindings.storage.length > 0 || config.bindings.queue.length > 0 ||
      config.envVars.length > 0 || config.secrets.length > 0;

    if (!hasAnything) return { imports, bindings };

    bindings.push('// ── Bindings ──');

    // KV stub
    for (const b of config.bindings.kv) {
      bindings.push(`const ${b.name} = null; // KV not natively supported on Bun — use a third-party store`);
    }

    // SQL via bun:sqlite
    if (config.bindings.sql.length > 0) {
      imports.push('import { Database } from "bun:sqlite";');
      for (const b of config.bindings.sql) {
        bindings.push(`const ${b.name} = new Database("${b.name}.sqlite");`);
      }
    }

    // Storage/Queue stubs
    for (const b of config.bindings.storage) {
      bindings.push(`const ${b.name} = null; // Object storage not natively supported on Bun`);
    }
    for (const b of config.bindings.queue) {
      bindings.push(`const ${b.name} = null; // Queues not natively supported on Bun`);
    }

    // Env/Secret via process.env
    for (const e of config.envVars) {
      bindings.push(`const ${e.name} = process.env.${e.name}${this._genDefaultSuffix(e)};`);
    }
    for (const s of config.secrets) {
      bindings.push(`const ${s.name} = process.env.${s.name};`);
    }

    bindings.push('');
    return { imports, bindings };
  }

  // ════════════════════════════════════════════════════════════
  // Cloudflare Workers target
  // ════════════════════════════════════════════════════════════

  _generateCloudflare(config, sharedCode, securityConfig) {
    const lines = [];
    const hasCors = !!config.corsConfig;
    const hasErrorHandler = !!config.errorHandler;

    lines.push('// Generated by Tova — Cloudflare Workers target');
    lines.push('');

    // Shared code
    if (sharedCode && sharedCode.trim()) {
      lines.push(sharedCode);
      lines.push('');
    }

    // Binding declarations (module-level let + fetch init lines)
    const { moduleLines, fetchInitLines } = this._emitCloudflareBindings(config);
    for (const l of moduleLines) lines.push(l);

    // User functions
    this._emitFunctions(lines, config.functions);

    // Misc statements (assignments, etc.)
    this._emitMiscStatements(lines, config.miscStatements);

    // CORS
    this._emitEdgeCors(lines, config.corsConfig);

    // Error handler
    this._emitEdgeErrorHandler(lines, config.errorHandler);

    // Security (roles, auth, protection, sanitization)
    const secFlags = this._emitEdgeSecurity(lines, securityConfig);

    // Middleware chain
    this._emitMiddlewareFunctions(lines, config.middlewares);

    // Route matching helper
    this._emitRouteMatchHelper(lines);

    // Build route table
    lines.push('// ── Route Table ──');
    lines.push('const __routes = [];');
    this._emitRouteRegistrations(lines, config.routes);

    // Health check route
    this._emitEdgeHealthCheck(lines, config, 'response');
    lines.push('');

    // Fetch handler
    lines.push('export default {');
    lines.push('  async fetch(request, env, ctx) {');

    // Init bindings from env
    for (const l of fetchInitLines) lines.push(l);

    lines.push('    const url = new URL(request.url);');
    lines.push('    const method = request.method;');
    lines.push('    const pathname = url.pathname;');
    lines.push('');

    // OPTIONS preflight
    if (hasCors) {
      lines.push('    if (request.method === "OPTIONS") {');
      lines.push('      return new Response(null, { status: 204, headers: __getCorsHeaders(request) });');
      lines.push('    }');
      lines.push('');
    }

    // Security check (auth + protection)
    const userVar = this._emitEdgeSecurityCheck(lines, secFlags, 'response', '    ', 'request', hasCors);
    const sanitize = secFlags.hasAutoSanitize;

    // Middleware wrapping
    if (config.middlewares.length > 0) {
      lines.push('    // Apply middleware chain');
      lines.push('    const __handler = async (req) => {');
      lines.push('      const __match = __matchRoute(method, pathname, __routes);');
      lines.push('      if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('      return __match.handler(req, __match.params, env);');
      lines.push('    };');
      let chain = '__handler';
      for (let i = config.middlewares.length - 1; i >= 0; i--) {
        const mw = config.middlewares[i];
        chain = `(req) => __mw_${mw.name}(req, ${chain})`;
      }
      lines.push('    try {');
      lines.push(`      const __result = await (${chain})(request);`);
      lines.push('      if (__result instanceof Response) return __result;');
      const mwVal = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`      return new Response(JSON.stringify(${mwVal}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`      return Response.json(${mwVal});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '    ', 'request');
    } else {
      lines.push('    const __match = __matchRoute(method, pathname, __routes);');
      lines.push('    if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('');
      lines.push('    try {');
      lines.push('      const __result = await __match.handler(request, __match.params, env);');
      lines.push('      if (__result instanceof Response) return __result;');
      const val = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`      return new Response(JSON.stringify(${val}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`      return Response.json(${val});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '    ', 'request');
    }
    lines.push('  },');

    // Scheduled handler
    if (config.schedules.length > 0) {
      lines.push('');
      lines.push('  async scheduled(event, env, ctx) {');
      // Init bindings in scheduled handler too
      for (const l of fetchInitLines) lines.push(l);
      for (let si = 0; si < config.schedules.length; si++) {
        const sched = config.schedules[si];
        const kw = si === 0 ? 'if' : 'else if';
        lines.push(`    ${kw} (event.cron === ${JSON.stringify(sched.cron)}) {`);
        lines.push(`      // ${sched.name}`);
        const body = this.genBlockStatements(sched.body);
        for (const line of body.split('\n')) {
          lines.push('      ' + line);
        }
        lines.push('    }');
      }
      lines.push('  },');
    }

    // Queue consumer
    if (config.consumers.length > 0) {
      lines.push('');
      lines.push('  async queue(batch, env, ctx) {');
      // Init bindings in queue handler too
      for (const l of fetchInitLines) lines.push(l);
      for (const consumer of config.consumers) {
        lines.push(`    // consume ${consumer.queue}`);
        const handlerCode = this.genExpression(consumer.handler);
        lines.push(`    await (${handlerCode})(batch.messages);`);
      }
      lines.push('  },');
    }

    lines.push('};');

    return lines.join('\n');
  }

  // ════════════════════════════════════════════════════════════
  // Deno Deploy target
  // ════════════════════════════════════════════════════════════

  _generateDeno(config, sharedCode, securityConfig) {
    const lines = [];
    const hasCors = !!config.corsConfig;
    const hasErrorHandler = !!config.errorHandler;

    lines.push('// Generated by Tova — Deno Deploy target');
    lines.push('');

    // Shared code
    if (sharedCode && sharedCode.trim()) {
      lines.push(sharedCode);
      lines.push('');
    }

    // Bindings
    this._emitDenoBindings(lines, config);

    // User functions
    this._emitFunctions(lines, config.functions);

    // Misc statements
    this._emitMiscStatements(lines, config.miscStatements);

    // CORS
    this._emitEdgeCors(lines, config.corsConfig);

    // Error handler
    this._emitEdgeErrorHandler(lines, config.errorHandler);

    // Security
    const secFlags = this._emitEdgeSecurity(lines, securityConfig);

    // Middleware
    this._emitMiddlewareFunctions(lines, config.middlewares);

    // Route matching helper
    this._emitRouteMatchHelper(lines);

    // Build route table
    lines.push('// ── Route Table ──');
    lines.push('const __routes = [];');
    this._emitRouteRegistrations(lines, config.routes);

    // Health check route
    this._emitEdgeHealthCheck(lines, config, 'response');
    lines.push('');

    // Cron schedules
    for (const sched of config.schedules) {
      lines.push(`Deno.cron(${JSON.stringify(sched.name)}, ${JSON.stringify(sched.cron)}, async () => {`);
      const body = this.genBlockStatements(sched.body);
      for (const line of body.split('\n')) {
        lines.push('  ' + line);
      }
      lines.push('});');
      lines.push('');
    }

    // Server
    lines.push('Deno.serve(async (request) => {');
    lines.push('  const url = new URL(request.url);');
    lines.push('  const method = request.method;');
    lines.push('  const pathname = url.pathname;');
    lines.push('');

    // OPTIONS preflight
    if (hasCors) {
      lines.push('  if (request.method === "OPTIONS") {');
      lines.push('    return new Response(null, { status: 204, headers: __getCorsHeaders(request) });');
      lines.push('  }');
      lines.push('');
    }

    // Security check
    const userVar = this._emitEdgeSecurityCheck(lines, secFlags, 'response', '  ', 'request', hasCors);
    const sanitize = secFlags.hasAutoSanitize;

    if (config.middlewares.length > 0) {
      lines.push('  const __handler = async (req) => {');
      lines.push('    const __match = __matchRoute(method, pathname, __routes);');
      lines.push('    if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('    return __match.handler(req, __match.params);');
      lines.push('  };');
      let chain = '__handler';
      for (let i = config.middlewares.length - 1; i >= 0; i--) {
        const mw = config.middlewares[i];
        chain = `(req) => __mw_${mw.name}(req, ${chain})`;
      }
      lines.push('  try {');
      lines.push(`    const __result = await (${chain})(request);`);
      lines.push('    if (__result instanceof Response) return __result;');
      const mwVal = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`    return new Response(JSON.stringify(${mwVal}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`    return Response.json(${mwVal});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '  ', 'request');
    } else {
      lines.push('  const __match = __matchRoute(method, pathname, __routes);');
      lines.push('  if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('');
      lines.push('  try {');
      lines.push('    const __result = await __match.handler(request, __match.params);');
      lines.push('    if (__result instanceof Response) return __result;');
      const val = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`    return new Response(JSON.stringify(${val}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`    return Response.json(${val});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '  ', 'request');
    }
    lines.push('});');

    return lines.join('\n');
  }

  // ════════════════════════════════════════════════════════════
  // Vercel Edge target
  // ════════════════════════════════════════════════════════════

  _generateVercel(config, sharedCode, securityConfig) {
    const lines = [];
    const hasCors = !!config.corsConfig;
    const hasErrorHandler = !!config.errorHandler;

    lines.push('// Generated by Tova — Vercel Edge target');
    lines.push('');
    lines.push('export const config = { runtime: "edge" };');
    lines.push('');

    if (sharedCode && sharedCode.trim()) {
      lines.push(sharedCode);
      lines.push('');
    }

    // Bindings
    this._emitProcessEnvBindings(lines, config, 'Vercel Edge');

    this._emitFunctions(lines, config.functions);
    this._emitMiscStatements(lines, config.miscStatements);

    // CORS
    this._emitEdgeCors(lines, config.corsConfig);

    // Error handler
    this._emitEdgeErrorHandler(lines, config.errorHandler);

    // Security
    const secFlags = this._emitEdgeSecurity(lines, securityConfig);

    this._emitMiddlewareFunctions(lines, config.middlewares);

    this._emitRouteMatchHelper(lines);

    lines.push('const __routes = [];');
    this._emitRouteRegistrations(lines, config.routes);

    // Health check route
    this._emitEdgeHealthCheck(lines, config, 'response');
    lines.push('');

    lines.push('export default async function handler(request) {');
    lines.push('  const url = new URL(request.url);');
    lines.push('  const method = request.method;');
    lines.push('  const pathname = url.pathname;');

    // OPTIONS preflight
    if (hasCors) {
      lines.push('  if (request.method === "OPTIONS") {');
      lines.push('    return new Response(null, { status: 204, headers: __getCorsHeaders(request) });');
      lines.push('  }');
    }

    // Security check
    const userVar = this._emitEdgeSecurityCheck(lines, secFlags, 'response', '  ', 'request', hasCors);
    const sanitize = secFlags.hasAutoSanitize;

    if (config.middlewares.length > 0) {
      lines.push('  // Apply middleware chain');
      lines.push('  const __handler = async (req) => {');
      lines.push('    const __match = __matchRoute(method, pathname, __routes);');
      lines.push('    if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('    return __match.handler(req, __match.params);');
      lines.push('  };');
      let chain = '__handler';
      for (let i = config.middlewares.length - 1; i >= 0; i--) {
        const mw = config.middlewares[i];
        chain = `(req) => __mw_${mw.name}(req, ${chain})`;
      }
      lines.push('  try {');
      lines.push(`    const __result = await (${chain})(request);`);
      lines.push('    if (__result instanceof Response) return __result;');
      const mwVal = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`    return new Response(JSON.stringify(${mwVal}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`    return Response.json(${mwVal});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '  ', 'request');
    } else {
      lines.push('  const __match = __matchRoute(method, pathname, __routes);');
      lines.push('  if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('  try {');
      lines.push('    const __result = await __match.handler(request, __match.params);');
      lines.push('    if (__result instanceof Response) return __result;');
      const val = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`    return new Response(JSON.stringify(${val}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`    return Response.json(${val});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '  ', 'request');
    }
    lines.push('}');

    return lines.join('\n');
  }

  // ════════════════════════════════════════════════════════════
  // AWS Lambda target
  // ════════════════════════════════════════════════════════════

  _generateLambda(config, sharedCode, securityConfig) {
    const lines = [];
    const hasCors = !!config.corsConfig;
    const hasErrorHandler = !!config.errorHandler;

    lines.push('// Generated by Tova — AWS Lambda target');
    lines.push('');

    if (sharedCode && sharedCode.trim()) {
      lines.push(sharedCode);
      lines.push('');
    }

    // Bindings
    this._emitProcessEnvBindings(lines, config, 'AWS Lambda');

    this._emitFunctions(lines, config.functions);
    this._emitMiscStatements(lines, config.miscStatements);

    // CORS
    this._emitEdgeCors(lines, config.corsConfig);

    // Error handler
    this._emitEdgeErrorHandler(lines, config.errorHandler);

    // Security
    const secFlags = this._emitEdgeSecurity(lines, securityConfig);

    this._emitMiddlewareFunctions(lines, config.middlewares);

    this._emitRouteMatchHelper(lines);

    lines.push('const __routes = [];');
    this._emitRouteRegistrations(lines, config.routes);

    // Health check route
    this._emitEdgeHealthCheck(lines, config, 'lambda');
    lines.push('');

    // Lambda handler — translate API Gateway event to Request-like object
    lines.push('export const handler = async (event, context) => {');
    lines.push('  const method = event.httpMethod || (event.requestContext && event.requestContext.http && event.requestContext.http.method) || "GET";');
    lines.push('  const pathname = event.path || event.rawPath || "/";');
    lines.push('  const __rawHeaders = event.headers || {};');
    lines.push('  const headers = { ...__rawHeaders, get: (k) => __rawHeaders[k] || __rawHeaders[k.toLowerCase()] || __rawHeaders[k.charAt(0).toUpperCase() + k.slice(1).toLowerCase()] || null };');
    lines.push('  const body = event.body ? (event.isBase64Encoded ? Buffer.from(event.body, "base64").toString() : event.body) : null;');
    lines.push('  const request = { method, path: pathname, headers, body, json: () => JSON.parse(body || "{}"), url: "https://lambda.local" + pathname };');
    lines.push('');

    // OPTIONS preflight
    if (hasCors) {
      lines.push('  if (method === "OPTIONS") {');
      lines.push('    return { statusCode: 204, headers: __getCorsHeaders(request) };');
      lines.push('  }');
      lines.push('');
    }

    // Security check
    const userVar = this._emitEdgeSecurityCheck(lines, secFlags, 'lambda', '  ', 'request', hasCors);
    const sanitize = secFlags.hasAutoSanitize;

    if (config.middlewares.length > 0) {
      lines.push('  // Apply middleware chain');
      lines.push('  const __handler = async (req) => {');
      lines.push('    const __match = __matchRoute(method, pathname, __routes);');
      lines.push('    if (!__match) return { statusCode: 404, headers: { "Content-Type": "application/json" }, body: JSON.stringify({ error: "Not Found" }) };');
      lines.push('    const __r = await __match.handler(req, __match.params);');
      lines.push('    if (__r && __r.statusCode) return __r;');
      const mwValInner = sanitize ? `__autoSanitize(__r, ${userVar})` : '__r';
      if (hasCors) {
        lines.push(`    return { statusCode: 200, headers: { "Content-Type": "application/json", ...__getCorsHeaders(req) }, body: JSON.stringify(${mwValInner}) };`);
      } else {
        lines.push(`    return { statusCode: 200, headers: { "Content-Type": "application/json" }, body: JSON.stringify(${mwValInner}) };`);
      }
      lines.push('  };');
      let chain = '__handler';
      for (let i = config.middlewares.length - 1; i >= 0; i--) {
        const mw = config.middlewares[i];
        chain = `(req) => __mw_${mw.name}(req, ${chain})`;
      }
      lines.push('  try {');
      lines.push(`    const __result = await (${chain})(request);`);
      lines.push('    if (__result && __result.statusCode) return __result;');
      const mwVal = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`    return { statusCode: 200, headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) }, body: JSON.stringify(${mwVal}) };`);
      } else {
        lines.push(`    return { statusCode: 200, headers: { "Content-Type": "application/json" }, body: JSON.stringify(${mwVal}) };`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'lambda', '  ', 'request');
    } else {
      lines.push('  const __match = __matchRoute(method, pathname, __routes);');
      lines.push('  if (!__match) return { statusCode: 404, headers: { "Content-Type": "application/json" }, body: JSON.stringify({ error: "Not Found" }) };');
      lines.push('');
      lines.push('  try {');
      lines.push('    const __result = await __match.handler(request, __match.params);');
      lines.push('    if (__result && __result.statusCode) return __result;');
      const val = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`    return { statusCode: 200, headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) }, body: JSON.stringify(${val}) };`);
      } else {
        lines.push(`    return { statusCode: 200, headers: { "Content-Type": "application/json" }, body: JSON.stringify(${val}) };`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'lambda', '  ', 'request');
    }
    lines.push('};');

    return lines.join('\n');
  }

  // ════════════════════════════════════════════════════════════
  // Bun target (similar to existing server but edge-optimized)
  // ════════════════════════════════════════════════════════════

  _generateBun(config, sharedCode, securityConfig) {
    const lines = [];
    const hasCors = !!config.corsConfig;
    const hasErrorHandler = !!config.errorHandler;

    lines.push('// Generated by Tova — Bun edge target');
    lines.push('');

    // Bun bindings (imports go first)
    const { imports: bunImports, bindings: bunBindings } = this._emitBunBindings(config);
    for (const imp of bunImports) lines.push(imp);
    if (bunImports.length > 0) lines.push('');

    if (sharedCode && sharedCode.trim()) {
      lines.push(sharedCode);
      lines.push('');
    }

    // Binding declarations
    for (const l of bunBindings) lines.push(l);

    this._emitFunctions(lines, config.functions);
    this._emitMiscStatements(lines, config.miscStatements);

    // CORS
    this._emitEdgeCors(lines, config.corsConfig);

    // Error handler
    this._emitEdgeErrorHandler(lines, config.errorHandler);

    // Security
    const secFlags = this._emitEdgeSecurity(lines, securityConfig);

    this._emitMiddlewareFunctions(lines, config.middlewares);

    this._emitRouteMatchHelper(lines);

    lines.push('const __routes = [];');
    this._emitRouteRegistrations(lines, config.routes);

    // Health check route
    this._emitEdgeHealthCheck(lines, config, 'response');
    lines.push('');

    lines.push('Bun.serve({');
    lines.push('  port: process.env.PORT || 3000,');
    lines.push('  async fetch(request) {');
    lines.push('    const url = new URL(request.url);');
    lines.push('    const method = request.method;');
    lines.push('    const pathname = url.pathname;');

    // OPTIONS preflight
    if (hasCors) {
      lines.push('    if (request.method === "OPTIONS") {');
      lines.push('      return new Response(null, { status: 204, headers: __getCorsHeaders(request) });');
      lines.push('    }');
    }

    // Security check
    const userVar = this._emitEdgeSecurityCheck(lines, secFlags, 'response', '    ', 'request', hasCors);
    const sanitize = secFlags.hasAutoSanitize;

    if (config.middlewares.length > 0) {
      lines.push('    const __handler = async (req) => {');
      lines.push('      const __match = __matchRoute(method, pathname, __routes);');
      lines.push('      if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('      return __match.handler(req, __match.params);');
      lines.push('    };');
      let chain = '__handler';
      for (let i = config.middlewares.length - 1; i >= 0; i--) {
        const mw = config.middlewares[i];
        chain = `(req) => __mw_${mw.name}(req, ${chain})`;
      }
      lines.push('    try {');
      lines.push(`      const __result = await (${chain})(request);`);
      lines.push('      if (__result instanceof Response) return __result;');
      const mwVal = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`      return new Response(JSON.stringify(${mwVal}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`      return Response.json(${mwVal});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '    ', 'request');
    } else {
      lines.push('    const __match = __matchRoute(method, pathname, __routes);');
      lines.push('    if (!__match) return new Response("Not Found", { status: 404 });');
      lines.push('    try {');
      lines.push('      const __result = await __match.handler(request, __match.params);');
      lines.push('      if (__result instanceof Response) return __result;');
      const val = sanitize ? `__autoSanitize(__result, ${userVar})` : '__result';
      if (hasCors) {
        lines.push(`      return new Response(JSON.stringify(${val}), { headers: { "Content-Type": "application/json", ...__getCorsHeaders(request) } });`);
      } else {
        lines.push(`      return Response.json(${val});`);
      }
      this._emitEdgeCatchBlock(lines, hasErrorHandler, hasCors, 'response', '    ', 'request');
    }
    lines.push('  }');
    lines.push('});');

    return lines.join('\n');
  }

  // ════════════════════════════════════════════════════════════
  // Shared helpers
  // ════════════════════════════════════════════════════════════

  _emitRouteMatchHelper(lines) {
    lines.push('// ── Route Matching ──');
    lines.push('function __matchRoute(method, pathname, routes) {');
    lines.push('  for (const route of routes) {');
    lines.push('    if (route.method !== method && route.method !== "*") continue;');
    lines.push('    const match = route.pattern.exec(pathname);');
    lines.push('    if (match) {');
    lines.push('      const params = {};');
    lines.push('      for (let i = 0; i < route.paramNames.length; i++) {');
    lines.push('        params[route.paramNames[i]] = match[i + 1];');
    lines.push('      }');
    lines.push('      return { handler: route.handler, params };');
    lines.push('    }');
    lines.push('  }');
    lines.push('  return null;');
    lines.push('}');
    lines.push('');
  }

  _emitFunctions(lines, functions) {
    if (functions.length === 0) return;
    lines.push('// ── Functions ──');
    for (const fn of functions) {
      const code = this.generateStatement(fn);
      lines.push(code);
      lines.push('');
    }
  }

  _emitMiscStatements(lines, stmts) {
    for (const stmt of stmts) {
      const code = this.generateStatement(stmt);
      if (code && code.trim()) {
        lines.push(code);
      }
    }
  }

  _emitMiddlewareFunctions(lines, middlewares) {
    if (middlewares.length === 0) return;
    lines.push('// ── Middleware ──');
    for (const mw of middlewares) {
      const params = mw.params.map(p => p.name || this.genExpression(p)).join(', ');
      const body = this.genBlockStatements(mw.body);
      lines.push(`async function __mw_${mw.name}(${params}) {`);
      lines.push(body);
      lines.push('}');
      lines.push('');
    }
  }

  /**
   * Convert route path pattern (e.g., "/api/users/:id") to a regex
   * and emit __routes.push({ method, pattern, paramNames, handler })
   */
  _emitRouteRegistrations(lines, routes) {
    for (const route of routes) {
      const method = route.method.toUpperCase();
      const path = route.path;

      // Extract param names and build regex
      const paramNames = [];
      const regexParts = path.split('/').map(seg => {
        if (seg.startsWith(':')) {
          paramNames.push(seg.slice(1));
          return '([^/]+)';
        }
        if (seg.startsWith('*')) {
          paramNames.push(seg.slice(1) || 'wild');
          return '(.*)';
        }
        return seg.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      });
      const regexStr = '^' + regexParts.join('/') + '$';

      const handler = this.genExpression(route.handler);
      lines.push(`__routes.push({ method: ${JSON.stringify(method)}, pattern: new RegExp(${JSON.stringify(regexStr)}), paramNames: ${JSON.stringify(paramNames)}, handler: ${handler} });`);
    }
  }

  /**
   * Generate a wrangler.toml config string for Cloudflare deployments.
   */
  static generateWranglerToml(config, name, blockName) {
    const appName = name || 'app';
    const today = new Date().toISOString().slice(0, 10);
    const mainFile = blockName
      ? '.tova-out/' + appName + '.edge.' + blockName + '.js'
      : '.tova-out/' + appName + '.edge.js';
    const lines = [];
    lines.push('name = "' + appName + '"');
    lines.push('main = "' + mainFile + '"');
    lines.push('compatibility_date = "' + today + '"');
    lines.push('');

    // KV namespaces
    for (const kv of config.bindings.kv) {
      lines.push('[[kv_namespaces]]');
      lines.push('binding = "' + kv.name + '"');
      lines.push('id = "TODO_' + kv.name + '_ID"');
      lines.push('');
    }

    // D1 databases
    for (const db of config.bindings.sql) {
      lines.push('[[d1_databases]]');
      lines.push('binding = "' + db.name + '"');
      lines.push('database_name = "' + db.name.toLowerCase() + '"');
      lines.push('database_id = "TODO_' + db.name + '_ID"');
      lines.push('');
    }

    // R2 buckets
    for (const bucket of config.bindings.storage) {
      lines.push('[[r2_buckets]]');
      lines.push('binding = "' + bucket.name + '"');
      lines.push('bucket_name = "' + bucket.name.toLowerCase() + '"');
      lines.push('');
    }

    // Queue producers
    for (const q of config.bindings.queue) {
      lines.push('[[queues.producers]]');
      lines.push('binding = "' + q.name + '"');
      lines.push('queue = "' + q.name.toLowerCase() + '"');
      lines.push('');
    }

    // Queue consumers
    for (const c of config.consumers) {
      lines.push('[[queues.consumers]]');
      lines.push('queue = "' + c.queue.toLowerCase() + '"');
      lines.push('max_batch_size = 10');
      lines.push('max_batch_timeout = 30');
      lines.push('');
    }

    // Cron triggers
    if (config.schedules.length > 0) {
      lines.push('[triggers]');
      const crons = config.schedules.map(s => '"' + s.cron + '"').join(', ');
      lines.push('crons = [' + crons + ']');
      lines.push('');
    }

    // Env vars
    if (config.envVars.length > 0) {
      lines.push('[vars]');
      for (const env of config.envVars) {
        if (env.defaultValue && env.defaultValue.type === 'StringLiteral') {
          lines.push(env.name + ' = "' + env.defaultValue.value + '"');
        }
      }
      lines.push('');
    }

    return lines.join('\n');
  }
}

// ─── src/codegen/codegen.js ────────────────────────────

// Main code generator — orchestrates shared/server/browser codegen
// Supports named multi-blocks: server "api" { }, server "ws" { }
// Blocks with the same name are merged; different names produce separate output files.




// Lazy-load domain-specific codegens so pure scripts don't pay for them



function getServerCodegen() { return ServerCodegen; }

function getBrowserCodegen() { return BrowserCodegen; }

function getSecurityCodegen() { return SecurityCodegen; }

function getCliCodegen() { return CliCodegen; }

function getEdgeCodegen() { return EdgeCodegen; }
class CodeGenerator {
  constructor(ast, filename = '<stdin>', options = {}) {
    this.ast = ast;
    this.filename = filename;
    this._sourceMaps = options.sourceMaps !== false; // default true; pass false for REPL/check
  }

  // Group blocks by name (null name = "default")
  _groupByName(blocks) {
    const groups = new Map();
    for (const block of blocks) {
      const key = block.name || null;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key).push(block);
    }
    return groups;
  }

  generate() {
    // Registry-driven block sorting
    const blocksByType = new Map();
    const topLevel = [];

    for (const node of this.ast.body) {
      const plugin = BlockRegistry.getByAstType(node.type);
      if (plugin) {
        if (!blocksByType.has(plugin.name)) blocksByType.set(plugin.name, []);
        blocksByType.get(plugin.name).push(node);
      } else {
        topLevel.push(node);
      }
    }

    const getBlocks = (name) => blocksByType.get(name) || [];

    // Early-return blocks (e.g., CLI mode)
    for (const plugin of BlockRegistry.all()) {
      if (plugin.codegen?.earlyReturn && getBlocks(plugin.name).length > 0) {
        return this[plugin.codegen.earlyReturnMethod](getBlocks(plugin.name), topLevel);
      }
    }

    // Convenience aliases
    const sharedBlocks = getBlocks('shared');
    const serverBlocks = getBlocks('server');
    const browserBlocks = getBlocks('browser');
    const testBlocks = getBlocks('test');
    const benchBlocks = getBlocks('bench');
    const dataBlocks = getBlocks('data');
    const securityBlocks = getBlocks('security');
    const edgeBlocks = getBlocks('edge');

    // Detect module mode: no blocks, only top-level statements
    const hasAnyBlocks = BlockRegistry.all().some(p => getBlocks(p.name).length > 0);
    const isModule = !hasAnyBlocks && topLevel.length > 0;

    if (isModule) {
      const moduleGen = new SharedCodegen();
      moduleGen._sourceMapsEnabled = this._sourceMaps;
      moduleGen.setSourceFile(this.filename);
      // Use genBlockStatements for pattern optimization (array fill detection, etc.)
      const fakeBlock = { type: 'BlockStatement', body: topLevel };
      const moduleCode = moduleGen.genBlockStatements(fakeBlock);
      const helpers = moduleGen.generateHelpers();
      const combined = [helpers, moduleCode].filter(s => s.trim()).join('\n').trim();
      return {
        shared: combined,
        server: '',
        browser: '',
        client: '',  // deprecated alias
        isModule: true,
        sourceMappings: moduleGen.getSourceMappings(),
        _sourceFile: this.filename,
      };
    }

    const sharedGen = new SharedCodegen();
    sharedGen._sourceMapsEnabled = this._sourceMaps;
    sharedGen.setSourceFile(this.filename);

    // All shared blocks (regardless of name) are merged into one shared output
    const sharedCode = sharedBlocks.map(b => sharedGen.generate(b)).join('\n');
    const topLevelCode = topLevel.length > 0
      ? sharedGen.genBlockStatements({ type: 'BlockStatement', body: topLevel })
      : '';

    // Pre-scan server/browser blocks for builtin usage so shared stdlib includes them
    this._scanBlocksForBuiltins([...serverBlocks, ...browserBlocks, ...edgeBlocks], sharedGen._usedBuiltins);

    const helpers = sharedGen.generateHelpers();

    // Generate data block code (sources, pipelines, validators, refresh)
    const dataCode = dataBlocks.map(b => this._genDataBlock(b, sharedGen)).join('\n');

    const combinedShared = [helpers, sharedCode, topLevelCode, dataCode].filter(s => s.trim()).join('\n').trim();

    // Group server and browser blocks by name
    const serverGroups = this._groupByName(serverBlocks);
    const browserGroups = this._groupByName(browserBlocks);

    // Collect function names per named server block for inter-server RPC
    const serverFunctionMap = new Map(); // blockName -> [fnName, ...]
    const collectFns = (stmts) => {
      const fns = [];
      for (const stmt of stmts) {
        if (stmt.type === 'FunctionDeclaration') {
          fns.push(stmt.name);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          fns.push(...collectFns(stmt.body));
        }
      }
      return fns;
    };
    for (const [name, blocks] of serverGroups) {
      if (name) {
        const fns = [];
        for (const block of blocks) {
          fns.push(...collectFns(block.body));
        }
        serverFunctionMap.set(name, fns);
      }
    }

    // Merge security blocks into a single config
    const securityConfig = securityBlocks.length > 0
      ? getSecurityCodegen().mergeSecurityBlocks(securityBlocks)
      : null;

    // Generate server outputs (one per named group)
    const servers = {};
    for (const [name, blocks] of serverGroups) {
      const gen = new (getServerCodegen())();
      gen._sourceMapsEnabled = this._sourceMaps;
      const key = name || 'default';
      // Build peer blocks map (all named blocks except self)
      let peerBlocks = null;
      if (name && serverFunctionMap.size > 1) {
        peerBlocks = new Map();
        for (const [peerName, peerFns] of serverFunctionMap) {
          if (peerName !== name) {
            peerBlocks.set(peerName, peerFns);
          }
        }
      }
      // Include top-level statements so _collectTypes finds top-level type declarations
      const allSharedBlocks = topLevel.length > 0
        ? [...sharedBlocks, { type: 'BlockStatement', body: topLevel }]
        : sharedBlocks;
      servers[key] = gen.generate(blocks, combinedShared, name, peerBlocks, allSharedBlocks, securityConfig);
    }

    // Collect type validators from shared blocks and top-level for form type inheritance
    const typeValidatorsMap = {};
    const _collectTypeValidators = (stmts) => {
      for (const stmt of stmts) {
        if (stmt.type === 'TypeDeclaration' && stmt.variants) {
          const fields = [];
          for (const v of stmt.variants) {
            if (v.type === 'TypeField' && v.validators && v.validators.length > 0) {
              fields.push({ name: v.name, validators: v.validators });
            }
          }
          if (fields.length > 0) {
            typeValidatorsMap[stmt.name] = { fields };
          }
        }
      }
    };
    for (const sb of sharedBlocks) {
      _collectTypeValidators(sb.body);
    }
    _collectTypeValidators(topLevel);

    // Generate browser outputs (one per named group)
    const browsers = {};
    for (const [name, blocks] of browserGroups) {
      const gen = new (getBrowserCodegen())();
      gen._sourceMapsEnabled = this._sourceMaps;
      const key = name || 'default';
      browsers[key] = gen.generate(blocks, combinedShared, sharedGen._usedBuiltins, securityConfig, typeValidatorsMap);
    }

    // Generate edge outputs (one per named group)
    const edges = {};
    if (edgeBlocks.length > 0) {
      const edgeGroups = this._groupByName(edgeBlocks);
      for (const [name, blocks] of edgeGroups) {
        const Edge = getEdgeCodegen();
        const gen = new Edge();
        gen._sourceMapsEnabled = this._sourceMaps;
        const key = name || 'default';
        const edgeConfig = Edge.mergeEdgeBlocks(blocks);
        edges[key] = gen.generate(edgeConfig, combinedShared, securityConfig);
      }
    }

    // Generate tests if test blocks exist
    let testCode = '';
    if (testBlocks.length > 0) {
      const testGen = new (getServerCodegen())();
      testCode = testGen.generateTests(testBlocks, combinedShared);

      // Add __handleRequest export to server code
      const defaultServer = servers['default'] || '';
      if (defaultServer) {
        servers['default'] = defaultServer + '\nexport { __handleRequest };\n';
      }
    }

    // Generate benchmarks if bench blocks exist
    let benchCode = '';
    if (benchBlocks.length > 0) {
      const benchGen = new (getServerCodegen())();
      benchCode = benchGen.generateBench(benchBlocks, combinedShared);
    }

    // Backward-compatible: if only unnamed blocks, return flat structure
    const edgeGroupKeys = edgeBlocks.length > 0 ? [...this._groupByName(edgeBlocks).keys()] : [];
    const hasNamedBlocks = [...serverGroups.keys(), ...browserGroups.keys(), ...edgeGroupKeys].some(k => k !== null);

    // Collect source mappings from all codegens
    const sourceMappings = sharedGen.getSourceMappings();

    if (!hasNamedBlocks) {
      const browserCode = browsers['default'] || '';
      const result = {
        shared: combinedShared,
        server: servers['default'] || '',
        browser: browserCode,
        client: browserCode,  // deprecated alias for backward compat
        edge: edges['default'] || '',
        sourceMappings,
        _sourceFile: this.filename,
      };
      if (testCode) result.test = testCode;
      if (benchCode) result.bench = benchCode;
      return result;
    }

    // Multi-block output: separate files per named block
    const browserDefault = browsers['default'] || '';
    const result = {
      shared: combinedShared,
      server: servers['default'] || '',
      browser: browserDefault,
      client: browserDefault,  // deprecated alias for backward compat
      edge: edges['default'] || '',
      servers,   // { "api": code, "ws": code, ... }
      browsers,  // { "admin": code, "dashboard": code, ... }
      clients: browsers,   // deprecated alias for backward compat
      edges,     // { "api": code, "assets": code, ... }
      multiBlock: true,
      sourceMappings,
      _sourceFile: this.filename,
    };
    if (testCode) result.test = testCode;
    if (benchCode) result.bench = benchCode;
    return result;
  }

  // Generate CLI executable from cli {} blocks
  _generateCli(cliBlocks, topLevel) {
    const sharedGen = new SharedCodegen();
    sharedGen._sourceMapsEnabled = this._sourceMaps;
    sharedGen.setSourceFile(this.filename);

    // Generate top-level code (shared helpers, type declarations, etc.)
    const topLevelCode = topLevel.length > 0
      ? sharedGen.genBlockStatements({ type: 'BlockStatement', body: topLevel })
      : '';

    // Scan cli command bodies for builtin usage
    for (const block of cliBlocks) {
      for (const cmd of block.commands) {
        this._scanBlocksForBuiltins([cmd.body], sharedGen._usedBuiltins);
      }
    }
    // Also scan top-level for builtins
    this._scanBlocksForBuiltins(topLevel, sharedGen._usedBuiltins);

    const helpers = sharedGen.generateHelpers();
    const combinedShared = [helpers, topLevelCode].filter(s => s.trim()).join('\n').trim();

    const Cli = getCliCodegen();
    const cliConfig = Cli.mergeCliBlocks(cliBlocks);
    const cliGen = new Cli();
    cliGen._sourceMapsEnabled = this._sourceMaps;
    const cliCode = cliGen.generate(cliConfig, combinedShared);

    return {
      cli: cliCode,
      isCli: true,
      shared: '',
      server: '',
      browser: '',
      client: '',  // deprecated alias
      sourceMappings: sharedGen.getSourceMappings(),
      _sourceFile: this.filename,
    };
  }

  // Walk AST nodes to find builtin function calls/identifiers
  _scanBlocksForBuiltins(blocks, targetSet) {
    const walk = (node) => {
      if (!node || typeof node !== 'object') return;
      if (node.type === 'Identifier' && BUILTIN_NAMES.has(node.name)) {
        targetSet.add(node.name);
      }
      if (node.type === 'CallExpression' && node.callee && node.callee.type === 'Identifier' && BUILTIN_NAMES.has(node.callee.name)) {
        targetSet.add(node.callee.name);
      }
      // Track namespace builtin usage: math.sin() or math.PI
      if (node.type === 'MemberExpression' &&
          node.object.type === 'Identifier' &&
          BUILTIN_NAMES.has(node.object.name)) {
        targetSet.add(node.object.name);
      }
      for (const key of Object.keys(node)) {
        if (key === 'loc' || key === 'type') continue;
        const val = node[key];
        if (Array.isArray(val)) {
          for (const item of val) {
            if (item && typeof item === 'object') walk(item);
          }
        } else if (val && typeof val === 'object' && val.type) {
          walk(val);
        }
      }
    };
    for (const block of blocks) walk(block);
  }

  _genDataBlock(node, gen) {
    const lines = [];
    lines.push('// ── Data Block ──');

    for (const stmt of node.body) {
      switch (stmt.type) {
        case 'SourceDeclaration': {
          // Source: lazy cached getter
          const expr = gen.genExpression(stmt.expression);
          lines.push(`let __data_${stmt.name}_cache = null;`);
          lines.push(`async function __data_${stmt.name}_load() {`);
          lines.push(`  if (__data_${stmt.name}_cache === null) {`);
          lines.push(`    __data_${stmt.name}_cache = await ${expr};`);
          lines.push(`  }`);
          lines.push(`  return __data_${stmt.name}_cache;`);
          lines.push(`}`);
          // Also expose as a simple getter variable via lazy init
          lines.push(`let ${stmt.name} = null;`);
          lines.push(`Object.defineProperty(globalThis, ${JSON.stringify(stmt.name)}, {`);
          lines.push(`  get() { if (${stmt.name} === null) { ${stmt.name} = __data_${stmt.name}_load(); } return ${stmt.name}; },`);
          lines.push(`  configurable: true,`);
          lines.push(`});`);
          break;
        }
        case 'PipelineDeclaration': {
          // Pipeline: function that chains transforms
          const expr = gen.genExpression(stmt.expression);
          lines.push(`async function __pipeline_${stmt.name}() {`);
          lines.push(`  return ${expr};`);
          lines.push(`}`);
          lines.push(`let ${stmt.name} = null;`);
          lines.push(`Object.defineProperty(globalThis, ${JSON.stringify(stmt.name)}, {`);
          lines.push(`  get() { if (${stmt.name} === null) { ${stmt.name} = __pipeline_${stmt.name}(); } return ${stmt.name}; },`);
          lines.push(`  configurable: true,`);
          lines.push(`});`);
          break;
        }
        case 'ValidateBlock': {
          // Validate: validator function — include rule expression in error for debuggability
          const rules = stmt.rules.map(r => gen.genExpression(r));
          lines.push(`function __validate_${stmt.typeName}(it) {`);
          lines.push(`  const errors = [];`);
          for (let i = 0; i < rules.length; i++) {
            const escapedRule = rules[i].replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            lines.push(`  if (!(${rules[i]})) errors.push("Validation failed for ${stmt.typeName}: expected \`${escapedRule}\`");`);
          }
          lines.push(`  return errors.length === 0 ? { valid: true, errors: [] } : { valid: false, errors };`);
          lines.push(`}`);
          break;
        }
        case 'RefreshPolicy': {
          // Refresh: interval cache invalidation
          if (stmt.interval === 'on_demand') {
            lines.push(`function refresh_${stmt.sourceName}() { __data_${stmt.sourceName}_cache = null; ${stmt.sourceName} = null; }`);
          } else {
            const { value, unit } = stmt.interval;
            let ms;
            switch (unit) {
              case 'seconds': case 'second': ms = value * 1000; break;
              case 'minutes': case 'minute': ms = value * 60 * 1000; break;
              case 'hours': case 'hour': ms = value * 60 * 60 * 1000; break;
              case 'days': case 'day': ms = value * 24 * 60 * 60 * 1000; break;
              default: ms = value * 60 * 1000; // default to minutes
            }
            lines.push(`setInterval(() => { __data_${stmt.sourceName}_cache = null; ${stmt.sourceName} = null; }, ${ms});`);
          }
          break;
        }
      }
    }

    return lines.join('\n');
  }
}

window.Lexer = Lexer;

window.Parser = Parser;

window.Analyzer = Analyzer;

window.CodeGenerator = CodeGenerator;

})();
</script>

<!-- ─── CodeMirror & App (bundled locally) ────────── -->
<script>
(()=>{var wZ=[],$8=[];(()=>{let Z="lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(($)=>$?parseInt($,36):1);for(let $=0,J=0;$<Z.length;$++)($%2?$8:wZ).push(J=J+Z[$])})();function C2(Z){if(Z<768)return!1;for(let $=0,J=wZ.length;;){let X=$+J>>1;if(Z<wZ[X])J=X;else if(Z>=$8[X])$=X+1;else return!0;if($==J)return!1}}function t4(Z){return Z>=127462&&Z<=127487}var e4=8205;function J8(Z,$,J=!0,X=!0){return(J?X8:T2)(Z,$,X)}function X8(Z,$,J){if($==Z.length)return $;if($&&Y8(Z.charCodeAt($))&&K8(Z.charCodeAt($-1)))$--;let X=xZ(Z,$);$+=Z8(X);while($<Z.length){let Y=xZ(Z,$);if(X==e4||Y==e4||J&&C2(Y))$+=Z8(Y),X=Y;else if(t4(Y)){let K=0,Q=$-2;while(Q>=0&&t4(xZ(Z,Q)))K++,Q-=2;if(K%2==0)break;else $+=2}else break}return $}function T2(Z,$,J){while($>0){let X=X8(Z,$-2,J);if(X<$)return X;$--}return 0}function xZ(Z,$){let J=Z.charCodeAt($);if(!K8(J)||$+1==Z.length)return J;let X=Z.charCodeAt($+1);if(!Y8(X))return J;return(J-55296<<10)+(X-56320)+65536}function Y8(Z){return Z>=56320&&Z<57344}function K8(Z){return Z>=55296&&Z<56320}function Z8(Z){return Z<65536?1:2}class u{lineAt(Z){if(Z<0||Z>this.length)throw RangeError(`Invalid position ${Z} in document of length ${this.length}`);return this.lineInner(Z,!1,1,0)}line(Z){if(Z<1||Z>this.lines)throw RangeError(`Invalid line number ${Z} in ${this.lines}-line document`);return this.lineInner(Z,!0,1,0)}replace(Z,$,J){[Z,$]=a0(this,Z,$);let X=[];if(this.decompose(0,Z,X,2),J.length)J.decompose(0,J.length,X,3);return this.decompose($,this.length,X,1),J0.from(X,this.length-($-Z)+J.length)}append(Z){return this.replace(this.length,this.length,Z)}slice(Z,$=this.length){[Z,$]=a0(this,Z,$);let J=[];return this.decompose(Z,$,J,0),J0.from(J,$-Z)}eq(Z){if(Z==this)return!0;if(Z.length!=this.length||Z.lines!=this.lines)return!1;let $=this.scanIdentical(Z,1),J=this.length-this.scanIdentical(Z,-1),X=new n0(this),Y=new n0(Z);for(let K=$,Q=$;;){if(X.next(K),Y.next(K),K=0,X.lineBreak!=Y.lineBreak||X.done!=Y.done||X.value!=Y.value)return!1;if(Q+=X.value.length,X.done||Q>=J)return!0}}iter(Z=1){return new n0(this,Z)}iterRange(Z,$=this.length){return new sZ(this,Z,$)}iterLines(Z,$){let J;if(Z==null)J=this.iter();else{if($==null)$=this.lines+1;let X=this.line(Z).from;J=this.iterRange(X,Math.max(X,$==this.lines+1?this.length:$<=1?0:this.line($-1).to))}return new nZ(J)}toString(){return this.sliceString(0)}toJSON(){let Z=[];return this.flatten(Z),Z}constructor(){}static of(Z){if(Z.length==0)throw RangeError("A document must have at least one line");if(Z.length==1&&!Z[0])return u.empty;return Z.length<=32?new $9(Z):J0.from($9.split(Z,[]))}}class $9 extends u{constructor(Z,$=y2(Z)){super();this.text=Z,this.length=$}get lines(){return this.text.length}get children(){return null}lineInner(Z,$,J,X){for(let Y=0;;Y++){let K=this.text[Y],Q=X+K.length;if(($?J:Q)>=Z)return new j8(X,Q,J,K);X=Q+1,J++}}decompose(Z,$,J,X){let Y=Z<=0&&$>=this.length?this:new $9(Q8(this.text,Z,$),Math.min($,this.length)-Math.max(0,Z));if(X&1){let K=J.pop(),Q=V7(Y.text,K.text.slice(),0,Y.length);if(Q.length<=32)J.push(new $9(Q,K.length+Y.length));else{let U=Q.length>>1;J.push(new $9(Q.slice(0,U)),new $9(Q.slice(U)))}}else J.push(Y)}replace(Z,$,J){if(!(J instanceof $9))return super.replace(Z,$,J);[Z,$]=a0(this,Z,$);let X=V7(this.text,V7(J.text,Q8(this.text,0,Z)),$),Y=this.length+J.length-($-Z);if(X.length<=32)return new $9(X,Y);return J0.from($9.split(X,[]),Y)}sliceString(Z,$=this.length,J=`
`){[Z,$]=a0(this,Z,$);let X="";for(let Y=0,K=0;Y<=$&&K<this.text.length;K++){let Q=this.text[K],U=Y+Q.length;if(Y>Z&&K)X+=J;if(Z<U&&$>Y)X+=Q.slice(Math.max(0,Z-Y),$-Y);Y=U+1}return X}flatten(Z){for(let $ of this.text)Z.push($)}scanIdentical(){return 0}static split(Z,$){let J=[],X=-1;for(let Y of Z)if(J.push(Y),X+=Y.length+1,J.length==32)$.push(new $9(J,X)),J=[],X=-1;if(X>-1)$.push(new $9(J,X));return $}}class J0 extends u{constructor(Z,$){super();this.children=Z,this.length=$,this.lines=0;for(let J of Z)this.lines+=J.lines}lineInner(Z,$,J,X){for(let Y=0;;Y++){let K=this.children[Y],Q=X+K.length,U=J+K.lines-1;if(($?U:Q)>=Z)return K.lineInner(Z,$,J,X);X=Q+1,J=U+1}}decompose(Z,$,J,X){for(let Y=0,K=0;K<=$&&Y<this.children.length;Y++){let Q=this.children[Y],U=K+Q.length;if(Z<=U&&$>=K){let q=X&((K<=Z?1:0)|(U>=$?2:0));if(K>=Z&&U<=$&&!q)J.push(Q);else Q.decompose(Z-K,$-K,J,q)}K=U+1}}replace(Z,$,J){if([Z,$]=a0(this,Z,$),J.lines<this.lines)for(let X=0,Y=0;X<this.children.length;X++){let K=this.children[X],Q=Y+K.length;if(Z>=Y&&$<=Q){let U=K.replace(Z-Y,$-Y,J),q=this.lines-K.lines+U.lines;if(U.lines<q>>4&&U.lines>q>>6){let G=this.children.slice();return G[X]=U,new J0(G,this.length-($-Z)+J.length)}return super.replace(Y,Q,U)}Y=Q+1}return super.replace(Z,$,J)}sliceString(Z,$=this.length,J=`
`){[Z,$]=a0(this,Z,$);let X="";for(let Y=0,K=0;Y<this.children.length&&K<=$;Y++){let Q=this.children[Y],U=K+Q.length;if(K>Z&&Y)X+=J;if(Z<U&&$>K)X+=Q.sliceString(Z-K,$-K,J);K=U+1}return X}flatten(Z){for(let $ of this.children)$.flatten(Z)}scanIdentical(Z,$){if(!(Z instanceof J0))return 0;let J=0,[X,Y,K,Q]=$>0?[0,0,this.children.length,Z.children.length]:[this.children.length-1,Z.children.length-1,-1,-1];for(;;X+=$,Y+=$){if(X==K||Y==Q)return J;let U=this.children[X],q=Z.children[Y];if(U!=q)return J+U.scanIdentical(q,$);J+=U.length+1}}static from(Z,$=Z.reduce((J,X)=>J+X.length+1,-1)){let J=0;for(let W of Z)J+=W.lines;if(J<32){let W=[];for(let O of Z)O.flatten(W);return new $9(W,$)}let X=Math.max(32,J>>5),Y=X<<1,K=X>>1,Q=[],U=0,q=-1,G=[];function z(W){let O;if(W.lines>Y&&W instanceof J0)for(let _ of W.children)z(_);else if(W.lines>K&&(U>K||!U))j(),Q.push(W);else if(W instanceof $9&&U&&(O=G[G.length-1])instanceof $9&&W.lines+O.lines<=32)U+=W.lines,q+=W.length+1,G[G.length-1]=new $9(O.text.concat(W.text),O.length+1+W.length);else{if(U+W.lines>X)j();U+=W.lines,q+=W.length+1,G.push(W)}}function j(){if(U==0)return;Q.push(G.length==1?G[0]:J0.from(G,q)),q=-1,U=G.length=0}for(let W of Z)z(W);return j(),Q.length==1?Q[0]:new J0(Q,$)}}u.empty=new $9([""],0);function y2(Z){let $=-1;for(let J of Z)$+=J.length+1;return $}function V7(Z,$,J=0,X=1e9){for(let Y=0,K=0,Q=!0;K<Z.length&&Y<=X;K++){let U=Z[K],q=Y+U.length;if(q>=J){if(q>X)U=U.slice(0,X-Y);if(Y<J)U=U.slice(J-Y);if(Q)$[$.length-1]+=U,Q=!1;else $.push(U)}Y=q+1}return $}function Q8(Z,$,J){return V7(Z,[""],$,J)}class n0{constructor(Z,$=1){this.dir=$,this.done=!1,this.lineBreak=!1,this.value="",this.nodes=[Z],this.offsets=[$>0?1:(Z instanceof $9?Z.text.length:Z.children.length)<<1]}nextInner(Z,$){this.done=this.lineBreak=!1;for(;;){let J=this.nodes.length-1,X=this.nodes[J],Y=this.offsets[J],K=Y>>1,Q=X instanceof $9?X.text.length:X.children.length;if(K==($>0?Q:0)){if(J==0)return this.done=!0,this.value="",this;if($>0)this.offsets[J-1]++;this.nodes.pop(),this.offsets.pop()}else if((Y&1)==($>0?0:1)){if(this.offsets[J]+=$,Z==0)return this.lineBreak=!0,this.value=`
`,this;Z--}else if(X instanceof $9){let U=X.text[K+($<0?-1:0)];if(this.offsets[J]+=$,U.length>Math.max(0,Z))return this.value=Z==0?U:$>0?U.slice(Z):U.slice(0,U.length-Z),this;Z-=U.length}else{let U=X.children[K+($<0?-1:0)];if(Z>U.length)Z-=U.length,this.offsets[J]+=$;else{if($<0)this.offsets[J]--;this.nodes.push(U),this.offsets.push($>0?1:(U instanceof $9?U.text.length:U.children.length)<<1)}}}}next(Z=0){if(Z<0)this.nextInner(-Z,-this.dir),Z=this.value.length;return this.nextInner(Z,this.dir)}}class sZ{constructor(Z,$,J){this.value="",this.done=!1,this.cursor=new n0(Z,$>J?-1:1),this.pos=$>J?Z.length:0,this.from=Math.min($,J),this.to=Math.max($,J)}nextInner(Z,$){if($<0?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=!0,this;Z+=Math.max(0,$<0?this.pos-this.to:this.from-this.pos);let J=$<0?this.pos-this.from:this.to-this.pos;if(Z>J)Z=J;J-=Z;let{value:X}=this.cursor.next(Z);return this.pos+=(X.length+Z)*$,this.value=X.length<=J?X:$<0?X.slice(X.length-J):X.slice(0,J),this.done=!this.value,this}next(Z=0){if(Z<0)Z=Math.max(Z,this.from-this.pos);else if(Z>0)Z=Math.min(Z,this.to-this.pos);return this.nextInner(Z,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&this.value!=""}}class nZ{constructor(Z){this.inner=Z,this.afterBreak=!0,this.value="",this.done=!1}next(Z=0){let{done:$,lineBreak:J,value:X}=this.inner.next(Z);if($&&this.afterBreak)this.value="",this.afterBreak=!1;else if($)this.done=!0,this.value="";else if(J)if(this.afterBreak)this.value="";else this.afterBreak=!0,this.next();else this.value=X,this.afterBreak=!1;return this}get lineBreak(){return!1}}if(typeof Symbol<"u")u.prototype[Symbol.iterator]=function(){return this.iter()},n0.prototype[Symbol.iterator]=sZ.prototype[Symbol.iterator]=nZ.prototype[Symbol.iterator]=function(){return this};class j8{constructor(Z,$,J,X){this.from=Z,this.to=$,this.number=J,this.text=X}get length(){return this.to-this.from}}function a0(Z,$,J){return $=Math.max(0,Math.min(Z.length,$)),[$,Math.max($,Math.min(Z.length,J))]}function X9(Z,$,J=!0,X=!0){return J8(Z,$,J,X)}function k2(Z){return Z>=56320&&Z<57344}function S2(Z){return Z>=55296&&Z<56320}function G9(Z,$){let J=Z.charCodeAt($);if(!S2(J)||$+1==Z.length)return J;let X=Z.charCodeAt($+1);if(!k2(X))return J;return(J-55296<<10)+(X-56320)+65536}function B5(Z){if(Z<=65535)return String.fromCharCode(Z);return Z-=65536,String.fromCharCode((Z>>10)+55296,(Z&1023)+56320)}function E9(Z){return Z<65536?1:2}var vZ=/\r\n?|\n/,q9=function(Z){return Z[Z.Simple=0]="Simple",Z[Z.TrackDel=1]="TrackDel",Z[Z.TrackBefore=2]="TrackBefore",Z[Z.TrackAfter=3]="TrackAfter",Z}(q9||(q9={}));class p9{constructor(Z){this.sections=Z}get length(){let Z=0;for(let $=0;$<this.sections.length;$+=2)Z+=this.sections[$];return Z}get newLength(){let Z=0;for(let $=0;$<this.sections.length;$+=2){let J=this.sections[$+1];Z+=J<0?this.sections[$]:J}return Z}get empty(){return this.sections.length==0||this.sections.length==2&&this.sections[1]<0}iterGaps(Z){for(let $=0,J=0,X=0;$<this.sections.length;){let Y=this.sections[$++],K=this.sections[$++];if(K<0)Z(J,X,Y),X+=Y;else X+=K;J+=Y}}iterChangedRanges(Z,$=!1){mZ(this,Z,$)}get invertedDesc(){let Z=[];for(let $=0;$<this.sections.length;){let J=this.sections[$++],X=this.sections[$++];if(X<0)Z.push(J,X);else Z.push(X,J)}return new p9(Z)}composeDesc(Z){return this.empty?Z:Z.empty?this:W8(this,Z)}mapDesc(Z,$=!1){return Z.empty?this:uZ(this,Z,$)}mapPos(Z,$=-1,J=q9.Simple){let X=0,Y=0;for(let K=0;K<this.sections.length;){let Q=this.sections[K++],U=this.sections[K++],q=X+Q;if(U<0){if(q>Z)return Y+(Z-X);Y+=Q}else{if(J!=q9.Simple&&q>=Z&&(J==q9.TrackDel&&X<Z&&q>Z||J==q9.TrackBefore&&X<Z||J==q9.TrackAfter&&q>Z))return null;if(q>Z||q==Z&&$<0&&!Q)return Z==X||$<0?Y:Y+U;Y+=U}X=q}if(Z>X)throw RangeError(`Position ${Z} is out of range for changeset of length ${X}`);return Y}touchesRange(Z,$=Z){for(let J=0,X=0;J<this.sections.length&&X<=$;){let Y=this.sections[J++],K=this.sections[J++],Q=X+Y;if(K>=0&&X<=$&&Q>=Z)return X<Z&&Q>$?"cover":!0;X=Q}return!1}toString(){let Z="";for(let $=0;$<this.sections.length;){let J=this.sections[$++],X=this.sections[$++];Z+=(Z?" ":"")+J+(X>=0?":"+X:"")}return Z}toJSON(){return this.sections}static fromJSON(Z){if(!Array.isArray(Z)||Z.length%2||Z.some(($)=>typeof $!="number"))throw RangeError("Invalid JSON representation of ChangeDesc");return new p9(Z)}static create(Z){return new p9(Z)}}class J9 extends p9{constructor(Z,$){super(Z);this.inserted=$}apply(Z){if(this.length!=Z.length)throw RangeError("Applying change set to a document with the wrong length");return mZ(this,($,J,X,Y,K)=>Z=Z.replace(X,X+(J-$),K),!1),Z}mapDesc(Z,$=!1){return uZ(this,Z,$,!0)}invert(Z){let $=this.sections.slice(),J=[];for(let X=0,Y=0;X<$.length;X+=2){let K=$[X],Q=$[X+1];if(Q>=0){$[X]=Q,$[X+1]=K;let U=X>>1;while(J.length<U)J.push(u.empty);J.push(K?Z.slice(Y,Y+K):u.empty)}Y+=K}return new J9($,J)}compose(Z){return this.empty?Z:Z.empty?this:W8(this,Z,!0)}map(Z,$=!1){return Z.empty?this:uZ(this,Z,$,!0)}iterChanges(Z,$=!1){mZ(this,Z,$)}get desc(){return p9.create(this.sections)}filter(Z){let $=[],J=[],X=[],Y=new r0(this);Z:for(let K=0,Q=0;;){let U=K==Z.length?1e9:Z[K++];while(Q<U||Q==U&&Y.len==0){if(Y.done)break Z;let G=Math.min(Y.len,U-Q);O9(X,G,-1);let z=Y.ins==-1?-1:Y.off==0?Y.ins:0;if(O9($,G,z),z>0)_0(J,$,Y.text);Y.forward(G),Q+=G}let q=Z[K++];while(Q<q){if(Y.done)break Z;let G=Math.min(Y.len,q-Q);O9($,G,-1),O9(X,G,Y.ins==-1?-1:Y.off==0?Y.ins:0),Y.forward(G),Q+=G}}return{changes:new J9($,J),filtered:p9.create(X)}}toJSON(){let Z=[];for(let $=0;$<this.sections.length;$+=2){let J=this.sections[$],X=this.sections[$+1];if(X<0)Z.push(J);else if(X==0)Z.push([J]);else Z.push([J].concat(this.inserted[$>>1].toJSON()))}return Z}static of(Z,$,J){let X=[],Y=[],K=0,Q=null;function U(G=!1){if(!G&&!X.length)return;if(K<$)O9(X,$-K,-1);let z=new J9(X,Y);Q=Q?Q.compose(z.map(Q)):z,X=[],Y=[],K=0}function q(G){if(Array.isArray(G))for(let z of G)q(z);else if(G instanceof J9){if(G.length!=$)throw RangeError(`Mismatched change set length (got ${G.length}, expected ${$})`);U(),Q=Q?Q.compose(G.map(Q)):G}else{let{from:z,to:j=z,insert:W}=G;if(z>j||z<0||j>$)throw RangeError(`Invalid change range ${z} to ${j} (in doc of length ${$})`);let O=!W?u.empty:typeof W=="string"?u.of(W.split(J||vZ)):W,_=O.length;if(z==j&&_==0)return;if(z<K)U();if(z>K)O9(X,z-K,-1);O9(X,j-z,_),_0(Y,X,O),K=j}}return q(Z),U(!Q),Q}static empty(Z){return new J9(Z?[Z,-1]:[],[])}static fromJSON(Z){if(!Array.isArray(Z))throw RangeError("Invalid JSON representation of ChangeSet");let $=[],J=[];for(let X=0;X<Z.length;X++){let Y=Z[X];if(typeof Y=="number")$.push(Y,-1);else if(!Array.isArray(Y)||typeof Y[0]!="number"||Y.some((K,Q)=>Q&&typeof K!="string"))throw RangeError("Invalid JSON representation of ChangeSet");else if(Y.length==1)$.push(Y[0],0);else{while(J.length<X)J.push(u.empty);J[X]=u.of(Y.slice(1)),$.push(Y[0],J[X].length)}}return new J9($,J)}static createSet(Z,$){return new J9(Z,$)}}function O9(Z,$,J,X=!1){if($==0&&J<=0)return;let Y=Z.length-2;if(Y>=0&&J<=0&&J==Z[Y+1])Z[Y]+=$;else if(Y>=0&&$==0&&Z[Y]==0)Z[Y+1]+=J;else if(X)Z[Y]+=$,Z[Y+1]+=J;else Z.push($,J)}function _0(Z,$,J){if(J.length==0)return;let X=$.length-2>>1;if(X<Z.length)Z[Z.length-1]=Z[Z.length-1].append(J);else{while(Z.length<X)Z.push(u.empty);Z.push(J)}}function mZ(Z,$,J){let X=Z.inserted;for(let Y=0,K=0,Q=0;Q<Z.sections.length;){let U=Z.sections[Q++],q=Z.sections[Q++];if(q<0)Y+=U,K+=U;else{let G=Y,z=K,j=u.empty;for(;;){if(G+=U,z+=q,q&&X)j=j.append(X[Q-2>>1]);if(J||Q==Z.sections.length||Z.sections[Q+1]<0)break;U=Z.sections[Q++],q=Z.sections[Q++]}$(Y,G,K,z,j),Y=G,K=z}}}function uZ(Z,$,J,X=!1){let Y=[],K=X?[]:null,Q=new r0(Z),U=new r0($);for(let q=-1;;)if(Q.done&&U.len||U.done&&Q.len)throw Error("Mismatched change set lengths");else if(Q.ins==-1&&U.ins==-1){let G=Math.min(Q.len,U.len);O9(Y,G,-1),Q.forward(G),U.forward(G)}else if(U.ins>=0&&(Q.ins<0||q==Q.i||Q.off==0&&(U.len<Q.len||U.len==Q.len&&!J))){let G=U.len;O9(Y,U.ins,-1);while(G){let z=Math.min(Q.len,G);if(Q.ins>=0&&q<Q.i&&Q.len<=z){if(O9(Y,0,Q.ins),K)_0(K,Y,Q.text);q=Q.i}Q.forward(z),G-=z}U.next()}else if(Q.ins>=0){let G=0,z=Q.len;while(z)if(U.ins==-1){let j=Math.min(z,U.len);G+=j,z-=j,U.forward(j)}else if(U.ins==0&&U.len<z)z-=U.len,U.next();else break;if(O9(Y,G,q<Q.i?Q.ins:0),K&&q<Q.i)_0(K,Y,Q.text);q=Q.i,Q.forward(Q.len-z)}else if(Q.done&&U.done)return K?J9.createSet(Y,K):p9.create(Y);else throw Error("Mismatched change set lengths")}function W8(Z,$,J=!1){let X=[],Y=J?[]:null,K=new r0(Z),Q=new r0($);for(let U=!1;;)if(K.done&&Q.done)return Y?J9.createSet(X,Y):p9.create(X);else if(K.ins==0)O9(X,K.len,0,U),K.next();else if(Q.len==0&&!Q.done){if(O9(X,0,Q.ins,U),Y)_0(Y,X,Q.text);Q.next()}else if(K.done||Q.done)throw Error("Mismatched change set lengths");else{let q=Math.min(K.len2,Q.len),G=X.length;if(K.ins==-1){let z=Q.ins==-1?-1:Q.off?0:Q.ins;if(O9(X,q,z,U),Y&&z)_0(Y,X,Q.text)}else if(Q.ins==-1){if(O9(X,K.off?0:K.len,q,U),Y)_0(Y,X,K.textBit(q))}else if(O9(X,K.off?0:K.len,Q.off?0:Q.ins,U),Y&&!Q.off)_0(Y,X,Q.text);U=(K.ins>q||Q.ins>=0&&Q.len>q)&&(U||X.length>G),K.forward2(q),Q.forward(q)}}class r0{constructor(Z){this.set=Z,this.i=0,this.next()}next(){let{sections:Z}=this.set;if(this.i<Z.length)this.len=Z[this.i++],this.ins=Z[this.i++];else this.len=0,this.ins=-2;this.off=0}get done(){return this.ins==-2}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:Z}=this.set,$=this.i-2>>1;return $>=Z.length?u.empty:Z[$]}textBit(Z){let{inserted:$}=this.set,J=this.i-2>>1;return J>=$.length&&!Z?u.empty:$[J].slice(this.off,Z==null?void 0:this.off+Z)}forward(Z){if(Z==this.len)this.next();else this.len-=Z,this.off+=Z}forward2(Z){if(this.ins==-1)this.forward(Z);else if(Z==this.ins)this.next();else this.ins-=Z,this.off+=Z}}class y0{constructor(Z,$,J){this.from=Z,this.to=$,this.flags=J}get anchor(){return this.flags&32?this.to:this.from}get head(){return this.flags&32?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return this.flags&8?-1:this.flags&16?1:0}get bidiLevel(){let Z=this.flags&7;return Z==7?null:Z}get goalColumn(){let Z=this.flags>>6;return Z==16777215?void 0:Z}map(Z,$=-1){let J,X;if(this.empty)J=X=Z.mapPos(this.from,$);else J=Z.mapPos(this.from,1),X=Z.mapPos(this.to,-1);return J==this.from&&X==this.to?this:new y0(J,X,this.flags)}extend(Z,$=Z){if(Z<=this.anchor&&$>=this.anchor)return R.range(Z,$);let J=Math.abs(Z-this.anchor)>Math.abs($-this.anchor)?Z:$;return R.range(this.anchor,J)}eq(Z,$=!1){return this.anchor==Z.anchor&&this.head==Z.head&&this.goalColumn==Z.goalColumn&&(!$||!this.empty||this.assoc==Z.assoc)}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(Z){if(!Z||typeof Z.anchor!="number"||typeof Z.head!="number")throw RangeError("Invalid JSON representation for SelectionRange");return R.range(Z.anchor,Z.head)}static create(Z,$,J){return new y0(Z,$,J)}}class R{constructor(Z,$){this.ranges=Z,this.mainIndex=$}map(Z,$=-1){if(Z.empty)return this;return R.create(this.ranges.map((J)=>J.map(Z,$)),this.mainIndex)}eq(Z,$=!1){if(this.ranges.length!=Z.ranges.length||this.mainIndex!=Z.mainIndex)return!1;for(let J=0;J<this.ranges.length;J++)if(!this.ranges[J].eq(Z.ranges[J],$))return!1;return!0}get main(){return this.ranges[this.mainIndex]}asSingle(){return this.ranges.length==1?this:new R([this.main],0)}addRange(Z,$=!0){return R.create([Z].concat(this.ranges),$?0:this.mainIndex+1)}replaceRange(Z,$=this.mainIndex){let J=this.ranges.slice();return J[$]=Z,R.create(J,this.mainIndex)}toJSON(){return{ranges:this.ranges.map((Z)=>Z.toJSON()),main:this.mainIndex}}static fromJSON(Z){if(!Z||!Array.isArray(Z.ranges)||typeof Z.main!="number"||Z.main>=Z.ranges.length)throw RangeError("Invalid JSON representation for EditorSelection");return new R(Z.ranges.map(($)=>y0.fromJSON($)),Z.main)}static single(Z,$=Z){return new R([R.range(Z,$)],0)}static create(Z,$=0){if(Z.length==0)throw RangeError("A selection needs at least one range");for(let J=0,X=0;X<Z.length;X++){let Y=Z[X];if(Y.empty?Y.from<=J:Y.from<J)return R.normalized(Z.slice(),$);J=Y.to}return new R(Z,$)}static cursor(Z,$=0,J,X){return y0.create(Z,Z,($==0?0:$<0?8:16)|(J==null?7:Math.min(6,J))|(X!==null&&X!==void 0?X:16777215)<<6)}static range(Z,$,J,X){let Y=(J!==null&&J!==void 0?J:16777215)<<6|(X==null?7:Math.min(6,X));return $<Z?y0.create($,Z,48|Y):y0.create(Z,$,($>Z?8:0)|Y)}static normalized(Z,$=0){let J=Z[$];Z.sort((X,Y)=>X.from-Y.from),$=Z.indexOf(J);for(let X=1;X<Z.length;X++){let Y=Z[X],K=Z[X-1];if(Y.empty?Y.from<=K.to:Y.from<K.to){let Q=K.from,U=Math.max(Y.to,K.to);if(X<=$)$--;Z.splice(--X,2,Y.anchor>Y.head?R.range(U,Q):R.range(Q,U))}}return new R(Z,$)}}function O8(Z,$){for(let J of Z.ranges)if(J.to>$)throw RangeError("Selection points outside of document")}var iZ=0;class L{constructor(Z,$,J,X,Y){this.combine=Z,this.compareInput=$,this.compare=J,this.isStatic=X,this.id=iZ++,this.default=Z([]),this.extensions=typeof Y=="function"?Y(this):Y}get reader(){return this}static define(Z={}){return new L(Z.combine||(($)=>$),Z.compareInput||(($,J)=>$===J),Z.compare||(!Z.combine?aZ:($,J)=>$===J),!!Z.static,Z.enables)}of(Z){return new A5([],this,0,Z)}compute(Z,$){if(this.isStatic)throw Error("Can't compute a static facet");return new A5(Z,this,1,$)}computeN(Z,$){if(this.isStatic)throw Error("Can't compute a static facet");return new A5(Z,this,2,$)}from(Z,$){if(!$)$=(J)=>J;return this.compute([Z],(J)=>$(J.field(Z)))}}function aZ(Z,$){return Z==$||Z.length==$.length&&Z.every((J,X)=>J===$[X])}class A5{constructor(Z,$,J,X){this.dependencies=Z,this.facet=$,this.type=J,this.value=X,this.id=iZ++}dynamicSlot(Z){var $;let J=this.value,X=this.facet.compareInput,Y=this.id,K=Z[Y]>>1,Q=this.type==2,U=!1,q=!1,G=[];for(let z of this.dependencies)if(z=="doc")U=!0;else if(z=="selection")q=!0;else if(((($=Z[z.id])!==null&&$!==void 0?$:1)&1)==0)G.push(Z[z.id]);return{create(z){return z.values[K]=J(z),1},update(z,j){if(U&&j.docChanged||q&&(j.docChanged||j.selection)||fZ(z,G)){let W=J(z);if(Q?!U8(W,z.values[K],X):!X(W,z.values[K]))return z.values[K]=W,1}return 0},reconfigure:(z,j)=>{let W,O=j.config.address[Y];if(O!=null){let _=R7(j,O);if(this.dependencies.every((V)=>{return V instanceof L?j.facet(V)===z.facet(V):V instanceof a?j.field(V,!1)==z.field(V,!1):!0})||(Q?U8(W=J(z),_,X):X(W=J(z),_)))return z.values[K]=_,0}else W=J(z);return z.values[K]=W,1}}}}function U8(Z,$,J){if(Z.length!=$.length)return!1;for(let X=0;X<Z.length;X++)if(!J(Z[X],$[X]))return!1;return!0}function fZ(Z,$){let J=!1;for(let X of $)if(L5(Z,X)&1)J=!0;return J}function b2(Z,$,J){let X=J.map((q)=>Z[q.id]),Y=J.map((q)=>q.type),K=X.filter((q)=>!(q&1)),Q=Z[$.id]>>1;function U(q){let G=[];for(let z=0;z<X.length;z++){let j=R7(q,X[z]);if(Y[z]==2)for(let W of j)G.push(W);else G.push(j)}return $.combine(G)}return{create(q){for(let G of X)L5(q,G);return q.values[Q]=U(q),1},update(q,G){if(!fZ(q,K))return 0;let z=U(q);if($.compare(z,q.values[Q]))return 0;return q.values[Q]=z,1},reconfigure(q,G){let z=fZ(q,X),j=G.config.facets[$.id],W=G.facet($);if(j&&!z&&aZ(J,j))return q.values[Q]=W,0;let O=U(q);if($.compare(O,W))return q.values[Q]=W,0;return q.values[Q]=O,1}}}var W7=L.define({static:!0});class a{constructor(Z,$,J,X,Y){this.id=Z,this.createF=$,this.updateF=J,this.compareF=X,this.spec=Y,this.provides=void 0}static define(Z){let $=new a(iZ++,Z.create,Z.update,Z.compare||((J,X)=>J===X),Z);if(Z.provide)$.provides=Z.provide($);return $}create(Z){let $=Z.facet(W7).find((J)=>J.field==this);return(($===null||$===void 0?void 0:$.create)||this.createF)(Z)}slot(Z){let $=Z[this.id]>>1;return{create:(J)=>{return J.values[$]=this.create(J),1},update:(J,X)=>{let Y=J.values[$],K=this.updateF(Y,X);if(this.compareF(Y,K))return 0;return J.values[$]=K,1},reconfigure:(J,X)=>{let Y=J.facet(W7),K=X.facet(W7),Q;if((Q=Y.find((U)=>U.field==this))&&Q!=K.find((U)=>U.field==this))return J.values[$]=Q.create(J),1;if(X.config.address[this.id]!=null)return J.values[$]=X.field(this),0;return J.values[$]=this.create(J),1}}}init(Z){return[this,W7.of({field:this,create:Z})]}get extension(){return this}}var T0={lowest:4,low:3,default:2,high:1,highest:0};function F5(Z){return($)=>new rZ($,Z)}var d9={highest:F5(T0.highest),high:F5(T0.high),default:F5(T0.default),low:F5(T0.low),lowest:F5(T0.lowest)};class rZ{constructor(Z,$){this.inner=Z,this.prec=$}}class o0{of(Z){return new H7(this,Z)}reconfigure(Z){return o0.reconfigure.of({compartment:this,extension:Z})}get(Z){return Z.config.compartments.get(this)}}class H7{constructor(Z,$){this.compartment=Z,this.inner=$}}class N7{constructor(Z,$,J,X,Y,K){this.base=Z,this.compartments=$,this.dynamicSlots=J,this.address=X,this.staticValues=Y,this.facets=K,this.statusTemplate=[];while(this.statusTemplate.length<J.length)this.statusTemplate.push(0)}staticFacet(Z){let $=this.address[Z.id];return $==null?Z.default:this.staticValues[$>>1]}static resolve(Z,$,J){let X=[],Y=Object.create(null),K=new Map;for(let j of x2(Z,$,K))if(j instanceof a)X.push(j);else(Y[j.facet.id]||(Y[j.facet.id]=[])).push(j);let Q=Object.create(null),U=[],q=[];for(let j of X)Q[j.id]=q.length<<1,q.push((W)=>j.slot(W));let G=J===null||J===void 0?void 0:J.config.facets;for(let j in Y){let W=Y[j],O=W[0].facet,_=G&&G[j]||[];if(W.every((V)=>V.type==0))if(Q[O.id]=U.length<<1|1,aZ(_,W))U.push(J.facet(O));else{let V=O.combine(W.map((H)=>H.value));U.push(J&&O.compare(V,J.facet(O))?J.facet(O):V)}else{for(let V of W)if(V.type==0)Q[V.id]=U.length<<1|1,U.push(V.value);else Q[V.id]=q.length<<1,q.push((H)=>V.dynamicSlot(H));Q[O.id]=q.length<<1,q.push((V)=>b2(V,O,W))}}let z=q.map((j)=>j(Q));return new N7(Z,K,z,Q,U,Y)}}function x2(Z,$,J){let X=[[],[],[],[],[]],Y=new Map;function K(Q,U){let q=Y.get(Q);if(q!=null){if(q<=U)return;let G=X[q].indexOf(Q);if(G>-1)X[q].splice(G,1);if(Q instanceof H7)J.delete(Q.compartment)}if(Y.set(Q,U),Array.isArray(Q))for(let G of Q)K(G,U);else if(Q instanceof H7){if(J.has(Q.compartment))throw RangeError("Duplicate use of compartment in extensions");let G=$.get(Q.compartment)||Q.inner;J.set(Q.compartment,G),K(G,U)}else if(Q instanceof rZ)K(Q.inner,Q.prec);else if(Q instanceof a){if(X[U].push(Q),Q.provides)K(Q.provides,U)}else if(Q instanceof A5){if(X[U].push(Q),Q.facet.extensions)K(Q.facet.extensions,T0.default)}else{let G=Q.extension;if(!G)throw Error(`Unrecognized extension value in extension set (${Q}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);K(G,U)}}return K(Z,T0.default),X.reduce((Q,U)=>Q.concat(U))}function L5(Z,$){if($&1)return 2;let J=$>>1,X=Z.status[J];if(X==4)throw Error("Cyclic dependency between fields and/or facets");if(X&2)return X;Z.status[J]=4;let Y=Z.computeSlot(Z,Z.config.dynamicSlots[J]);return Z.status[J]=2|Y}function R7(Z,$){return $&1?Z.config.staticValues[$>>1]:Z.values[$>>1]}var _8=L.define(),gZ=L.define({combine:(Z)=>Z.some(($)=>$),static:!0}),V8=L.define({combine:(Z)=>Z.length?Z[0]:void 0,static:!0}),H8=L.define(),N8=L.define(),R8=L.define(),I8=L.define({combine:(Z)=>Z.length?Z[0]:!1});class B9{constructor(Z,$){this.type=Z,this.value=$}static define(){return new D8}}class D8{of(Z){return new B9(this,Z)}}class F8{constructor(Z){this.map=Z}of(Z){return new k(this,Z)}}class k{constructor(Z,$){this.type=Z,this.value=$}map(Z){let $=this.type.map(this.value,Z);return $===void 0?void 0:$==this.value?this:new k(this.type,$)}is(Z){return this.type==Z}static define(Z={}){return new F8(Z.map||(($)=>$))}static mapEffects(Z,$){if(!Z.length)return Z;let J=[];for(let X of Z){let Y=X.map($);if(Y)J.push(Y)}return J}}k.reconfigure=k.define();k.appendConfig=k.define();class e{constructor(Z,$,J,X,Y,K){if(this.startState=Z,this.changes=$,this.selection=J,this.effects=X,this.annotations=Y,this.scrollIntoView=K,this._doc=null,this._state=null,J)O8(J,$.newLength);if(!Y.some((Q)=>Q.type==e.time))this.annotations=Y.concat(e.time.of(Date.now()))}static create(Z,$,J,X,Y,K){return new e(Z,$,J,X,Y,K)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){if(!this._state)this.startState.applyTransaction(this);return this._state}annotation(Z){for(let $ of this.annotations)if($.type==Z)return $.value;return}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(Z){let $=this.annotation(e.userEvent);return!!($&&($==Z||$.length>Z.length&&$.slice(0,Z.length)==Z&&$[Z.length]=="."))}}e.time=B9.define();e.userEvent=B9.define();e.addToHistory=B9.define();e.remote=B9.define();function w2(Z,$){let J=[];for(let X=0,Y=0;;){let K,Q;if(X<Z.length&&(Y==$.length||$[Y]>=Z[X]))K=Z[X++],Q=Z[X++];else if(Y<$.length)K=$[Y++],Q=$[Y++];else return J;if(!J.length||J[J.length-1]<K)J.push(K,Q);else if(J[J.length-1]<Q)J[J.length-1]=Q}}function A8(Z,$,J){var X;let Y,K,Q;if(J)Y=$.changes,K=J9.empty($.changes.length),Q=Z.changes.compose($.changes);else Y=$.changes.map(Z.changes),K=Z.changes.mapDesc($.changes,!0),Q=Z.changes.compose(Y);return{changes:Q,selection:$.selection?$.selection.map(K):(X=Z.selection)===null||X===void 0?void 0:X.map(Y),effects:k.mapEffects(Z.effects,Y).concat(k.mapEffects($.effects,K)),annotations:Z.annotations.length?Z.annotations.concat($.annotations):$.annotations,scrollIntoView:Z.scrollIntoView||$.scrollIntoView}}function pZ(Z,$,J){let X=$.selection,Y=i0($.annotations);if($.userEvent)Y=Y.concat(e.userEvent.of($.userEvent));return{changes:$.changes instanceof J9?$.changes:J9.of($.changes||[],J,Z.facet(V8)),selection:X&&(X instanceof R?X:R.single(X.anchor,X.head)),effects:i0($.effects),annotations:Y,scrollIntoView:!!$.scrollIntoView}}function L8(Z,$,J){let X=pZ(Z,$.length?$[0]:{},Z.doc.length);if($.length&&$[0].filter===!1)J=!1;for(let K=1;K<$.length;K++){if($[K].filter===!1)J=!1;let Q=!!$[K].sequential;X=A8(X,pZ(Z,$[K],Q?X.changes.newLength:Z.doc.length),Q)}let Y=e.create(Z,X.changes,X.selection,X.effects,X.annotations,X.scrollIntoView);return v2(J?h2(Y):Y)}function h2(Z){let $=Z.startState,J=!0;for(let Y of $.facet(H8)){let K=Y(Z);if(K===!1){J=!1;break}if(Array.isArray(K))J=J===!0?K:w2(J,K)}if(J!==!0){let Y,K;if(J===!1)K=Z.changes.invertedDesc,Y=J9.empty($.doc.length);else{let Q=Z.changes.filter(J);Y=Q.changes,K=Q.filtered.mapDesc(Q.changes).invertedDesc}Z=e.create($,Y,Z.selection&&Z.selection.map(K),k.mapEffects(Z.effects,K),Z.annotations,Z.scrollIntoView)}let X=$.facet(N8);for(let Y=X.length-1;Y>=0;Y--){let K=X[Y](Z);if(K instanceof e)Z=K;else if(Array.isArray(K)&&K.length==1&&K[0]instanceof e)Z=K[0];else Z=L8($,i0(K),!1)}return Z}function v2(Z){let $=Z.startState,J=$.facet(R8),X=Z;for(let Y=J.length-1;Y>=0;Y--){let K=J[Y](Z);if(K&&Object.keys(K).length)X=A8(X,pZ($,K,Z.changes.newLength),!0)}return X==Z?Z:e.create($,Z.changes,Z.selection,X.effects,X.annotations,X.scrollIntoView)}var m2=[];function i0(Z){return Z==null?m2:Array.isArray(Z)?Z:[Z]}var d=function(Z){return Z[Z.Word=0]="Word",Z[Z.Space=1]="Space",Z[Z.Other=2]="Other",Z}(d||(d={})),u2=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,lZ;try{lZ=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(Z){}function f2(Z){if(lZ)return lZ.test(Z);for(let $=0;$<Z.length;$++){let J=Z[$];if(/\w/.test(J)||J>""&&(J.toUpperCase()!=J.toLowerCase()||u2.test(J)))return!0}return!1}function g2(Z){return($)=>{if(!/\S/.test($))return d.Space;if(f2($))return d.Word;for(let J=0;J<Z.length;J++)if($.indexOf(Z[J])>-1)return d.Word;return d.Other}}class h{constructor(Z,$,J,X,Y,K){if(this.config=Z,this.doc=$,this.selection=J,this.values=X,this.status=Z.statusTemplate.slice(),this.computeSlot=Y,K)K._state=this;for(let Q=0;Q<this.config.dynamicSlots.length;Q++)L5(this,Q<<1);this.computeSlot=null}field(Z,$=!0){let J=this.config.address[Z.id];if(J==null){if($)throw RangeError("Field is not present in this state");return}return L5(this,J),R7(this,J)}update(...Z){return L8(this,Z,!0)}applyTransaction(Z){let $=this.config,{base:J,compartments:X}=$;for(let Q of Z.effects)if(Q.is(o0.reconfigure)){if($)X=new Map,$.compartments.forEach((U,q)=>X.set(q,U)),$=null;X.set(Q.value.compartment,Q.value.extension)}else if(Q.is(k.reconfigure))$=null,J=Q.value;else if(Q.is(k.appendConfig))$=null,J=i0(J).concat(Q.value);let Y;if(!$)$=N7.resolve(J,X,this),Y=new h($,this.doc,this.selection,$.dynamicSlots.map(()=>null),(U,q)=>q.reconfigure(U,this),null).values;else Y=Z.startState.values.slice();let K=Z.startState.facet(gZ)?Z.newSelection:Z.newSelection.asSingle();new h($,Z.newDoc,K,Y,(Q,U)=>U.update(Q,Z),Z)}replaceSelection(Z){if(typeof Z=="string")Z=this.toText(Z);return this.changeByRange(($)=>({changes:{from:$.from,to:$.to,insert:Z},range:R.cursor($.from+Z.length)}))}changeByRange(Z){let $=this.selection,J=Z($.ranges[0]),X=this.changes(J.changes),Y=[J.range],K=i0(J.effects);for(let Q=1;Q<$.ranges.length;Q++){let U=Z($.ranges[Q]),q=this.changes(U.changes),G=q.map(X);for(let j=0;j<Q;j++)Y[j]=Y[j].map(G);let z=X.mapDesc(q,!0);Y.push(U.range.map(z)),X=X.compose(G),K=k.mapEffects(K,G).concat(k.mapEffects(i0(U.effects),z))}return{changes:X,selection:R.create(Y,$.mainIndex),effects:K}}changes(Z=[]){if(Z instanceof J9)return Z;return J9.of(Z,this.doc.length,this.facet(h.lineSeparator))}toText(Z){return u.of(Z.split(this.facet(h.lineSeparator)||vZ))}sliceDoc(Z=0,$=this.doc.length){return this.doc.sliceString(Z,$,this.lineBreak)}facet(Z){let $=this.config.address[Z.id];if($==null)return Z.default;return L5(this,$),R7(this,$)}toJSON(Z){let $={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(Z)for(let J in Z){let X=Z[J];if(X instanceof a&&this.config.address[X.id]!=null)$[J]=X.spec.toJSON(this.field(Z[J]),this)}return $}static fromJSON(Z,$={},J){if(!Z||typeof Z.doc!="string")throw RangeError("Invalid JSON representation for EditorState");let X=[];if(J){for(let Y in J)if(Object.prototype.hasOwnProperty.call(Z,Y)){let K=J[Y],Q=Z[Y];X.push(K.init((U)=>K.spec.fromJSON(Q,U)))}}return h.create({doc:Z.doc,selection:R.fromJSON(Z.selection),extensions:$.extensions?X.concat([$.extensions]):X})}static create(Z={}){let $=N7.resolve(Z.extensions||[],new Map),J=Z.doc instanceof u?Z.doc:u.of((Z.doc||"").split($.staticFacet(h.lineSeparator)||vZ)),X=!Z.selection?R.single(0):Z.selection instanceof R?Z.selection:R.single(Z.selection.anchor,Z.selection.head);if(O8(X,J.length),!$.staticFacet(gZ))X=X.asSingle();return new h($,J,X,$.dynamicSlots.map(()=>null),(Y,K)=>K.create(Y),null)}get tabSize(){return this.facet(h.tabSize)}get lineBreak(){return this.facet(h.lineSeparator)||`
`}get readOnly(){return this.facet(I8)}phrase(Z,...$){for(let J of this.facet(h.phrases))if(Object.prototype.hasOwnProperty.call(J,Z)){Z=J[Z];break}if($.length)Z=Z.replace(/\$(\$|\d*)/g,(J,X)=>{if(X=="$")return"$";let Y=+(X||1);return!Y||Y>$.length?J:$[Y-1]});return Z}languageDataAt(Z,$,J=-1){let X=[];for(let Y of this.facet(_8))for(let K of Y(this,$,J))if(Object.prototype.hasOwnProperty.call(K,Z))X.push(K[Z]);return X}charCategorizer(Z){let $=this.languageDataAt("wordChars",Z);return g2($.length?$[0]:"")}wordAt(Z){let{text:$,from:J,length:X}=this.doc.lineAt(Z),Y=this.charCategorizer(Z),K=Z-J,Q=Z-J;while(K>0){let U=X9($,K,!1);if(Y($.slice(U,K))!=d.Word)break;K=U}while(Q<X){let U=X9($,Q);if(Y($.slice(Q,U))!=d.Word)break;Q=U}return K==Q?null:R.range(K+J,Q+J)}}h.allowMultipleSelections=gZ;h.tabSize=L.define({combine:(Z)=>Z.length?Z[0]:4});h.lineSeparator=V8;h.readOnly=I8;h.phrases=L.define({compare(Z,$){let J=Object.keys(Z),X=Object.keys($);return J.length==X.length&&J.every((Y)=>Z[Y]==$[Y])}});h.languageData=_8;h.changeFilter=H8;h.transactionFilter=N8;h.transactionExtender=R8;o0.reconfigure=k.define();function _9(Z,$,J={}){let X={};for(let Y of Z)for(let K of Object.keys(Y)){let Q=Y[K],U=X[K];if(U===void 0)X[K]=Q;else if(U===Q||Q===void 0);else if(Object.hasOwnProperty.call(J,K))X[K]=J[K](U,Q);else throw Error("Config merge conflict for field "+K)}for(let Y in $)if(X[Y]===void 0)X[Y]=$[Y];return X}class l9{eq(Z){return this==Z}range(Z,$=Z){return M5.create(Z,$,this)}}l9.prototype.startSide=l9.prototype.endSide=0;l9.prototype.point=!1;l9.prototype.mapMode=q9.TrackDel;function oZ(Z,$){return Z==$||Z.constructor==$.constructor&&Z.eq($)}class M5{constructor(Z,$,J){this.from=Z,this.to=$,this.value=J}static create(Z,$,J){return new M5(Z,$,J)}}function dZ(Z,$){return Z.from-$.from||Z.value.startSide-$.value.startSide}class tZ{constructor(Z,$,J,X){this.from=Z,this.to=$,this.value=J,this.maxPoint=X}get length(){return this.to[this.to.length-1]}findIndex(Z,$,J,X=0){let Y=J?this.to:this.from;for(let K=X,Q=Y.length;;){if(K==Q)return K;let U=K+Q>>1,q=Y[U]-Z||(J?this.value[U].endSide:this.value[U].startSide)-$;if(U==K)return q>=0?K:Q;if(q>=0)Q=U;else K=U+1}}between(Z,$,J,X){for(let Y=this.findIndex($,-1e9,!0),K=this.findIndex(J,1e9,!1,Y);Y<K;Y++)if(X(this.from[Y]+Z,this.to[Y]+Z,this.value[Y])===!1)return!1}map(Z,$){let J=[],X=[],Y=[],K=-1,Q=-1;for(let U=0;U<this.value.length;U++){let q=this.value[U],G=this.from[U]+Z,z=this.to[U]+Z,j,W;if(G==z){let O=$.mapPos(G,q.startSide,q.mapMode);if(O==null)continue;if(j=W=O,q.startSide!=q.endSide){if(W=$.mapPos(G,q.endSide),W<j)continue}}else if(j=$.mapPos(G,q.startSide),W=$.mapPos(z,q.endSide),j>W||j==W&&q.startSide>0&&q.endSide<=0)continue;if((W-j||q.endSide-q.startSide)<0)continue;if(K<0)K=j;if(q.point)Q=Math.max(Q,W-j);J.push(q),X.push(j-K),Y.push(W-K)}return{mapped:J.length?new tZ(X,Y,J,Q):null,pos:K}}}class b{constructor(Z,$,J,X){this.chunkPos=Z,this.chunk=$,this.nextLayer=J,this.maxPoint=X}static create(Z,$,J,X){return new b(Z,$,J,X)}get length(){let Z=this.chunk.length-1;return Z<0?0:Math.max(this.chunkEnd(Z),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let Z=this.nextLayer.size;for(let $ of this.chunk)Z+=$.value.length;return Z}chunkEnd(Z){return this.chunkPos[Z]+this.chunk[Z].length}update(Z){let{add:$=[],sort:J=!1,filterFrom:X=0,filterTo:Y=this.length}=Z,K=Z.filter;if($.length==0&&!K)return this;if(J)$=$.slice().sort(dZ);if(this.isEmpty)return $.length?b.of($):this;let Q=new eZ(this,null,-1).goto(0),U=0,q=[],G=new M9;while(Q.value||U<$.length)if(U<$.length&&(Q.from-$[U].from||Q.startSide-$[U].value.startSide)>=0){let z=$[U++];if(!G.addInner(z.from,z.to,z.value))q.push(z)}else if(Q.rangeIndex==1&&Q.chunkIndex<this.chunk.length&&(U==$.length||this.chunkEnd(Q.chunkIndex)<$[U].from)&&(!K||X>this.chunkEnd(Q.chunkIndex)||Y<this.chunkPos[Q.chunkIndex])&&G.addChunk(this.chunkPos[Q.chunkIndex],this.chunk[Q.chunkIndex]))Q.nextChunk();else{if(!K||X>Q.to||Y<Q.from||K(Q.from,Q.to,Q.value)){if(!G.addInner(Q.from,Q.to,Q.value))q.push(M5.create(Q.from,Q.to,Q.value))}Q.next()}return G.finishInner(this.nextLayer.isEmpty&&!q.length?b.empty:this.nextLayer.update({add:q,filter:K,filterFrom:X,filterTo:Y}))}map(Z){if(Z.empty||this.isEmpty)return this;let $=[],J=[],X=-1;for(let K=0;K<this.chunk.length;K++){let Q=this.chunkPos[K],U=this.chunk[K],q=Z.touchesRange(Q,Q+U.length);if(q===!1)X=Math.max(X,U.maxPoint),$.push(U),J.push(Z.mapPos(Q));else if(q===!0){let{mapped:G,pos:z}=U.map(Q,Z);if(G)X=Math.max(X,G.maxPoint),$.push(G),J.push(z)}}let Y=this.nextLayer.map(Z);return $.length==0?Y:new b(J,$,Y||b.empty,X)}between(Z,$,J){if(this.isEmpty)return;for(let X=0;X<this.chunk.length;X++){let Y=this.chunkPos[X],K=this.chunk[X];if($>=Y&&Z<=Y+K.length&&K.between(Y,Z-Y,$-Y,J)===!1)return}this.nextLayer.between(Z,$,J)}iter(Z=0){return E5.from([this]).goto(Z)}get isEmpty(){return this.nextLayer==this}static iter(Z,$=0){return E5.from(Z).goto($)}static compare(Z,$,J,X,Y=-1){let K=Z.filter((z)=>z.maxPoint>0||!z.isEmpty&&z.maxPoint>=Y),Q=$.filter((z)=>z.maxPoint>0||!z.isEmpty&&z.maxPoint>=Y),U=q8(K,Q,J),q=new s0(K,U,Y),G=new s0(Q,U,Y);if(J.iterGaps((z,j,W)=>G8(q,z,G,j,W,X)),J.empty&&J.length==0)G8(q,0,G,0,0,X)}static eq(Z,$,J=0,X){if(X==null)X=999999999;let Y=Z.filter((G)=>!G.isEmpty&&$.indexOf(G)<0),K=$.filter((G)=>!G.isEmpty&&Z.indexOf(G)<0);if(Y.length!=K.length)return!1;if(!Y.length)return!0;let Q=q8(Y,K),U=new s0(Y,Q,0).goto(J),q=new s0(K,Q,0).goto(J);for(;;){if(U.to!=q.to||!cZ(U.active,q.active)||U.point&&(!q.point||!oZ(U.point,q.point)))return!1;if(U.to>X)return!0;U.next(),q.next()}}static spans(Z,$,J,X,Y=-1){let K=new s0(Z,null,Y).goto($),Q=$,U=K.openStart;for(;;){let q=Math.min(K.to,J);if(K.point){let G=K.activeForPoint(K.to),z=K.pointFrom<$?G.length+1:K.point.startSide<0?G.length:Math.min(G.length,U);X.point(Q,q,K.point,G,z,K.pointRank),U=Math.min(K.openEnd(q),G.length)}else if(q>Q)X.span(Q,q,K.active,U),U=K.openEnd(q);if(K.to>J)return U+(K.point&&K.to>J?1:0);Q=K.to,K.next()}}static of(Z,$=!1){let J=new M9;for(let X of Z instanceof M5?[Z]:$?p2(Z):Z)J.add(X.from,X.to,X.value);return J.finish()}static join(Z){if(!Z.length)return b.empty;let $=Z[Z.length-1];for(let J=Z.length-2;J>=0;J--)for(let X=Z[J];X!=b.empty;X=X.nextLayer)$=new b(X.chunkPos,X.chunk,$,Math.max(X.maxPoint,$.maxPoint));return $}}b.empty=new b([],[],null,-1);function p2(Z){if(Z.length>1)for(let $=Z[0],J=1;J<Z.length;J++){let X=Z[J];if(dZ($,X)>0)return Z.slice().sort(dZ);$=X}return Z}b.empty.nextLayer=b.empty;class M9{finishChunk(Z){if(this.chunks.push(new tZ(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,Z)this.from=[],this.to=[],this.value=[]}constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9,this.lastTo=-1e9,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null}add(Z,$,J){if(!this.addInner(Z,$,J))(this.nextLayer||(this.nextLayer=new M9)).add(Z,$,J)}addInner(Z,$,J){let X=Z-this.lastTo||J.startSide-this.last.endSide;if(X<=0&&(Z-this.lastFrom||J.startSide-this.last.startSide)<0)throw Error("Ranges must be added sorted by `from` position and `startSide`");if(X<0)return!1;if(this.from.length==250)this.finishChunk(!0);if(this.chunkStart<0)this.chunkStart=Z;if(this.from.push(Z-this.chunkStart),this.to.push($-this.chunkStart),this.last=J,this.lastFrom=Z,this.lastTo=$,this.value.push(J),J.point)this.maxPoint=Math.max(this.maxPoint,$-Z);return!0}addChunk(Z,$){if((Z-this.lastTo||$.value[0].startSide-this.last.endSide)<0)return!1;if(this.from.length)this.finishChunk(!0);this.setMaxPoint=Math.max(this.setMaxPoint,$.maxPoint),this.chunks.push($),this.chunkPos.push(Z);let J=$.value.length-1;return this.last=$.value[J],this.lastFrom=$.from[J]+Z,this.lastTo=$.to[J]+Z,!0}finish(){return this.finishInner(b.empty)}finishInner(Z){if(this.from.length)this.finishChunk(!1);if(this.chunks.length==0)return Z;let $=b.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(Z):Z,this.setMaxPoint);return this.from=null,$}}function q8(Z,$,J){let X=new Map;for(let K of Z)for(let Q=0;Q<K.chunk.length;Q++)if(K.chunk[Q].maxPoint<=0)X.set(K.chunk[Q],K.chunkPos[Q]);let Y=new Set;for(let K of $)for(let Q=0;Q<K.chunk.length;Q++){let U=X.get(K.chunk[Q]);if(U!=null&&(J?J.mapPos(U):U)==K.chunkPos[Q]&&!(J===null||J===void 0?void 0:J.touchesRange(U,U+K.chunk[Q].length)))Y.add(K.chunk[Q])}return Y}class eZ{constructor(Z,$,J,X=0){this.layer=Z,this.skip=$,this.minPoint=J,this.rank=X}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(Z,$=-1e9){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(Z,$,!1),this}gotoInner(Z,$,J){while(this.chunkIndex<this.layer.chunk.length){let X=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(X)||this.layer.chunkEnd(this.chunkIndex)<Z||X.maxPoint<this.minPoint))break;this.chunkIndex++,J=!1}if(this.chunkIndex<this.layer.chunk.length){let X=this.layer.chunk[this.chunkIndex].findIndex(Z-this.layer.chunkPos[this.chunkIndex],$,!0);if(!J||this.rangeIndex<X)this.setRangeIndex(X)}this.next()}forward(Z,$){if((this.to-Z||this.endSide-$)<0)this.gotoInner(Z,$,!0)}next(){for(;;)if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9,this.value=null;break}else{let Z=this.layer.chunkPos[this.chunkIndex],$=this.layer.chunk[this.chunkIndex],J=Z+$.from[this.rangeIndex];if(this.from=J,this.to=Z+$.to[this.rangeIndex],this.value=$.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}setRangeIndex(Z){if(Z==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)while(this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=Z}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next()}compare(Z){return this.from-Z.from||this.startSide-Z.startSide||this.rank-Z.rank||this.to-Z.to||this.endSide-Z.endSide}}class E5{constructor(Z){this.heap=Z}static from(Z,$=null,J=-1){let X=[];for(let Y=0;Y<Z.length;Y++)for(let K=Z[Y];!K.isEmpty;K=K.nextLayer)if(K.maxPoint>=J)X.push(new eZ(K,$,J,Y));return X.length==1?X[0]:new E5(X)}get startSide(){return this.value?this.value.startSide:0}goto(Z,$=-1e9){for(let J of this.heap)J.goto(Z,$);for(let J=this.heap.length>>1;J>=0;J--)hZ(this.heap,J);return this.next(),this}forward(Z,$){for(let J of this.heap)J.forward(Z,$);for(let J=this.heap.length>>1;J>=0;J--)hZ(this.heap,J);if((this.to-Z||this.value.endSide-$)<0)this.next()}next(){if(this.heap.length==0)this.from=this.to=1e9,this.value=null,this.rank=-1;else{let Z=this.heap[0];if(this.from=Z.from,this.to=Z.to,this.value=Z.value,this.rank=Z.rank,Z.value)Z.next();hZ(this.heap,0)}}}function hZ(Z,$){for(let J=Z[$];;){let X=($<<1)+1;if(X>=Z.length)break;let Y=Z[X];if(X+1<Z.length&&Y.compare(Z[X+1])>=0)Y=Z[X+1],X++;if(J.compare(Y)<0)break;Z[X]=J,Z[$]=Y,$=X}}class s0{constructor(Z,$,J){this.minPoint=J,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9,this.endSide=0,this.openStart=-1,this.cursor=E5.from(Z,$,J)}goto(Z,$=-1e9){return this.cursor.goto(Z,$),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=Z,this.endSide=$,this.openStart=-1,this.next(),this}forward(Z,$){while(this.minActive>-1&&(this.activeTo[this.minActive]-Z||this.active[this.minActive].endSide-$)<0)this.removeActive(this.minActive);this.cursor.forward(Z,$)}removeActive(Z){O7(this.active,Z),O7(this.activeTo,Z),O7(this.activeRank,Z),this.minActive=z8(this.active,this.activeTo)}addActive(Z){let $=0,{value:J,to:X,rank:Y}=this.cursor;while($<this.activeRank.length&&(Y-this.activeRank[$]||X-this.activeTo[$])>0)$++;if(_7(this.active,$,J),_7(this.activeTo,$,X),_7(this.activeRank,$,Y),Z)_7(Z,$,this.cursor.from);this.minActive=z8(this.active,this.activeTo)}next(){let Z=this.to,$=this.point;this.point=null;let J=this.openStart<0?[]:null;for(;;){let X=this.minActive;if(X>-1&&(this.activeTo[X]-this.cursor.from||this.active[X].endSide-this.cursor.startSide)<0){if(this.activeTo[X]>Z){this.to=this.activeTo[X],this.endSide=this.active[X].endSide;break}if(this.removeActive(X),J)O7(J,X)}else if(!this.cursor.value){this.to=this.endSide=1e9;break}else if(this.cursor.from>Z){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}else{let Y=this.cursor.value;if(!Y.point)this.addActive(J),this.cursor.next();else if($&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)this.cursor.next();else{this.point=Y,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=Y.endSide,this.cursor.next(),this.forward(this.to,this.endSide);break}}}if(J){this.openStart=0;for(let X=J.length-1;X>=0&&J[X]<Z;X--)this.openStart++}}activeForPoint(Z){if(!this.active.length)return this.active;let $=[];for(let J=this.active.length-1;J>=0;J--){if(this.activeRank[J]<this.pointRank)break;if(this.activeTo[J]>Z||this.activeTo[J]==Z&&this.active[J].endSide>=this.point.endSide)$.push(this.active[J])}return $.reverse()}openEnd(Z){let $=0;for(let J=this.activeTo.length-1;J>=0&&this.activeTo[J]>Z;J--)$++;return $}}function G8(Z,$,J,X,Y,K){Z.goto($),J.goto(X);let Q=X+Y,U=X,q=X-$,G=!!K.boundChange;for(let z=!1;;){let j=Z.to+q-J.to,W=j||Z.endSide-J.endSide,O=W<0?Z.to+q:J.to,_=Math.min(O,Q);if(Z.point||J.point){if(!(Z.point&&J.point&&oZ(Z.point,J.point)&&cZ(Z.activeForPoint(Z.to),J.activeForPoint(J.to))))K.comparePoint(U,_,Z.point,J.point);z=!1}else{if(z)K.boundChange(U);if(_>U&&!cZ(Z.active,J.active))K.compareRange(U,_,Z.active,J.active);if(G&&_<Q&&(j||Z.openEnd(O)!=J.openEnd(O)))z=!0}if(O>Q)break;if(U=O,W<=0)Z.next();if(W>=0)J.next()}}function cZ(Z,$){if(Z.length!=$.length)return!1;for(let J=0;J<Z.length;J++)if(Z[J]!=$[J]&&!oZ(Z[J],$[J]))return!1;return!0}function O7(Z,$){for(let J=$,X=Z.length-1;J<X;J++)Z[J]=Z[J+1];Z.pop()}function _7(Z,$,J){for(let X=Z.length-1;X>=$;X--)Z[X+1]=Z[X];Z[$]=J}function z8(Z,$){let J=-1,X=1e9;for(let Y=0;Y<$.length;Y++)if(($[Y]-X||Z[Y].endSide-Z[J].endSide)<0)J=Y,X=$[Y];return J}function G0(Z,$,J=Z.length){let X=0;for(let Y=0;Y<J&&Y<Z.length;)if(Z.charCodeAt(Y)==9)X+=$-X%$,Y++;else X++,Y=X9(Z,Y);return X}function I7(Z,$,J,X){for(let Y=0,K=0;;){if(K>=$)return Y;if(Y==Z.length)break;K+=Z.charCodeAt(Y)==9?J-K%J:1,Y=X9(Z,Y)}return X===!0?-1:Z.length}var M8=typeof Symbol>"u"?"__"+"ͼ":Symbol.for("ͼ"),Z3=typeof Symbol>"u"?"__styleSet"+Math.floor(Math.random()*1e8):Symbol("styleSet"),E8=typeof globalThis<"u"?globalThis:typeof window<"u"?window:{};class c9{constructor(Z,$){this.rules=[];let{finish:J}=$||{};function X(K){return/^@/.test(K)?[K]:K.split(/,\s*/)}function Y(K,Q,U,q){let G=[],z=/^@(\w+)\b/.exec(K[0]),j=z&&z[1]=="keyframes";if(z&&Q==null)return U.push(K[0]+";");for(let W in Q){let O=Q[W];if(/&/.test(W))Y(W.split(/,\s*/).map((_)=>K.map((V)=>_.replace(/&/,V))).reduce((_,V)=>_.concat(V)),O,U);else if(O&&typeof O=="object"){if(!z)throw RangeError("The value of a property ("+W+") should be a primitive value.");Y(X(W),O,G,j)}else if(O!=null)G.push(W.replace(/_.*/,"").replace(/[A-Z]/g,(_)=>"-"+_.toLowerCase())+": "+O+";")}if(G.length||j)U.push((J&&!z&&!q?K.map(J):K).join(", ")+" {"+G.join(" ")+"}")}for(let K in Z)Y(X(K),Z[K],this.rules)}getRules(){return this.rules.join(`
`)}static newName(){let Z=E8[M8]||1;return E8[M8]=Z+1,"ͼ"+Z.toString(36)}static mount(Z,$,J){let X=Z[Z3],Y=J&&J.nonce;if(!X)X=new P8(Z,Y);else if(Y)X.setNonce(Y);X.mount(Array.isArray($)?$:[$],Z)}}var B8=new Map;class P8{constructor(Z,$){let J=Z.ownerDocument||Z,X=J.defaultView;if(!Z.head&&Z.adoptedStyleSheets&&X.CSSStyleSheet){let Y=B8.get(J);if(Y)return Z[Z3]=Y;this.sheet=new X.CSSStyleSheet,B8.set(J,this)}else if(this.styleTag=J.createElement("style"),$)this.styleTag.setAttribute("nonce",$);this.modules=[],Z[Z3]=this}mount(Z,$){let J=this.sheet,X=0,Y=0;for(let K=0;K<Z.length;K++){let Q=Z[K],U=this.modules.indexOf(Q);if(U<Y&&U>-1)this.modules.splice(U,1),Y--,U=-1;if(U==-1){if(this.modules.splice(Y++,0,Q),J)for(let q=0;q<Q.rules.length;q++)J.insertRule(Q.rules[q],X++)}else{while(Y<U)X+=this.modules[Y++].rules.length;X+=Q.rules.length,Y++}}if(J){if($.adoptedStyleSheets.indexOf(this.sheet)<0)$.adoptedStyleSheets=[this.sheet,...$.adoptedStyleSheets]}else{let K="";for(let U=0;U<this.modules.length;U++)K+=this.modules[U].getRules()+`
`;this.styleTag.textContent=K;let Q=$.head||$;if(this.styleTag.parentNode!=Q)Q.insertBefore(this.styleTag,Q.firstChild)}}setNonce(Z){if(this.styleTag&&this.styleTag.getAttribute("nonce")!=Z)this.styleTag.setAttribute("nonce",Z)}}var z0={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},t0={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},l2=typeof navigator<"u"&&/Mac/.test(navigator.platform),d2=typeof navigator<"u"&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);for(t=0;t<10;t++)z0[48+t]=z0[96+t]=String(t);var t;for(t=1;t<=24;t++)z0[t+111]="F"+t;var t;for(t=65;t<=90;t++)z0[t]=String.fromCharCode(t+32),t0[t]=String.fromCharCode(t);var t;for(P5 in z0)if(!t0.hasOwnProperty(P5))t0[P5]=z0[P5];var P5;function C8(Z){var $=l2&&Z.metaKey&&Z.shiftKey&&!Z.ctrlKey&&!Z.altKey||d2&&Z.shiftKey&&Z.key&&Z.key.length==1||Z.key=="Unidentified",J=!$&&Z.key||(Z.shiftKey?t0:z0)[Z.keyCode]||Z.key||"Unidentified";if(J=="Esc")J="Escape";if(J=="Del")J="Delete";if(J=="Left")J="ArrowLeft";if(J=="Up")J="ArrowUp";if(J=="Right")J="ArrowRight";if(J=="Down")J="ArrowDown";return J}function f(){var Z=arguments[0];if(typeof Z=="string")Z=document.createElement(Z);var $=1,J=arguments[1];if(J&&typeof J=="object"&&J.nodeType==null&&!Array.isArray(J)){for(var X in J)if(Object.prototype.hasOwnProperty.call(J,X)){var Y=J[X];if(typeof Y=="string")Z.setAttribute(X,Y);else if(Y!=null)Z[X]=Y}$++}for(;$<arguments.length;$++)T8(Z,arguments[$]);return Z}function T8(Z,$){if(typeof $=="string")Z.appendChild(document.createTextNode($));else if($==null);else if($.nodeType!=null)Z.appendChild($);else if(Array.isArray($))for(var J=0;J<$.length;J++)T8(Z,$[J]);else throw RangeError("Unsupported child node: "+$)}var N9=typeof navigator<"u"?navigator:{userAgent:"",vendor:"",platform:""},z3=typeof document<"u"?document:{documentElement:{style:{}}},j3=/Edge\/(\d+)/.exec(N9.userAgent),_1=/MSIE \d/.test(N9.userAgent),W3=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(N9.userAgent),n7=!!(_1||W3||j3),y8=!n7&&/gecko\/(\d+)/i.test(N9.userAgent),$3=!n7&&/Chrome\/(\d+)/.exec(N9.userAgent),k8="webkitFontSmoothing"in z3.documentElement.style,O3=!n7&&/Apple Computer/.test(N9.vendor),S8=O3&&(/Mobile\/\w+/.test(N9.userAgent)||N9.maxTouchPoints>2),B={mac:S8||/Mac/.test(N9.platform),windows:/Win/.test(N9.platform),linux:/Linux|X11/.test(N9.platform),ie:n7,ie_version:_1?z3.documentMode||6:W3?+W3[1]:j3?+j3[1]:0,gecko:y8,gecko_version:y8?+(/Firefox\/(\d+)/.exec(N9.userAgent)||[0,0])[1]:0,chrome:!!$3,chrome_version:$3?+$3[1]:0,ios:S8,android:/Android\b/.test(N9.userAgent),webkit:k8,webkit_version:k8?+(/\bAppleWebKit\/(\d+)/.exec(N9.userAgent)||[0,0])[1]:0,safari:O3,safari_version:O3?+(/\bVersion\/(\d+(\.\d+)?)/.exec(N9.userAgent)||[0,0])[1]:0,tabSize:z3.documentElement.style.tabSize!=null?"tab-size":"-moz-tab-size"};function w3(Z,$){for(let J in Z)if(J=="class"&&$.class)$.class+=" "+Z.class;else if(J=="style"&&$.style)$.style+=";"+Z.style;else $[J]=Z[J];return $}var m7=Object.create(null);function h3(Z,$,J){if(Z==$)return!0;if(!Z)Z=m7;if(!$)$=m7;let X=Object.keys(Z),Y=Object.keys($);if(X.length-(J&&X.indexOf(J)>-1?1:0)!=Y.length-(J&&Y.indexOf(J)>-1?1:0))return!1;for(let K of X)if(K!=J&&(Y.indexOf(K)==-1||Z[K]!==$[K]))return!1;return!0}function c2(Z,$){for(let J=Z.attributes.length-1;J>=0;J--){let X=Z.attributes[J].name;if($[X]==null)Z.removeAttribute(X)}for(let J in $){let X=$[J];if(J=="style")Z.style.cssText=X;else if(Z.getAttribute(J)!=X)Z.setAttribute(J,X)}}function b8(Z,$,J){let X=!1;if($){for(let Y in $)if(!(J&&(Y in J)))if(X=!0,Y=="style")Z.style.cssText="";else Z.removeAttribute(Y)}if(J){for(let Y in J)if(!($&&$[Y]==J[Y]))if(X=!0,Y=="style")Z.style.cssText=J[Y];else Z.setAttribute(Y,J[Y])}return X}function s2(Z){let $=Object.create(null);for(let J=0;J<Z.attributes.length;J++){let X=Z.attributes[J];$[X.name]=X.value}return $}class C9{eq(Z){return!1}updateDOM(Z,$){return!1}compare(Z){return this==Z||this.constructor==Z.constructor&&this.eq(Z)}get estimatedHeight(){return-1}get lineBreaks(){return 0}ignoreEvent(Z){return!0}coordsAt(Z,$,J){return null}get isHidden(){return!1}get editable(){return!1}destroy(Z){}}var W9=function(Z){return Z[Z.Text=0]="Text",Z[Z.WidgetBefore=1]="WidgetBefore",Z[Z.WidgetAfter=2]="WidgetAfter",Z[Z.WidgetRange=3]="WidgetRange",Z}(W9||(W9={}));class y extends l9{constructor(Z,$,J,X){super();this.startSide=Z,this.endSide=$,this.widget=J,this.spec=X}get heightRelevant(){return!1}static mark(Z){return new l5(Z)}static widget(Z){let $=Math.max(-1e4,Math.min(1e4,Z.side||0)),J=!!Z.block;return $+=J&&!Z.inlineOrder?$>0?300000000:-400000000:$>0?1e8:-1e8,new b0(Z,$,$,J,Z.widget||null,!1)}static replace(Z){let $=!!Z.block,J,X;if(Z.isBlockGap)J=-500000000,X=400000000;else{let{start:Y,end:K}=V1(Z,$);J=(Y?$?-300000000:-1:500000000)-1,X=(K?$?200000000:1:-600000000)+1}return new b0(Z,J,X,$,Z.widget||null,!0)}static line(Z){return new d5(Z)}static set(Z,$=!1){return b.of(Z,$)}hasHeight(){return this.widget?this.widget.estimatedHeight>-1:!1}}y.none=b.empty;class l5 extends y{constructor(Z){let{start:$,end:J}=V1(Z);super($?-1:500000000,J?1:-600000000,null,Z);this.tagName=Z.tagName||"span",this.attrs=Z.class&&Z.attributes?w3(Z.attributes,{class:Z.class}):Z.class?{class:Z.class}:Z.attributes||m7}eq(Z){return this==Z||Z instanceof l5&&this.tagName==Z.tagName&&h3(this.attrs,Z.attrs)}range(Z,$=Z){if(Z>=$)throw RangeError("Mark decorations may not be empty");return super.range(Z,$)}}l5.prototype.point=!1;class d5 extends y{constructor(Z){super(-200000000,-200000000,null,Z)}eq(Z){return Z instanceof d5&&this.spec.class==Z.spec.class&&h3(this.spec.attributes,Z.spec.attributes)}range(Z,$=Z){if($!=Z)throw RangeError("Line decoration ranges must be zero-length");return super.range(Z,$)}}d5.prototype.mapMode=q9.TrackBefore;d5.prototype.point=!0;class b0 extends y{constructor(Z,$,J,X,Y,K){super($,J,Y,Z);this.block=X,this.isReplace=K,this.mapMode=!X?q9.TrackDel:$<=0?q9.TrackBefore:q9.TrackAfter}get type(){return this.startSide!=this.endSide?W9.WidgetRange:this.startSide<=0?W9.WidgetBefore:W9.WidgetAfter}get heightRelevant(){return this.block||!!this.widget&&(this.widget.estimatedHeight>=5||this.widget.lineBreaks>0)}eq(Z){return Z instanceof b0&&n2(this.widget,Z.widget)&&this.block==Z.block&&this.startSide==Z.startSide&&this.endSide==Z.endSide}range(Z,$=Z){if(this.isReplace&&(Z>$||Z==$&&this.startSide>0&&this.endSide<=0))throw RangeError("Invalid range for replacement decoration");if(!this.isReplace&&$!=Z)throw RangeError("Widget decorations can only have zero-length ranges");return super.range(Z,$)}}b0.prototype.point=!0;function V1(Z,$=!1){let{inclusiveStart:J,inclusiveEnd:X}=Z;if(J==null)J=Z.inclusive;if(X==null)X=Z.inclusive;return{start:J!==null&&J!==void 0?J:$,end:X!==null&&X!==void 0?X:$}}function n2(Z,$){return Z==$||!!(Z&&$&&Z.compare($))}function $5(Z,$,J,X=0){let Y=J.length-1;if(Y>=0&&J[Y]+X>=Z)J[Y]=Math.max(J[Y],$);else J.push(Z,$)}class m5 extends l9{constructor(Z,$){super();this.tagName=Z,this.attributes=$}eq(Z){return Z==this||Z instanceof m5&&this.tagName==Z.tagName&&h3(this.attributes,Z.attributes)}static create(Z){return new m5(Z.tagName,Z.attributes||m7)}static set(Z,$=!1){return b.of(Z,$)}}m5.prototype.startSide=m5.prototype.endSide=-1;function u5(Z){let $;if(Z.nodeType==11)$=Z.getSelection?Z:Z.ownerDocument;else $=Z;return $.getSelection()}function _3(Z,$){return $?Z==$||Z.contains($.nodeType!=1?$.parentNode:$):!1}function x5(Z,$){if(!$.anchorNode)return!1;try{return _3(Z,$.anchorNode)}catch(J){return!1}}function T7(Z){if(Z.nodeType==3)return f5(Z,0,Z.nodeValue.length).getClientRects();else if(Z.nodeType==1)return Z.getClientRects();else return[]}function w5(Z,$,J,X){return J?x8(Z,$,J,X,-1)||x8(Z,$,J,X,1):!1}function H0(Z){for(var $=0;;$++)if(Z=Z.previousSibling,!Z)return $}function u7(Z){return Z.nodeType==1&&/^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(Z.nodeName)}function x8(Z,$,J,X,Y){for(;;){if(Z==J&&$==X)return!0;if($==(Y<0?0:O0(Z))){if(Z.nodeName=="DIV")return!1;let K=Z.parentNode;if(!K||K.nodeType!=1)return!1;$=H0(Z)+(Y<0?0:1),Z=K}else if(Z.nodeType==1){if(Z=Z.childNodes[$+(Y<0?-1:0)],Z.nodeType==1&&Z.contentEditable=="false")return!1;$=Y<0?O0(Z):0}else return!1}}function O0(Z){return Z.nodeType==3?Z.nodeValue.length:Z.childNodes.length}function f7(Z,$){let J=$?Z.left:Z.right;return{left:J,right:J,top:Z.top,bottom:Z.bottom}}function i2(Z){let $=Z.visualViewport;if($)return{left:0,right:$.width,top:0,bottom:$.height};return{left:0,right:Z.innerWidth,top:0,bottom:Z.innerHeight}}function H1(Z,$){let J=$.width/Z.offsetWidth,X=$.height/Z.offsetHeight;if(J>0.995&&J<1.005||!isFinite(J)||Math.abs($.width-Z.offsetWidth)<1)J=1;if(X>0.995&&X<1.005||!isFinite(X)||Math.abs($.height-Z.offsetHeight)<1)X=1;return{scaleX:J,scaleY:X}}function a2(Z,$,J,X,Y,K,Q,U){let q=Z.ownerDocument,G=q.defaultView||window;for(let z=Z,j=!1;z&&!j;)if(z.nodeType==1){let W,O=z==q.body,_=1,V=1;if(O)W=i2(G);else{if(/^(fixed|sticky)$/.test(getComputedStyle(z).position))j=!0;if(z.scrollHeight<=z.clientHeight&&z.scrollWidth<=z.clientWidth){z=z.assignedSlot||z.parentNode;continue}let D=z.getBoundingClientRect();({scaleX:_,scaleY:V}=H1(z,D)),W={left:D.left,right:D.left+z.clientWidth*_,top:D.top,bottom:D.top+z.clientHeight*V}}let H=0,I=0;if(Y=="nearest"){if($.top<W.top){if(I=$.top-(W.top+Q),J>0&&$.bottom>W.bottom+I)I=$.bottom-W.bottom+Q}else if($.bottom>W.bottom){if(I=$.bottom-W.bottom+Q,J<0&&$.top-I<W.top)I=$.top-(W.top+Q)}}else{let D=$.bottom-$.top,F=W.bottom-W.top;I=(Y=="center"&&D<=F?$.top+D/2-F/2:Y=="start"||Y=="center"&&J<0?$.top-Q:$.bottom-F+Q)-W.top}if(X=="nearest"){if($.left<W.left){if(H=$.left-(W.left+K),J>0&&$.right>W.right+H)H=$.right-W.right+K}else if($.right>W.right){if(H=$.right-W.right+K,J<0&&$.left<W.left+H)H=$.left-(W.left+K)}}else H=(X=="center"?$.left+($.right-$.left)/2-(W.right-W.left)/2:X=="start"==U?$.left-K:$.right-(W.right-W.left)+K)-W.left;if(H||I)if(O)G.scrollBy(H,I);else{let D=0,F=0;if(I){let C=z.scrollTop;z.scrollTop+=I/V,F=(z.scrollTop-C)*V}if(H){let C=z.scrollLeft;z.scrollLeft+=H/_,D=(z.scrollLeft-C)*_}if($={left:$.left-D,top:$.top-F,right:$.right-D,bottom:$.bottom-F},D&&Math.abs(D-H)<1)X="nearest";if(F&&Math.abs(F-I)<1)Y="nearest"}if(O)break;if($.top<W.top||$.bottom>W.bottom||$.left<W.left||$.right>W.right)$={left:Math.max($.left,W.left),right:Math.min($.right,W.right),top:Math.max($.top,W.top),bottom:Math.min($.bottom,W.bottom)};z=z.assignedSlot||z.parentNode}else if(z.nodeType==11)z=z.host;else break}function r2(Z){let $=Z.ownerDocument,J,X;for(let Y=Z.parentNode;Y;)if(Y==$.body||J&&X)break;else if(Y.nodeType==1){if(!X&&Y.scrollHeight>Y.clientHeight)X=Y;if(!J&&Y.scrollWidth>Y.clientWidth)J=Y;Y=Y.assignedSlot||Y.parentNode}else if(Y.nodeType==11)Y=Y.host;else break;return{x:J,y:X}}class N1{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0}eq(Z){return this.anchorNode==Z.anchorNode&&this.anchorOffset==Z.anchorOffset&&this.focusNode==Z.focusNode&&this.focusOffset==Z.focusOffset}setRange(Z){let{anchorNode:$,focusNode:J}=Z;this.set($,Math.min(Z.anchorOffset,$?O0($):0),J,Math.min(Z.focusOffset,J?O0(J):0))}set(Z,$,J,X){this.anchorNode=Z,this.anchorOffset=$,this.focusNode=J,this.focusOffset=X}}var k0=null;if(B.safari&&B.safari_version>=26)k0=!1;function R1(Z){if(Z.setActive)return Z.setActive();if(k0)return Z.focus(k0);let $=[];for(let J=Z;J;J=J.parentNode)if($.push(J,J.scrollTop,J.scrollLeft),J==J.ownerDocument)break;if(Z.focus(k0==null?{get preventScroll(){return k0={preventScroll:!0},!0}}:void 0),!k0){k0=!1;for(let J=0;J<$.length;){let X=$[J++],Y=$[J++],K=$[J++];if(X.scrollTop!=Y)X.scrollTop=Y;if(X.scrollLeft!=K)X.scrollLeft=K}}}var w8;function f5(Z,$,J=$){let X=w8||(w8=document.createRange());return X.setEnd(Z,J),X.setStart(Z,$),X}function J5(Z,$,J,X){let Y={key:$,code:$,keyCode:J,which:J,cancelable:!0};if(X)({altKey:Y.altKey,ctrlKey:Y.ctrlKey,shiftKey:Y.shiftKey,metaKey:Y.metaKey}=X);let K=new KeyboardEvent("keydown",Y);K.synthetic=!0,Z.dispatchEvent(K);let Q=new KeyboardEvent("keyup",Y);return Q.synthetic=!0,Z.dispatchEvent(Q),K.defaultPrevented||Q.defaultPrevented}function o2(Z){while(Z){if(Z&&(Z.nodeType==9||Z.nodeType==11&&Z.host))return Z;Z=Z.assignedSlot||Z.parentNode}return null}function t2(Z,$){let{focusNode:J,focusOffset:X}=$;if(!J||$.anchorNode!=J||$.anchorOffset!=X)return!1;X=Math.min(X,O0(J));for(;;)if(X){if(J.nodeType!=1)return!1;let Y=J.childNodes[X-1];if(Y.contentEditable=="false")X--;else J=Y,X=O0(J)}else if(J==Z)return!0;else X=H0(J),J=J.parentNode}function I1(Z){return Z.scrollTop>Math.max(1,Z.scrollHeight-Z.clientHeight-4)}function D1(Z,$){for(let J=Z,X=$;;)if(J.nodeType==3&&X>0)return{node:J,offset:X};else if(J.nodeType==1&&X>0){if(J.contentEditable=="false")return null;J=J.childNodes[X-1],X=O0(J)}else if(J.parentNode&&!u7(J))X=H0(J),J=J.parentNode;else return null}function F1(Z,$){for(let J=Z,X=$;;)if(J.nodeType==3&&X<J.nodeValue.length)return{node:J,offset:X};else if(J.nodeType==1&&X<J.childNodes.length){if(J.contentEditable=="false")return null;J=J.childNodes[X],X=0}else if(J.parentNode&&!u7(J))X=H0(J)+1,J=J.parentNode;else return null}class i9{constructor(Z,$,J=!0){this.node=Z,this.offset=$,this.precise=J}static before(Z,$){return new i9(Z.parentNode,H0(Z),$)}static after(Z,$){return new i9(Z.parentNode,H0(Z)+1,$)}}var p=function(Z){return Z[Z.LTR=0]="LTR",Z[Z.RTL=1]="RTL",Z}(p||(p={})),x0=p.LTR,v3=p.RTL;function A1(Z){let $=[];for(let J=0;J<Z.length;J++)$.push(1<<+Z[J]);return $}var e2=A1("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"),ZX=A1("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"),V3=Object.create(null),X0=[];for(let Z of["()","[]","{}"]){let $=Z.charCodeAt(0),J=Z.charCodeAt(1);V3[$]=J,V3[J]=-$}function L1(Z){return Z<=247?e2[Z]:1424<=Z&&Z<=1524?2:1536<=Z&&Z<=1785?ZX[Z-1536]:1774<=Z&&Z<=2220?4:8192<=Z&&Z<=8204?256:64336<=Z&&Z<=65023?4:1}var $X=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;class a9{get dir(){return this.level%2?v3:x0}constructor(Z,$,J){this.from=Z,this.to=$,this.level=J}side(Z,$){return this.dir==$==Z?this.to:this.from}forward(Z,$){return Z==(this.dir==$)}static find(Z,$,J,X){let Y=-1;for(let K=0;K<Z.length;K++){let Q=Z[K];if(Q.from<=$&&Q.to>=$){if(Q.level==J)return K;if(Y<0||(X!=0?X<0?Q.from<$:Q.to>$:Z[Y].level>Q.level))Y=K}}if(Y<0)throw RangeError("Index out of range");return Y}}function M1(Z,$){if(Z.length!=$.length)return!1;for(let J=0;J<Z.length;J++){let X=Z[J],Y=$[J];if(X.from!=Y.from||X.to!=Y.to||X.direction!=Y.direction||!M1(X.inner,Y.inner))return!1}return!0}var s=[];function JX(Z,$,J,X,Y){for(let K=0;K<=X.length;K++){let Q=K?X[K-1].to:$,U=K<X.length?X[K].from:J,q=K?256:Y;for(let G=Q,z=q,j=q;G<U;G++){let W=L1(Z.charCodeAt(G));if(W==512)W=z;else if(W==8&&j==4)W=16;if(s[G]=W==4?2:W,W&7)j=W;z=W}for(let G=Q,z=q,j=q;G<U;G++){let W=s[G];if(W==128)if(G<U-1&&z==s[G+1]&&z&24)W=s[G]=z;else s[G]=256;else if(W==64){let O=G+1;while(O<U&&s[O]==64)O++;let _=G&&z==8||O<J&&s[O]==8?j==1?1:8:256;for(let V=G;V<O;V++)s[V]=_;G=O-1}else if(W==8&&j==1)s[G]=1;if(z=W,W&7)j=W}}}function XX(Z,$,J,X,Y){let K=Y==1?2:1;for(let Q=0,U=0,q=0;Q<=X.length;Q++){let G=Q?X[Q-1].to:$,z=Q<X.length?X[Q].from:J;for(let j=G,W,O,_;j<z;j++)if(O=V3[W=Z.charCodeAt(j)])if(O<0){for(let V=U-3;V>=0;V-=3)if(X0[V+1]==-O){let H=X0[V+2],I=H&2?Y:!(H&4)?0:H&1?K:Y;if(I)s[j]=s[X0[V]]=I;U=V;break}}else if(X0.length==189)break;else X0[U++]=j,X0[U++]=W,X0[U++]=q;else if((_=s[j])==2||_==1){let V=_==Y;q=V?0:1;for(let H=U-3;H>=0;H-=3){let I=X0[H+2];if(I&2)break;if(V)X0[H+2]|=2;else{if(I&4)break;X0[H+2]|=4}}}}}function YX(Z,$,J,X){for(let Y=0,K=X;Y<=J.length;Y++){let Q=Y?J[Y-1].to:Z,U=Y<J.length?J[Y].from:$;for(let q=Q;q<U;){let G=s[q];if(G==256){let z=q+1;for(;;)if(z==U){if(Y==J.length)break;z=J[Y++].to,U=Y<J.length?J[Y].from:$}else if(s[z]==256)z++;else break;let j=K==1,W=(z<$?s[z]:X)==1,O=j==W?j?1:2:X;for(let _=z,V=Y,H=V?J[V-1].to:Z;_>q;){if(_==H)_=J[--V].from,H=V?J[V-1].to:Z;s[--_]=O}q=z}else K=G,q++}}}function H3(Z,$,J,X,Y,K,Q){let U=X%2?2:1;if(X%2==Y%2)for(let q=$,G=0;q<J;){let z=!0,j=!1;if(G==K.length||q<K[G].from){let V=s[q];if(V!=U)z=!1,j=V==16}let W=!z&&U==1?[]:null,O=z?X:X+1,_=q;Z:for(;;)if(G<K.length&&_==K[G].from){if(j)break Z;let V=K[G];if(!z)for(let H=V.to,I=G+1;;){if(H==J)break Z;if(I<K.length&&K[I].from==H)H=K[I++].to;else if(s[H]==U)break Z;else break}if(G++,W)W.push(V);else{if(V.from>q)Q.push(new a9(q,V.from,O));let H=V.direction==x0!=!(O%2);N3(Z,H?X+1:X,Y,V.inner,V.from,V.to,Q),q=V.to}_=V.to}else if(_==J||(z?s[_]!=U:s[_]==U))break;else _++;if(W)H3(Z,q,_,X+1,Y,W,Q);else if(q<_)Q.push(new a9(q,_,O));q=_}else for(let q=J,G=K.length;q>$;){let z=!0,j=!1;if(!G||q>K[G-1].to){let V=s[q-1];if(V!=U)z=!1,j=V==16}let W=!z&&U==1?[]:null,O=z?X:X+1,_=q;Z:for(;;)if(G&&_==K[G-1].to){if(j)break Z;let V=K[--G];if(!z)for(let H=V.from,I=G;;){if(H==$)break Z;if(I&&K[I-1].to==H)H=K[--I].from;else if(s[H-1]==U)break Z;else break}if(W)W.push(V);else{if(V.to<q)Q.push(new a9(V.to,q,O));let H=V.direction==x0!=!(O%2);N3(Z,H?X+1:X,Y,V.inner,V.from,V.to,Q),q=V.from}_=V.from}else if(_==$||(z?s[_-1]!=U:s[_-1]==U))break;else _--;if(W)H3(Z,_,q,X+1,Y,W,Q);else if(_<q)Q.push(new a9(_,q,O));q=_}}function N3(Z,$,J,X,Y,K,Q){let U=$%2?2:1;JX(Z,Y,K,X,U),XX(Z,Y,K,X,U),YX(Y,K,X,U),H3(Z,Y,K,$,J,X,Q)}function KX(Z,$,J){if(!Z)return[new a9(0,0,$==v3?1:0)];if($==x0&&!J.length&&!$X.test(Z))return E1(Z.length);if(J.length)while(Z.length>s.length)s[s.length]=256;let X=[],Y=$==x0?0:1;return N3(Z,Y,Y,J,0,Z.length,X),X}function E1(Z){return[new a9(0,Z,0)]}var B1="";function QX(Z,$,J,X,Y){var K;let Q=X.head-Z.from,U=a9.find($,Q,(K=X.bidiLevel)!==null&&K!==void 0?K:-1,X.assoc),q=$[U],G=q.side(Y,J);if(Q==G){let W=U+=Y?1:-1;if(W<0||W>=$.length)return null;q=$[U=W],Q=q.side(!Y,J),G=q.side(Y,J)}let z=X9(Z.text,Q,q.forward(Y,J));if(z<q.from||z>q.to)z=G;B1=Z.text.slice(Math.min(Q,z),Math.max(Q,z));let j=U==(Y?$.length-1:0)?null:$[U+(Y?1:-1)];if(j&&z==G&&j.level+(Y?0:1)<q.level)return R.cursor(j.side(!Y,J)+Z.from,j.forward(Y,J)?1:-1,j.level);return R.cursor(z+Z.from,q.forward(Y,J)?-1:1,q.level)}function UX(Z,$,J){for(let X=$;X<J;X++){let Y=L1(Z.charCodeAt(X));if(Y==1)return x0;if(Y==2||Y==4)return v3}return x0}var P1=L.define(),C1=L.define(),T1=L.define(),y1=L.define(),R3=L.define(),k1=L.define(),S1=L.define(),m3=L.define(),u3=L.define(),b1=L.define({combine:(Z)=>Z.some(($)=>$)}),x1=L.define({combine:(Z)=>Z.some(($)=>$)}),w1=L.define();class X5{constructor(Z,$="nearest",J="nearest",X=5,Y=5,K=!1){this.range=Z,this.y=$,this.x=J,this.yMargin=X,this.xMargin=Y,this.isSnapshot=K}map(Z){return Z.empty?this:new X5(this.range.map(Z),this.y,this.x,this.yMargin,this.xMargin,this.isSnapshot)}clip(Z){return this.range.to<=Z.doc.length?this:new X5(R.cursor(Z.doc.length),this.y,this.x,this.yMargin,this.xMargin,this.isSnapshot)}}var D7=k.define({map:(Z,$)=>Z.map($)}),h1=k.define();function j9(Z,$,J){let X=Z.facet(y1);if(X.length)X[0]($);else if(window.onerror&&window.onerror(String($),J,void 0,void 0,$));else if(J)console.error(J+":",$);else console.error($)}var j0=L.define({combine:(Z)=>Z.length?Z[0]:!0}),qX=0,e0=L.define({combine(Z){return Z.filter(($,J)=>{for(let X=0;X<J;X++)if(Z[X].plugin==$.plugin)return!1;return!0})}});class o{constructor(Z,$,J,X,Y){this.id=Z,this.create=$,this.domEventHandlers=J,this.domEventObservers=X,this.baseExtensions=Y(this),this.extension=this.baseExtensions.concat(e0.of({plugin:this,arg:void 0}))}of(Z){return this.baseExtensions.concat(e0.of({plugin:this,arg:Z}))}static define(Z,$){let{eventHandlers:J,eventObservers:X,provide:Y,decorations:K}=$||{};return new o(qX++,Z,J,X,(Q)=>{let U=[];if(K)U.push(i7.of((q)=>{let G=q.plugin(Q);return G?K(G):y.none}));if(Y)U.push(Y(Q));return U})}static fromClass(Z,$){return o.define((J,X)=>new Z(J,X),$)}}class y7{constructor(Z){this.spec=Z,this.mustUpdate=null,this.value=null}get plugin(){return this.spec&&this.spec.plugin}update(Z){if(!this.value){if(this.spec)try{this.value=this.spec.plugin.create(Z,this.spec.arg)}catch($){j9(Z.state,$,"CodeMirror plugin crashed"),this.deactivate()}}else if(this.mustUpdate){let $=this.mustUpdate;if(this.mustUpdate=null,this.value.update)try{this.value.update($)}catch(J){if(j9($.state,J,"CodeMirror plugin crashed"),this.value.destroy)try{this.value.destroy()}catch(X){}this.deactivate()}}return this}destroy(Z){var $;if(($=this.value)===null||$===void 0?void 0:$.destroy)try{this.value.destroy()}catch(J){j9(Z.state,J,"CodeMirror plugin crashed")}}deactivate(){this.spec=this.value=null}}var v1=L.define(),f3=L.define(),i7=L.define(),m1=L.define(),g3=L.define(),c5=L.define(),u1=L.define();function h8(Z,$){let J=Z.state.facet(u1);if(!J.length)return J;let X=J.map((K)=>K instanceof Function?K(Z):K),Y=[];return b.spans(X,$.from,$.to,{point(){},span(K,Q,U,q){let G=K-$.from,z=Q-$.from,j=Y;for(let W=U.length-1;W>=0;W--,q--){let O=U[W].spec.bidiIsolate,_;if(O==null)O=UX($.text,G,z);if(q>0&&j.length&&(_=j[j.length-1]).to==G&&_.direction==O)_.to=z,j=_.inner;else{let V={from:G,to:z,direction:O,inner:[]};j.push(V),j=V.inner}}}}),Y}var f1=L.define();function p3(Z){let $=0,J=0,X=0,Y=0;for(let K of Z.state.facet(f1)){let Q=K(Z);if(Q){if(Q.left!=null)$=Math.max($,Q.left);if(Q.right!=null)J=Math.max(J,Q.right);if(Q.top!=null)X=Math.max(X,Q.top);if(Q.bottom!=null)Y=Math.max(Y,Q.bottom)}}return{left:$,right:J,top:X,bottom:Y}}var C5=L.define();class b9{constructor(Z,$,J,X){this.fromA=Z,this.toA=$,this.fromB=J,this.toB=X}join(Z){return new b9(Math.min(this.fromA,Z.fromA),Math.max(this.toA,Z.toA),Math.min(this.fromB,Z.fromB),Math.max(this.toB,Z.toB))}addToSet(Z){let $=Z.length,J=this;for(;$>0;$--){let X=Z[$-1];if(X.fromA>J.toA)continue;if(X.toA<J.fromA)break;J=J.join(X),Z.splice($-1,1)}return Z.splice($,0,J),Z}static extendWithRanges(Z,$){if($.length==0)return Z;let J=[];for(let X=0,Y=0,K=0;;){let Q=X<Z.length?Z[X].fromB:1e9,U=Y<$.length?$[Y]:1e9,q=Math.min(Q,U);if(q==1e9)break;let G=q+K,z=q,j=G;for(;;)if(Y<$.length&&$[Y]<=z){let W=$[Y+1];Y+=2,z=Math.max(z,W);for(let O=X;O<Z.length&&Z[O].fromB<=z;O++)K=Z[O].toA-Z[O].toB;j=Math.max(j,W+K)}else if(X<Z.length&&Z[X].fromB<=z){let W=Z[X++];z=Math.max(z,W.toB),j=Math.max(j,W.toA),K=W.toA-W.toB}else break;J.push(new b9(G,j,q,z))}return J}}class g7{constructor(Z,$,J){this.view=Z,this.state=$,this.transactions=J,this.flags=0,this.startState=Z.state,this.changes=J9.empty(this.startState.doc.length);for(let Y of J)this.changes=this.changes.compose(Y.changes);let X=[];this.changes.iterChangedRanges((Y,K,Q,U)=>X.push(new b9(Y,K,Q,U))),this.changedRanges=X}static create(Z,$,J){return new g7(Z,$,J)}get viewportChanged(){return(this.flags&4)>0}get viewportMoved(){return(this.flags&8)>0}get heightChanged(){return(this.flags&2)>0}get geometryChanged(){return this.docChanged||(this.flags&18)>0}get focusChanged(){return(this.flags&1)>0}get docChanged(){return!this.changes.empty}get selectionSet(){return this.transactions.some((Z)=>Z.selection)}get empty(){return this.flags==0&&this.transactions.length==0}}var GX=[];class Y9{constructor(Z,$,J=0){this.dom=Z,this.length=$,this.flags=J,this.parent=null,Z.cmTile=this}get breakAfter(){return this.flags&1}get children(){return GX}isWidget(){return!1}get isHidden(){return!1}isComposite(){return!1}isLine(){return!1}isText(){return!1}isBlock(){return!1}get domAttrs(){return null}sync(Z){if(this.flags|=2,this.flags&4){this.flags&=-5;let $=this.domAttrs;if($)c2(this.dom,$)}}toString(){return this.constructor.name+(this.children.length?`(${this.children})`:"")+(this.breakAfter?"#":"")}destroy(){this.parent=null}setDOM(Z){this.dom=Z,Z.cmTile=this}get posAtStart(){return this.parent?this.parent.posBefore(this):0}get posAtEnd(){return this.posAtStart+this.length}posBefore(Z,$=this.posAtStart){let J=$;for(let X of this.children){if(X==Z)return J;J+=X.length+X.breakAfter}throw RangeError("Invalid child in posBefore")}posAfter(Z){return this.posBefore(Z)+Z.length}covers(Z){return!0}coordsIn(Z,$){return null}domPosFor(Z,$){let J=H0(this.dom),X=this.length?Z>0:$>0;return new i9(this.parent.dom,J+(X?1:0),Z==0||Z==this.length)}markDirty(Z){if(this.flags&=-3,Z)this.flags|=4;if(this.parent&&this.parent.flags&2)this.parent.markDirty(!1)}get overrideDOMText(){return null}get root(){for(let Z=this;Z;Z=Z.parent)if(Z instanceof n5)return Z;return null}static get(Z){return Z.cmTile}}class s5 extends Y9{constructor(Z){super(Z,0);this._children=[]}isComposite(){return!0}get children(){return this._children}get lastChild(){return this.children.length?this.children[this.children.length-1]:null}append(Z){this.children.push(Z),Z.parent=this}sync(Z){if(this.flags&2)return;super.sync(Z);let $=this.dom,J=null,X,Y=(Z===null||Z===void 0?void 0:Z.node)==$?Z:null,K=0;for(let Q of this.children){if(Q.sync(Z),K+=Q.length+Q.breakAfter,X=J?J.nextSibling:$.firstChild,Y&&X!=Q.dom)Y.written=!0;if(Q.dom.parentNode==$)while(X&&X!=Q.dom)X=v8(X);else $.insertBefore(Q.dom,X);J=Q.dom}if(X=J?J.nextSibling:$.firstChild,Y&&X)Y.written=!0;while(X)X=v8(X);this.length=K}}function v8(Z){let $=Z.nextSibling;return Z.parentNode.removeChild(Z),$}class n5 extends s5{constructor(Z,$){super($);this.view=Z}owns(Z){for(;Z;Z=Z.parent)if(Z==this)return!0;return!1}isBlock(){return!0}nearest(Z){for(;;){if(!Z)return null;let $=Y9.get(Z);if($&&this.owns($))return $;Z=Z.parentNode}}blockTiles(Z){for(let $=[],J=this,X=0,Y=0;;)if(X==J.children.length){if(!$.length)return;if(J=J.parent,J.breakAfter)Y++;X=$.pop()}else{let K=J.children[X++];if(K instanceof W0)$.push(X),J=K,X=0;else{let Q=Y+K.length,U=Z(K,Y);if(U!==void 0)return U;Y=Q+K.breakAfter}}}resolveBlock(Z,$){let J,X=-1,Y,K=-1;if(this.blockTiles((Q,U)=>{let q=U+Q.length;if(Z>=U&&Z<=q){if(Q.isWidget()&&$>=-1&&$<=1){if(Q.flags&32)return!0;if(Q.flags&16)J=void 0}if((U<Z||Z==q&&($<-1?Q.length:Q.covers(1)))&&(!J||!Q.isWidget()&&J.isWidget()))J=Q,X=Z-U;if((q>Z||Z==U&&($>1?Q.length:Q.covers(-1)))&&(!Y||!Q.isWidget()&&Y.isWidget()))Y=Q,K=Z-U}}),!J&&!Y)throw Error("No tile at position "+Z);return J&&$<0||!Y?{tile:J,offset:X}:{tile:Y,offset:K}}}class W0 extends s5{constructor(Z,$){super(Z);this.wrapper=$}isBlock(){return!0}covers(Z){if(!this.children.length)return!1;return Z<0?this.children[0].covers(-1):this.lastChild.covers(1)}get domAttrs(){return this.wrapper.attributes}static of(Z,$){let J=new W0($||document.createElement(Z.tagName),Z);if(!$)J.flags|=4;return J}}class Y5 extends s5{constructor(Z,$){super(Z);this.attrs=$}isLine(){return!0}static start(Z,$,J){let X=new Y5($||document.createElement("div"),Z);if(!$||!J)X.flags|=4;return X}get domAttrs(){return this.attrs}resolveInline(Z,$,J){let X=null,Y=-1,K=null,Q=-1;function U(G,z){for(let j=0,W=0;j<G.children.length&&W<=z;j++){let O=G.children[j],_=W+O.length;if(_>=z){if(O.isComposite())U(O,z-W);else if((!K||K.isHidden&&($>0||J&&jX(K,O)))&&(_>z||O.flags&32))K=O,Q=z-W;else if(W<z||O.flags&16&&!O.isHidden)X=O,Y=z-W}W=_}}U(this,Z);let q=($<0?X:K)||X||K;return q?{tile:q,offset:q==X?Y:Q}:null}coordsIn(Z,$){let J=this.resolveInline(Z,$,!0);if(!J)return zX(this);return J.tile.coordsIn(Math.max(0,J.offset),$)}domIn(Z,$){let J=this.resolveInline(Z,$);if(J){let{tile:X,offset:Y}=J;if(this.dom.contains(X.dom)){if(X.isText())return new i9(X.dom,Math.min(X.dom.nodeValue.length,Y));return X.domPosFor(Y,X.flags&16?1:X.flags&32?-1:$)}let K=J.tile.parent,Q=!1;for(let U of K.children){if(Q)return new i9(U.dom,0);if(U==J.tile)Q=!0}}return new i9(this.dom,0)}}function zX(Z){let $=Z.dom.lastChild;if(!$)return Z.dom.getBoundingClientRect();let J=T7($);return J[J.length-1]||null}function jX(Z,$){let J=Z.coordsIn(0,1),X=$.coordsIn(0,1);return J&&X&&X.top<J.bottom}class D9 extends s5{constructor(Z,$){super(Z);this.mark=$}get domAttrs(){return this.mark.attrs}static of(Z,$){let J=new D9($||document.createElement(Z.tagName),Z);if(!$)J.flags|=4;return J}}class S0 extends Y9{constructor(Z,$){super(Z,$.length);this.text=$}sync(Z){if(this.flags&2)return;if(super.sync(Z),this.dom.nodeValue!=this.text){if(Z&&Z.node==this.dom)Z.written=!0;this.dom.nodeValue=this.text}}isText(){return!0}toString(){return JSON.stringify(this.text)}coordsIn(Z,$){let J=this.dom.nodeValue.length;if(Z>J)Z=J;let X=Z,Y=Z,K=0;if(Z==0&&$<0||Z==J&&$>=0){if(!(B.chrome||B.gecko)){if(Z)X--,K=1;else if(Y<J)Y++,K=-1}}else if($<0)X--;else if(Y<J)Y++;let Q=f5(this.dom,X,Y).getClientRects();if(!Q.length)return null;let U=Q[(K?K<0:$>=0)?0:Q.length-1];if(B.safari&&!K&&U.width==0)U=Array.prototype.find.call(Q,(q)=>q.width)||U;return K?f7(U,K<0):U||null}static of(Z,$){let J=new S0($||document.createTextNode(Z),Z);if(!$)J.flags|=2;return J}}class w0 extends Y9{constructor(Z,$,J,X){super(Z,$,X);this.widget=J}isWidget(){return!0}get isHidden(){return this.widget.isHidden}covers(Z){if(this.flags&48)return!1;return(this.flags&(Z<0?64:128))>0}coordsIn(Z,$){return this.coordsInWidget(Z,$,!1)}coordsInWidget(Z,$,J){let X=this.widget.coordsAt(this.dom,Z,$);if(X)return X;if(J)return f7(this.dom.getBoundingClientRect(),this.length?Z==0:$<=0);else{let Y=this.dom.getClientRects(),K=null;if(!Y.length)return null;let Q=this.flags&16?!0:this.flags&32?!1:Z>0;for(let U=Q?Y.length-1:0;;U+=Q?-1:1)if(K=Y[U],Z>0?U==0:U==Y.length-1||K.top<K.bottom)break;return f7(K,!Q)}}get overrideDOMText(){if(!this.length)return u.empty;let{root:Z}=this;if(!Z)return u.empty;let $=this.posAtStart;return Z.view.state.doc.slice($,$+this.length)}destroy(){super.destroy(),this.widget.destroy(this.dom)}static of(Z,$,J,X,Y){if(!Y){if(Y=Z.toDOM($),!Z.editable)Y.contentEditable="false"}return new w0(Y,J,Z,X)}}class g5 extends Y9{constructor(Z){let $=document.createElement("img");$.className="cm-widgetBuffer",$.setAttribute("aria-hidden","true");super($,0,Z)}get isHidden(){return!0}get overrideDOMText(){return u.empty}coordsIn(Z){return this.dom.getBoundingClientRect()}}class g1{constructor(Z){this.index=0,this.beforeBreak=!1,this.parents=[],this.tile=Z}advance(Z,$,J){let{tile:X,index:Y,beforeBreak:K,parents:Q}=this;while(Z||$>0)if(!X.isComposite())if(Y==X.length)K=!!X.breakAfter,{tile:X,index:Y}=Q.pop(),Y++;else if(!Z)break;else{let U=Math.min(Z,X.length-Y);if(J)J.skip(X,Y,Y+U);Z-=U,Y+=U}else if(K){if(!Z)break;if(J)J.break();Z--,K=!1}else if(Y==X.children.length){if(!Z&&!Q.length)break;if(J)J.leave(X);K=!!X.breakAfter,{tile:X,index:Y}=Q.pop(),Y++}else{let U=X.children[Y],q=U.breakAfter;if(($>0?U.length<=Z:U.length<Z)&&(!J||J.skip(U,0,U.length)!==!1||!U.isComposite))K=!!q,Y++,Z-=U.length;else if(Q.push({tile:X,index:Y}),X=U,Y=0,J&&U.isComposite())J.enter(U)}return this.tile=X,this.index=Y,this.beforeBreak=K,this}get root(){return this.parents.length?this.parents[0].tile:this.tile}}class p1{constructor(Z,$,J,X){this.from=Z,this.to=$,this.wrapper=J,this.rank=X}}class l1{constructor(Z,$,J){this.cache=Z,this.root=$,this.blockWrappers=J,this.curLine=null,this.lastBlock=null,this.afterWidget=null,this.pos=0,this.wrappers=[],this.wrapperPos=0}addText(Z,$,J,X){var Y;this.flushBuffer();let K=this.ensureMarks($,J),Q=K.lastChild;if(Q&&Q.isText()&&!(Q.flags&8)&&Q.length+Z.length<512){this.cache.reused.set(Q,2);let U=K.children[K.children.length-1]=new S0(Q.dom,Q.text+Z);U.parent=K}else K.append(X||S0.of(Z,(Y=this.cache.find(S0))===null||Y===void 0?void 0:Y.dom));this.pos+=Z.length,this.afterWidget=null}addComposition(Z,$){let J=this.curLine;if(J.dom!=$.line.dom)J.setDOM(this.cache.reused.has($.line)?J3($.line.dom):$.line.dom),this.cache.reused.set($.line,2);let X=J;for(let Q=$.marks.length-1;Q>=0;Q--){let U=$.marks[Q],q=X.lastChild;if(q instanceof D9&&q.mark.eq(U.mark)){if(q.dom!=U.dom)q.setDOM(J3(U.dom));X=q}else{if(this.cache.reused.get(U)){let z=Y9.get(U.dom);if(z)z.setDOM(J3(U.dom))}let G=D9.of(U.mark,U.dom);X.append(G),X=G}this.cache.reused.set(U,2)}let Y=Y9.get(Z.text);if(Y)this.cache.reused.set(Y,2);let K=new S0(Z.text,Z.text.nodeValue);K.flags|=8,X.append(K)}addInlineWidget(Z,$,J){let X=this.afterWidget&&Z.flags&48&&(this.afterWidget.flags&48)==(Z.flags&48);if(!X)this.flushBuffer();let Y=this.ensureMarks($,J);if(!X&&!(Z.flags&16))Y.append(this.getBuffer(1));Y.append(Z),this.pos+=Z.length,this.afterWidget=Z}addMark(Z,$,J){this.flushBuffer(),this.ensureMarks($,J).append(Z),this.pos+=Z.length,this.afterWidget=null}addBlockWidget(Z){this.getBlockPos().append(Z),this.pos+=Z.length,this.lastBlock=Z,this.endLine()}continueWidget(Z){let $=this.afterWidget||this.lastBlock;$.length+=Z,this.pos+=Z}addLineStart(Z,$){var J;if(!Z)Z=n1;let X=Y5.start(Z,$||((J=this.cache.find(Y5))===null||J===void 0?void 0:J.dom),!!$);this.getBlockPos().append(this.lastBlock=this.curLine=X)}addLine(Z){this.getBlockPos().append(Z),this.pos+=Z.length,this.lastBlock=Z,this.endLine()}addBreak(){this.lastBlock.flags|=1,this.endLine(),this.pos++}addLineStartIfNotCovered(Z){if(!this.blockPosCovered())this.addLineStart(Z)}ensureLine(Z){if(!this.curLine)this.addLineStart(Z)}ensureMarks(Z,$){var J;let X=this.curLine;for(let Y=Z.length-1;Y>=0;Y--){let K=Z[Y],Q;if($>0&&(Q=X.lastChild)&&Q instanceof D9&&Q.mark.eq(K))X=Q,$--;else{let U=D9.of(K,(J=this.cache.find(D9,(q)=>q.mark.eq(K)))===null||J===void 0?void 0:J.dom);X.append(U),X=U,$=0}}return X}endLine(){if(this.curLine){this.flushBuffer();let Z=this.curLine.lastChild;if(!Z||!m8(this.curLine,!1)||Z.dom.nodeName!="BR"&&Z.isWidget()&&!(B.ios&&m8(this.curLine,!0)))this.curLine.append(this.cache.findWidget(X3,0,32)||new w0(X3.toDOM(),0,X3,32));this.curLine=this.afterWidget=null}}updateBlockWrappers(){if(this.wrapperPos>this.pos+1e4)this.blockWrappers.goto(this.pos),this.wrappers.length=0;for(let Z=this.wrappers.length-1;Z>=0;Z--)if(this.wrappers[Z].to<this.pos)this.wrappers.splice(Z,1);for(let Z=this.blockWrappers;Z.value&&Z.from<=this.pos;Z.next())if(Z.to>=this.pos){let $=new p1(Z.from,Z.to,Z.value,Z.rank),J=this.wrappers.length;while(J>0&&(this.wrappers[J-1].rank-$.rank||this.wrappers[J-1].to-$.to)<0)J--;this.wrappers.splice(J,0,$)}this.wrapperPos=this.pos}getBlockPos(){var Z;this.updateBlockWrappers();let $=this.root;for(let J of this.wrappers){let X=$.lastChild;if(J.from<this.pos&&X instanceof W0&&X.wrapper.eq(J.wrapper))$=X;else{let Y=W0.of(J.wrapper,(Z=this.cache.find(W0,(K)=>K.wrapper.eq(J.wrapper)))===null||Z===void 0?void 0:Z.dom);$.append(Y),$=Y}}return $}blockPosCovered(){let Z=this.lastBlock;return Z!=null&&!Z.breakAfter&&(!Z.isWidget()||(Z.flags&160)>0)}getBuffer(Z){let $=2|(Z<0?16:32),J=this.cache.find(g5,void 0,1);if(J)J.flags=$;return J||new g5($)}flushBuffer(){if(this.afterWidget&&!(this.afterWidget.flags&32))this.afterWidget.parent.append(this.getBuffer(-1)),this.afterWidget=null}}class d1{constructor(Z){this.skipCount=0,this.text="",this.textOff=0,this.cursor=Z.iter()}skip(Z){if(this.textOff+Z<=this.text.length)this.textOff+=Z;else this.skipCount+=Z-(this.text.length-this.textOff),this.text="",this.textOff=0}next(Z){if(this.textOff==this.text.length){let{value:X,lineBreak:Y,done:K}=this.cursor.next(this.skipCount);if(this.skipCount=0,K)throw Error("Ran out of text content when drawing inline views");this.text=X;let Q=this.textOff=Math.min(Z,X.length);return Y?null:X.slice(0,Q)}let $=Math.min(this.text.length,this.textOff+Z),J=this.text.slice(this.textOff,$);return this.textOff=$,J}}var p7=[w0,Y5,S0,D9,g5,W0,n5];for(let Z=0;Z<p7.length;Z++)p7[Z].bucket=Z;class c1{constructor(Z){this.view=Z,this.buckets=p7.map(()=>[]),this.index=p7.map(()=>0),this.reused=new Map}add(Z){let $=Z.constructor.bucket,J=this.buckets[$];if(J.length<6)J.push(Z);else J[this.index[$]=(this.index[$]+1)%6]=Z}find(Z,$,J=2){let X=Z.bucket,Y=this.buckets[X],K=this.index[X];for(let Q=Y.length-1;Q>=0;Q--){let U=(Q+K)%Y.length,q=Y[U];if((!$||$(q))&&!this.reused.has(q)){if(Y.splice(U,1),U<K)this.index[X]--;return this.reused.set(q,J),q}}return null}findWidget(Z,$,J){let X=this.buckets[0];if(X.length)for(let Y=0,K=0;;Y++){if(Y==X.length){if(K)return null;K=1,Y=0}let Q=X[Y];if(!this.reused.has(Q)&&(K==0?Q.widget.compare(Z):Q.widget.constructor==Z.constructor&&Z.updateDOM(Q.dom,this.view))){if(X.splice(Y,1),Y<this.index[0])this.index[0]--;if(Q.widget==Z&&Q.length==$&&(Q.flags&497)==J)return this.reused.set(Q,1),Q;else return this.reused.set(Q,2),new w0(Q.dom,$,Z,Q.flags&-498|J)}}}reuse(Z){return this.reused.set(Z,1),Z}maybeReuse(Z,$=2){if(this.reused.has(Z))return;return this.reused.set(Z,$),Z.dom}clear(){for(let Z=0;Z<this.buckets.length;Z++)this.buckets[Z].length=this.index[Z]=0}}class s1{constructor(Z,$,J,X,Y){this.view=Z,this.decorations=X,this.disallowBlockEffectsFor=Y,this.openWidget=!1,this.openMarks=0,this.cache=new c1(Z),this.text=new d1(Z.state.doc),this.builder=new l1(this.cache,new n5(Z,Z.contentDOM),b.iter(J)),this.cache.reused.set($,2),this.old=new g1($),this.reuseWalker={skip:(K,Q,U)=>{if(this.cache.add(K),K.isComposite())return!1},enter:(K)=>this.cache.add(K),leave:()=>{},break:()=>{}}}run(Z,$){let J=$&&this.getCompositionContext($.text);for(let X=0,Y=0,K=0;;){let Q=K<Z.length?Z[K++]:null,U=Q?Q.fromA:this.old.root.length;if(U>X){let q=U-X;this.preserve(q,!K,!Q),X=U,Y+=q}if(!Q)break;if($&&Q.fromA<=$.range.fromA&&Q.toA>=$.range.toA)this.forward(Q.fromA,$.range.fromA,$.range.fromA<$.range.toA?1:-1),this.emit(Y,$.range.fromB),this.cache.clear(),this.builder.addComposition($,J),this.text.skip($.range.toB-$.range.fromB),this.forward($.range.fromA,Q.toA),this.emit($.range.toB,Q.toB);else this.forward(Q.fromA,Q.toA),this.emit(Y,Q.toB);Y=Q.toB,X=Q.toA}if(this.builder.curLine)this.builder.endLine();return this.builder.root}preserve(Z,$,J){let X=_X(this.old),Y=this.openMarks;this.old.advance(Z,J?1:-1,{skip:(K,Q,U)=>{if(K.isWidget())if(this.openWidget)this.builder.continueWidget(U-Q);else{let q=U>0||Q<K.length?w0.of(K.widget,this.view,U-Q,K.flags&496,this.cache.maybeReuse(K)):this.cache.reuse(K);if(q.flags&256)q.flags&=-2,this.builder.addBlockWidget(q);else this.builder.ensureLine(null),this.builder.addInlineWidget(q,X,Y),Y=X.length}else if(K.isText()){if(this.builder.ensureLine(null),!Q&&U==K.length)this.builder.addText(K.text,X,Y,this.cache.reuse(K));else this.cache.add(K),this.builder.addText(K.text.slice(Q,U),X,Y);Y=X.length}else if(K.isLine())K.flags&=-2,this.cache.reused.set(K,1),this.builder.addLine(K);else if(K instanceof g5)this.cache.add(K);else if(K instanceof D9)this.builder.ensureLine(null),this.builder.addMark(K,X,Y),this.cache.reused.set(K,1),Y=X.length;else return!1;this.openWidget=!1},enter:(K)=>{if(K.isLine())this.builder.addLineStart(K.attrs,this.cache.maybeReuse(K));else if(this.cache.add(K),K instanceof D9)X.unshift(K.mark);this.openWidget=!1},leave:(K)=>{if(K.isLine()){if(X.length)X.length=Y=0}else if(K instanceof D9)X.shift(),Y=Math.min(Y,X.length)},break:()=>{this.builder.addBreak(),this.openWidget=!1}}),this.text.skip(Z)}emit(Z,$){let J=null,X=this.builder,Y=0,K=b.spans(this.decorations,Z,$,{point:(Q,U,q,G,z,j)=>{if(q instanceof b0){if(this.disallowBlockEffectsFor[j]){if(q.block)throw RangeError("Block decorations may not be specified via plugins");if(U>this.view.state.doc.lineAt(Q).to)throw RangeError("Decorations that replace line breaks may not be specified via plugins")}if(Y=G.length,z>G.length)X.continueWidget(U-Q);else{let W=q.widget||(q.block?h0.block:h0.inline),O=WX(q),_=this.cache.findWidget(W,U-Q,O)||w0.of(W,this.view,U-Q,O);if(q.block){if(q.startSide>0)X.addLineStartIfNotCovered(J);X.addBlockWidget(_)}else X.ensureLine(J),X.addInlineWidget(_,G,z)}J=null}else J=OX(J,q);if(U>Q)this.text.skip(U-Q)},span:(Q,U,q,G)=>{for(let z=Q;z<U;){let j=this.text.next(Math.min(512,U-z));if(j==null)X.addLineStartIfNotCovered(J),X.addBreak(),z++;else X.ensureLine(J),X.addText(j,q,z==Q?G:q.length),z+=j.length;J=null}}});X.addLineStartIfNotCovered(J),this.openWidget=K>Y,this.openMarks=K}forward(Z,$,J=1){if($-Z<=10)this.old.advance($-Z,J,this.reuseWalker);else this.old.advance(5,-1,this.reuseWalker),this.old.advance($-Z-10,-1),this.old.advance(5,J,this.reuseWalker)}getCompositionContext(Z){let $=[],J=null;for(let X=Z.parentNode;;X=X.parentNode){let Y=Y9.get(X);if(X==this.view.contentDOM)break;if(Y instanceof D9)$.push(Y);else if(Y===null||Y===void 0?void 0:Y.isLine())J=Y;else if(Y instanceof W0);else if(X.nodeName=="DIV"&&!J&&X!=this.view.contentDOM)J=new Y5(X,n1);else if(!J)$.push(D9.of(new l5({tagName:X.nodeName.toLowerCase(),attributes:s2(X)}),X))}return{line:J,marks:$}}}function m8(Z,$){let J=(X)=>{for(let Y of X.children)if(($?Y.isText():Y.length)||J(Y))return!0;return!1};return J(Z)}function WX(Z){let $=Z.isReplace?(Z.startSide<0?64:0)|(Z.endSide>0?128:0):Z.startSide>0?32:16;if(Z.block)$|=256;return $}var n1={class:"cm-line"};function OX(Z,$){let J=$.spec.attributes,X=$.spec.class;if(!J&&!X)return Z;if(!Z)Z={class:"cm-line"};if(J)w3(J,Z);if(X)Z.class+=" "+X;return Z}function _X(Z){let $=[];for(let J=Z.parents.length;J>1;J--){let X=J==Z.parents.length?Z.tile:Z.parents[J].tile;if(X instanceof D9)$.push(X.mark)}return $}function J3(Z){let $=Y9.get(Z);if($)$.setDOM(Z.cloneNode());return Z}class h0 extends C9{constructor(Z){super();this.tag=Z}eq(Z){return Z.tag==this.tag}toDOM(){return document.createElement(this.tag)}updateDOM(Z){return Z.nodeName.toLowerCase()==this.tag}get isHidden(){return!0}}h0.inline=new h0("span");h0.block=new h0("div");var X3=new class extends C9{toDOM(){return document.createElement("br")}get isHidden(){return!0}get editable(){return!0}};class I3{constructor(Z){this.view=Z,this.decorations=[],this.blockWrappers=[],this.dynamicDecorationMap=[!1],this.domChanged=null,this.hasComposition=null,this.editContextFormatting=y.none,this.lastCompositionAfterCursor=!1,this.minWidth=0,this.minWidthFrom=0,this.minWidthTo=0,this.impreciseAnchor=null,this.impreciseHead=null,this.forceSelection=!1,this.lastUpdate=Date.now(),this.updateDeco(),this.tile=new n5(Z,Z.contentDOM),this.updateInner([new b9(0,0,0,Z.state.doc.length)],null)}update(Z){var $;let J=Z.changedRanges;if(this.minWidth>0&&J.length)if(!J.every(({fromA:G,toA:z})=>z<this.minWidthFrom||G>this.minWidthTo))this.minWidth=this.minWidthFrom=this.minWidthTo=0;else this.minWidthFrom=Z.changes.mapPos(this.minWidthFrom,1),this.minWidthTo=Z.changes.mapPos(this.minWidthTo,1);this.updateEditContextFormatting(Z);let X=-1;if(this.view.inputState.composing>=0&&!this.view.observer.editContext){if(($=this.domChanged)===null||$===void 0?void 0:$.newSel)X=this.domChanged.newSel.head;else if(!AX(Z.changes,this.hasComposition)&&!Z.selectionSet)X=Z.state.selection.main.head}let Y=X>-1?HX(this.view,Z.changes,X):null;if(this.domChanged=null,this.hasComposition){let{from:G,to:z}=this.hasComposition;J=new b9(G,z,Z.changes.mapPos(G,-1),Z.changes.mapPos(z,1)).addToSet(J.slice())}if(this.hasComposition=Y?{from:Y.range.fromB,to:Y.range.toB}:null,(B.ie||B.chrome)&&!Y&&Z&&Z.state.doc.lines!=Z.startState.doc.lines)this.forceSelection=!0;let K=this.decorations,Q=this.blockWrappers;this.updateDeco();let U=IX(K,this.decorations,Z.changes);if(U.length)J=b9.extendWithRanges(J,U);let q=DX(Q,this.blockWrappers,Z.changes);if(q.length)J=b9.extendWithRanges(J,q);if(Y&&!J.some((G)=>G.fromA<=Y.range.fromA&&G.toA>=Y.range.toA))J=Y.range.addToSet(J.slice());if(this.tile.flags&2&&J.length==0)return!1;else{if(this.updateInner(J,Y),Z.transactions.length)this.lastUpdate=Date.now();return!0}}updateInner(Z,$){this.view.viewState.mustMeasureContent=!0;let{observer:J}=this.view;J.ignore(()=>{if($||Z.length){let K=this.tile,Q=new s1(this.view,K,this.blockWrappers,this.decorations,this.dynamicDecorationMap);this.tile=Q.run(Z,$),D3(K,Q.cache.reused)}this.tile.dom.style.height=this.view.viewState.contentHeight/this.view.scaleY+"px",this.tile.dom.style.flexBasis=this.minWidth?this.minWidth+"px":"";let Y=B.chrome||B.ios?{node:J.selectionRange.focusNode,written:!1}:void 0;if(this.tile.sync(Y),Y&&(Y.written||J.selectionRange.focusNode!=Y.node||!this.tile.dom.contains(Y.node)))this.forceSelection=!0;this.tile.dom.style.height=""});let X=[];if(this.view.viewport.from||this.view.viewport.to<this.view.state.doc.length){for(let Y of this.tile.children)if(Y.isWidget()&&Y.widget instanceof k7)X.push(Y.dom)}J.updateGaps(X)}updateEditContextFormatting(Z){this.editContextFormatting=this.editContextFormatting.map(Z.changes);for(let $ of Z.transactions)for(let J of $.effects)if(J.is(h1))this.editContextFormatting=J.value}updateSelection(Z=!1,$=!1){if(Z||!this.view.observer.selectionRange.focusNode)this.view.observer.readSelectionRange();let{dom:J}=this.tile,X=this.view.root.activeElement,Y=X==J,K=!Y&&!(this.view.state.facet(j0)||J.tabIndex>-1)&&x5(J,this.view.observer.selectionRange)&&!(X&&J.contains(X));if(!(Y||$||K))return;let Q=this.forceSelection;this.forceSelection=!1;let U=this.view.state.selection.main,q,G;if(U.empty)G=q=this.inlineDOMNearPos(U.anchor,U.assoc||1);else G=this.inlineDOMNearPos(U.head,U.head==U.from?1:-1),q=this.inlineDOMNearPos(U.anchor,U.anchor==U.from?1:-1);if(B.gecko&&U.empty&&!this.hasComposition&&VX(q)){let j=document.createTextNode("");this.view.observer.ignore(()=>q.node.insertBefore(j,q.node.childNodes[q.offset]||null)),q=G=new i9(j,0),Q=!0}let z=this.view.observer.selectionRange;if(Q||!z.focusNode||(!w5(q.node,q.offset,z.anchorNode,z.anchorOffset)||!w5(G.node,G.offset,z.focusNode,z.focusOffset))&&!this.suppressWidgetCursorChange(z,U))this.view.observer.ignore(()=>{if(B.android&&B.chrome&&J.contains(z.focusNode)&&FX(z.focusNode,J))J.blur(),J.focus({preventScroll:!0});let j=u5(this.view.root);if(!j);else if(U.empty){if(B.gecko){let W=NX(q.node,q.offset);if(W&&W!=3){let O=(W==1?D1:F1)(q.node,q.offset);if(O)q=new i9(O.node,O.offset)}}if(j.collapse(q.node,q.offset),U.bidiLevel!=null&&j.caretBidiLevel!==void 0)j.caretBidiLevel=U.bidiLevel}else if(j.extend){j.collapse(q.node,q.offset);try{j.extend(G.node,G.offset)}catch(W){}}else{let W=document.createRange();if(U.anchor>U.head)[q,G]=[G,q];W.setEnd(G.node,G.offset),W.setStart(q.node,q.offset),j.removeAllRanges(),j.addRange(W)}if(K&&this.view.root.activeElement==J){if(J.blur(),X)X.focus()}}),this.view.observer.setSelectionRange(q,G);this.impreciseAnchor=q.precise?null:new i9(z.anchorNode,z.anchorOffset),this.impreciseHead=G.precise?null:new i9(z.focusNode,z.focusOffset)}suppressWidgetCursorChange(Z,$){return this.hasComposition&&$.empty&&w5(Z.focusNode,Z.focusOffset,Z.anchorNode,Z.anchorOffset)&&this.posFromDOM(Z.focusNode,Z.focusOffset)==$.head}enforceCursorAssoc(){if(this.hasComposition)return;let{view:Z}=this,$=Z.state.selection.main,J=u5(Z.root),{anchorNode:X,anchorOffset:Y}=Z.observer.selectionRange;if(!J||!$.empty||!$.assoc||!J.modify)return;let K=this.lineAt($.head,$.assoc);if(!K)return;let Q=K.posAtStart;if($.head==Q||$.head==Q+K.length)return;let U=this.coordsAt($.head,-1),q=this.coordsAt($.head,1);if(!U||!q||U.bottom>q.top)return;let G=this.domAtPos($.head+$.assoc,$.assoc);J.collapse(G.node,G.offset),J.modify("move",$.assoc<0?"forward":"backward","lineboundary"),Z.observer.readSelectionRange();let z=Z.observer.selectionRange;if(Z.docView.posFromDOM(z.anchorNode,z.anchorOffset)!=$.from)J.collapse(X,Y)}posFromDOM(Z,$){let J=this.tile.nearest(Z);if(!J)return this.tile.dom.compareDocumentPosition(Z)&2?0:this.view.state.doc.length;let X=J.posAtStart;if(J.isComposite()){let Y;if(Z==J.dom)Y=J.dom.childNodes[$];else{let K=O0(Z)==0?0:$==0?-1:1;for(;;){let Q=Z.parentNode;if(Q==J.dom)break;if(K==0&&Q.firstChild!=Q.lastChild)if(Z==Q.firstChild)K=-1;else K=1;Z=Q}if(K<0)Y=Z;else Y=Z.nextSibling}if(Y==J.dom.firstChild)return X;while(Y&&!Y9.get(Y))Y=Y.nextSibling;if(!Y)return X+J.length;for(let K=0,Q=X;;K++){let U=J.children[K];if(U.dom==Y)return Q;Q+=U.length+U.breakAfter}}else if(J.isText())return Z==J.dom?X+$:X+($?J.length:0);else return X}domAtPos(Z,$){let{tile:J,offset:X}=this.tile.resolveBlock(Z,$);if(J.isWidget())return J.domPosFor(Z,$);return J.domIn(X,$)}inlineDOMNearPos(Z,$){let J,X=-1,Y=!1,K,Q=-1,U=!1;if(this.tile.blockTiles((q,G)=>{if(q.isWidget()){if(q.flags&32&&G>=Z)return!0;if(q.flags&16)Y=!0}else{let z=G+q.length;if(G<=Z)J=q,X=Z-G,Y=z<Z;if(z>=Z&&!K)K=q,Q=Z-G,U=G>Z;if(G>Z&&K)return!0}}),!J&&!K)return this.domAtPos(Z,$);if(Y&&K)J=null;else if(U&&J)K=null;return J&&$<0||!K?J.domIn(X,$):K.domIn(Q,$)}coordsAt(Z,$){let{tile:J,offset:X}=this.tile.resolveBlock(Z,$);if(J.isWidget()){if(J.widget instanceof k7)return null;return J.coordsInWidget(X,$,!0)}return J.coordsIn(X,$)}lineAt(Z,$){let{tile:J}=this.tile.resolveBlock(Z,$);return J.isLine()?J:null}coordsForChar(Z){let{tile:$,offset:J}=this.tile.resolveBlock(Z,1);if(!$.isLine())return null;function X(Y,K){if(Y.isComposite())for(let Q of Y.children){if(Q.length>=K){let U=X(Q,K);if(U)return U}if(K-=Q.length,K<0)break}else if(Y.isText()&&K<Y.length){let Q=X9(Y.text,K);if(Q==K)return null;let U=f5(Y.dom,K,Q).getClientRects();for(let q=0;q<U.length;q++){let G=U[q];if(q==U.length-1||G.top<G.bottom&&G.left<G.right)return G}}return null}return X($,J)}measureVisibleLineHeights(Z){let $=[],{from:J,to:X}=Z,Y=this.view.contentDOM.clientWidth,K=Y>Math.max(this.view.scrollDOM.clientWidth,this.minWidth)+1,Q=-1,U=this.view.textDirection==p.LTR,q=0,G=(z,j,W)=>{for(let O=0;O<z.children.length;O++){if(j>X)break;let _=z.children[O],V=j+_.length,H=_.dom.getBoundingClientRect(),{height:I}=H;if(W&&!O)q+=H.top-W.top;if(_ instanceof W0){if(V>J)G(_,j,H)}else if(j>=J){if(q>0)$.push(-q);if($.push(I+q),q=0,K){let D=_.dom.lastChild,F=D?T7(D):[];if(F.length){let C=F[F.length-1],M=U?C.right-H.left:H.right-C.left;if(M>Q)Q=M,this.minWidth=Y,this.minWidthFrom=j,this.minWidthTo=V}}}if(W&&O==z.children.length-1)q+=W.bottom-H.bottom;j=V+_.breakAfter}};return G(this.tile,0,null),$}textDirectionAt(Z){let{tile:$}=this.tile.resolveBlock(Z,1);return getComputedStyle($.dom).direction=="rtl"?p.RTL:p.LTR}measureTextSize(){let Z=this.tile.blockTiles((K)=>{if(K.isLine()&&K.children.length&&K.length<=20){let Q=0,U;for(let q of K.children){if(!q.isText()||/[^ -~]/.test(q.text))return;let G=T7(q.dom);if(G.length!=1)return;Q+=G[0].width,U=G[0].height}if(Q)return{lineHeight:K.dom.getBoundingClientRect().height,charWidth:Q/K.length,textHeight:U}}});if(Z)return Z;let $=document.createElement("div"),J,X,Y;return $.className="cm-line",$.style.width="99999px",$.style.position="absolute",$.textContent="abc def ghi jkl mno pqr stu",this.view.observer.ignore(()=>{this.tile.dom.appendChild($);let K=T7($.firstChild)[0];J=$.getBoundingClientRect().height,X=K&&K.width?K.width/27:7,Y=K&&K.height?K.height:J,$.remove()}),{lineHeight:J,charWidth:X,textHeight:Y}}computeBlockGapDeco(){let Z=[],$=this.view.viewState;for(let J=0,X=0;;X++){let Y=X==$.viewports.length?null:$.viewports[X],K=Y?Y.from-1:this.view.state.doc.length;if(K>J){let Q=($.lineBlockAt(K).bottom-$.lineBlockAt(J).top)/this.view.scaleY;Z.push(y.replace({widget:new k7(Q),block:!0,inclusive:!0,isBlockGap:!0}).range(J,K))}if(!Y)break;J=Y.to+1}return y.set(Z)}updateDeco(){let Z=1,$=this.view.state.facet(i7).map((Y)=>{return(this.dynamicDecorationMap[Z++]=typeof Y=="function")?Y(this.view):Y}),J=!1,X=this.view.state.facet(g3).map((Y,K)=>{let Q=typeof Y=="function";if(Q)J=!0;return Q?Y(this.view):Y});if(X.length)this.dynamicDecorationMap[Z++]=J,$.push(b.join(X));this.decorations=[this.editContextFormatting,...$,this.computeBlockGapDeco(),this.view.viewState.lineGapDeco];while(Z<this.decorations.length)this.dynamicDecorationMap[Z++]=!1;this.blockWrappers=this.view.state.facet(m1).map((Y)=>typeof Y=="function"?Y(this.view):Y)}scrollIntoView(Z){if(Z.isSnapshot){let q=this.view.viewState.lineBlockAt(Z.range.head);this.view.scrollDOM.scrollTop=q.top-Z.yMargin,this.view.scrollDOM.scrollLeft=Z.xMargin;return}for(let q of this.view.state.facet(w1))try{if(q(this.view,Z.range,Z))return!0}catch(G){j9(this.view.state,G,"scroll handler")}let{range:$}=Z,J=this.coordsAt($.head,$.empty?$.assoc:$.head>$.anchor?-1:1),X;if(!J)return;if(!$.empty&&(X=this.coordsAt($.anchor,$.anchor>$.head?-1:1)))J={left:Math.min(J.left,X.left),top:Math.min(J.top,X.top),right:Math.max(J.right,X.right),bottom:Math.max(J.bottom,X.bottom)};let Y=p3(this.view),K={left:J.left-Y.left,top:J.top-Y.top,right:J.right+Y.right,bottom:J.bottom+Y.bottom},{offsetWidth:Q,offsetHeight:U}=this.view.scrollDOM;if(a2(this.view.scrollDOM,K,$.head<$.anchor?-1:1,Z.x,Z.y,Math.max(Math.min(Z.xMargin,Q),-Q),Math.max(Math.min(Z.yMargin,U),-U),this.view.textDirection==p.LTR),window.visualViewport&&window.innerHeight-window.visualViewport.height>1&&(J.top>window.pageYOffset+window.visualViewport.offsetTop+window.visualViewport.height||J.bottom<window.pageYOffset+window.visualViewport.offsetTop)){let q=this.view.docView.lineAt($.head,1);if(q)q.dom.scrollIntoView({block:"nearest"})}}lineHasWidget(Z){let $=(J)=>J.isWidget()||J.children.some($);return $(this.tile.resolveBlock(Z,1).tile)}destroy(){D3(this.tile)}}function D3(Z,$){let J=$===null||$===void 0?void 0:$.get(Z);if(J!=1){if(J==null)Z.destroy();for(let X of Z.children)D3(X,$)}}function VX(Z){return Z.node.nodeType==1&&Z.node.firstChild&&(Z.offset==0||Z.node.childNodes[Z.offset-1].contentEditable=="false")&&(Z.offset==Z.node.childNodes.length||Z.node.childNodes[Z.offset].contentEditable=="false")}function i1(Z,$){let J=Z.observer.selectionRange;if(!J.focusNode)return null;let X=D1(J.focusNode,J.focusOffset),Y=F1(J.focusNode,J.focusOffset),K=X||Y;if(Y&&X&&Y.node!=X.node){let U=Y9.get(Y.node);if(!U||U.isText()&&U.text!=Y.node.nodeValue)K=Y;else if(Z.docView.lastCompositionAfterCursor){let q=Y9.get(X.node);if(!(!q||q.isText()&&q.text!=X.node.nodeValue))K=Y}}if(Z.docView.lastCompositionAfterCursor=K!=X,!K)return null;let Q=$-K.offset;return{from:Q,to:Q+K.node.nodeValue.length,node:K.node}}function HX(Z,$,J){let X=i1(Z,J);if(!X)return null;let{node:Y,from:K,to:Q}=X,U=Y.nodeValue;if(/[\n\r]/.test(U))return null;if(Z.state.doc.sliceString(X.from,X.to)!=U)return null;let q=$.invertedDesc;return{range:new b9(q.mapPos(K),q.mapPos(Q),K,Q),text:Y}}function NX(Z,$){if(Z.nodeType!=1)return 0;return($&&Z.childNodes[$-1].contentEditable=="false"?1:0)|($<Z.childNodes.length&&Z.childNodes[$].contentEditable=="false"?2:0)}var RX=class{constructor(){this.changes=[]}compareRange($,J){$5($,J,this.changes)}comparePoint($,J){$5($,J,this.changes)}boundChange($){$5($,$,this.changes)}};function IX(Z,$,J){let X=new RX;return b.compare(Z,$,J,X),X.changes}class a1{constructor(){this.changes=[]}compareRange(Z,$){$5(Z,$,this.changes)}comparePoint(){}boundChange(Z){$5(Z,Z,this.changes)}}function DX(Z,$,J){let X=new a1;return b.compare(Z,$,J,X),X.changes}function FX(Z,$){for(let J=Z;J&&J!=$;J=J.assignedSlot||J.parentNode)if(J.nodeType==1&&J.contentEditable=="false")return!0;return!1}function AX(Z,$){let J=!1;if($)Z.iterChangedRanges((X,Y)=>{if(X<$.to&&Y>$.from)J=!0});return J}class k7 extends C9{constructor(Z){super();this.height=Z}toDOM(){let Z=document.createElement("div");return Z.className="cm-gap",this.updateDOM(Z),Z}eq(Z){return Z.height==this.height}updateDOM(Z){return Z.style.height=this.height+"px",!0}get editable(){return!0}get estimatedHeight(){return this.height}ignoreEvent(){return!1}}function LX(Z,$,J=1){let X=Z.charCategorizer($),Y=Z.doc.lineAt($),K=$-Y.from;if(Y.length==0)return R.cursor($);if(K==0)J=1;else if(K==Y.length)J=-1;let Q=K,U=K;if(J<0)Q=X9(Y.text,K,!1);else U=X9(Y.text,K);let q=X(Y.text.slice(Q,U));while(Q>0){let G=X9(Y.text,Q,!1);if(X(Y.text.slice(G,Q))!=q)break;Q=G}while(U<Y.length){let G=X9(Y.text,U);if(X(Y.text.slice(U,G))!=q)break;U=G}return R.range(Q+Y.from,U+Y.from)}function MX(Z,$,J,X,Y){let K=Math.round((X-$.left)*Z.defaultCharacterWidth);if(Z.lineWrapping&&J.height>Z.defaultLineHeight*1.5){let U=Z.viewState.heightOracle.textHeight,q=Math.floor((Y-J.top-(Z.defaultLineHeight-U)*0.5)/U);K+=q*Z.viewState.heightOracle.lineLength}let Q=Z.state.sliceDoc(J.from,J.to);return J.from+I7(Q,K,Z.state.tabSize)}function F3(Z,$,J){let X=Z.lineBlockAt($);if(Array.isArray(X.type)){let Y;for(let K of X.type){if(K.from>$)break;if(K.to<$)continue;if(K.from<$&&K.to>$)return K;if(!Y||K.type==W9.Text&&(Y.type!=K.type||(J<0?K.from<$:K.to>$)))Y=K}return Y||X}return X}function EX(Z,$,J,X){let Y=F3(Z,$.head,$.assoc||-1),K=!X||Y.type!=W9.Text||!(Z.lineWrapping||Y.widgetLineBreaks)?null:Z.coordsAtPos($.assoc<0&&$.head>Y.from?$.head-1:$.head);if(K){let Q=Z.dom.getBoundingClientRect(),U=Z.textDirectionAt(Y.from),q=Z.posAtCoords({x:J==(U==p.LTR)?Q.right-1:Q.left+1,y:(K.top+K.bottom)/2});if(q!=null)return R.cursor(q,J?-1:1)}return R.cursor(J?Y.to:Y.from,J?-1:1)}function u8(Z,$,J,X){let Y=Z.state.doc.lineAt($.head),K=Z.bidiSpans(Y),Q=Z.textDirectionAt(Y.from);for(let U=$,q=null;;){let G=QX(Y,K,Q,U,J),z=B1;if(!G){if(Y.number==(J?Z.state.doc.lines:1))return U;z=`
`,Y=Z.state.doc.line(Y.number+(J?1:-1)),K=Z.bidiSpans(Y),G=Z.visualLineSide(Y,!J)}if(!q){if(!X)return G;q=X(z)}else if(!q(z))return U;U=G}}function BX(Z,$,J){let X=Z.state.charCategorizer($),Y=X(J);return(K)=>{let Q=X(K);if(Y==d.Space)Y=Q;return Y==Q}}function PX(Z,$,J,X){let Y=$.head,K=J?1:-1;if(Y==(J?Z.state.doc.length:0))return R.cursor(Y,$.assoc);let Q=$.goalColumn,U,q=Z.contentDOM.getBoundingClientRect(),G=Z.coordsAtPos(Y,($.empty?$.assoc:0)||(J?1:-1)),z=Z.documentTop;if(G){if(Q==null)Q=G.left-q.left;U=K<0?G.top:G.bottom}else{let _=Z.viewState.lineBlockAt(Y);if(Q==null)Q=Math.min(q.right-q.left,Z.defaultCharacterWidth*(Y-_.from));U=(K<0?_.top:_.bottom)+z}let j=q.left+Q,W=X!==null&&X!==void 0?X:Z.viewState.heightOracle.textHeight>>1,O=A3(Z,{x:j,y:U+W*K},!1,K);return R.cursor(O.pos,O.assoc,void 0,Q)}function h5(Z,$,J){for(;;){let X=0;for(let Y of Z)Y.between($-1,$+1,(K,Q,U)=>{if($>K&&$<Q){let q=X||J||($-K<Q-$?-1:1);$=q<0?K:Q,X=q}});if(!X)return $}}function r1(Z,$){let J=null;for(let X=0;X<$.ranges.length;X++){let Y=$.ranges[X],K=null;if(Y.empty){let Q=h5(Z,Y.from,0);if(Q!=Y.from)K=R.cursor(Q,-1)}else{let Q=h5(Z,Y.from,-1),U=h5(Z,Y.to,1);if(Q!=Y.from||U!=Y.to)K=R.range(Y.from==Y.anchor?Q:U,Y.from==Y.head?Q:U)}if(K){if(!J)J=$.ranges.slice();J[X]=K}}return J?R.create(J,$.mainIndex):$}function Y3(Z,$,J){let X=h5(Z.state.facet(c5).map((Y)=>Y(Z)),J.from,$.head>J.from?-1:1);return X==J.from?J:R.cursor(X,X<J.from?1:-1)}class s9{constructor(Z,$){this.pos=Z,this.assoc=$}}function A3(Z,$,J,X){let Y=Z.contentDOM.getBoundingClientRect(),K=Y.top+Z.viewState.paddingTop,{x:Q,y:U}=$,q=U-K,G;for(;;){if(q<0)return new s9(0,1);if(q>Z.viewState.docHeight)return new s9(Z.state.doc.length,-1);if(G=Z.elementAtHeight(q),X==null)break;if(G.type==W9.Text){if(X<0?G.to<Z.viewport.from:G.from>Z.viewport.to)break;let W=Z.docView.coordsAt(X<0?G.from:G.to,X>0?-1:1);if(W&&(X<0?W.top<=q+K:W.bottom>=q+K))break}let j=Z.viewState.heightOracle.textHeight/2;q=X>0?G.bottom+j:G.top-j}if(Z.viewport.from>=G.to||Z.viewport.to<=G.from){if(J)return null;if(G.type==W9.Text){let j=MX(Z,Y,G,Q,U);return new s9(j,j==G.from?1:-1)}}if(G.type!=W9.Text)return q<(G.top+G.bottom)/2?new s9(G.from,1):new s9(G.to,-1);let z=Z.docView.lineAt(G.from,2);if(!z||z.length!=G.length)z=Z.docView.lineAt(G.from,-2);return new o1(Z,Q,U,Z.textDirectionAt(G.from)).scanTile(z,G.from)}class o1{constructor(Z,$,J,X){this.view=Z,this.x=$,this.y=J,this.baseDir=X,this.line=null,this.spans=null}bidiSpansAt(Z){if(!this.line||this.line.from>Z||this.line.to<Z)this.line=this.view.state.doc.lineAt(Z),this.spans=this.view.bidiSpans(this.line);return this}baseDirAt(Z,$){let{line:J,spans:X}=this.bidiSpansAt(Z);return X[a9.find(X,Z-J.from,-1,$)].level==this.baseDir}dirAt(Z,$){let{line:J,spans:X}=this.bidiSpansAt(Z);return X[a9.find(X,Z-J.from,-1,$)].dir}bidiIn(Z,$){let{spans:J,line:X}=this.bidiSpansAt(Z);return J.length>1||J.length&&(J[0].level!=this.baseDir||J[0].to+X.from<$)}scan(Z,$){let J=0,X=Z.length-1,Y=new Set,K=this.bidiIn(Z[0],Z[X]),Q,U,q=-1,G=1e9,z;Z:while(J<X){let W=X-J,O=J+X>>1;$:if(Y.has(O)){let V=J+Math.floor(Math.random()*W);for(let H=0;H<W;H++){if(!Y.has(V)){O=V;break $}if(V++,V==X)V=J}break Z}Y.add(O);let _=$(O);if(_)for(let V=0;V<_.length;V++){let H=_[V],I=0;if(H.bottom<this.y){if(!Q||Q.bottom<H.bottom)Q=H;I=1}else if(H.top>this.y){if(!U||U.top>H.top)U=H;I=-1}else{let D=H.left>this.x?this.x-H.left:H.right<this.x?this.x-H.right:0,F=Math.abs(D);if(F<G)q=O,G=F,z=H;if(D)I=D<0==(this.baseDir==p.LTR)?-1:1}if(I==-1&&(!K||this.baseDirAt(Z[O],1)))X=O;else if(I==1&&(!K||this.baseDirAt(Z[O+1],-1)))J=O+1}}if(!z){let W=Q&&(!U||this.y-Q.bottom<U.top-this.y)?Q:U;return this.y=(W.top+W.bottom)/2,this.scan(Z,$)}let j=(K?this.dirAt(Z[q],1):this.baseDir)==p.LTR;return{i:q,after:this.x>(z.left+z.right)/2==j}}scanText(Z,$){let J=[];for(let Y=0;Y<Z.length;Y=X9(Z.text,Y))J.push($+Y);J.push($+Z.length);let X=this.scan(J,(Y)=>{let K=J[Y]-$,Q=J[Y+1]-$;return f5(Z.dom,K,Q).getClientRects()});return X.after?new s9(J[X.i+1],-1):new s9(J[X.i],1)}scanTile(Z,$){if(!Z.length)return new s9($,1);if(Z.children.length==1){let Q=Z.children[0];if(Q.isText())return this.scanText(Q,$);else if(Q.isComposite())return this.scanTile(Q,$)}let J=[$];for(let Q=0,U=$;Q<Z.children.length;Q++)J.push(U+=Z.children[Q].length);let X=this.scan(J,(Q)=>{let U=Z.children[Q];if(U.flags&48)return null;return(U.dom.nodeType==1?U.dom:f5(U.dom,0,U.length)).getClientRects()}),Y=Z.children[X.i],K=J[X.i];if(Y.isText())return this.scanText(Y,K);if(Y.isComposite())return this.scanTile(Y,K);return X.after?new s9(J[X.i+1],-1):new s9(K,1)}}var T5="￿";class t1{constructor(Z,$){this.points=Z,this.view=$,this.text="",this.lineSeparator=$.state.facet(h.lineSeparator)}append(Z){this.text+=Z}lineBreak(){this.text+=T5}readRange(Z,$){if(!Z)return this;let J=Z.parentNode;for(let X=Z;;){this.findPointBefore(J,X);let Y=this.text.length;this.readNode(X);let K=Y9.get(X),Q=X.nextSibling;if(Q==$){if((K===null||K===void 0?void 0:K.breakAfter)&&!Q&&J!=this.view.contentDOM)this.lineBreak();break}let U=Y9.get(Q);if((K&&U?K.breakAfter:(K?K.breakAfter:u7(X))||u7(Q)&&(X.nodeName!="BR"||(K===null||K===void 0?void 0:K.isWidget()))&&this.text.length>Y)&&!TX(Q,$))this.lineBreak();X=Q}return this.findPointBefore(J,$),this}readTextNode(Z){let $=Z.nodeValue;for(let J of this.points)if(J.node==Z)J.pos=this.text.length+Math.min(J.offset,$.length);for(let J=0,X=this.lineSeparator?null:/\r\n?|\n/g;;){let Y=-1,K=1,Q;if(this.lineSeparator)Y=$.indexOf(this.lineSeparator,J),K=this.lineSeparator.length;else if(Q=X.exec($))Y=Q.index,K=Q[0].length;if(this.append($.slice(J,Y<0?$.length:Y)),Y<0)break;if(this.lineBreak(),K>1){for(let U of this.points)if(U.node==Z&&U.pos>this.text.length)U.pos-=K-1}J=Y+K}}readNode(Z){let $=Y9.get(Z),J=$&&$.overrideDOMText;if(J!=null){this.findPointInside(Z,J.length);for(let X=J.iter();!X.next().done;)if(X.lineBreak)this.lineBreak();else this.append(X.value)}else if(Z.nodeType==3)this.readTextNode(Z);else if(Z.nodeName=="BR"){if(Z.nextSibling)this.lineBreak()}else if(Z.nodeType==1)this.readRange(Z.firstChild,null)}findPointBefore(Z,$){for(let J of this.points)if(J.node==Z&&Z.childNodes[J.offset]==$)J.pos=this.text.length}findPointInside(Z,$){for(let J of this.points)if(Z.nodeType==3?J.node==Z:Z.contains(J.node))J.pos=this.text.length+(CX(Z,J.node,J.offset)?$:0)}}function CX(Z,$,J){for(;;){if(!$||J<O0($))return!1;if($==Z)return!0;J=H0($)+1,$=$.parentNode}}function TX(Z,$){let J;for(;;Z=Z.nextSibling){if(Z==$||!Z)break;let X=Y9.get(Z);if(!(X===null||X===void 0?void 0:X.isWidget()))return!1;if(X)(J||(J=[])).push(X)}if(J)for(let X of J){let Y=X.overrideDOMText;if(Y===null||Y===void 0?void 0:Y.length)return!1}return!0}class L3{constructor(Z,$){this.node=Z,this.offset=$,this.pos=-1}}class e1{constructor(Z,$,J,X){this.typeOver=X,this.bounds=null,this.text="",this.domChanged=$>-1;let{impreciseHead:Y,impreciseAnchor:K}=Z.docView;if(Z.state.readOnly&&$>-1)this.newSel=null;else if($>-1&&(this.bounds=Z6(Z.docView.tile,$,J,0))){let Q=Y||K?[]:kX(Z),U=new t1(Q,Z);U.readRange(this.bounds.startDOM,this.bounds.endDOM),this.text=U.text,this.newSel=SX(Q,this.bounds.from)}else{let Q=Z.observer.selectionRange,U=Y&&Y.node==Q.focusNode&&Y.offset==Q.focusOffset||!_3(Z.contentDOM,Q.focusNode)?Z.state.selection.main.head:Z.docView.posFromDOM(Q.focusNode,Q.focusOffset),q=K&&K.node==Q.anchorNode&&K.offset==Q.anchorOffset||!_3(Z.contentDOM,Q.anchorNode)?Z.state.selection.main.anchor:Z.docView.posFromDOM(Q.anchorNode,Q.anchorOffset),G=Z.viewport;if((B.ios||B.chrome)&&Z.state.selection.main.empty&&U!=q&&(G.from>0||G.to<Z.state.doc.length)){let z=Math.min(U,q),j=Math.max(U,q),W=G.from-z,O=G.to-j;if((W==0||W==1||z==0)&&(O==0||O==-1||j==Z.state.doc.length))U=0,q=Z.state.doc.length}if(Z.inputState.composing>-1&&Z.state.selection.ranges.length>1)this.newSel=Z.state.selection.replaceRange(R.range(q,U));else this.newSel=R.single(q,U)}}}function Z6(Z,$,J,X){if(Z.isComposite()){let Y=-1,K=-1,Q=-1,U=-1;for(let q=0,G=X,z=X;q<Z.children.length;q++){let j=Z.children[q],W=G+j.length;if(G<$&&W>J)return Z6(j,$,J,G);if(W>=$&&Y==-1)Y=q,K=G;if(G>J&&j.dom.parentNode==Z.dom){Q=q,U=z;break}z=W,G=W+j.breakAfter}return{from:K,to:U<0?X+Z.length:U,startDOM:(Y?Z.children[Y-1].dom.nextSibling:null)||Z.dom.firstChild,endDOM:Q<Z.children.length&&Q>=0?Z.children[Q].dom:null}}else if(Z.isText())return{from:X,to:X+Z.length,startDOM:Z.dom,endDOM:Z.dom.nextSibling};else return null}function $6(Z,$){let J,{newSel:X}=$,Y=Z.state.selection.main,K=Z.inputState.lastKeyTime>Date.now()-100?Z.inputState.lastKeyCode:-1;if($.bounds){let{from:Q,to:U}=$.bounds,q=Y.from,G=null;if(K===8||B.android&&$.text.length<U-Q)q=Y.to,G="end";let z=J6(Z.state.doc.sliceString(Q,U,T5),$.text,q-Q,G);if(z){if(B.chrome&&K==13&&z.toB==z.from+2&&$.text.slice(z.from,z.toB)==T5+T5)z.toB--;J={from:Q+z.from,to:Q+z.toA,insert:u.of($.text.slice(z.from,z.toB).split(T5))}}}else if(X&&(!Z.hasFocus&&Z.state.facet(j0)||l7(X,Y)))X=null;if(!J&&!X)return!1;if(!J&&$.typeOver&&!Y.empty&&X&&X.main.empty)J={from:Y.from,to:Y.to,insert:Z.state.doc.slice(Y.from,Y.to)};else if((B.mac||B.android)&&J&&J.from==J.to&&J.from==Y.head-1&&/^\. ?$/.test(J.insert.toString())&&Z.contentDOM.getAttribute("autocorrect")=="off"){if(X&&J.insert.length==2)X=R.single(X.main.anchor-1,X.main.head-1);J={from:J.from,to:J.to,insert:u.of([J.insert.toString().replace("."," ")])}}else if(J&&J.from>=Y.from&&J.to<=Y.to&&(J.from!=Y.from||J.to!=Y.to)&&Y.to-Y.from-(J.to-J.from)<=4)J={from:Y.from,to:Y.to,insert:Z.state.doc.slice(Y.from,J.from).append(J.insert).append(Z.state.doc.slice(J.to,Y.to))};else if(Z.state.doc.lineAt(Y.from).to<Y.to&&Z.docView.lineHasWidget(Y.to)&&Z.inputState.insertingTextAt>Date.now()-50)J={from:Y.from,to:Y.to,insert:Z.state.toText(Z.inputState.insertingText)};else if(B.chrome&&J&&J.from==J.to&&J.from==Y.head&&J.insert.toString()==`
 `&&Z.lineWrapping){if(X)X=R.single(X.main.anchor-1,X.main.head-1);J={from:Y.from,to:Y.to,insert:u.of([" "])}}if(J)return l3(Z,J,X,K);else if(X&&!l7(X,Y)){let Q=!1,U="select";if(Z.inputState.lastSelectionTime>Date.now()-50){if(Z.inputState.lastSelectionOrigin=="select")Q=!0;if(U=Z.inputState.lastSelectionOrigin,U=="select.pointer")X=r1(Z.state.facet(c5).map((q)=>q(Z)),X)}return Z.dispatch({selection:X,scrollIntoView:Q,userEvent:U}),!0}else return!1}function l3(Z,$,J,X=-1){if(B.ios&&Z.inputState.flushIOSKey($))return!0;let Y=Z.state.selection.main;if(B.android&&($.to==Y.to&&($.from==Y.from||$.from==Y.from-1&&Z.state.sliceDoc($.from,Y.from)==" ")&&$.insert.length==1&&$.insert.lines==2&&J5(Z.contentDOM,"Enter",13)||($.from==Y.from-1&&$.to==Y.to&&$.insert.length==0||X==8&&$.insert.length<$.to-$.from&&$.to>Y.head)&&J5(Z.contentDOM,"Backspace",8)||$.from==Y.from&&$.to==Y.to+1&&$.insert.length==0&&J5(Z.contentDOM,"Delete",46)))return!0;let K=$.insert.toString();if(Z.inputState.composing>=0)Z.inputState.composing++;let Q,U=()=>Q||(Q=yX(Z,$,J));if(!Z.state.facet(k1).some((q)=>q(Z,$.from,$.to,K,U)))Z.dispatch(U());return!0}function yX(Z,$,J){let X,Y=Z.state,K=Y.selection.main,Q=-1;if($.from==$.to&&$.from<K.from||$.from>K.to){let q=$.from<K.from?-1:1,G=q<0?K.from:K.to,z=h5(Y.facet(c5).map((j)=>j(Z)),G,q);if($.from==z)Q=z}if(Q>-1)X={changes:$,selection:R.cursor($.from+$.insert.length,-1)};else if($.from>=K.from&&$.to<=K.to&&$.to-$.from>=(K.to-K.from)/3&&(!J||J.main.empty&&J.main.from==$.from+$.insert.length)&&Z.inputState.composing<0){let q=K.from<$.from?Y.sliceDoc(K.from,$.from):"",G=K.to>$.to?Y.sliceDoc($.to,K.to):"";X=Y.replaceSelection(Z.state.toText(q+$.insert.sliceString(0,void 0,Z.state.lineBreak)+G))}else{let q=Y.changes($),G=J&&J.main.to<=q.newLength?J.main:void 0;if(Y.selection.ranges.length>1&&(Z.inputState.composing>=0||Z.inputState.compositionPendingChange)&&$.to<=K.to+10&&$.to>=K.to-10){let z=Z.state.sliceDoc($.from,$.to),j,W=J&&i1(Z,J.main.head);if(W){let _=$.insert.length-($.to-$.from);j={from:W.from,to:W.to-_}}else j=Z.state.doc.lineAt(K.head);let O=K.to-$.to;X=Y.changeByRange((_)=>{if(_.from==K.from&&_.to==K.to)return{changes:q,range:G||_.map(q)};let V=_.to-O,H=V-z.length;if(Z.state.sliceDoc(H,V)!=z||V>=j.from&&H<=j.to)return{range:_};let I=Y.changes({from:H,to:V,insert:$.insert}),D=_.to-K.to;return{changes:I,range:!G?_.map(I):R.range(Math.max(0,G.anchor+D),Math.max(0,G.head+D))}})}else X={changes:q,selection:G&&Y.selection.replaceRange(G)}}let U="input.type";if(Z.composing||Z.inputState.compositionPendingChange&&Z.inputState.compositionEndedAt>Date.now()-50){if(Z.inputState.compositionPendingChange=!1,U+=".compose",Z.inputState.compositionFirstChange)U+=".start",Z.inputState.compositionFirstChange=!1}return Y.update(X,{userEvent:U,scrollIntoView:!0})}function J6(Z,$,J,X){let Y=Math.min(Z.length,$.length),K=0;while(K<Y&&Z.charCodeAt(K)==$.charCodeAt(K))K++;if(K==Y&&Z.length==$.length)return null;let Q=Z.length,U=$.length;while(Q>0&&U>0&&Z.charCodeAt(Q-1)==$.charCodeAt(U-1))Q--,U--;if(X=="end"){let q=Math.max(0,K-Math.min(Q,U));J-=Q+q-K}if(Q<K&&Z.length<$.length){let q=J<=K&&J>=Q?K-J:0;K-=q,U=K+(U-Q),Q=K}else if(U<K){let q=J<=K&&J>=U?K-J:0;K-=q,Q=K+(Q-U),U=K}return{from:K,toA:Q,toB:U}}function kX(Z){let $=[];if(Z.root.activeElement!=Z.contentDOM)return $;let{anchorNode:J,anchorOffset:X,focusNode:Y,focusOffset:K}=Z.observer.selectionRange;if(J){if($.push(new L3(J,X)),Y!=J||K!=X)$.push(new L3(Y,K))}return $}function SX(Z,$){if(Z.length==0)return null;let J=Z[0].pos,X=Z.length==2?Z[1].pos:J;return J>-1&&X>-1?R.single(J+$,X+$):null}function l7(Z,$){return $.head==Z.main.head&&$.anchor==Z.main.anchor}class X6{setSelectionOrigin(Z){this.lastSelectionOrigin=Z,this.lastSelectionTime=Date.now()}constructor(Z){if(this.view=Z,this.lastKeyCode=0,this.lastKeyTime=0,this.lastTouchTime=0,this.lastFocusTime=0,this.lastScrollTop=0,this.lastScrollLeft=0,this.pendingIOSKey=void 0,this.tabFocusMode=-1,this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastContextMenu=0,this.scrollHandlers=[],this.handlers=Object.create(null),this.composing=-1,this.compositionFirstChange=null,this.compositionEndedAt=0,this.compositionPendingKey=!1,this.compositionPendingChange=!1,this.insertingText="",this.insertingTextAt=0,this.mouseSelection=null,this.draggedContent=null,this.handleEvent=this.handleEvent.bind(this),this.notifiedFocused=Z.hasFocus,B.safari)Z.contentDOM.addEventListener("input",()=>null);if(B.gecko)sX(Z.contentDOM.ownerDocument)}handleEvent(Z){if(!uX(this.view,Z)||this.ignoreDuringComposition(Z))return;if(Z.type=="keydown"&&this.keydown(Z))return;if(this.view.updateState!=0)Promise.resolve().then(()=>this.runHandlers(Z.type,Z));else this.runHandlers(Z.type,Z)}runHandlers(Z,$){let J=this.handlers[Z];if(J){for(let X of J.observers)X(this.view,$);for(let X of J.handlers){if($.defaultPrevented)break;if(X(this.view,$)){$.preventDefault();break}}}}ensureHandlers(Z){let $=bX(Z),J=this.handlers,X=this.view.contentDOM;for(let Y in $)if(Y!="scroll"){let K=!$[Y].handlers.length,Q=J[Y];if(Q&&K!=!Q.handlers.length)X.removeEventListener(Y,this.handleEvent),Q=null;if(!Q)X.addEventListener(Y,this.handleEvent,{passive:K})}for(let Y in J)if(Y!="scroll"&&!$[Y])X.removeEventListener(Y,this.handleEvent);this.handlers=$}keydown(Z){if(this.lastKeyCode=Z.keyCode,this.lastKeyTime=Date.now(),Z.keyCode==9&&this.tabFocusMode>-1&&(!this.tabFocusMode||Date.now()<=this.tabFocusMode))return!0;if(this.tabFocusMode>0&&Z.keyCode!=27&&K6.indexOf(Z.keyCode)<0)this.tabFocusMode=-1;if(B.android&&B.chrome&&!Z.synthetic&&(Z.keyCode==13||Z.keyCode==8))return this.view.observer.delayAndroidKey(Z.key,Z.keyCode),!0;let $;if(B.ios&&!Z.synthetic&&!Z.altKey&&!Z.metaKey&&(($=Y6.find((J)=>J.keyCode==Z.keyCode))&&!Z.ctrlKey||xX.indexOf(Z.key)>-1&&Z.ctrlKey&&!Z.shiftKey))return this.pendingIOSKey=$||Z,setTimeout(()=>this.flushIOSKey(),250),!0;if(Z.keyCode!=229)this.view.observer.forceFlush();return!1}flushIOSKey(Z){let $=this.pendingIOSKey;if(!$)return!1;if($.key=="Enter"&&Z&&Z.from<Z.to&&/^\S+$/.test(Z.insert.toString()))return!1;return this.pendingIOSKey=void 0,J5(this.view.contentDOM,$.key,$.keyCode,$ instanceof KeyboardEvent?$:void 0)}ignoreDuringComposition(Z){if(!/^key/.test(Z.type)||Z.synthetic)return!1;if(this.composing>0)return!0;if(B.safari&&!B.ios&&this.compositionPendingKey&&Date.now()-this.compositionEndedAt<100)return this.compositionPendingKey=!1,!0;return!1}startMouseSelection(Z){if(this.mouseSelection)this.mouseSelection.destroy();this.mouseSelection=Z}update(Z){if(this.view.observer.update(Z),this.mouseSelection)this.mouseSelection.update(Z);if(this.draggedContent&&Z.docChanged)this.draggedContent=this.draggedContent.map(Z.changes);if(Z.transactions.length)this.lastKeyCode=this.lastSelectionTime=0}destroy(){if(this.mouseSelection)this.mouseSelection.destroy()}}function f8(Z,$){return(J,X)=>{try{return $.call(Z,X,J)}catch(Y){j9(J.state,Y)}}}function bX(Z){let $=Object.create(null);function J(X){return $[X]||($[X]={observers:[],handlers:[]})}for(let X of Z){let Y=X.spec,K=Y&&Y.plugin.domEventHandlers,Q=Y&&Y.plugin.domEventObservers;if(K)for(let U in K){let q=K[U];if(q)J(U).handlers.push(f8(X.value,q))}if(Q)for(let U in Q){let q=Q[U];if(q)J(U).observers.push(f8(X.value,q))}}for(let X in r9)J(X).handlers.push(r9[X]);for(let X in x9)J(X).observers.push(x9[X]);return $}var Y6=[{key:"Backspace",keyCode:8,inputType:"deleteContentBackward"},{key:"Enter",keyCode:13,inputType:"insertParagraph"},{key:"Enter",keyCode:13,inputType:"insertLineBreak"},{key:"Delete",keyCode:46,inputType:"deleteContentForward"}],xX="dthko",K6=[16,17,18,20,91,92,224,225],F7=6;function A7(Z){return Math.max(0,Z)*0.7+8}function wX(Z,$){return Math.max(Math.abs(Z.clientX-$.clientX),Math.abs(Z.clientY-$.clientY))}class Q6{constructor(Z,$,J,X){this.view=Z,this.startEvent=$,this.style=J,this.mustSelect=X,this.scrollSpeed={x:0,y:0},this.scrolling=-1,this.lastEvent=$,this.scrollParents=r2(Z.contentDOM),this.atoms=Z.state.facet(c5).map((K)=>K(Z));let Y=Z.contentDOM.ownerDocument;Y.addEventListener("mousemove",this.move=this.move.bind(this)),Y.addEventListener("mouseup",this.up=this.up.bind(this)),this.extend=$.shiftKey,this.multiple=Z.state.facet(h.allowMultipleSelections)&&hX(Z,$),this.dragging=mX(Z,$)&&G6($)==1?null:!1}start(Z){if(this.dragging===!1)this.select(Z)}move(Z){if(Z.buttons==0)return this.destroy();if(this.dragging||this.dragging==null&&wX(this.startEvent,Z)<10)return;this.select(this.lastEvent=Z);let $=0,J=0,X=0,Y=0,K=this.view.win.innerWidth,Q=this.view.win.innerHeight;if(this.scrollParents.x)({left:X,right:K}=this.scrollParents.x.getBoundingClientRect());if(this.scrollParents.y)({top:Y,bottom:Q}=this.scrollParents.y.getBoundingClientRect());let U=p3(this.view);if(Z.clientX-U.left<=X+F7)$=-A7(X-Z.clientX);else if(Z.clientX+U.right>=K-F7)$=A7(Z.clientX-K);if(Z.clientY-U.top<=Y+F7)J=-A7(Y-Z.clientY);else if(Z.clientY+U.bottom>=Q-F7)J=A7(Z.clientY-Q);this.setScrollSpeed($,J)}up(Z){if(this.dragging==null)this.select(this.lastEvent);if(!this.dragging)Z.preventDefault();this.destroy()}destroy(){this.setScrollSpeed(0,0);let Z=this.view.contentDOM.ownerDocument;Z.removeEventListener("mousemove",this.move),Z.removeEventListener("mouseup",this.up),this.view.inputState.mouseSelection=this.view.inputState.draggedContent=null}setScrollSpeed(Z,$){if(this.scrollSpeed={x:Z,y:$},Z||$){if(this.scrolling<0)this.scrolling=setInterval(()=>this.scroll(),50)}else if(this.scrolling>-1)clearInterval(this.scrolling),this.scrolling=-1}scroll(){let{x:Z,y:$}=this.scrollSpeed;if(Z&&this.scrollParents.x)this.scrollParents.x.scrollLeft+=Z,Z=0;if($&&this.scrollParents.y)this.scrollParents.y.scrollTop+=$,$=0;if(Z||$)this.view.win.scrollBy(Z,$);if(this.dragging===!1)this.select(this.lastEvent)}select(Z){let{view:$}=this,J=r1(this.atoms,this.style.get(Z,this.extend,this.multiple));if(this.mustSelect||!J.eq($.state.selection,this.dragging===!1))this.view.dispatch({selection:J,userEvent:"select.pointer"});this.mustSelect=!1}update(Z){if(Z.transactions.some(($)=>$.isUserEvent("input.type")))this.destroy();else if(this.style.update(Z))setTimeout(()=>this.select(this.lastEvent),20)}}function hX(Z,$){let J=Z.state.facet(P1);return J.length?J[0]($):B.mac?$.metaKey:$.ctrlKey}function vX(Z,$){let J=Z.state.facet(C1);return J.length?J[0]($):B.mac?!$.altKey:!$.ctrlKey}function mX(Z,$){let{main:J}=Z.state.selection;if(J.empty)return!1;let X=u5(Z.root);if(!X||X.rangeCount==0)return!0;let Y=X.getRangeAt(0).getClientRects();for(let K=0;K<Y.length;K++){let Q=Y[K];if(Q.left<=$.clientX&&Q.right>=$.clientX&&Q.top<=$.clientY&&Q.bottom>=$.clientY)return!0}return!1}function uX(Z,$){if(!$.bubbles)return!0;if($.defaultPrevented)return!1;for(let J=$.target,X;J!=Z.contentDOM;J=J.parentNode)if(!J||J.nodeType==11||(X=Y9.get(J))&&X.isWidget()&&!X.isHidden&&X.widget.ignoreEvent($))return!1;return!0}var r9=Object.create(null),x9=Object.create(null),U6=B.ie&&B.ie_version<15||B.ios&&B.webkit_version<604;function fX(Z){let $=Z.dom.parentNode;if(!$)return;let J=$.appendChild(document.createElement("textarea"));J.style.cssText="position: fixed; left: -10000px; top: 10px",J.focus(),setTimeout(()=>{Z.focus(),J.remove(),q6(Z,J.value)},50)}function a7(Z,$,J){for(let X of Z.facet($))J=X(J,Z);return J}function q6(Z,$){$=a7(Z.state,m3,$);let{state:J}=Z,X,Y=1,K=J.toText($),Q=K.lines==J.selection.ranges.length;if(M3!=null&&J.selection.ranges.every((q)=>q.empty)&&M3==K.toString()){let q=-1;X=J.changeByRange((G)=>{let z=J.doc.lineAt(G.from);if(z.from==q)return{range:G};q=z.from;let j=J.toText((Q?K.line(Y++).text:$)+J.lineBreak);return{changes:{from:z.from,insert:j},range:R.cursor(G.from+j.length)}})}else if(Q)X=J.changeByRange((q)=>{let G=K.line(Y++);return{changes:{from:q.from,to:q.to,insert:G.text},range:R.cursor(q.from+G.length)}});else X=J.replaceSelection(K);Z.dispatch(X,{userEvent:"input.paste",scrollIntoView:!0})}x9.scroll=(Z)=>{Z.inputState.lastScrollTop=Z.scrollDOM.scrollTop,Z.inputState.lastScrollLeft=Z.scrollDOM.scrollLeft};r9.keydown=(Z,$)=>{if(Z.inputState.setSelectionOrigin("select"),$.keyCode==27&&Z.inputState.tabFocusMode!=0)Z.inputState.tabFocusMode=Date.now()+2000;return!1};x9.touchstart=(Z,$)=>{Z.inputState.lastTouchTime=Date.now(),Z.inputState.setSelectionOrigin("select.pointer")};x9.touchmove=(Z)=>{Z.inputState.setSelectionOrigin("select.pointer")};r9.mousedown=(Z,$)=>{if(Z.observer.flush(),Z.inputState.lastTouchTime>Date.now()-2000)return!1;let J=null;for(let X of Z.state.facet(T1))if(J=X(Z,$),J)break;if(!J&&$.button==0)J=pX(Z,$);if(J){let X=!Z.hasFocus;if(Z.inputState.startMouseSelection(new Q6(Z,$,J,X)),X)Z.observer.ignore(()=>{R1(Z.contentDOM);let K=Z.root.activeElement;if(K&&!K.contains(Z.contentDOM))K.blur()});let Y=Z.inputState.mouseSelection;if(Y)return Y.start($),Y.dragging===!1}else Z.inputState.setSelectionOrigin("select.pointer");return!1};function g8(Z,$,J,X){if(X==1)return R.cursor($,J);else if(X==2)return LX(Z.state,$,J);else{let Y=Z.docView.lineAt($,J),K=Z.state.doc.lineAt(Y?Y.posAtEnd:$),Q=Y?Y.posAtStart:K.from,U=Y?Y.posAtEnd:K.to;if(U<Z.state.doc.length&&U==K.to)U++;return R.range(Q,U)}}var gX=B.ie&&B.ie_version<=11,p8=null,l8=0,d8=0;function G6(Z){if(!gX)return Z.detail;let $=p8,J=d8;return p8=Z,d8=Date.now(),l8=!$||J>Date.now()-400&&Math.abs($.clientX-Z.clientX)<2&&Math.abs($.clientY-Z.clientY)<2?(l8+1)%3:1}function pX(Z,$){let J=Z.posAndSideAtCoords({x:$.clientX,y:$.clientY},!1),X=G6($),Y=Z.state.selection;return{update(K){if(K.docChanged)J.pos=K.changes.mapPos(J.pos),Y=Y.map(K.changes)},get(K,Q,U){let q=Z.posAndSideAtCoords({x:K.clientX,y:K.clientY},!1),G,z=g8(Z,q.pos,q.assoc,X);if(J.pos!=q.pos&&!Q){let j=g8(Z,J.pos,J.assoc,X),W=Math.min(j.from,z.from),O=Math.max(j.to,z.to);z=W<z.from?R.range(W,O):R.range(O,W)}if(Q)return Y.replaceRange(Y.main.extend(z.from,z.to));else if(U&&X==1&&Y.ranges.length>1&&(G=lX(Y,q.pos)))return G;else if(U)return Y.addRange(z);else return R.create([z])}}}function lX(Z,$){for(let J=0;J<Z.ranges.length;J++){let{from:X,to:Y}=Z.ranges[J];if(X<=$&&Y>=$)return R.create(Z.ranges.slice(0,J).concat(Z.ranges.slice(J+1)),Z.mainIndex==J?0:Z.mainIndex-(Z.mainIndex>J?1:0))}return null}r9.dragstart=(Z,$)=>{let{selection:{main:J}}=Z.state;if($.target.draggable){let Y=Z.docView.tile.nearest($.target);if(Y&&Y.isWidget()){let K=Y.posAtStart,Q=K+Y.length;if(K>=J.to||Q<=J.from)J=R.range(K,Q)}}let{inputState:X}=Z;if(X.mouseSelection)X.mouseSelection.dragging=!0;if(X.draggedContent=J,$.dataTransfer)$.dataTransfer.setData("Text",a7(Z.state,u3,Z.state.sliceDoc(J.from,J.to))),$.dataTransfer.effectAllowed="copyMove";return!1};r9.dragend=(Z)=>{return Z.inputState.draggedContent=null,!1};function c8(Z,$,J,X){if(J=a7(Z.state,m3,J),!J)return;let Y=Z.posAtCoords({x:$.clientX,y:$.clientY},!1),{draggedContent:K}=Z.inputState,Q=X&&K&&vX(Z,$)?{from:K.from,to:K.to}:null,U={from:Y,insert:J},q=Z.state.changes(Q?[Q,U]:U);Z.focus(),Z.dispatch({changes:q,selection:{anchor:q.mapPos(Y,-1),head:q.mapPos(Y,1)},userEvent:Q?"move.drop":"input.drop"}),Z.inputState.draggedContent=null}r9.drop=(Z,$)=>{if(!$.dataTransfer)return!1;if(Z.state.readOnly)return!0;let J=$.dataTransfer.files;if(J&&J.length){let X=Array(J.length),Y=0,K=()=>{if(++Y==J.length)c8(Z,$,X.filter((Q)=>Q!=null).join(Z.state.lineBreak),!1)};for(let Q=0;Q<J.length;Q++){let U=new FileReader;U.onerror=K,U.onload=()=>{if(!/[\x00-\x08\x0e-\x1f]{2}/.test(U.result))X[Q]=U.result;K()},U.readAsText(J[Q])}return!0}else{let X=$.dataTransfer.getData("Text");if(X)return c8(Z,$,X,!0),!0}return!1};r9.paste=(Z,$)=>{if(Z.state.readOnly)return!0;Z.observer.flush();let J=U6?null:$.clipboardData;if(J)return q6(Z,J.getData("text/plain")||J.getData("text/uri-list")),!0;else return fX(Z),!1};function dX(Z,$){let J=Z.dom.parentNode;if(!J)return;let X=J.appendChild(document.createElement("textarea"));X.style.cssText="position: fixed; left: -10000px; top: 10px",X.value=$,X.focus(),X.selectionEnd=$.length,X.selectionStart=0,setTimeout(()=>{X.remove(),Z.focus()},50)}function cX(Z){let $=[],J=[],X=!1;for(let Y of Z.selection.ranges)if(!Y.empty)$.push(Z.sliceDoc(Y.from,Y.to)),J.push(Y);if(!$.length){let Y=-1;for(let{from:K}of Z.selection.ranges){let Q=Z.doc.lineAt(K);if(Q.number>Y)$.push(Q.text),J.push({from:Q.from,to:Math.min(Z.doc.length,Q.to+1)});Y=Q.number}X=!0}return{text:a7(Z,u3,$.join(Z.lineBreak)),ranges:J,linewise:X}}var M3=null;r9.copy=r9.cut=(Z,$)=>{if(!x5(Z.contentDOM,Z.observer.selectionRange))return!1;let{text:J,ranges:X,linewise:Y}=cX(Z.state);if(!J&&!Y)return!1;if(M3=Y?J:null,$.type=="cut"&&!Z.state.readOnly)Z.dispatch({changes:X,scrollIntoView:!0,userEvent:"delete.cut"});let K=U6?null:$.clipboardData;if(K)return K.clearData(),K.setData("text/plain",J),!0;else return dX(Z,J),!1};var z6=B9.define();function j6(Z,$){let J=[];for(let X of Z.facet(S1)){let Y=X(Z,$);if(Y)J.push(Y)}return J.length?Z.update({effects:J,annotations:z6.of(!0)}):null}function W6(Z){setTimeout(()=>{let $=Z.hasFocus;if($!=Z.inputState.notifiedFocused){let J=j6(Z.state,$);if(J)Z.dispatch(J);else Z.update([])}},10)}x9.focus=(Z)=>{if(Z.inputState.lastFocusTime=Date.now(),!Z.scrollDOM.scrollTop&&(Z.inputState.lastScrollTop||Z.inputState.lastScrollLeft))Z.scrollDOM.scrollTop=Z.inputState.lastScrollTop,Z.scrollDOM.scrollLeft=Z.inputState.lastScrollLeft;W6(Z)};x9.blur=(Z)=>{Z.observer.clearSelectionRange(),W6(Z)};x9.compositionstart=x9.compositionupdate=(Z)=>{if(Z.observer.editContext)return;if(Z.inputState.compositionFirstChange==null)Z.inputState.compositionFirstChange=!0;if(Z.inputState.composing<0)Z.inputState.composing=0};x9.compositionend=(Z)=>{if(Z.observer.editContext)return;if(Z.inputState.composing=-1,Z.inputState.compositionEndedAt=Date.now(),Z.inputState.compositionPendingKey=!0,Z.inputState.compositionPendingChange=Z.observer.pendingRecords().length>0,Z.inputState.compositionFirstChange=null,B.chrome&&B.android)Z.observer.flushSoon();else if(Z.inputState.compositionPendingChange)Promise.resolve().then(()=>Z.observer.flush());else setTimeout(()=>{if(Z.inputState.composing<0&&Z.docView.hasComposition)Z.update([])},50)};x9.contextmenu=(Z)=>{Z.inputState.lastContextMenu=Date.now()};r9.beforeinput=(Z,$)=>{var J,X;if($.inputType=="insertText"||$.inputType=="insertCompositionText")Z.inputState.insertingText=$.data,Z.inputState.insertingTextAt=Date.now();if($.inputType=="insertReplacementText"&&Z.observer.editContext){let K=(J=$.dataTransfer)===null||J===void 0?void 0:J.getData("text/plain"),Q=$.getTargetRanges();if(K&&Q.length){let U=Q[0],q=Z.posAtDOM(U.startContainer,U.startOffset),G=Z.posAtDOM(U.endContainer,U.endOffset);return l3(Z,{from:q,to:G,insert:Z.state.toText(K)},null),!0}}let Y;if(B.chrome&&B.android&&(Y=Y6.find((K)=>K.inputType==$.inputType))){if(Z.observer.delayAndroidKey(Y.key,Y.keyCode),Y.key=="Backspace"||Y.key=="Delete"){let K=((X=window.visualViewport)===null||X===void 0?void 0:X.height)||0;setTimeout(()=>{var Q;if((((Q=window.visualViewport)===null||Q===void 0?void 0:Q.height)||0)>K+10&&Z.hasFocus)Z.contentDOM.blur(),Z.focus()},100)}}if(B.ios&&$.inputType=="deleteContentForward")Z.observer.flushSoon();if(B.safari&&$.inputType=="insertText"&&Z.inputState.composing>=0)setTimeout(()=>x9.compositionend(Z,$),20);return!1};var s8=new Set;function sX(Z){if(!s8.has(Z))s8.add(Z),Z.addEventListener("copy",()=>{}),Z.addEventListener("cut",()=>{})}var n8=["pre-wrap","normal","pre-line","break-spaces"],K5=!1;function i8(){K5=!1}class O6{constructor(Z){this.lineWrapping=Z,this.doc=u.empty,this.heightSamples={},this.lineHeight=14,this.charWidth=7,this.textHeight=14,this.lineLength=30}heightForGap(Z,$){let J=this.doc.lineAt($).number-this.doc.lineAt(Z).number+1;if(this.lineWrapping)J+=Math.max(0,Math.ceil(($-Z-J*this.lineLength*0.5)/this.lineLength));return this.lineHeight*J}heightForLine(Z){if(!this.lineWrapping)return this.lineHeight;return(1+Math.max(0,Math.ceil((Z-this.lineLength)/Math.max(1,this.lineLength-5))))*this.lineHeight}setDoc(Z){return this.doc=Z,this}mustRefreshForWrapping(Z){return n8.indexOf(Z)>-1!=this.lineWrapping}mustRefreshForHeights(Z){let $=!1;for(let J=0;J<Z.length;J++){let X=Z[J];if(X<0)J++;else if(!this.heightSamples[Math.floor(X*10)])$=!0,this.heightSamples[Math.floor(X*10)]=!0}return $}refresh(Z,$,J,X,Y,K){let Q=n8.indexOf(Z)>-1,U=Math.abs($-this.lineHeight)>0.3||this.lineWrapping!=Q||Math.abs(J-this.charWidth)>0.1;if(this.lineWrapping=Q,this.lineHeight=$,this.charWidth=J,this.textHeight=X,this.lineLength=Y,U){this.heightSamples={};for(let q=0;q<K.length;q++){let G=K[q];if(G<0)q++;else this.heightSamples[Math.floor(G*10)]=!0}}return U}}class _6{constructor(Z,$){this.from=Z,this.heights=$,this.index=0}get more(){return this.index<this.heights.length}}class n9{constructor(Z,$,J,X,Y){this.from=Z,this.length=$,this.top=J,this.height=X,this._content=Y}get type(){return typeof this._content=="number"?W9.Text:Array.isArray(this._content)?this._content:this._content.type}get to(){return this.from+this.length}get bottom(){return this.top+this.height}get widget(){return this._content instanceof b0?this._content.widget:null}get widgetLineBreaks(){return typeof this._content=="number"?this._content:0}join(Z){let $=(Array.isArray(this._content)?this._content:[this]).concat(Array.isArray(Z._content)?Z._content:[Z]);return new n9(this.from,this.length+Z.length,this.top,this.height+Z.height,$)}}var i=function(Z){return Z[Z.ByPos=0]="ByPos",Z[Z.ByHeight=1]="ByHeight",Z[Z.ByPosNoHeight=2]="ByPosNoHeight",Z}(i||(i={})),S7=0.001;class R9{constructor(Z,$,J=2){this.length=Z,this.height=$,this.flags=J}get outdated(){return(this.flags&2)>0}set outdated(Z){this.flags=(Z?2:0)|this.flags&-3}setHeight(Z){if(this.height!=Z){if(Math.abs(this.height-Z)>S7)K5=!0;this.height=Z}}replace(Z,$,J){return R9.of(J)}decomposeLeft(Z,$){$.push(this)}decomposeRight(Z,$){$.push(this)}applyChanges(Z,$,J,X){let Y=this,K=J.doc;for(let Q=X.length-1;Q>=0;Q--){let{fromA:U,toA:q,fromB:G,toB:z}=X[Q],j=Y.lineAt(U,i.ByPosNoHeight,J.setDoc($),0,0),W=j.to>=q?j:Y.lineAt(q,i.ByPosNoHeight,J,0,0);z+=W.to-q,q=W.to;while(Q>0&&j.from<=X[Q-1].toA)if(U=X[Q-1].fromA,G=X[Q-1].fromB,Q--,U<j.from)j=Y.lineAt(U,i.ByPosNoHeight,J,0,0);G+=j.from-U,U=j.from;let O=c3.build(J.setDoc(K),Z,G,z);Y=d7(Y,Y.replace(U,q,O))}return Y.updateHeight(J,0)}static empty(){return new P9(0,0,0)}static of(Z){if(Z.length==1)return Z[0];let $=0,J=Z.length,X=0,Y=0;for(;;)if($==J)if(X>Y*2){let Q=Z[$-1];if(Q.break)Z.splice(--$,1,Q.left,null,Q.right);else Z.splice(--$,1,Q.left,Q.right);J+=1+Q.break,X-=Q.size}else if(Y>X*2){let Q=Z[J];if(Q.break)Z.splice(J,1,Q.left,null,Q.right);else Z.splice(J,1,Q.left,Q.right);J+=2+Q.break,Y-=Q.size}else break;else if(X<Y){let Q=Z[$++];if(Q)X+=Q.size}else{let Q=Z[--J];if(Q)Y+=Q.size}let K=0;if(Z[$-1]==null)K=1,$--;else if(Z[$]==null)K=1,J++;return new V6(R9.of(Z.slice(0,$)),K,R9.of(Z.slice(J)))}}function d7(Z,$){if(Z==$)return Z;if(Z.constructor!=$.constructor)K5=!0;return $}R9.prototype.size=1;var nX=y.replace({});class d3 extends R9{constructor(Z,$,J){super(Z,$);this.deco=J,this.spaceAbove=0}mainBlock(Z,$){return new n9($,this.length,Z+this.spaceAbove,this.height-this.spaceAbove,this.deco||0)}blockAt(Z,$,J,X){return this.spaceAbove&&Z<J+this.spaceAbove?new n9(X,0,J,this.spaceAbove,nX):this.mainBlock(J,X)}lineAt(Z,$,J,X,Y){let K=this.mainBlock(X,Y);return this.spaceAbove?this.blockAt(0,J,X,Y).join(K):K}forEachLine(Z,$,J,X,Y,K){if(Z<=Y+this.length&&$>=Y)K(this.lineAt(0,i.ByPos,J,X,Y))}setMeasuredHeight(Z){let $=Z.heights[Z.index++];if($<0)this.spaceAbove=-$,$=Z.heights[Z.index++];else this.spaceAbove=0;this.setHeight($)}updateHeight(Z,$=0,J=!1,X){if(X&&X.from<=$&&X.more)this.setMeasuredHeight(X);return this.outdated=!1,this}toString(){return`block(${this.length})`}}class P9 extends d3{constructor(Z,$,J){super(Z,$,null);this.collapsed=0,this.widgetHeight=0,this.breaks=0,this.spaceAbove=J}mainBlock(Z,$){return new n9($,this.length,Z+this.spaceAbove,this.height-this.spaceAbove,this.breaks)}replace(Z,$,J){let X=J[0];if(J.length==1&&(X instanceof P9||X instanceof z9&&X.flags&4)&&Math.abs(this.length-X.length)<10){if(X instanceof z9)X=new P9(X.length,this.height,this.spaceAbove);else X.height=this.height;if(!this.outdated)X.outdated=!1;return X}else return R9.of(J)}updateHeight(Z,$=0,J=!1,X){if(X&&X.from<=$&&X.more)this.setMeasuredHeight(X);else if(J||this.outdated)this.spaceAbove=0,this.setHeight(Math.max(this.widgetHeight,Z.heightForLine(this.length-this.collapsed))+this.breaks*Z.lineHeight);return this.outdated=!1,this}toString(){return`line(${this.length}${this.collapsed?-this.collapsed:""}${this.widgetHeight?":"+this.widgetHeight:""})`}}class z9 extends R9{constructor(Z){super(Z,0)}heightMetrics(Z,$){let J=Z.doc.lineAt($).number,X=Z.doc.lineAt($+this.length).number,Y=X-J+1,K,Q=0;if(Z.lineWrapping){let U=Math.min(this.height,Z.lineHeight*Y);if(K=U/Y,this.length>Y+1)Q=(this.height-U)/(this.length-Y-1)}else K=this.height/Y;return{firstLine:J,lastLine:X,perLine:K,perChar:Q}}blockAt(Z,$,J,X){let{firstLine:Y,lastLine:K,perLine:Q,perChar:U}=this.heightMetrics($,X);if($.lineWrapping){let q=X+(Z<$.lineHeight?0:Math.round(Math.max(0,Math.min(1,(Z-J)/this.height))*this.length)),G=$.doc.lineAt(q),z=Q+G.length*U,j=Math.max(J,Z-z/2);return new n9(G.from,G.length,j,z,0)}else{let q=Math.max(0,Math.min(K-Y,Math.floor((Z-J)/Q))),{from:G,length:z}=$.doc.line(Y+q);return new n9(G,z,J+Q*q,Q,0)}}lineAt(Z,$,J,X,Y){if($==i.ByHeight)return this.blockAt(Z,J,X,Y);if($==i.ByPosNoHeight){let{from:W,to:O}=J.doc.lineAt(Z);return new n9(W,O-W,0,0,0)}let{firstLine:K,perLine:Q,perChar:U}=this.heightMetrics(J,Y),q=J.doc.lineAt(Z),G=Q+q.length*U,z=q.number-K,j=X+Q*z+U*(q.from-Y-z);return new n9(q.from,q.length,Math.max(X,Math.min(j,X+this.height-G)),G,0)}forEachLine(Z,$,J,X,Y,K){Z=Math.max(Z,Y),$=Math.min($,Y+this.length);let{firstLine:Q,perLine:U,perChar:q}=this.heightMetrics(J,Y);for(let G=Z,z=X;G<=$;){let j=J.doc.lineAt(G);if(G==Z){let O=j.number-Q;z+=U*O+q*(Z-Y-O)}let W=U+q*j.length;K(new n9(j.from,j.length,z,W,0)),z+=W,G=j.to+1}}replace(Z,$,J){let X=this.length-$;if(X>0){let Y=J[J.length-1];if(Y instanceof z9)J[J.length-1]=new z9(Y.length+X);else J.push(null,new z9(X-1))}if(Z>0){let Y=J[0];if(Y instanceof z9)J[0]=new z9(Z+Y.length);else J.unshift(new z9(Z-1),null)}return R9.of(J)}decomposeLeft(Z,$){$.push(new z9(Z-1),null)}decomposeRight(Z,$){$.push(null,new z9(this.length-Z-1))}updateHeight(Z,$=0,J=!1,X){let Y=$+this.length;if(X&&X.from<=$+this.length&&X.more){let K=[],Q=Math.max($,X.from),U=-1;if(X.from>$)K.push(new z9(X.from-$-1).updateHeight(Z,$));while(Q<=Y&&X.more){let G=Z.doc.lineAt(Q).length;if(K.length)K.push(null);let z=X.heights[X.index++],j=0;if(z<0)j=-z,z=X.heights[X.index++];if(U==-1)U=z;else if(Math.abs(z-U)>=S7)U=-2;let W=new P9(G,z,j);W.outdated=!1,K.push(W),Q+=G+1}if(Q<=Y)K.push(null,new z9(Y-Q).updateHeight(Z,Q));let q=R9.of(K);if(U<0||Math.abs(q.height-this.height)>=S7||Math.abs(U-this.heightMetrics(Z,$).perLine)>=S7)K5=!0;return d7(this,q)}else if(J||this.outdated)this.setHeight(Z.heightForGap($,$+this.length)),this.outdated=!1;return this}toString(){return`gap(${this.length})`}}class V6 extends R9{constructor(Z,$,J){super(Z.length+$+J.length,Z.height+J.height,$|(Z.outdated||J.outdated?2:0));this.left=Z,this.right=J,this.size=Z.size+J.size}get break(){return this.flags&1}blockAt(Z,$,J,X){let Y=J+this.left.height;return Z<Y?this.left.blockAt(Z,$,J,X):this.right.blockAt(Z,$,Y,X+this.left.length+this.break)}lineAt(Z,$,J,X,Y){let K=X+this.left.height,Q=Y+this.left.length+this.break,U=$==i.ByHeight?Z<K:Z<Q,q=U?this.left.lineAt(Z,$,J,X,Y):this.right.lineAt(Z,$,J,K,Q);if(this.break||(U?q.to<Q:q.from>Q))return q;let G=$==i.ByPosNoHeight?i.ByPosNoHeight:i.ByPos;if(U)return q.join(this.right.lineAt(Q,G,J,K,Q));else return this.left.lineAt(Q,G,J,X,Y).join(q)}forEachLine(Z,$,J,X,Y,K){let Q=X+this.left.height,U=Y+this.left.length+this.break;if(this.break){if(Z<U)this.left.forEachLine(Z,$,J,X,Y,K);if($>=U)this.right.forEachLine(Z,$,J,Q,U,K)}else{let q=this.lineAt(U,i.ByPos,J,X,Y);if(Z<q.from)this.left.forEachLine(Z,q.from-1,J,X,Y,K);if(q.to>=Z&&q.from<=$)K(q);if($>q.to)this.right.forEachLine(q.to+1,$,J,Q,U,K)}}replace(Z,$,J){let X=this.left.length+this.break;if($<X)return this.balanced(this.left.replace(Z,$,J),this.right);if(Z>this.left.length)return this.balanced(this.left,this.right.replace(Z-X,$-X,J));let Y=[];if(Z>0)this.decomposeLeft(Z,Y);let K=Y.length;for(let Q of J)Y.push(Q);if(Z>0)a8(Y,K-1);if($<this.length){let Q=Y.length;this.decomposeRight($,Y),a8(Y,Q)}return R9.of(Y)}decomposeLeft(Z,$){let J=this.left.length;if(Z<=J)return this.left.decomposeLeft(Z,$);if($.push(this.left),this.break){if(J++,Z>=J)$.push(null)}if(Z>J)this.right.decomposeLeft(Z-J,$)}decomposeRight(Z,$){let J=this.left.length,X=J+this.break;if(Z>=X)return this.right.decomposeRight(Z-X,$);if(Z<J)this.left.decomposeRight(Z,$);if(this.break&&Z<X)$.push(null);$.push(this.right)}balanced(Z,$){if(Z.size>2*$.size||$.size>2*Z.size)return R9.of(this.break?[Z,null,$]:[Z,$]);return this.left=d7(this.left,Z),this.right=d7(this.right,$),this.setHeight(Z.height+$.height),this.outdated=Z.outdated||$.outdated,this.size=Z.size+$.size,this.length=Z.length+this.break+$.length,this}updateHeight(Z,$=0,J=!1,X){let{left:Y,right:K}=this,Q=$+Y.length+this.break,U=null;if(X&&X.from<=$+Y.length&&X.more)U=Y=Y.updateHeight(Z,$,J,X);else Y.updateHeight(Z,$,J);if(X&&X.from<=Q+K.length&&X.more)U=K=K.updateHeight(Z,Q,J,X);else K.updateHeight(Z,Q,J);if(U)return this.balanced(Y,K);return this.height=this.left.height+this.right.height,this.outdated=!1,this}toString(){return this.left+(this.break?" ":"-")+this.right}}function a8(Z,$){let J,X;if(Z[$]==null&&(J=Z[$-1])instanceof z9&&(X=Z[$+1])instanceof z9)Z.splice($-1,3,new z9(J.length+1+X.length))}var iX=5;class c3{constructor(Z,$){this.pos=Z,this.oracle=$,this.nodes=[],this.lineStart=-1,this.lineEnd=-1,this.covering=null,this.writtenTo=Z}get isCovered(){return this.covering&&this.nodes[this.nodes.length-1]==this.covering}span(Z,$){if(this.lineStart>-1){let J=Math.min($,this.lineEnd),X=this.nodes[this.nodes.length-1];if(X instanceof P9)X.length+=J-this.pos;else if(J>this.pos||!this.isCovered)this.nodes.push(new P9(J-this.pos,-1,0));if(this.writtenTo=J,$>J)this.nodes.push(null),this.writtenTo++,this.lineStart=-1}this.pos=$}point(Z,$,J){if(Z<$||J.heightRelevant){let X=J.widget?J.widget.estimatedHeight:0,Y=J.widget?J.widget.lineBreaks:0;if(X<0)X=this.oracle.lineHeight;let K=$-Z;if(J.block)this.addBlock(new d3(K,X,J));else if(K||Y||X>=iX)this.addLineDeco(X,Y,K)}else if($>Z)this.span(Z,$);if(this.lineEnd>-1&&this.lineEnd<this.pos)this.lineEnd=this.oracle.doc.lineAt(this.pos).to}enterLine(){if(this.lineStart>-1)return;let{from:Z,to:$}=this.oracle.doc.lineAt(this.pos);if(this.lineStart=Z,this.lineEnd=$,this.writtenTo<Z){if(this.writtenTo<Z-1||this.nodes[this.nodes.length-1]==null)this.nodes.push(this.blankContent(this.writtenTo,Z-1));this.nodes.push(null)}if(this.pos>Z)this.nodes.push(new P9(this.pos-Z,-1,0));this.writtenTo=this.pos}blankContent(Z,$){let J=new z9($-Z);if(this.oracle.doc.lineAt(Z).to==$)J.flags|=4;return J}ensureLine(){this.enterLine();let Z=this.nodes.length?this.nodes[this.nodes.length-1]:null;if(Z instanceof P9)return Z;let $=new P9(0,-1,0);return this.nodes.push($),$}addBlock(Z){this.enterLine();let $=Z.deco;if($&&$.startSide>0&&!this.isCovered)this.ensureLine();if(this.nodes.push(Z),this.writtenTo=this.pos=this.pos+Z.length,$&&$.endSide>0)this.covering=Z}addLineDeco(Z,$,J){let X=this.ensureLine();X.length+=J,X.collapsed+=J,X.widgetHeight=Math.max(X.widgetHeight,Z),X.breaks+=$,this.writtenTo=this.pos=this.pos+J}finish(Z){let $=this.nodes.length==0?null:this.nodes[this.nodes.length-1];if(this.lineStart>-1&&!($ instanceof P9)&&!this.isCovered)this.nodes.push(new P9(0,-1,0));else if(this.writtenTo<this.pos||$==null)this.nodes.push(this.blankContent(this.writtenTo,this.pos));let J=Z;for(let X of this.nodes){if(X instanceof P9)X.updateHeight(this.oracle,J);J+=X?X.length:1}return this.nodes}static build(Z,$,J,X){let Y=new c3(J,Z);return b.spans($,J,X,Y,0),Y.finish(J)}}function aX(Z,$,J){let X=new H6;return b.compare(Z,$,J,X,0),X.changes}class H6{constructor(){this.changes=[]}compareRange(){}comparePoint(Z,$,J,X){if(Z<$||J&&J.heightRelevant||X&&X.heightRelevant)$5(Z,$,this.changes,5)}}function rX(Z,$){let J=Z.getBoundingClientRect(),X=Z.ownerDocument,Y=X.defaultView||window,K=Math.max(0,J.left),Q=Math.min(Y.innerWidth,J.right),U=Math.max(0,J.top),q=Math.min(Y.innerHeight,J.bottom);for(let G=Z.parentNode;G&&G!=X.body;)if(G.nodeType==1){let z=G,j=window.getComputedStyle(z);if((z.scrollHeight>z.clientHeight||z.scrollWidth>z.clientWidth)&&j.overflow!="visible"){let W=z.getBoundingClientRect();K=Math.max(K,W.left),Q=Math.min(Q,W.right),U=Math.max(U,W.top),q=Math.min(G==Z.parentNode?Y.innerHeight:q,W.bottom)}G=j.position=="absolute"||j.position=="fixed"?z.offsetParent:z.parentNode}else if(G.nodeType==11)G=G.host;else break;return{left:K-J.left,right:Math.max(K,Q)-J.left,top:U-(J.top+$),bottom:Math.max(U,q)-(J.top+$)}}function oX(Z){let $=Z.getBoundingClientRect(),J=Z.ownerDocument.defaultView||window;return $.left<J.innerWidth&&$.right>0&&$.top<J.innerHeight&&$.bottom>0}function tX(Z,$){let J=Z.getBoundingClientRect();return{left:0,right:J.right-J.left,top:$,bottom:J.bottom-(J.top+$)}}class b7{constructor(Z,$,J,X){this.from=Z,this.to=$,this.size=J,this.displaySize=X}static same(Z,$){if(Z.length!=$.length)return!1;for(let J=0;J<Z.length;J++){let X=Z[J],Y=$[J];if(X.from!=Y.from||X.to!=Y.to||X.size!=Y.size)return!1}return!0}draw(Z,$){return y.replace({widget:new N6(this.displaySize*($?Z.scaleY:Z.scaleX),$)}).range(this.from,this.to)}}class N6 extends C9{constructor(Z,$){super();this.size=Z,this.vertical=$}eq(Z){return Z.size==this.size&&Z.vertical==this.vertical}toDOM(){let Z=document.createElement("div");if(this.vertical)Z.style.height=this.size+"px";else Z.style.width=this.size+"px",Z.style.height="2px",Z.style.display="inline-block";return Z}get estimatedHeight(){return this.vertical?this.size:-1}}class E3{constructor(Z){this.state=Z,this.pixelViewport={left:0,right:window.innerWidth,top:0,bottom:0},this.inView=!0,this.paddingTop=0,this.paddingBottom=0,this.contentDOMWidth=0,this.contentDOMHeight=0,this.editorHeight=0,this.editorWidth=0,this.scrollTop=0,this.scrolledToBottom=!1,this.scaleX=1,this.scaleY=1,this.scrollAnchorPos=0,this.scrollAnchorHeight=-1,this.scaler=r8,this.scrollTarget=null,this.printing=!1,this.mustMeasureContent=!0,this.defaultTextDirection=p.LTR,this.visibleRanges=[],this.mustEnforceCursorAssoc=!1;let $=Z.facet(f3).some((J)=>typeof J!="function"&&J.class=="cm-lineWrapping");this.heightOracle=new O6($),this.stateDeco=o8(Z),this.heightMap=R9.empty().applyChanges(this.stateDeco,u.empty,this.heightOracle.setDoc(Z.doc),[new b9(0,0,0,Z.doc.length)]);for(let J=0;J<2;J++)if(this.viewport=this.getViewport(0,null),!this.updateForViewport())break;this.updateViewportLines(),this.lineGaps=this.ensureLineGaps([]),this.lineGapDeco=y.set(this.lineGaps.map((J)=>J.draw(this,!1))),this.computeVisibleRanges()}updateForViewport(){let Z=[this.viewport],{main:$}=this.state.selection;for(let J=0;J<=1;J++){let X=J?$.head:$.anchor;if(!Z.some(({from:Y,to:K})=>X>=Y&&X<=K)){let{from:Y,to:K}=this.lineBlockAt(X);Z.push(new y5(Y,K))}}return this.viewports=Z.sort((J,X)=>J.from-X.from),this.updateScaler()}updateScaler(){let Z=this.scaler;return this.scaler=this.heightMap.height<=7000000?r8:new s3(this.heightOracle,this.heightMap,this.viewports),Z.eq(this.scaler)?0:2}updateViewportLines(){this.viewportLines=[],this.heightMap.forEachLine(this.viewport.from,this.viewport.to,this.heightOracle.setDoc(this.state.doc),0,0,(Z)=>{this.viewportLines.push(k5(Z,this.scaler))})}update(Z,$=null){this.state=Z.state;let J=this.stateDeco;this.stateDeco=o8(this.state);let X=Z.changedRanges,Y=b9.extendWithRanges(X,aX(J,this.stateDeco,Z?Z.changes:J9.empty(this.state.doc.length))),K=this.heightMap.height,Q=this.scrolledToBottom?null:this.scrollAnchorAt(this.scrollTop);if(i8(),this.heightMap=this.heightMap.applyChanges(this.stateDeco,Z.startState.doc,this.heightOracle.setDoc(this.state.doc),Y),this.heightMap.height!=K||K5)Z.flags|=2;if(Q)this.scrollAnchorPos=Z.changes.mapPos(Q.from,-1),this.scrollAnchorHeight=Q.top;else this.scrollAnchorPos=-1,this.scrollAnchorHeight=K;let U=Y.length?this.mapViewport(this.viewport,Z.changes):this.viewport;if($&&($.range.head<U.from||$.range.head>U.to)||!this.viewportIsAppropriate(U))U=this.getViewport(0,$);let q=U.from!=this.viewport.from||U.to!=this.viewport.to;if(this.viewport=U,Z.flags|=this.updateForViewport(),q||!Z.changes.empty||Z.flags&2)this.updateViewportLines();if(this.lineGaps.length||this.viewport.to-this.viewport.from>4000)this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps,Z.changes)));if(Z.flags|=this.computeVisibleRanges(Z.changes),$)this.scrollTarget=$;if(!this.mustEnforceCursorAssoc&&(Z.selectionSet||Z.focusChanged)&&Z.view.lineWrapping&&Z.state.selection.main.empty&&Z.state.selection.main.assoc&&!Z.state.facet(x1))this.mustEnforceCursorAssoc=!0}measure(Z){let $=Z.contentDOM,J=window.getComputedStyle($),X=this.heightOracle,Y=J.whiteSpace;this.defaultTextDirection=J.direction=="rtl"?p.RTL:p.LTR;let K=this.heightOracle.mustRefreshForWrapping(Y)||this.mustMeasureContent==="refresh",Q=$.getBoundingClientRect(),U=K||this.mustMeasureContent||this.contentDOMHeight!=Q.height;this.contentDOMHeight=Q.height,this.mustMeasureContent=!1;let q=0,G=0;if(Q.width&&Q.height){let{scaleX:F,scaleY:C}=H1($,Q);if(F>0.005&&Math.abs(this.scaleX-F)>0.005||C>0.005&&Math.abs(this.scaleY-C)>0.005)this.scaleX=F,this.scaleY=C,q|=16,K=U=!0}let z=(parseInt(J.paddingTop)||0)*this.scaleY,j=(parseInt(J.paddingBottom)||0)*this.scaleY;if(this.paddingTop!=z||this.paddingBottom!=j)this.paddingTop=z,this.paddingBottom=j,q|=18;if(this.editorWidth!=Z.scrollDOM.clientWidth){if(X.lineWrapping)U=!0;this.editorWidth=Z.scrollDOM.clientWidth,q|=16}let W=Z.scrollDOM.scrollTop*this.scaleY;if(this.scrollTop!=W)this.scrollAnchorHeight=-1,this.scrollTop=W;this.scrolledToBottom=I1(Z.scrollDOM);let O=(this.printing?tX:rX)($,this.paddingTop),_=O.top-this.pixelViewport.top,V=O.bottom-this.pixelViewport.bottom;this.pixelViewport=O;let H=this.pixelViewport.bottom>this.pixelViewport.top&&this.pixelViewport.right>this.pixelViewport.left;if(H!=this.inView){if(this.inView=H,H)U=!0}if(!this.inView&&!this.scrollTarget&&!oX(Z.dom))return 0;let I=Q.width;if(this.contentDOMWidth!=I||this.editorHeight!=Z.scrollDOM.clientHeight)this.contentDOMWidth=Q.width,this.editorHeight=Z.scrollDOM.clientHeight,q|=16;if(U){let F=Z.docView.measureVisibleLineHeights(this.viewport);if(X.mustRefreshForHeights(F))K=!0;if(K||X.lineWrapping&&Math.abs(I-this.contentDOMWidth)>X.charWidth){let{lineHeight:C,charWidth:M,textHeight:T}=Z.docView.measureTextSize();if(K=C>0&&X.refresh(Y,C,M,T,Math.max(5,I/M),F),K)Z.docView.minWidth=0,q|=16}if(_>0&&V>0)G=Math.max(_,V);else if(_<0&&V<0)G=Math.min(_,V);i8();for(let C of this.viewports){let M=C.from==this.viewport.from?F:Z.docView.measureVisibleLineHeights(C);this.heightMap=(K?R9.empty().applyChanges(this.stateDeco,u.empty,this.heightOracle,[new b9(0,0,0,Z.state.doc.length)]):this.heightMap).updateHeight(X,0,K,new _6(C.from,M))}if(K5)q|=2}let D=!this.viewportIsAppropriate(this.viewport,G)||this.scrollTarget&&(this.scrollTarget.range.head<this.viewport.from||this.scrollTarget.range.head>this.viewport.to);if(D){if(q&2)q|=this.updateScaler();this.viewport=this.getViewport(G,this.scrollTarget),q|=this.updateForViewport()}if(q&2||D)this.updateViewportLines();if(this.lineGaps.length||this.viewport.to-this.viewport.from>4000)this.updateLineGaps(this.ensureLineGaps(K?[]:this.lineGaps,Z));if(q|=this.computeVisibleRanges(),this.mustEnforceCursorAssoc)this.mustEnforceCursorAssoc=!1,Z.docView.enforceCursorAssoc();return q}get visibleTop(){return this.scaler.fromDOM(this.pixelViewport.top)}get visibleBottom(){return this.scaler.fromDOM(this.pixelViewport.bottom)}getViewport(Z,$){let J=0.5-Math.max(-0.5,Math.min(0.5,Z/1000/2)),X=this.heightMap,Y=this.heightOracle,{visibleTop:K,visibleBottom:Q}=this,U=new y5(X.lineAt(K-J*1000,i.ByHeight,Y,0,0).from,X.lineAt(Q+(1-J)*1000,i.ByHeight,Y,0,0).to);if($){let{head:q}=$.range;if(q<U.from||q>U.to){let G=Math.min(this.editorHeight,this.pixelViewport.bottom-this.pixelViewport.top),z=X.lineAt(q,i.ByPos,Y,0,0),j;if($.y=="center")j=(z.top+z.bottom)/2-G/2;else if($.y=="start"||$.y=="nearest"&&q<U.from)j=z.top;else j=z.bottom-G;U=new y5(X.lineAt(j-500,i.ByHeight,Y,0,0).from,X.lineAt(j+G+500,i.ByHeight,Y,0,0).to)}}return U}mapViewport(Z,$){let J=$.mapPos(Z.from,-1),X=$.mapPos(Z.to,1);return new y5(this.heightMap.lineAt(J,i.ByPos,this.heightOracle,0,0).from,this.heightMap.lineAt(X,i.ByPos,this.heightOracle,0,0).to)}viewportIsAppropriate({from:Z,to:$},J=0){if(!this.inView)return!0;let{top:X}=this.heightMap.lineAt(Z,i.ByPos,this.heightOracle,0,0),{bottom:Y}=this.heightMap.lineAt($,i.ByPos,this.heightOracle,0,0),{visibleTop:K,visibleBottom:Q}=this;return(Z==0||X<=K-Math.max(10,Math.min(-J,250)))&&($==this.state.doc.length||Y>=Q+Math.max(10,Math.min(J,250)))&&(X>K-2000&&Y<Q+2000)}mapLineGaps(Z,$){if(!Z.length||$.empty)return Z;let J=[];for(let X of Z)if(!$.touchesRange(X.from,X.to))J.push(new b7($.mapPos(X.from),$.mapPos(X.to),X.size,X.displaySize));return J}ensureLineGaps(Z,$){let J=this.heightOracle.lineWrapping,X=J?1e4:2000,Y=X>>1,K=X<<1;if(this.defaultTextDirection!=p.LTR&&!J)return[];let Q=[],U=(G,z,j,W)=>{if(z-G<Y)return;let O=this.state.selection.main,_=[O.from];if(!O.empty)_.push(O.to);for(let H of _)if(H>G&&H<z){U(G,H-10,j,W),U(H+10,z,j,W);return}let V=ZY(Z,(H)=>H.from>=j.from&&H.to<=j.to&&Math.abs(H.from-G)<Y&&Math.abs(H.to-z)<Y&&!_.some((I)=>H.from<I&&H.to>I));if(!V){if(z<j.to&&$&&J&&$.visibleRanges.some((D)=>D.from<=z&&D.to>=z)){let D=$.moveToLineBoundary(R.cursor(z),!1,!0).head;if(D>G)z=D}let H=this.gapSize(j,G,z,W),I=J||H<2000000?H:2000000;V=new b7(G,z,H,I)}Q.push(V)},q=(G)=>{if(G.length<K||G.type!=W9.Text)return;let z=eX(G.from,G.to,this.stateDeco);if(z.total<K)return;let j=this.scrollTarget?this.scrollTarget.range.head:null,W,O;if(J){let _=X/this.heightOracle.lineLength*this.heightOracle.lineHeight,V,H;if(j!=null){let I=M7(z,j),D=((this.visibleBottom-this.visibleTop)/2+_)/G.height;V=I-D,H=I+D}else V=(this.visibleTop-G.top-_)/G.height,H=(this.visibleBottom-G.top+_)/G.height;W=L7(z,V),O=L7(z,H)}else{let _=z.total*this.heightOracle.charWidth,V=X*this.heightOracle.charWidth,H=0;if(_>2000000){for(let M of Z)if(M.from>=G.from&&M.from<G.to&&M.size!=M.displaySize&&M.from*this.heightOracle.charWidth+H<this.pixelViewport.left)H=M.size-M.displaySize}let I=this.pixelViewport.left+H,D=this.pixelViewport.right+H,F,C;if(j!=null){let M=M7(z,j),T=((D-I)/2+V)/_;F=M-T,C=M+T}else F=(I-V)/_,C=(D+V)/_;W=L7(z,F),O=L7(z,C)}if(W>G.from)U(G.from,W,G,z);if(O<G.to)U(O,G.to,G,z)};for(let G of this.viewportLines)if(Array.isArray(G.type))G.type.forEach(q);else q(G);return Q}gapSize(Z,$,J,X){let Y=M7(X,J)-M7(X,$);if(this.heightOracle.lineWrapping)return Z.height*Y;else return X.total*this.heightOracle.charWidth*Y}updateLineGaps(Z){if(!b7.same(Z,this.lineGaps))this.lineGaps=Z,this.lineGapDeco=y.set(Z.map(($)=>$.draw(this,this.heightOracle.lineWrapping)))}computeVisibleRanges(Z){let $=this.stateDeco;if(this.lineGaps.length)$=$.concat(this.lineGapDeco);let J=[];b.spans($,this.viewport.from,this.viewport.to,{span(Y,K){J.push({from:Y,to:K})},point(){}},20);let X=0;if(J.length!=this.visibleRanges.length)X=12;else for(let Y=0;Y<J.length&&!(X&8);Y++){let K=this.visibleRanges[Y],Q=J[Y];if(K.from!=Q.from||K.to!=Q.to){if(X|=4,!(Z&&Z.mapPos(K.from,-1)==Q.from&&Z.mapPos(K.to,1)==Q.to))X|=8}}return this.visibleRanges=J,X}lineBlockAt(Z){return Z>=this.viewport.from&&Z<=this.viewport.to&&this.viewportLines.find(($)=>$.from<=Z&&$.to>=Z)||k5(this.heightMap.lineAt(Z,i.ByPos,this.heightOracle,0,0),this.scaler)}lineBlockAtHeight(Z){return Z>=this.viewportLines[0].top&&Z<=this.viewportLines[this.viewportLines.length-1].bottom&&this.viewportLines.find(($)=>$.top<=Z&&$.bottom>=Z)||k5(this.heightMap.lineAt(this.scaler.fromDOM(Z),i.ByHeight,this.heightOracle,0,0),this.scaler)}scrollAnchorAt(Z){let $=this.lineBlockAtHeight(Z+8);return $.from>=this.viewport.from||this.viewportLines[0].top-Z>200?$:this.viewportLines[0]}elementAtHeight(Z){return k5(this.heightMap.blockAt(this.scaler.fromDOM(Z),this.heightOracle,0,0),this.scaler)}get docHeight(){return this.scaler.toDOM(this.heightMap.height)}get contentHeight(){return this.docHeight+this.paddingTop+this.paddingBottom}}class y5{constructor(Z,$){this.from=Z,this.to=$}}function eX(Z,$,J){let X=[],Y=Z,K=0;if(b.spans(J,Z,$,{span(){},point(Q,U){if(Q>Y)X.push({from:Y,to:Q}),K+=Q-Y;Y=U}},20),Y<$)X.push({from:Y,to:$}),K+=$-Y;return{total:K,ranges:X}}function L7({total:Z,ranges:$},J){if(J<=0)return $[0].from;if(J>=1)return $[$.length-1].to;let X=Math.floor(Z*J);for(let Y=0;;Y++){let{from:K,to:Q}=$[Y],U=Q-K;if(X<=U)return K+X;X-=U}}function M7(Z,$){let J=0;for(let{from:X,to:Y}of Z.ranges){if($<=Y){J+=$-X;break}J+=Y-X}return J/Z.total}function ZY(Z,$){for(let J of Z)if($(J))return J;return}var r8={toDOM(Z){return Z},fromDOM(Z){return Z},scale:1,eq(Z){return Z==this}};function o8(Z){let $=Z.facet(i7).filter((X)=>typeof X!="function"),J=Z.facet(g3).filter((X)=>typeof X!="function");if(J.length)$.push(b.join(J));return $}class s3{constructor(Z,$,J){let X=0,Y=0,K=0;this.viewports=J.map(({from:Q,to:U})=>{let q=$.lineAt(Q,i.ByPos,Z,0,0).top,G=$.lineAt(U,i.ByPos,Z,0,0).bottom;return X+=G-q,{from:Q,to:U,top:q,bottom:G,domTop:0,domBottom:0}}),this.scale=(7000000-X)/($.height-X);for(let Q of this.viewports)Q.domTop=K+(Q.top-Y)*this.scale,K=Q.domBottom=Q.domTop+(Q.bottom-Q.top),Y=Q.bottom}toDOM(Z){for(let $=0,J=0,X=0;;$++){let Y=$<this.viewports.length?this.viewports[$]:null;if(!Y||Z<Y.top)return X+(Z-J)*this.scale;if(Z<=Y.bottom)return Y.domTop+(Z-Y.top);J=Y.bottom,X=Y.domBottom}}fromDOM(Z){for(let $=0,J=0,X=0;;$++){let Y=$<this.viewports.length?this.viewports[$]:null;if(!Y||Z<Y.domTop)return J+(Z-X)/this.scale;if(Z<=Y.domBottom)return Y.top+(Z-Y.domTop);J=Y.bottom,X=Y.domBottom}}eq(Z){if(!(Z instanceof s3))return!1;return this.scale==Z.scale&&this.viewports.length==Z.viewports.length&&this.viewports.every(($,J)=>$.from==Z.viewports[J].from&&$.to==Z.viewports[J].to)}}function k5(Z,$){if($.scale==1)return Z;let J=$.toDOM(Z.top),X=$.toDOM(Z.bottom);return new n9(Z.from,Z.length,J,X-J,Array.isArray(Z._content)?Z._content.map((Y)=>k5(Y,$)):Z._content)}var E7=L.define({combine:(Z)=>Z.join(" ")}),B3=L.define({combine:(Z)=>Z.indexOf(!0)>-1}),P3=c9.newName(),R6=c9.newName(),I6=c9.newName(),D6={"&light":"."+R6,"&dark":"."+I6};function C3(Z,$,J){return new c9($,{finish(X){return/&/.test(X)?X.replace(/&\w*/,(Y)=>{if(Y=="&")return Z;if(!J||!J[Y])throw RangeError(`Unsupported selector: ${Y}`);return J[Y]}):Z+" "+X}})}var $Y=C3("."+P3,{"&":{position:"relative !important",boxSizing:"border-box","&.cm-focused":{outline:"1px dotted #212121"},display:"flex !important",flexDirection:"column"},".cm-scroller":{display:"flex !important",alignItems:"flex-start !important",fontFamily:"monospace",lineHeight:1.4,height:"100%",overflowX:"auto",position:"relative",zIndex:0,overflowAnchor:"none"},".cm-content":{margin:0,flexGrow:2,flexShrink:0,display:"block",whiteSpace:"pre",wordWrap:"normal",boxSizing:"border-box",minHeight:"100%",padding:"4px 0",outline:"none","&[contenteditable=true]":{WebkitUserModify:"read-write-plaintext-only"}},".cm-lineWrapping":{whiteSpace_fallback:"pre-wrap",whiteSpace:"break-spaces",wordBreak:"break-word",overflowWrap:"anywhere",flexShrink:1},"&light .cm-content":{caretColor:"black"},"&dark .cm-content":{caretColor:"white"},".cm-line":{display:"block",padding:"0 2px 0 6px"},".cm-layer":{position:"absolute",left:0,top:0,contain:"size style","& > *":{position:"absolute"}},"&light .cm-selectionBackground":{background:"#d9d9d9"},"&dark .cm-selectionBackground":{background:"#222"},"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground":{background:"#d7d4f0"},"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground":{background:"#233"},".cm-cursorLayer":{pointerEvents:"none"},"&.cm-focused > .cm-scroller > .cm-cursorLayer":{animation:"steps(1) cm-blink 1.2s infinite"},"@keyframes cm-blink":{"0%":{},"50%":{opacity:0},"100%":{}},"@keyframes cm-blink2":{"0%":{},"50%":{opacity:0},"100%":{}},".cm-cursor, .cm-dropCursor":{borderLeft:"1.2px solid black",marginLeft:"-0.6px",pointerEvents:"none"},".cm-cursor":{display:"none"},"&dark .cm-cursor":{borderLeftColor:"#ddd"},".cm-dropCursor":{position:"absolute"},"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor":{display:"block"},".cm-iso":{unicodeBidi:"isolate"},".cm-announced":{position:"fixed",top:"-10000px"},"@media print":{".cm-announced":{display:"none"}},"&light .cm-activeLine":{backgroundColor:"#cceeff44"},"&dark .cm-activeLine":{backgroundColor:"#99eeff33"},"&light .cm-specialChar":{color:"red"},"&dark .cm-specialChar":{color:"#f78"},".cm-gutters":{flexShrink:0,display:"flex",height:"100%",boxSizing:"border-box",zIndex:200},".cm-gutters-before":{insetInlineStart:0},".cm-gutters-after":{insetInlineEnd:0},"&light .cm-gutters":{backgroundColor:"#f5f5f5",color:"#6c6c6c",border:"0px solid #ddd","&.cm-gutters-before":{borderRightWidth:"1px"},"&.cm-gutters-after":{borderLeftWidth:"1px"}},"&dark .cm-gutters":{backgroundColor:"#333338",color:"#ccc"},".cm-gutter":{display:"flex !important",flexDirection:"column",flexShrink:0,boxSizing:"border-box",minHeight:"100%",overflow:"hidden"},".cm-gutterElement":{boxSizing:"border-box"},".cm-lineNumbers .cm-gutterElement":{padding:"0 3px 0 5px",minWidth:"20px",textAlign:"right",whiteSpace:"nowrap"},"&light .cm-activeLineGutter":{backgroundColor:"#e2f2ff"},"&dark .cm-activeLineGutter":{backgroundColor:"#222227"},".cm-panels":{boxSizing:"border-box",position:"sticky",left:0,right:0,zIndex:300},"&light .cm-panels":{backgroundColor:"#f5f5f5",color:"black"},"&light .cm-panels-top":{borderBottom:"1px solid #ddd"},"&light .cm-panels-bottom":{borderTop:"1px solid #ddd"},"&dark .cm-panels":{backgroundColor:"#333338",color:"white"},".cm-dialog":{padding:"2px 19px 4px 6px",position:"relative","& label":{fontSize:"80%"}},".cm-dialog-close":{position:"absolute",top:"3px",right:"4px",backgroundColor:"inherit",border:"none",font:"inherit",fontSize:"14px",padding:"0"},".cm-tab":{display:"inline-block",overflow:"hidden",verticalAlign:"bottom"},".cm-widgetBuffer":{verticalAlign:"text-top",height:"1em",width:0,display:"inline"},".cm-placeholder":{color:"#888",display:"inline-block",verticalAlign:"top",userSelect:"none"},".cm-highlightSpace":{backgroundImage:"radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",backgroundPosition:"center"},".cm-highlightTab":{backgroundImage:`url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,backgroundSize:"auto 100%",backgroundPosition:"right 90%",backgroundRepeat:"no-repeat"},".cm-trailingSpace":{backgroundColor:"#ff332255"},".cm-button":{verticalAlign:"middle",color:"inherit",fontSize:"70%",padding:".2em 1em",borderRadius:"1px"},"&light .cm-button":{backgroundImage:"linear-gradient(#eff1f5, #d9d9df)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#b4b4b4, #d0d3d6)"}},"&dark .cm-button":{backgroundImage:"linear-gradient(#393939, #111)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#111, #333)"}},".cm-textfield":{verticalAlign:"middle",color:"inherit",fontSize:"70%",border:"1px solid silver",padding:".2em .5em"},"&light .cm-textfield":{backgroundColor:"white"},"&dark .cm-textfield":{border:"1px solid #555",backgroundColor:"inherit"}},D6),JY={childList:!0,characterData:!0,subtree:!0,attributes:!0,characterDataOldValue:!0},K3=B.ie&&B.ie_version<=11;class F6{constructor(Z){if(this.view=Z,this.active=!1,this.editContext=null,this.selectionRange=new N1,this.selectionChanged=!1,this.delayedFlush=-1,this.resizeTimeout=-1,this.queue=[],this.delayedAndroidKey=null,this.flushingAndroidKey=-1,this.lastChange=0,this.scrollTargets=[],this.intersection=null,this.resizeScroll=null,this.intersecting=!1,this.gapIntersection=null,this.gaps=[],this.printQuery=null,this.parentCheck=-1,this.dom=Z.contentDOM,this.observer=new MutationObserver(($)=>{for(let J of $)this.queue.push(J);if((B.ie&&B.ie_version<=11||B.ios&&Z.composing)&&$.some((J)=>J.type=="childList"&&J.removedNodes.length||J.type=="characterData"&&J.oldValue.length>J.target.nodeValue.length))this.flushSoon();else this.flush()}),window.EditContext&&B.android&&Z.constructor.EDIT_CONTEXT!==!1&&!(B.chrome&&B.chrome_version<126)){if(this.editContext=new A6(Z),Z.state.facet(j0))Z.contentDOM.editContext=this.editContext.editContext}if(K3)this.onCharData=($)=>{this.queue.push({target:$.target,type:"characterData",oldValue:$.prevValue}),this.flushSoon()};if(this.onSelectionChange=this.onSelectionChange.bind(this),this.onResize=this.onResize.bind(this),this.onPrint=this.onPrint.bind(this),this.onScroll=this.onScroll.bind(this),window.matchMedia)this.printQuery=window.matchMedia("print");if(typeof ResizeObserver=="function")this.resizeScroll=new ResizeObserver(()=>{var $;if((($=this.view.docView)===null||$===void 0?void 0:$.lastUpdate)<Date.now()-75)this.onResize()}),this.resizeScroll.observe(Z.scrollDOM);if(this.addWindowListeners(this.win=Z.win),this.start(),typeof IntersectionObserver=="function")this.intersection=new IntersectionObserver(($)=>{if(this.parentCheck<0)this.parentCheck=setTimeout(this.listenForScroll.bind(this),1000);if($.length>0&&$[$.length-1].intersectionRatio>0!=this.intersecting){if(this.intersecting=!this.intersecting,this.intersecting!=this.view.inView)this.onScrollChanged(document.createEvent("Event"))}},{threshold:[0,0.001]}),this.intersection.observe(this.dom),this.gapIntersection=new IntersectionObserver(($)=>{if($.length>0&&$[$.length-1].intersectionRatio>0)this.onScrollChanged(document.createEvent("Event"))},{});this.listenForScroll(),this.readSelectionRange()}onScrollChanged(Z){if(this.view.inputState.runHandlers("scroll",Z),this.intersecting)this.view.measure()}onScroll(Z){if(this.intersecting)this.flush(!1);if(this.editContext)this.view.requestMeasure(this.editContext.measureReq);this.onScrollChanged(Z)}onResize(){if(this.resizeTimeout<0)this.resizeTimeout=setTimeout(()=>{this.resizeTimeout=-1,this.view.requestMeasure()},50)}onPrint(Z){if((Z.type=="change"||!Z.type)&&!Z.matches)return;this.view.viewState.printing=!0,this.view.measure(),setTimeout(()=>{this.view.viewState.printing=!1,this.view.requestMeasure()},500)}updateGaps(Z){if(this.gapIntersection&&(Z.length!=this.gaps.length||this.gaps.some(($,J)=>$!=Z[J]))){this.gapIntersection.disconnect();for(let $ of Z)this.gapIntersection.observe($);this.gaps=Z}}onSelectionChange(Z){let $=this.selectionChanged;if(!this.readSelectionRange()||this.delayedAndroidKey)return;let{view:J}=this,X=this.selectionRange;if(J.state.facet(j0)?J.root.activeElement!=this.dom:!x5(this.dom,X))return;let Y=X.anchorNode&&J.docView.tile.nearest(X.anchorNode);if(Y&&Y.isWidget()&&Y.widget.ignoreEvent(Z)){if(!$)this.selectionChanged=!1;return}if((B.ie&&B.ie_version<=11||B.android&&B.chrome)&&!J.state.selection.main.empty&&X.focusNode&&w5(X.focusNode,X.focusOffset,X.anchorNode,X.anchorOffset))this.flushSoon();else this.flush(!1)}readSelectionRange(){let{view:Z}=this,$=u5(Z.root);if(!$)return!1;let J=B.safari&&Z.root.nodeType==11&&Z.root.activeElement==this.dom&&XY(this.view,$)||$;if(!J||this.selectionRange.eq(J))return!1;let X=x5(this.dom,J);if(X&&!this.selectionChanged&&Z.inputState.lastFocusTime>Date.now()-200&&Z.inputState.lastTouchTime<Date.now()-300&&t2(this.dom,J))return this.view.inputState.lastFocusTime=0,Z.docView.updateSelection(),!1;if(this.selectionRange.setRange(J),X)this.selectionChanged=!0;return!0}setSelectionRange(Z,$){this.selectionRange.set(Z.node,Z.offset,$.node,$.offset),this.selectionChanged=!1}clearSelectionRange(){this.selectionRange.set(null,0,null,0)}listenForScroll(){this.parentCheck=-1;let Z=0,$=null;for(let J=this.dom;J;)if(J.nodeType==1){if(!$&&Z<this.scrollTargets.length&&this.scrollTargets[Z]==J)Z++;else if(!$)$=this.scrollTargets.slice(0,Z);if($)$.push(J);J=J.assignedSlot||J.parentNode}else if(J.nodeType==11)J=J.host;else break;if(Z<this.scrollTargets.length&&!$)$=this.scrollTargets.slice(0,Z);if($){for(let J of this.scrollTargets)J.removeEventListener("scroll",this.onScroll);for(let J of this.scrollTargets=$)J.addEventListener("scroll",this.onScroll)}}ignore(Z){if(!this.active)return Z();try{return this.stop(),Z()}finally{this.start(),this.clear()}}start(){if(this.active)return;if(this.observer.observe(this.dom,JY),K3)this.dom.addEventListener("DOMCharacterDataModified",this.onCharData);this.active=!0}stop(){if(!this.active)return;if(this.active=!1,this.observer.disconnect(),K3)this.dom.removeEventListener("DOMCharacterDataModified",this.onCharData)}clear(){this.processRecords(),this.queue.length=0,this.selectionChanged=!1}delayAndroidKey(Z,$){var J;if(!this.delayedAndroidKey){let X=()=>{let Y=this.delayedAndroidKey;if(Y){if(this.clearDelayedAndroidKey(),this.view.inputState.lastKeyCode=Y.keyCode,this.view.inputState.lastKeyTime=Date.now(),!this.flush()&&Y.force)J5(this.dom,Y.key,Y.keyCode)}};this.flushingAndroidKey=this.view.win.requestAnimationFrame(X)}if(!this.delayedAndroidKey||Z=="Enter")this.delayedAndroidKey={key:Z,keyCode:$,force:this.lastChange<Date.now()-50||!!((J=this.delayedAndroidKey)===null||J===void 0?void 0:J.force)}}clearDelayedAndroidKey(){this.win.cancelAnimationFrame(this.flushingAndroidKey),this.delayedAndroidKey=null,this.flushingAndroidKey=-1}flushSoon(){if(this.delayedFlush<0)this.delayedFlush=this.view.win.requestAnimationFrame(()=>{this.delayedFlush=-1,this.flush()})}forceFlush(){if(this.delayedFlush>=0)this.view.win.cancelAnimationFrame(this.delayedFlush),this.delayedFlush=-1;this.flush()}pendingRecords(){for(let Z of this.observer.takeRecords())this.queue.push(Z);return this.queue}processRecords(){let Z=this.pendingRecords();if(Z.length)this.queue=[];let $=-1,J=-1,X=!1;for(let Y of Z){let K=this.readMutation(Y);if(!K)continue;if(K.typeOver)X=!0;if($==-1)({from:$,to:J}=K);else $=Math.min(K.from,$),J=Math.max(K.to,J)}return{from:$,to:J,typeOver:X}}readChange(){let{from:Z,to:$,typeOver:J}=this.processRecords(),X=this.selectionChanged&&x5(this.dom,this.selectionRange);if(Z<0&&!X)return null;if(Z>-1)this.lastChange=Date.now();this.view.inputState.lastFocusTime=0,this.selectionChanged=!1;let Y=new e1(this.view,Z,$,J);return this.view.docView.domChanged={newSel:Y.newSel?Y.newSel.main:null},Y}flush(Z=!0){if(this.delayedFlush>=0||this.delayedAndroidKey)return!1;if(Z)this.readSelectionRange();let $=this.readChange();if(!$)return this.view.requestMeasure(),!1;let J=this.view.state,X=$6(this.view,$);if(this.view.state==J&&($.domChanged||$.newSel&&!l7(this.view.state.selection,$.newSel.main)))this.view.update([]);return X}readMutation(Z){let $=this.view.docView.tile.nearest(Z.target);if(!$||$.isWidget())return null;if($.markDirty(Z.type=="attributes"),Z.type=="childList"){let J=t8($,Z.previousSibling||Z.target.previousSibling,-1),X=t8($,Z.nextSibling||Z.target.nextSibling,1);return{from:J?$.posAfter(J):$.posAtStart,to:X?$.posBefore(X):$.posAtEnd,typeOver:!1}}else if(Z.type=="characterData")return{from:$.posAtStart,to:$.posAtEnd,typeOver:Z.target.nodeValue==Z.oldValue};else return null}setWindow(Z){if(Z!=this.win)this.removeWindowListeners(this.win),this.win=Z,this.addWindowListeners(this.win)}addWindowListeners(Z){if(Z.addEventListener("resize",this.onResize),this.printQuery)if(this.printQuery.addEventListener)this.printQuery.addEventListener("change",this.onPrint);else this.printQuery.addListener(this.onPrint);else Z.addEventListener("beforeprint",this.onPrint);Z.addEventListener("scroll",this.onScroll),Z.document.addEventListener("selectionchange",this.onSelectionChange)}removeWindowListeners(Z){if(Z.removeEventListener("scroll",this.onScroll),Z.removeEventListener("resize",this.onResize),this.printQuery)if(this.printQuery.removeEventListener)this.printQuery.removeEventListener("change",this.onPrint);else this.printQuery.removeListener(this.onPrint);else Z.removeEventListener("beforeprint",this.onPrint);Z.document.removeEventListener("selectionchange",this.onSelectionChange)}update(Z){if(this.editContext){if(this.editContext.update(Z),Z.startState.facet(j0)!=Z.state.facet(j0))Z.view.contentDOM.editContext=Z.state.facet(j0)?this.editContext.editContext:null}}destroy(){var Z,$,J;this.stop(),(Z=this.intersection)===null||Z===void 0||Z.disconnect(),($=this.gapIntersection)===null||$===void 0||$.disconnect(),(J=this.resizeScroll)===null||J===void 0||J.disconnect();for(let X of this.scrollTargets)X.removeEventListener("scroll",this.onScroll);if(this.removeWindowListeners(this.win),clearTimeout(this.parentCheck),clearTimeout(this.resizeTimeout),this.win.cancelAnimationFrame(this.delayedFlush),this.win.cancelAnimationFrame(this.flushingAndroidKey),this.editContext)this.view.contentDOM.editContext=null,this.editContext.destroy()}}function t8(Z,$,J){while($){let X=Y9.get($);if(X&&X.parent==Z)return X;let Y=$.parentNode;$=Y!=Z.dom?Y:J>0?$.nextSibling:$.previousSibling}return null}function e8(Z,$){let{startContainer:J,startOffset:X,endContainer:Y,endOffset:K}=$,Q=Z.docView.domAtPos(Z.state.selection.main.anchor,1);if(w5(Q.node,Q.offset,Y,K))[J,X,Y,K]=[Y,K,J,X];return{anchorNode:J,anchorOffset:X,focusNode:Y,focusOffset:K}}function XY(Z,$){if($.getComposedRanges){let Y=$.getComposedRanges(Z.root)[0];if(Y)return e8(Z,Y)}let J=null;function X(Y){Y.preventDefault(),Y.stopImmediatePropagation(),J=Y.getTargetRanges()[0]}return Z.contentDOM.addEventListener("beforeinput",X,!0),Z.dom.ownerDocument.execCommand("indent"),Z.contentDOM.removeEventListener("beforeinput",X,!0),J?e8(Z,J):null}class A6{constructor(Z){this.from=0,this.to=0,this.pendingContextChange=null,this.handlers=Object.create(null),this.composing=null,this.resetRange(Z.state);let $=this.editContext=new window.EditContext({text:Z.state.doc.sliceString(this.from,this.to),selectionStart:this.toContextPos(Math.max(this.from,Math.min(this.to,Z.state.selection.main.anchor))),selectionEnd:this.toContextPos(Z.state.selection.main.head)});this.handlers.textupdate=(J)=>{let X=Z.state.selection.main,{anchor:Y,head:K}=X,Q=this.toEditorPos(J.updateRangeStart),U=this.toEditorPos(J.updateRangeEnd);if(Z.inputState.composing>=0&&!this.composing)this.composing={contextBase:J.updateRangeStart,editorBase:Q,drifted:!1};let q=U-Q>J.text.length;if(Q==this.from&&Y<this.from)Q=Y;else if(U==this.to&&Y>this.to)U=Y;let G=J6(Z.state.sliceDoc(Q,U),J.text,(q?X.from:X.to)-Q,q?"end":null);if(!G){let j=R.single(this.toEditorPos(J.selectionStart),this.toEditorPos(J.selectionEnd));if(!l7(j,X))Z.dispatch({selection:j,userEvent:"select"});return}let z={from:G.from+Q,to:G.toA+Q,insert:u.of(J.text.slice(G.from,G.toB).split(`
`))};if((B.mac||B.android)&&z.from==K-1&&/^\. ?$/.test(J.text)&&Z.contentDOM.getAttribute("autocorrect")=="off")z={from:Q,to:U,insert:u.of([J.text.replace("."," ")])};if(this.pendingContextChange=z,!Z.state.readOnly){let j=this.to-this.from+(z.to-z.from+z.insert.length);l3(Z,z,R.single(this.toEditorPos(J.selectionStart,j),this.toEditorPos(J.selectionEnd,j)))}if(this.pendingContextChange)this.revertPending(Z.state),this.setSelection(Z.state);if(z.from<z.to&&!z.insert.length&&Z.inputState.composing>=0&&!/[\\p{Alphabetic}\\p{Number}_]/.test($.text.slice(Math.max(0,J.updateRangeStart-1),Math.min($.text.length,J.updateRangeStart+1))))this.handlers.compositionend(J)},this.handlers.characterboundsupdate=(J)=>{let X=[],Y=null;for(let K=this.toEditorPos(J.rangeStart),Q=this.toEditorPos(J.rangeEnd);K<Q;K++){let U=Z.coordsForChar(K);Y=U&&new DOMRect(U.left,U.top,U.right-U.left,U.bottom-U.top)||Y||new DOMRect,X.push(Y)}$.updateCharacterBounds(J.rangeStart,X)},this.handlers.textformatupdate=(J)=>{let X=[];for(let Y of J.getTextFormats()){let{underlineStyle:K,underlineThickness:Q}=Y;if(!/none/i.test(K)&&!/none/i.test(Q)){let U=this.toEditorPos(Y.rangeStart),q=this.toEditorPos(Y.rangeEnd);if(U<q){let G=`text-decoration: underline ${/^[a-z]/.test(K)?K+" ":K=="Dashed"?"dashed ":K=="Squiggle"?"wavy ":""}${/thin/i.test(Q)?1:2}px`;X.push(y.mark({attributes:{style:G}}).range(U,q))}}}Z.dispatch({effects:h1.of(y.set(X))})},this.handlers.compositionstart=()=>{if(Z.inputState.composing<0)Z.inputState.composing=0,Z.inputState.compositionFirstChange=!0},this.handlers.compositionend=()=>{if(Z.inputState.composing=-1,Z.inputState.compositionFirstChange=null,this.composing){let{drifted:J}=this.composing;if(this.composing=null,J)this.reset(Z.state)}};for(let J in this.handlers)$.addEventListener(J,this.handlers[J]);this.measureReq={read:(J)=>{this.editContext.updateControlBounds(J.contentDOM.getBoundingClientRect());let X=u5(J.root);if(X&&X.rangeCount)this.editContext.updateSelectionBounds(X.getRangeAt(0).getBoundingClientRect())}}}applyEdits(Z){let $=0,J=!1,X=this.pendingContextChange;if(Z.changes.iterChanges((Y,K,Q,U,q)=>{if(J)return;let G=q.length-(K-Y);if(X&&K>=X.to)if(X.from==Y&&X.to==K&&X.insert.eq(q)){X=this.pendingContextChange=null,$+=G,this.to+=G;return}else X=null,this.revertPending(Z.state);if(Y+=$,K+=$,K<=this.from)this.from+=G,this.to+=G;else if(Y<this.to){if(Y<this.from||K>this.to||this.to-this.from+q.length>30000){J=!0;return}this.editContext.updateText(this.toContextPos(Y),this.toContextPos(K),q.toString()),this.to+=G}$+=G}),X&&!J)this.revertPending(Z.state);return!J}update(Z){let $=this.pendingContextChange,J=Z.startState.selection.main;if(this.composing&&(this.composing.drifted||!Z.changes.touchesRange(J.from,J.to)&&Z.transactions.some((X)=>!X.isUserEvent("input.type")&&X.changes.touchesRange(this.from,this.to))))this.composing.drifted=!0,this.composing.editorBase=Z.changes.mapPos(this.composing.editorBase);else if(!this.applyEdits(Z)||!this.rangeIsValid(Z.state))this.pendingContextChange=null,this.reset(Z.state);else if(Z.docChanged||Z.selectionSet||$)this.setSelection(Z.state);if(Z.geometryChanged||Z.docChanged||Z.selectionSet)Z.view.requestMeasure(this.measureReq)}resetRange(Z){let{head:$}=Z.selection.main;this.from=Math.max(0,$-1e4),this.to=Math.min(Z.doc.length,$+1e4)}reset(Z){this.resetRange(Z),this.editContext.updateText(0,this.editContext.text.length,Z.doc.sliceString(this.from,this.to)),this.setSelection(Z)}revertPending(Z){let $=this.pendingContextChange;this.pendingContextChange=null,this.editContext.updateText(this.toContextPos($.from),this.toContextPos($.from+$.insert.length),Z.doc.sliceString($.from,$.to))}setSelection(Z){let{main:$}=Z.selection,J=this.toContextPos(Math.max(this.from,Math.min(this.to,$.anchor))),X=this.toContextPos($.head);if(this.editContext.selectionStart!=J||this.editContext.selectionEnd!=X)this.editContext.updateSelection(J,X)}rangeIsValid(Z){let{head:$}=Z.selection.main;return!(this.from>0&&$-this.from<500||this.to<Z.doc.length&&this.to-$<500||this.to-this.from>30000)}toEditorPos(Z,$=this.to-this.from){Z=Math.min(Z,$);let J=this.composing;return J&&J.drifted?J.editorBase+(Z-J.contextBase):Z+this.from}toContextPos(Z){let $=this.composing;return $&&$.drifted?$.contextBase+(Z-$.editorBase):Z-this.from}destroy(){for(let Z in this.handlers)this.editContext.removeEventListener(Z,this.handlers[Z])}}class E{get state(){return this.viewState.state}get viewport(){return this.viewState.viewport}get visibleRanges(){return this.viewState.visibleRanges}get inView(){return this.viewState.inView}get composing(){return!!this.inputState&&this.inputState.composing>0}get compositionStarted(){return!!this.inputState&&this.inputState.composing>=0}get root(){return this._root}get win(){return this.dom.ownerDocument.defaultView||window}constructor(Z={}){var $;if(this.plugins=[],this.pluginMap=new Map,this.editorAttrs={},this.contentAttrs={},this.bidiCache=[],this.destroyed=!1,this.updateState=2,this.measureScheduled=-1,this.measureRequests=[],this.contentDOM=document.createElement("div"),this.scrollDOM=document.createElement("div"),this.scrollDOM.tabIndex=-1,this.scrollDOM.className="cm-scroller",this.scrollDOM.appendChild(this.contentDOM),this.announceDOM=document.createElement("div"),this.announceDOM.className="cm-announced",this.announceDOM.setAttribute("aria-live","polite"),this.dom=document.createElement("div"),this.dom.appendChild(this.announceDOM),this.dom.appendChild(this.scrollDOM),Z.parent)Z.parent.appendChild(this.dom);let{dispatch:J}=Z;if(this.dispatchTransactions=Z.dispatchTransactions||J&&((X)=>X.forEach((Y)=>J(Y,this)))||((X)=>this.update(X)),this.dispatch=this.dispatch.bind(this),this._root=Z.root||o2(Z.parent)||document,this.viewState=new E3(Z.state||h.create(Z)),Z.scrollTo&&Z.scrollTo.is(D7))this.viewState.scrollTarget=Z.scrollTo.value.clip(this.viewState.state);this.plugins=this.state.facet(e0).map((X)=>new y7(X));for(let X of this.plugins)X.update(this);if(this.observer=new F6(this),this.inputState=new X6(this),this.inputState.ensureHandlers(this.plugins),this.docView=new I3(this),this.mountStyles(),this.updateAttrs(),this.updateState=0,this.requestMeasure(),($=document.fonts)===null||$===void 0?void 0:$.ready)document.fonts.ready.then(()=>{this.viewState.mustMeasureContent="refresh",this.requestMeasure()})}dispatch(...Z){let $=Z.length==1&&Z[0]instanceof e?Z:Z.length==1&&Array.isArray(Z[0])?Z[0]:[this.state.update(...Z)];this.dispatchTransactions($,this)}update(Z){if(this.updateState!=0)throw Error("Calls to EditorView.update are not allowed while an update is in progress");let $=!1,J=!1,X,Y=this.state;for(let j of Z){if(j.startState!=Y)throw RangeError("Trying to update state with a transaction that doesn't start from the previous state.");Y=j.state}if(this.destroyed){this.viewState.state=Y;return}let K=this.hasFocus,Q=0,U=null;if(Z.some((j)=>j.annotation(z6)))this.inputState.notifiedFocused=K,Q=1;else if(K!=this.inputState.notifiedFocused){if(this.inputState.notifiedFocused=K,U=j6(Y,K),!U)Q=1}let q=this.observer.delayedAndroidKey,G=null;if(q){if(this.observer.clearDelayedAndroidKey(),G=this.observer.readChange(),G&&!this.state.doc.eq(Y.doc)||!this.state.selection.eq(Y.selection))G=null}else this.observer.clear();if(Y.facet(h.phrases)!=this.state.facet(h.phrases))return this.setState(Y);X=g7.create(this,Y,Z),X.flags|=Q;let z=this.viewState.scrollTarget;try{this.updateState=2;for(let j of Z){if(z)z=z.map(j.changes);if(j.scrollIntoView){let{main:W}=j.state.selection;z=new X5(W.empty?W:R.cursor(W.head,W.head>W.anchor?-1:1))}for(let W of j.effects)if(W.is(D7))z=W.value.clip(this.state)}if(this.viewState.update(X,z),this.bidiCache=c7.update(this.bidiCache,X.changes),!X.empty)this.updatePlugins(X),this.inputState.update(X);if($=this.docView.update(X),this.state.facet(C5)!=this.styleModules)this.mountStyles();J=this.updateAttrs(),this.showAnnouncements(Z),this.docView.updateSelection($,Z.some((j)=>j.isUserEvent("select.pointer")))}finally{this.updateState=0}if(X.startState.facet(E7)!=X.state.facet(E7))this.viewState.mustMeasureContent=!0;if($||J||z||this.viewState.mustEnforceCursorAssoc||this.viewState.mustMeasureContent)this.requestMeasure();if($)this.docViewUpdate();if(!X.empty)for(let j of this.state.facet(R3))try{j(X)}catch(W){j9(this.state,W,"update listener")}if(U||G)Promise.resolve().then(()=>{if(U&&this.state==U.startState)this.dispatch(U);if(G){if(!$6(this,G)&&q.force)J5(this.contentDOM,q.key,q.keyCode)}})}setState(Z){if(this.updateState!=0)throw Error("Calls to EditorView.setState are not allowed while an update is in progress");if(this.destroyed){this.viewState.state=Z;return}this.updateState=2;let $=this.hasFocus;try{for(let J of this.plugins)J.destroy(this);this.viewState=new E3(Z),this.plugins=Z.facet(e0).map((J)=>new y7(J)),this.pluginMap.clear();for(let J of this.plugins)J.update(this);this.docView.destroy(),this.docView=new I3(this),this.inputState.ensureHandlers(this.plugins),this.mountStyles(),this.updateAttrs(),this.bidiCache=[]}finally{this.updateState=0}if($)this.focus();this.requestMeasure()}updatePlugins(Z){let $=Z.startState.facet(e0),J=Z.state.facet(e0);if($!=J){let X=[];for(let Y of J){let K=$.indexOf(Y);if(K<0)X.push(new y7(Y));else{let Q=this.plugins[K];Q.mustUpdate=Z,X.push(Q)}}for(let Y of this.plugins)if(Y.mustUpdate!=Z)Y.destroy(this);this.plugins=X,this.pluginMap.clear()}else for(let X of this.plugins)X.mustUpdate=Z;for(let X=0;X<this.plugins.length;X++)this.plugins[X].update(this);if($!=J)this.inputState.ensureHandlers(this.plugins)}docViewUpdate(){for(let Z of this.plugins){let $=Z.value;if($&&$.docViewUpdate)try{$.docViewUpdate(this)}catch(J){j9(this.state,J,"doc view update listener")}}}measure(Z=!0){if(this.destroyed)return;if(this.measureScheduled>-1)this.win.cancelAnimationFrame(this.measureScheduled);if(this.observer.delayedAndroidKey){this.measureScheduled=-1,this.requestMeasure();return}if(this.measureScheduled=0,Z)this.observer.forceFlush();let $=null,J=this.scrollDOM,X=J.scrollTop*this.scaleY,{scrollAnchorPos:Y,scrollAnchorHeight:K}=this.viewState;if(Math.abs(X-this.viewState.scrollTop)>1)K=-1;this.viewState.scrollAnchorHeight=-1;try{for(let Q=0;;Q++){if(K<0)if(I1(J))Y=-1,K=this.viewState.heightMap.height;else{let W=this.viewState.scrollAnchorAt(X);Y=W.from,K=W.top}this.updateState=1;let U=this.viewState.measure(this);if(!U&&!this.measureRequests.length&&this.viewState.scrollTarget==null)break;if(Q>5){console.warn(this.measureRequests.length?"Measure loop restarted more than 5 times":"Viewport failed to stabilize");break}let q=[];if(!(U&4))[this.measureRequests,q]=[q,this.measureRequests];let G=q.map((W)=>{try{return W.read(this)}catch(O){return j9(this.state,O),Z1}}),z=g7.create(this,this.state,[]),j=!1;if(z.flags|=U,!$)$=z;else $.flags|=U;if(this.updateState=2,!z.empty){if(this.updatePlugins(z),this.inputState.update(z),this.updateAttrs(),j=this.docView.update(z),j)this.docViewUpdate()}for(let W=0;W<q.length;W++)if(G[W]!=Z1)try{let O=q[W];if(O.write)O.write(G[W],this)}catch(O){j9(this.state,O)}if(j)this.docView.updateSelection(!0);if(!z.viewportChanged&&this.measureRequests.length==0){if(this.viewState.editorHeight)if(this.viewState.scrollTarget){this.docView.scrollIntoView(this.viewState.scrollTarget),this.viewState.scrollTarget=null,K=-1;continue}else{let O=(Y<0?this.viewState.heightMap.height:this.viewState.lineBlockAt(Y).top)-K;if(O>1||O<-1){X=X+O,J.scrollTop=X/this.scaleY,K=-1;continue}}break}}}finally{this.updateState=0,this.measureScheduled=-1}if($&&!$.empty)for(let Q of this.state.facet(R3))Q($)}get themeClasses(){return P3+" "+(this.state.facet(B3)?I6:R6)+" "+this.state.facet(E7)}updateAttrs(){let Z=$1(this,v1,{class:"cm-editor"+(this.hasFocus?" cm-focused ":" ")+this.themeClasses}),$={spellcheck:"false",autocorrect:"off",autocapitalize:"off",writingsuggestions:"false",translate:"no",contenteditable:!this.state.facet(j0)?"false":"true",class:"cm-content",style:`${B.tabSize}: ${this.state.tabSize}`,role:"textbox","aria-multiline":"true"};if(this.state.readOnly)$["aria-readonly"]="true";$1(this,f3,$);let J=this.observer.ignore(()=>{let X=b8(this.contentDOM,this.contentAttrs,$),Y=b8(this.dom,this.editorAttrs,Z);return X||Y});return this.editorAttrs=Z,this.contentAttrs=$,J}showAnnouncements(Z){let $=!0;for(let J of Z)for(let X of J.effects)if(X.is(E.announce)){if($)this.announceDOM.textContent="";$=!1;let Y=this.announceDOM.appendChild(document.createElement("div"));Y.textContent=X.value}}mountStyles(){this.styleModules=this.state.facet(C5);let Z=this.state.facet(E.cspNonce);c9.mount(this.root,this.styleModules.concat($Y).reverse(),Z?{nonce:Z}:void 0)}readMeasured(){if(this.updateState==2)throw Error("Reading the editor layout isn't allowed during an update");if(this.updateState==0&&this.measureScheduled>-1)this.measure(!1)}requestMeasure(Z){if(this.measureScheduled<0)this.measureScheduled=this.win.requestAnimationFrame(()=>this.measure());if(Z){if(this.measureRequests.indexOf(Z)>-1)return;if(Z.key!=null){for(let $=0;$<this.measureRequests.length;$++)if(this.measureRequests[$].key===Z.key){this.measureRequests[$]=Z;return}}this.measureRequests.push(Z)}}plugin(Z){let $=this.pluginMap.get(Z);if($===void 0||$&&$.plugin!=Z)this.pluginMap.set(Z,$=this.plugins.find((J)=>J.plugin==Z)||null);return $&&$.update(this).value}get documentTop(){return this.contentDOM.getBoundingClientRect().top+this.viewState.paddingTop}get documentPadding(){return{top:this.viewState.paddingTop,bottom:this.viewState.paddingBottom}}get scaleX(){return this.viewState.scaleX}get scaleY(){return this.viewState.scaleY}elementAtHeight(Z){return this.readMeasured(),this.viewState.elementAtHeight(Z)}lineBlockAtHeight(Z){return this.readMeasured(),this.viewState.lineBlockAtHeight(Z)}get viewportLineBlocks(){return this.viewState.viewportLines}lineBlockAt(Z){return this.viewState.lineBlockAt(Z)}get contentHeight(){return this.viewState.contentHeight}moveByChar(Z,$,J){return Y3(this,Z,u8(this,Z,$,J))}moveByGroup(Z,$){return Y3(this,Z,u8(this,Z,$,(J)=>BX(this,Z.head,J)))}visualLineSide(Z,$){let J=this.bidiSpans(Z),X=this.textDirectionAt(Z.from),Y=J[$?J.length-1:0];return R.cursor(Y.side($,X)+Z.from,Y.forward(!$,X)?1:-1)}moveToLineBoundary(Z,$,J=!0){return EX(this,Z,$,J)}moveVertically(Z,$,J){return Y3(this,Z,PX(this,Z,$,J))}domAtPos(Z,$=1){return this.docView.domAtPos(Z,$)}posAtDOM(Z,$=0){return this.docView.posFromDOM(Z,$)}posAtCoords(Z,$=!0){this.readMeasured();let J=A3(this,Z,$);return J&&J.pos}posAndSideAtCoords(Z,$=!0){return this.readMeasured(),A3(this,Z,$)}coordsAtPos(Z,$=1){this.readMeasured();let J=this.docView.coordsAt(Z,$);if(!J||J.left==J.right)return J;let X=this.state.doc.lineAt(Z),Y=this.bidiSpans(X),K=Y[a9.find(Y,Z-X.from,-1,$)];return f7(J,K.dir==p.LTR==$>0)}coordsForChar(Z){return this.readMeasured(),this.docView.coordsForChar(Z)}get defaultCharacterWidth(){return this.viewState.heightOracle.charWidth}get defaultLineHeight(){return this.viewState.heightOracle.lineHeight}get textDirection(){return this.viewState.defaultTextDirection}textDirectionAt(Z){if(!this.state.facet(b1)||Z<this.viewport.from||Z>this.viewport.to)return this.textDirection;return this.readMeasured(),this.docView.textDirectionAt(Z)}get lineWrapping(){return this.viewState.heightOracle.lineWrapping}bidiSpans(Z){if(Z.length>YY)return E1(Z.length);let $=this.textDirectionAt(Z.from),J;for(let Y of this.bidiCache)if(Y.from==Z.from&&Y.dir==$&&(Y.fresh||M1(Y.isolates,J=h8(this,Z))))return Y.order;if(!J)J=h8(this,Z);let X=KX(Z.text,$,J);return this.bidiCache.push(new c7(Z.from,Z.to,$,J,!0,X)),X}get hasFocus(){var Z;return(this.dom.ownerDocument.hasFocus()||B.safari&&((Z=this.inputState)===null||Z===void 0?void 0:Z.lastContextMenu)>Date.now()-30000)&&this.root.activeElement==this.contentDOM}focus(){this.observer.ignore(()=>{R1(this.contentDOM),this.docView.updateSelection()})}setRoot(Z){if(this._root!=Z)this._root=Z,this.observer.setWindow((Z.nodeType==9?Z:Z.ownerDocument).defaultView||window),this.mountStyles()}destroy(){if(this.root.activeElement==this.contentDOM)this.contentDOM.blur();for(let Z of this.plugins)Z.destroy(this);if(this.plugins=[],this.inputState.destroy(),this.docView.destroy(),this.dom.remove(),this.observer.destroy(),this.measureScheduled>-1)this.win.cancelAnimationFrame(this.measureScheduled);this.destroyed=!0}static scrollIntoView(Z,$={}){return D7.of(new X5(typeof Z=="number"?R.cursor(Z):Z,$.y,$.x,$.yMargin,$.xMargin))}scrollSnapshot(){let{scrollTop:Z,scrollLeft:$}=this.scrollDOM,J=this.viewState.scrollAnchorAt(Z);return D7.of(new X5(R.cursor(J.from),"start","start",J.top-Z,$,!0))}setTabFocusMode(Z){if(Z==null)this.inputState.tabFocusMode=this.inputState.tabFocusMode<0?0:-1;else if(typeof Z=="boolean")this.inputState.tabFocusMode=Z?0:-1;else if(this.inputState.tabFocusMode!=0)this.inputState.tabFocusMode=Date.now()+Z}static domEventHandlers(Z){return o.define(()=>({}),{eventHandlers:Z})}static domEventObservers(Z){return o.define(()=>({}),{eventObservers:Z})}static theme(Z,$){let J=c9.newName(),X=[E7.of(J),C5.of(C3(`.${J}`,Z))];if($&&$.dark)X.push(B3.of(!0));return X}static baseTheme(Z){return d9.lowest(C5.of(C3("."+P3,Z,D6)))}static findFromDOM(Z){var $;let J=Z.querySelector(".cm-content"),X=J&&Y9.get(J)||Y9.get(Z);return(($=X===null||X===void 0?void 0:X.root)===null||$===void 0?void 0:$.view)||null}}E.styleModule=C5;E.inputHandler=k1;E.clipboardInputFilter=m3;E.clipboardOutputFilter=u3;E.scrollHandler=w1;E.focusChangeEffect=S1;E.perLineTextDirection=b1;E.exceptionSink=y1;E.updateListener=R3;E.editable=j0;E.mouseSelectionStyle=T1;E.dragMovesSelection=C1;E.clickAddsSelectionRange=P1;E.decorations=i7;E.blockWrappers=m1;E.outerDecorations=g3;E.atomicRanges=c5;E.bidiIsolatedRanges=u1;E.scrollMargins=f1;E.darkTheme=B3;E.cspNonce=L.define({combine:(Z)=>Z.length?Z[0]:""});E.contentAttributes=f3;E.editorAttributes=v1;E.lineWrapping=E.contentAttributes.of({class:"cm-lineWrapping"});E.announce=k.define();var YY=4096,Z1={};class c7{constructor(Z,$,J,X,Y,K){this.from=Z,this.to=$,this.dir=J,this.isolates=X,this.fresh=Y,this.order=K}static update(Z,$){if($.empty&&!Z.some((Y)=>Y.fresh))return Z;let J=[],X=Z.length?Z[Z.length-1].dir:p.LTR;for(let Y=Math.max(0,Z.length-10);Y<Z.length;Y++){let K=Z[Y];if(K.dir==X&&!$.touchesRange(K.from,K.to))J.push(new c7($.mapPos(K.from,1),$.mapPos(K.to,-1),K.dir,K.isolates,!1,K.order))}return J}}function $1(Z,$,J){for(let X=Z.state.facet($),Y=X.length-1;Y>=0;Y--){let K=X[Y],Q=typeof K=="function"?K(Z):K;if(Q)w3(Q,J)}return J}var KY=B.mac?"mac":B.windows?"win":B.linux?"linux":"key";function QY(Z,$){let J=Z.split(/-(?!$)/),X=J[J.length-1];if(X=="Space")X=" ";let Y,K,Q,U;for(let q=0;q<J.length-1;++q){let G=J[q];if(/^(cmd|meta|m)$/i.test(G))U=!0;else if(/^a(lt)?$/i.test(G))Y=!0;else if(/^(c|ctrl|control)$/i.test(G))K=!0;else if(/^s(hift)?$/i.test(G))Q=!0;else if(/^mod$/i.test(G))if($=="mac")U=!0;else K=!0;else throw Error("Unrecognized modifier name: "+G)}if(Y)X="Alt-"+X;if(K)X="Ctrl-"+X;if(U)X="Meta-"+X;if(Q)X="Shift-"+X;return X}function B7(Z,$,J){if($.altKey)Z="Alt-"+Z;if($.ctrlKey)Z="Ctrl-"+Z;if($.metaKey)Z="Meta-"+Z;if(J!==!1&&$.shiftKey)Z="Shift-"+Z;return Z}var UY=d9.default(E.domEventHandlers({keydown(Z,$){return E6(L6($.state),Z,$,"editor")}})),m0=L.define({enables:UY}),J1=new WeakMap;function L6(Z){let $=Z.facet(m0),J=J1.get($);if(!J)J1.set($,J=GY($.reduce((X,Y)=>X.concat(Y),[])));return J}function M6(Z,$,J){return E6(L6(Z.state),$,Z,J)}var V0=null,qY=4000;function GY(Z,$=KY){let J=Object.create(null),X=Object.create(null),Y=(Q,U)=>{let q=X[Q];if(q==null)X[Q]=U;else if(q!=U)throw Error("Key binding "+Q+" is used both as a regular binding and as a multi-stroke prefix")},K=(Q,U,q,G,z)=>{var j,W;let O=J[Q]||(J[Q]=Object.create(null)),_=U.split(/ (?!$)/).map((I)=>QY(I,$));for(let I=1;I<_.length;I++){let D=_.slice(0,I).join(" ");if(Y(D,!0),!O[D])O[D]={preventDefault:!0,stopPropagation:!1,run:[(F)=>{let C=V0={view:F,prefix:D,scope:Q};return setTimeout(()=>{if(V0==C)V0=null},qY),!0}]}}let V=_.join(" ");Y(V,!1);let H=O[V]||(O[V]={preventDefault:!1,stopPropagation:!1,run:((W=(j=O._any)===null||j===void 0?void 0:j.run)===null||W===void 0?void 0:W.slice())||[]});if(q)H.run.push(q);if(G)H.preventDefault=!0;if(z)H.stopPropagation=!0};for(let Q of Z){let U=Q.scope?Q.scope.split(" "):["editor"];if(Q.any)for(let G of U){let z=J[G]||(J[G]=Object.create(null));if(!z._any)z._any={preventDefault:!1,stopPropagation:!1,run:[]};let{any:j}=Q;for(let W in z)z[W].run.push((O)=>j(O,T3))}let q=Q[$]||Q.key;if(!q)continue;for(let G of U)if(K(G,q,Q.run,Q.preventDefault,Q.stopPropagation),Q.shift)K(G,"Shift-"+q,Q.shift,Q.preventDefault,Q.stopPropagation)}return J}var T3=null;function E6(Z,$,J,X){T3=$;let Y=C8($),K=G9(Y,0),Q=E9(K)==Y.length&&Y!=" ",U="",q=!1,G=!1,z=!1;if(V0&&V0.view==J&&V0.scope==X){if(U=V0.prefix+" ",K6.indexOf($.keyCode)<0)G=!0,V0=null}let j=new Set,W=(H)=>{if(H){for(let I of H.run)if(!j.has(I)){if(j.add(I),I(J)){if(H.stopPropagation)z=!0;return!0}}if(H.preventDefault){if(H.stopPropagation)z=!0;G=!0}}return!1},O=Z[X],_,V;if(O){if(W(O[U+B7(Y,$,!Q)]))q=!0;else if(Q&&($.altKey||$.metaKey||$.ctrlKey)&&!(B.windows&&$.ctrlKey&&$.altKey)&&!(B.mac&&$.altKey&&!($.ctrlKey||$.metaKey))&&(_=z0[$.keyCode])&&_!=Y){if(W(O[U+B7(_,$,!0)]))q=!0;else if($.shiftKey&&(V=t0[$.keyCode])!=Y&&V!=_&&W(O[U+B7(V,$,!1)]))q=!0}else if(Q&&$.shiftKey&&W(O[U+B7(Y,$,!0)]))q=!0;if(!q&&W(O._any))q=!0}if(G)q=!0;if(q&&z)$.stopPropagation();return T3=null,q}class i5{constructor(Z,$,J,X,Y){this.className=Z,this.left=$,this.top=J,this.width=X,this.height=Y}draw(){let Z=document.createElement("div");return Z.className=this.className,this.adjust(Z),Z}update(Z,$){if($.className!=this.className)return!1;return this.adjust(Z),!0}adjust(Z){if(Z.style.left=this.left+"px",Z.style.top=this.top+"px",this.width!=null)Z.style.width=this.width+"px";Z.style.height=this.height+"px"}eq(Z){return this.left==Z.left&&this.top==Z.top&&this.width==Z.width&&this.height==Z.height&&this.className==Z.className}static forRange(Z,$,J){if(J.empty){let X=Z.coordsAtPos(J.head,J.assoc||1);if(!X)return[];let Y=B6(Z);return[new i5($,X.left-Y.left,X.top-Y.top,null,X.bottom-X.top)]}else return zY(Z,$,J)}}function B6(Z){let $=Z.scrollDOM.getBoundingClientRect();return{left:(Z.textDirection==p.LTR?$.left:$.right-Z.scrollDOM.clientWidth*Z.scaleX)-Z.scrollDOM.scrollLeft*Z.scaleX,top:$.top-Z.scrollDOM.scrollTop*Z.scaleY}}function X1(Z,$,J,X){let Y=Z.coordsAtPos($,J*2);if(!Y)return X;let K=Z.dom.getBoundingClientRect(),Q=(Y.top+Y.bottom)/2,U=Z.posAtCoords({x:K.left+1,y:Q}),q=Z.posAtCoords({x:K.right-1,y:Q});if(U==null||q==null)return X;return{from:Math.max(X.from,Math.min(U,q)),to:Math.min(X.to,Math.max(U,q))}}function zY(Z,$,J){if(J.to<=Z.viewport.from||J.from>=Z.viewport.to)return[];let X=Math.max(J.from,Z.viewport.from),Y=Math.min(J.to,Z.viewport.to),K=Z.textDirection==p.LTR,Q=Z.contentDOM,U=Q.getBoundingClientRect(),q=B6(Z),G=Q.querySelector(".cm-line"),z=G&&window.getComputedStyle(G),j=U.left+(z?parseInt(z.paddingLeft)+Math.min(0,parseInt(z.textIndent)):0),W=U.right-(z?parseInt(z.paddingRight):0),O=F3(Z,X,1),_=F3(Z,Y,-1),V=O.type==W9.Text?O:null,H=_.type==W9.Text?_:null;if(V&&(Z.lineWrapping||O.widgetLineBreaks))V=X1(Z,X,1,V);if(H&&(Z.lineWrapping||_.widgetLineBreaks))H=X1(Z,Y,-1,H);if(V&&H&&V.from==H.from&&V.to==H.to)return D(F(J.from,J.to,V));else{let M=V?F(J.from,null,V):C(O,!1),T=H?F(null,J.to,H):C(_,!0),P=[];if((V||O).to<(H||_).from-(V&&H?1:0)||O.widgetLineBreaks>1&&M.bottom+Z.defaultLineHeight/2<T.top)P.push(I(j,M.bottom,W,T.top));else if(M.bottom<T.top&&Z.elementAtHeight((M.bottom+T.top)/2).type==W9.Text)M.bottom=T.top=(M.bottom+T.top)/2;return D(M).concat(P).concat(D(T))}function I(M,T,P,x){return new i5($,M-q.left,T-q.top,Math.max(0,P-M),x-T)}function D({top:M,bottom:T,horizontal:P}){let x=[];for(let m=0;m<P.length;m+=2)x.push(I(P[m],M,P[m+1],T));return x}function F(M,T,P){let x=1e9,m=-1e9,c=[];function v(g,n,H9,L9,Z0){let U9=Z.coordsAtPos(g,g==P.to?-2:2),k9=Z.coordsAtPos(H9,H9==P.from?2:-2);if(!U9||!k9)return;if(x=Math.min(U9.top,k9.top,x),m=Math.max(U9.bottom,k9.bottom,m),Z0==p.LTR)c.push(K&&n?j:U9.left,K&&L9?W:k9.right);else c.push(!K&&L9?j:k9.left,!K&&n?W:U9.right)}let S=M!==null&&M!==void 0?M:P.from,l=T!==null&&T!==void 0?T:P.to;for(let g of Z.visibleRanges)if(g.to>S&&g.from<l)for(let n=Math.max(g.from,S),H9=Math.min(g.to,l);;){let L9=Z.state.doc.lineAt(n);for(let Z0 of Z.bidiSpans(L9)){let U9=Z0.from+L9.from,k9=Z0.to+L9.from;if(U9>=H9)break;if(k9>n)v(Math.max(U9,n),M==null&&U9<=S,Math.min(k9,H9),T==null&&k9>=l,Z0.dir)}if(n=L9.to+1,n>=H9)break}if(c.length==0)v(S,M==null,l,T==null,Z.textDirection);return{top:x,bottom:m,horizontal:c}}function C(M,T){let P=U.top+(T?M.top:M.bottom);return{top:P,bottom:P,horizontal:[]}}}function jY(Z,$){return Z.constructor==$.constructor&&Z.eq($)}class P6{constructor(Z,$){if(this.view=Z,this.layer=$,this.drawn=[],this.scaleX=1,this.scaleY=1,this.measureReq={read:this.measure.bind(this),write:this.draw.bind(this)},this.dom=Z.scrollDOM.appendChild(document.createElement("div")),this.dom.classList.add("cm-layer"),$.above)this.dom.classList.add("cm-layer-above");if($.class)this.dom.classList.add($.class);if(this.scale(),this.dom.setAttribute("aria-hidden","true"),this.setOrder(Z.state),Z.requestMeasure(this.measureReq),$.mount)$.mount(this.dom,Z)}update(Z){if(Z.startState.facet(x7)!=Z.state.facet(x7))this.setOrder(Z.state);if(this.layer.update(Z,this.dom)||Z.geometryChanged)this.scale(),Z.view.requestMeasure(this.measureReq)}docViewUpdate(Z){if(this.layer.updateOnDocViewUpdate!==!1)Z.requestMeasure(this.measureReq)}setOrder(Z){let $=0,J=Z.facet(x7);while($<J.length&&J[$]!=this.layer)$++;this.dom.style.zIndex=String((this.layer.above?150:-1)-$)}measure(){return this.layer.markers(this.view)}scale(){let{scaleX:Z,scaleY:$}=this.view;if(Z!=this.scaleX||$!=this.scaleY)this.scaleX=Z,this.scaleY=$,this.dom.style.transform=`scale(${1/Z}, ${1/$})`}draw(Z){if(Z.length!=this.drawn.length||Z.some(($,J)=>!jY($,this.drawn[J]))){let $=this.dom.firstChild,J=0;for(let X of Z)if(X.update&&$&&X.constructor&&this.drawn[J].constructor&&X.update($,this.drawn[J]))$=$.nextSibling,J++;else this.dom.insertBefore(X.draw(),$);while($){let X=$.nextSibling;$.remove(),$=X}if(this.drawn=Z,B.safari&&B.safari_version>=26)this.dom.style.display=this.dom.firstChild?"":"none"}}destroy(){if(this.layer.destroy)this.layer.destroy(this.dom,this.view);this.dom.remove()}}var x7=L.define();function C6(Z){return[o.define(($)=>new P6($,Z)),x7.of(Z)]}var p5=L.define({combine(Z){return _9(Z,{cursorBlinkRate:1200,drawRangeCursor:!0},{cursorBlinkRate:($,J)=>Math.min($,J),drawRangeCursor:($,J)=>$||J})}});function T6(Z={}){return[p5.of(Z),WY,OY,_Y,x1.of(!0)]}function y6(Z){return Z.startState.facet(p5)!=Z.state.facet(p5)}var WY=C6({above:!0,markers(Z){let{state:$}=Z,J=$.facet(p5),X=[];for(let Y of $.selection.ranges){let K=Y==$.selection.main;if(Y.empty||J.drawRangeCursor){let Q=K?"cm-cursor cm-cursor-primary":"cm-cursor cm-cursor-secondary",U=Y.empty?Y:R.cursor(Y.head,Y.head>Y.anchor?-1:1);for(let q of i5.forRange(Z,Q,U))X.push(q)}}return X},update(Z,$){if(Z.transactions.some((X)=>X.selection))$.style.animationName=$.style.animationName=="cm-blink"?"cm-blink2":"cm-blink";let J=y6(Z);if(J)Y1(Z.state,$);return Z.docChanged||Z.selectionSet||J},mount(Z,$){Y1($.state,Z)},class:"cm-cursorLayer"});function Y1(Z,$){$.style.animationDuration=Z.facet(p5).cursorBlinkRate+"ms"}var OY=C6({above:!1,markers(Z){return Z.state.selection.ranges.map(($)=>$.empty?[]:i5.forRange(Z,"cm-selectionBackground",$)).reduce(($,J)=>$.concat(J))},update(Z,$){return Z.docChanged||Z.selectionSet||Z.viewportChanged||y6(Z)},class:"cm-selectionLayer"}),_Y=d9.highest(E.theme({".cm-line":{"& ::selection, &::selection":{backgroundColor:"transparent !important"},caretColor:"transparent !important"},".cm-content":{caretColor:"transparent !important","& :focus":{caretColor:"initial !important","&::selection, & ::selection":{backgroundColor:"Highlight !important"}}}})),k6=k.define({map(Z,$){return Z==null?null:$.mapPos(Z)}}),S5=a.define({create(){return null},update(Z,$){if(Z!=null)Z=$.changes.mapPos(Z);return $.effects.reduce((J,X)=>X.is(k6)?X.value:J,Z)}}),VY=o.fromClass(class{constructor(Z){this.view=Z,this.cursor=null,this.measureReq={read:this.readPos.bind(this),write:this.drawCursor.bind(this)}}update(Z){var $;let J=Z.state.field(S5);if(J==null){if(this.cursor!=null)($=this.cursor)===null||$===void 0||$.remove(),this.cursor=null}else{if(!this.cursor)this.cursor=this.view.scrollDOM.appendChild(document.createElement("div")),this.cursor.className="cm-dropCursor";if(Z.startState.field(S5)!=J||Z.docChanged||Z.geometryChanged)this.view.requestMeasure(this.measureReq)}}readPos(){let{view:Z}=this,$=Z.state.field(S5),J=$!=null&&Z.coordsAtPos($);if(!J)return null;let X=Z.scrollDOM.getBoundingClientRect();return{left:J.left-X.left+Z.scrollDOM.scrollLeft*Z.scaleX,top:J.top-X.top+Z.scrollDOM.scrollTop*Z.scaleY,height:J.bottom-J.top}}drawCursor(Z){if(this.cursor){let{scaleX:$,scaleY:J}=this.view;if(Z)this.cursor.style.left=Z.left/$+"px",this.cursor.style.top=Z.top/J+"px",this.cursor.style.height=Z.height/J+"px";else this.cursor.style.left="-100000px"}}destroy(){if(this.cursor)this.cursor.remove()}setDropPos(Z){if(this.view.state.field(S5)!=Z)this.view.dispatch({effects:k6.of(Z)})}},{eventObservers:{dragover(Z){this.setDropPos(this.view.posAtCoords({x:Z.clientX,y:Z.clientY}))},dragleave(Z){if(Z.target==this.view.contentDOM||!this.view.contentDOM.contains(Z.relatedTarget))this.setDropPos(null)},dragend(){this.setDropPos(null)},drop(){this.setDropPos(null)}}});function S6(){return[S5,VY]}function K1(Z,$,J,X,Y){$.lastIndex=0;for(let K=Z.iterRange(J,X),Q=J,U;!K.next().done;Q+=K.value.length)if(!K.lineBreak)while(U=$.exec(K.value))Y(Q+U.index,U)}function HY(Z,$){let J=Z.visibleRanges;if(J.length==1&&J[0].from==Z.viewport.from&&J[0].to==Z.viewport.to)return J;let X=[];for(let{from:Y,to:K}of J)if(Y=Math.max(Z.state.doc.lineAt(Y).from,Y-$),K=Math.min(Z.state.doc.lineAt(K).to,K+$),X.length&&X[X.length-1].to>=Y)X[X.length-1].to=K;else X.push({from:Y,to:K});return X}class b6{constructor(Z){let{regexp:$,decoration:J,decorate:X,boundary:Y,maxLength:K=1000}=Z;if(!$.global)throw RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");if(this.regexp=$,X)this.addMatch=(Q,U,q,G)=>X(G,q,q+Q[0].length,Q,U);else if(typeof J=="function")this.addMatch=(Q,U,q,G)=>{let z=J(Q,U,q);if(z)G(q,q+Q[0].length,z)};else if(J)this.addMatch=(Q,U,q,G)=>G(q,q+Q[0].length,J);else throw RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");this.boundary=Y,this.maxLength=K}createDeco(Z){let $=new M9,J=$.add.bind($);for(let{from:X,to:Y}of HY(Z,this.maxLength))K1(Z.state.doc,this.regexp,X,Y,(K,Q)=>this.addMatch(Q,Z,K,J));return $.finish()}updateDeco(Z,$){let J=1e9,X=-1;if(Z.docChanged)Z.changes.iterChanges((Y,K,Q,U)=>{if(U>=Z.view.viewport.from&&Q<=Z.view.viewport.to)J=Math.min(Q,J),X=Math.max(U,X)});if(Z.viewportMoved||X-J>1000)return this.createDeco(Z.view);if(X>-1)return this.updateRange(Z.view,$.map(Z.changes),J,X);return $}updateRange(Z,$,J,X){for(let Y of Z.visibleRanges){let K=Math.max(Y.from,J),Q=Math.min(Y.to,X);if(Q>=K){let U=Z.state.doc.lineAt(K),q=U.to<Q?Z.state.doc.lineAt(Q):U,G=Math.max(Y.from,U.from),z=Math.min(Y.to,q.to);if(this.boundary){for(;K>U.from;K--)if(this.boundary.test(U.text[K-1-U.from])){G=K;break}for(;Q<q.to;Q++)if(this.boundary.test(q.text[Q-q.from])){z=Q;break}}let j=[],W,O=(_,V,H)=>j.push(H.range(_,V));if(U==q){this.regexp.lastIndex=G-U.from;while((W=this.regexp.exec(U.text))&&W.index<z-U.from)this.addMatch(W,Z,W.index+U.from,O)}else K1(Z.state.doc,this.regexp,G,z,(_,V)=>this.addMatch(V,Z,_,O));$=$.update({filterFrom:G,filterTo:z,filter:(_,V)=>_<G||V>z,add:j})}}return $}}var y3=/x/.unicode!=null?"gu":"g",NY=new RegExp(`[\x00-\b
-\x1F-­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`,y3),RY={0:"null",7:"bell",8:"backspace",10:"newline",11:"vertical tab",13:"carriage return",27:"escape",8203:"zero width space",8204:"zero width non-joiner",8205:"zero width joiner",8206:"left-to-right mark",8207:"right-to-left mark",8232:"line separator",8237:"left-to-right override",8238:"right-to-left override",8294:"left-to-right isolate",8295:"right-to-left isolate",8297:"pop directional isolate",8233:"paragraph separator",65279:"zero width no-break space",65532:"object replacement"},Q3=null;function IY(){var Z;if(Q3==null&&typeof document<"u"&&document.body){let $=document.body.style;Q3=((Z=$.tabSize)!==null&&Z!==void 0?Z:$.MozTabSize)!=null}return Q3||!1}var w7=L.define({combine(Z){let $=_9(Z,{render:null,specialChars:NY,addSpecialChars:null});if($.replaceTabs=!IY())$.specialChars=new RegExp("\t|"+$.specialChars.source,y3);if($.addSpecialChars)$.specialChars=new RegExp($.specialChars.source+"|"+$.addSpecialChars.source,y3);return $}});function x6(Z={}){return[w7.of(Z),DY()]}var Q1=null;function DY(){return Q1||(Q1=o.fromClass(class{constructor(Z){this.view=Z,this.decorations=y.none,this.decorationCache=Object.create(null),this.decorator=this.makeDecorator(Z.state.facet(w7)),this.decorations=this.decorator.createDeco(Z)}makeDecorator(Z){return new b6({regexp:Z.specialChars,decoration:($,J,X)=>{let{doc:Y}=J.state,K=G9($[0],0);if(K==9){let Q=Y.lineAt(X),U=J.state.tabSize,q=G0(Q.text,U,X-Q.from);return y.replace({widget:new h6((U-q%U)*this.view.defaultCharacterWidth/this.view.scaleX)})}return this.decorationCache[K]||(this.decorationCache[K]=y.replace({widget:new w6(Z,K)}))},boundary:Z.replaceTabs?void 0:/[^]/})}update(Z){let $=Z.state.facet(w7);if(Z.startState.facet(w7)!=$)this.decorator=this.makeDecorator($),this.decorations=this.decorator.createDeco(Z.view);else this.decorations=this.decorator.updateDeco(Z,this.decorations)}},{decorations:(Z)=>Z.decorations}))}var FY="•";function AY(Z){if(Z>=32)return FY;if(Z==10)return"␤";return String.fromCharCode(9216+Z)}class w6 extends C9{constructor(Z,$){super();this.options=Z,this.code=$}eq(Z){return Z.code==this.code}toDOM(Z){let $=AY(this.code),J=Z.state.phrase("Control character")+" "+(RY[this.code]||"0x"+this.code.toString(16)),X=this.options.render&&this.options.render(this.code,J,$);if(X)return X;let Y=document.createElement("span");return Y.textContent=$,Y.title=J,Y.setAttribute("aria-label",J),Y.className="cm-specialChar",Y}ignoreEvent(){return!1}}class h6 extends C9{constructor(Z){super();this.width=Z}eq(Z){return Z.width==this.width}toDOM(){let Z=document.createElement("span");return Z.textContent="\t",Z.className="cm-tab",Z.style.width=this.width+"px",Z}ignoreEvent(){return!1}}function v6(){return MY}var LY=y.line({class:"cm-activeLine"}),MY=o.fromClass(class{constructor(Z){this.decorations=this.getDeco(Z)}update(Z){if(Z.docChanged||Z.selectionSet)this.decorations=this.getDeco(Z.view)}getDeco(Z){let $=-1,J=[];for(let X of Z.state.selection.ranges){let Y=Z.lineBlockAt(X.head);if(Y.from>$)J.push(LY.range(Y.from)),$=Y.from}return y.set(J)}},{decorations:(Z)=>Z.decorations});var k3=2000;function EY(Z,$,J){let X=Math.min($.line,J.line),Y=Math.max($.line,J.line),K=[];if($.off>k3||J.off>k3||$.col<0||J.col<0){let Q=Math.min($.off,J.off),U=Math.max($.off,J.off);for(let q=X;q<=Y;q++){let G=Z.doc.line(q);if(G.length<=U)K.push(R.range(G.from+Q,G.to+U))}}else{let Q=Math.min($.col,J.col),U=Math.max($.col,J.col);for(let q=X;q<=Y;q++){let G=Z.doc.line(q),z=I7(G.text,Q,Z.tabSize,!0);if(z<0)K.push(R.cursor(G.to));else{let j=I7(G.text,U,Z.tabSize);K.push(R.range(G.from+z,G.from+j))}}}return K}function BY(Z,$){let J=Z.coordsAtPos(Z.viewport.from);return J?Math.round(Math.abs((J.left-$)/Z.defaultCharacterWidth)):-1}function U1(Z,$){let J=Z.posAtCoords({x:$.clientX,y:$.clientY},!1),X=Z.state.doc.lineAt(J),Y=J-X.from,K=Y>k3?-1:Y==X.length?BY(Z,$.clientX):G0(X.text,Z.state.tabSize,J-X.from);return{line:X.number,col:K,off:Y}}function PY(Z,$){let J=U1(Z,$),X=Z.state.selection;if(!J)return null;return{update(Y){if(Y.docChanged){let K=Y.changes.mapPos(Y.startState.doc.line(J.line).from),Q=Y.state.doc.lineAt(K);J={line:Q.number,col:J.col,off:Math.min(J.off,Q.length)},X=X.map(Y.changes)}},get(Y,K,Q){let U=U1(Z,Y);if(!U)return X;let q=EY(Z.state,J,U);if(!q.length)return X;if(Q)return R.create(q.concat(X.ranges));else return R.create(q)}}}function m6(Z){let $=(Z===null||Z===void 0?void 0:Z.eventFilter)||((J)=>J.altKey&&J.button==0);return E.mouseSelectionStyle.of((J,X)=>$(X)?PY(J,X):null)}var CY={Alt:[18,(Z)=>!!Z.altKey],Control:[17,(Z)=>!!Z.ctrlKey],Shift:[16,(Z)=>!!Z.shiftKey],Meta:[91,(Z)=>!!Z.metaKey]},TY={style:"cursor: crosshair"};function u6(Z={}){let[$,J]=CY[Z.key||"Alt"],X=o.fromClass(class{constructor(Y){this.view=Y,this.isDown=!1}set(Y){if(this.isDown!=Y)this.isDown=Y,this.view.update([])}},{eventObservers:{keydown(Y){this.set(Y.keyCode==$||J(Y))},keyup(Y){if(Y.keyCode==$||!J(Y))this.set(!1)},mousemove(Y){this.set(J(Y))}}});return[X,E.contentAttributes.of((Y)=>{var K;return((K=Y.plugin(X))===null||K===void 0?void 0:K.isDown)?TY:null})]}var P7="-10000px";class n3{constructor(Z,$,J,X){this.facet=$,this.createTooltipView=J,this.removeTooltipView=X,this.input=Z.state.facet($),this.tooltips=this.input.filter((K)=>K);let Y=null;this.tooltipViews=this.tooltips.map((K)=>Y=J(K,Y))}update(Z,$){var J;let X=Z.state.facet(this.facet),Y=X.filter((U)=>U);if(X===this.input){for(let U of this.tooltipViews)if(U.update)U.update(Z);return!1}let K=[],Q=$?[]:null;for(let U=0;U<Y.length;U++){let q=Y[U],G=-1;if(!q)continue;for(let z=0;z<this.tooltips.length;z++){let j=this.tooltips[z];if(j&&j.create==q.create)G=z}if(G<0){if(K[U]=this.createTooltipView(q,U?K[U-1]:null),Q)Q[U]=!!q.above}else{let z=K[U]=this.tooltipViews[G];if(Q)Q[U]=$[G];if(z.update)z.update(Z)}}for(let U of this.tooltipViews)if(K.indexOf(U)<0)this.removeTooltipView(U),(J=U.destroy)===null||J===void 0||J.call(U);if($)Q.forEach((U,q)=>$[q]=U),$.length=Q.length;return this.input=X,this.tooltips=Y,this.tooltipViews=K,!0}}function yY(Z){let $=Z.dom.ownerDocument.documentElement;return{top:0,left:0,bottom:$.clientHeight,right:$.clientWidth}}var U3=L.define({combine:(Z)=>{var $,J,X;return{position:B.ios?"absolute":(($=Z.find((Y)=>Y.position))===null||$===void 0?void 0:$.position)||"fixed",parent:((J=Z.find((Y)=>Y.parent))===null||J===void 0?void 0:J.parent)||null,tooltipSpace:((X=Z.find((Y)=>Y.tooltipSpace))===null||X===void 0?void 0:X.tooltipSpace)||yY}}}),q1=new WeakMap,i3=o.fromClass(class{constructor(Z){this.view=Z,this.above=[],this.inView=!0,this.madeAbsolute=!1,this.lastTransaction=0,this.measureTimeout=-1;let $=Z.state.facet(U3);this.position=$.position,this.parent=$.parent,this.classes=Z.themeClasses,this.createContainer(),this.measureReq={read:this.readMeasure.bind(this),write:this.writeMeasure.bind(this),key:this},this.resizeObserver=typeof ResizeObserver=="function"?new ResizeObserver(()=>this.measureSoon()):null,this.manager=new n3(Z,a5,(J,X)=>this.createTooltip(J,X),(J)=>{if(this.resizeObserver)this.resizeObserver.unobserve(J.dom);J.dom.remove()}),this.above=this.manager.tooltips.map((J)=>!!J.above),this.intersectionObserver=typeof IntersectionObserver=="function"?new IntersectionObserver((J)=>{if(Date.now()>this.lastTransaction-50&&J.length>0&&J[J.length-1].intersectionRatio<1)this.measureSoon()},{threshold:[1]}):null,this.observeIntersection(),Z.win.addEventListener("resize",this.measureSoon=this.measureSoon.bind(this)),this.maybeMeasure()}createContainer(){if(this.parent)this.container=document.createElement("div"),this.container.style.position="relative",this.container.className=this.view.themeClasses,this.parent.appendChild(this.container);else this.container=this.view.dom}observeIntersection(){if(this.intersectionObserver){this.intersectionObserver.disconnect();for(let Z of this.manager.tooltipViews)this.intersectionObserver.observe(Z.dom)}}measureSoon(){if(this.measureTimeout<0)this.measureTimeout=setTimeout(()=>{this.measureTimeout=-1,this.maybeMeasure()},50)}update(Z){if(Z.transactions.length)this.lastTransaction=Date.now();let $=this.manager.update(Z,this.above);if($)this.observeIntersection();let J=$||Z.geometryChanged,X=Z.state.facet(U3);if(X.position!=this.position&&!this.madeAbsolute){this.position=X.position;for(let Y of this.manager.tooltipViews)Y.dom.style.position=this.position;J=!0}if(X.parent!=this.parent){if(this.parent)this.container.remove();this.parent=X.parent,this.createContainer();for(let Y of this.manager.tooltipViews)this.container.appendChild(Y.dom);J=!0}else if(this.parent&&this.view.themeClasses!=this.classes)this.classes=this.container.className=this.view.themeClasses;if(J)this.maybeMeasure()}createTooltip(Z,$){let J=Z.create(this.view),X=$?$.dom:null;if(J.dom.classList.add("cm-tooltip"),Z.arrow&&!J.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")){let Y=document.createElement("div");Y.className="cm-tooltip-arrow",J.dom.appendChild(Y)}if(J.dom.style.position=this.position,J.dom.style.top=P7,J.dom.style.left="0px",this.container.insertBefore(J.dom,X),J.mount)J.mount(this.view);if(this.resizeObserver)this.resizeObserver.observe(J.dom);return J}destroy(){var Z,$,J;this.view.win.removeEventListener("resize",this.measureSoon);for(let X of this.manager.tooltipViews)X.dom.remove(),(Z=X.destroy)===null||Z===void 0||Z.call(X);if(this.parent)this.container.remove();($=this.resizeObserver)===null||$===void 0||$.disconnect(),(J=this.intersectionObserver)===null||J===void 0||J.disconnect(),clearTimeout(this.measureTimeout)}readMeasure(){let Z=1,$=1,J=!1;if(this.position=="fixed"&&this.manager.tooltipViews.length){let{dom:K}=this.manager.tooltipViews[0];if(B.safari){let Q=K.getBoundingClientRect();J=Math.abs(Q.top+1e4)>1||Math.abs(Q.left)>1}else J=!!K.offsetParent&&K.offsetParent!=this.container.ownerDocument.body}if(J||this.position=="absolute")if(this.parent){let K=this.parent.getBoundingClientRect();if(K.width&&K.height)Z=K.width/this.parent.offsetWidth,$=K.height/this.parent.offsetHeight}else({scaleX:Z,scaleY:$}=this.view.viewState);let X=this.view.scrollDOM.getBoundingClientRect(),Y=p3(this.view);return{visible:{left:X.left+Y.left,top:X.top+Y.top,right:X.right-Y.right,bottom:X.bottom-Y.bottom},parent:this.parent?this.container.getBoundingClientRect():this.view.dom.getBoundingClientRect(),pos:this.manager.tooltips.map((K,Q)=>{let U=this.manager.tooltipViews[Q];return U.getCoords?U.getCoords(K.pos):this.view.coordsAtPos(K.pos)}),size:this.manager.tooltipViews.map(({dom:K})=>K.getBoundingClientRect()),space:this.view.state.facet(U3).tooltipSpace(this.view),scaleX:Z,scaleY:$,makeAbsolute:J}}writeMeasure(Z){var $;if(Z.makeAbsolute){this.madeAbsolute=!0,this.position="absolute";for(let U of this.manager.tooltipViews)U.dom.style.position="absolute"}let{visible:J,space:X,scaleX:Y,scaleY:K}=Z,Q=[];for(let U=0;U<this.manager.tooltips.length;U++){let q=this.manager.tooltips[U],G=this.manager.tooltipViews[U],{dom:z}=G,j=Z.pos[U],W=Z.size[U];if(!j||q.clip!==!1&&(j.bottom<=Math.max(J.top,X.top)||j.top>=Math.min(J.bottom,X.bottom)||j.right<Math.max(J.left,X.left)-0.1||j.left>Math.min(J.right,X.right)+0.1)){z.style.top=P7;continue}let O=q.arrow?G.dom.querySelector(".cm-tooltip-arrow"):null,_=O?7:0,V=W.right-W.left,H=($=q1.get(G))!==null&&$!==void 0?$:W.bottom-W.top,I=G.offset||SY,D=this.view.textDirection==p.LTR,F=W.width>X.right-X.left?D?X.left:X.right-W.width:D?Math.max(X.left,Math.min(j.left-(O?14:0)+I.x,X.right-V)):Math.min(Math.max(X.left,j.left-V+(O?14:0)-I.x),X.right-V),C=this.above[U];if(!q.strictSide&&(C?j.top-H-_-I.y<X.top:j.bottom+H+_+I.y>X.bottom)&&C==X.bottom-j.bottom>j.top-X.top)C=this.above[U]=!C;let M=(C?j.top-X.top:X.bottom-j.bottom)-_;if(M<H&&G.resize!==!1){if(M<this.view.defaultLineHeight){z.style.top=P7;continue}q1.set(G,H),z.style.height=(H=M)/K+"px"}else if(z.style.height)z.style.height="";let T=C?j.top-H-_-I.y:j.bottom+_+I.y,P=F+V;if(G.overlap!==!0){for(let x of Q)if(x.left<P&&x.right>F&&x.top<T+H&&x.bottom>T)T=C?x.top-H-2-_:x.bottom+_+2}if(this.position=="absolute")z.style.top=(T-Z.parent.top)/K+"px",G1(z,(F-Z.parent.left)/Y);else z.style.top=T/K+"px",G1(z,F/Y);if(O){let x=j.left+(D?I.x:-I.x)-(F+14-7);O.style.left=x/Y+"px"}if(G.overlap!==!0)Q.push({left:F,top:T,right:P,bottom:T+H});if(z.classList.toggle("cm-tooltip-above",C),z.classList.toggle("cm-tooltip-below",!C),G.positioned)G.positioned(Z.space)}}maybeMeasure(){if(this.manager.tooltips.length){if(this.view.inView)this.view.requestMeasure(this.measureReq);if(this.inView!=this.view.inView){if(this.inView=this.view.inView,!this.inView)for(let Z of this.manager.tooltipViews)Z.dom.style.top=P7}}}},{eventObservers:{scroll(){this.maybeMeasure()}}});function G1(Z,$){let J=parseInt(Z.style.left,10);if(isNaN(J)||Math.abs($-J)>1)Z.style.left=$+"px"}var kY=E.baseTheme({".cm-tooltip":{zIndex:500,boxSizing:"border-box"},"&light .cm-tooltip":{border:"1px solid #bbb",backgroundColor:"#f5f5f5"},"&light .cm-tooltip-section:not(:first-child)":{borderTop:"1px solid #bbb"},"&dark .cm-tooltip":{backgroundColor:"#333338",color:"white"},".cm-tooltip-arrow":{height:"7px",width:"14px",position:"absolute",zIndex:-1,overflow:"hidden","&:before, &:after":{content:"''",position:"absolute",width:0,height:0,borderLeft:"7px solid transparent",borderRight:"7px solid transparent"},".cm-tooltip-above &":{bottom:"-7px","&:before":{borderTop:"7px solid #bbb"},"&:after":{borderTop:"7px solid #f5f5f5",bottom:"1px"}},".cm-tooltip-below &":{top:"-7px","&:before":{borderBottom:"7px solid #bbb"},"&:after":{borderBottom:"7px solid #f5f5f5",top:"1px"}}},"&dark .cm-tooltip .cm-tooltip-arrow":{"&:before":{borderTopColor:"#333338",borderBottomColor:"#333338"},"&:after":{borderTopColor:"transparent",borderBottomColor:"transparent"}}}),SY={x:0,y:0},a5=L.define({enables:[i3,kY]}),s7=L.define({combine:(Z)=>Z.reduce(($,J)=>$.concat(J),[])});class r7{static create(Z){return new r7(Z)}constructor(Z){this.view=Z,this.mounted=!1,this.dom=document.createElement("div"),this.dom.classList.add("cm-tooltip-hover"),this.manager=new n3(Z,s7,($,J)=>this.createHostedView($,J),($)=>$.dom.remove())}createHostedView(Z,$){let J=Z.create(this.view);if(J.dom.classList.add("cm-tooltip-section"),this.dom.insertBefore(J.dom,$?$.dom.nextSibling:this.dom.firstChild),this.mounted&&J.mount)J.mount(this.view);return J}mount(Z){for(let $ of this.manager.tooltipViews)if($.mount)$.mount(Z);this.mounted=!0}positioned(Z){for(let $ of this.manager.tooltipViews)if($.positioned)$.positioned(Z)}update(Z){this.manager.update(Z)}destroy(){var Z;for(let $ of this.manager.tooltipViews)(Z=$.destroy)===null||Z===void 0||Z.call($)}passProp(Z){let $=void 0;for(let J of this.manager.tooltipViews){let X=J[Z];if(X!==void 0){if($===void 0)$=X;else if($!==X)return}}return $}get offset(){return this.passProp("offset")}get getCoords(){return this.passProp("getCoords")}get overlap(){return this.passProp("overlap")}get resize(){return this.passProp("resize")}}var bY=a5.compute([s7],(Z)=>{let $=Z.facet(s7);if($.length===0)return null;return{pos:Math.min(...$.map((J)=>J.pos)),end:Math.max(...$.map((J)=>{var X;return(X=J.end)!==null&&X!==void 0?X:J.pos})),create:r7.create,above:$[0].above,arrow:$.some((J)=>J.arrow)}});class f6{constructor(Z,$,J,X,Y){this.view=Z,this.source=$,this.field=J,this.setHover=X,this.hoverTime=Y,this.hoverTimeout=-1,this.restartTimeout=-1,this.pending=null,this.lastMove={x:0,y:0,target:Z.dom,time:0},this.checkHover=this.checkHover.bind(this),Z.dom.addEventListener("mouseleave",this.mouseleave=this.mouseleave.bind(this)),Z.dom.addEventListener("mousemove",this.mousemove=this.mousemove.bind(this))}update(){if(this.pending)this.pending=null,clearTimeout(this.restartTimeout),this.restartTimeout=setTimeout(()=>this.startHover(),20)}get active(){return this.view.state.field(this.field)}checkHover(){if(this.hoverTimeout=-1,this.active.length)return;let Z=Date.now()-this.lastMove.time;if(Z<this.hoverTime)this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime-Z);else this.startHover()}startHover(){clearTimeout(this.restartTimeout);let{view:Z,lastMove:$}=this,J=Z.docView.tile.nearest($.target);if(!J)return;let X,Y=1;if(J.isWidget())X=J.posAtStart;else{if(X=Z.posAtCoords($),X==null)return;let Q=Z.coordsAtPos(X);if(!Q||$.y<Q.top||$.y>Q.bottom||$.x<Q.left-Z.defaultCharacterWidth||$.x>Q.right+Z.defaultCharacterWidth)return;let U=Z.bidiSpans(Z.state.doc.lineAt(X)).find((G)=>G.from<=X&&G.to>=X),q=U&&U.dir==p.RTL?-1:1;Y=$.x<Q.left?-q:q}let K=this.source(Z,X,Y);if(K===null||K===void 0?void 0:K.then){let Q=this.pending={pos:X};K.then((U)=>{if(this.pending==Q){if(this.pending=null,U&&!(Array.isArray(U)&&!U.length))Z.dispatch({effects:this.setHover.of(Array.isArray(U)?U:[U])})}},(U)=>j9(Z.state,U,"hover tooltip"))}else if(K&&!(Array.isArray(K)&&!K.length))Z.dispatch({effects:this.setHover.of(Array.isArray(K)?K:[K])})}get tooltip(){let Z=this.view.plugin(i3),$=Z?Z.manager.tooltips.findIndex((J)=>J.create==r7.create):-1;return $>-1?Z.manager.tooltipViews[$]:null}mousemove(Z){var $,J;if(this.lastMove={x:Z.clientX,y:Z.clientY,target:Z.target,time:Date.now()},this.hoverTimeout<0)this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime);let{active:X,tooltip:Y}=this;if(X.length&&Y&&!xY(Y.dom,Z)||this.pending){let{pos:K}=X[0]||this.pending,Q=(J=($=X[0])===null||$===void 0?void 0:$.end)!==null&&J!==void 0?J:K;if(K==Q?this.view.posAtCoords(this.lastMove)!=K:!wY(this.view,K,Q,Z.clientX,Z.clientY))this.view.dispatch({effects:this.setHover.of([])}),this.pending=null}}mouseleave(Z){clearTimeout(this.hoverTimeout),this.hoverTimeout=-1;let{active:$}=this;if($.length){let{tooltip:J}=this;if(!(J&&J.dom.contains(Z.relatedTarget)))this.view.dispatch({effects:this.setHover.of([])});else this.watchTooltipLeave(J.dom)}}watchTooltipLeave(Z){let $=(J)=>{if(Z.removeEventListener("mouseleave",$),this.active.length&&!this.view.dom.contains(J.relatedTarget))this.view.dispatch({effects:this.setHover.of([])})};Z.addEventListener("mouseleave",$)}destroy(){clearTimeout(this.hoverTimeout),clearTimeout(this.restartTimeout),this.view.dom.removeEventListener("mouseleave",this.mouseleave),this.view.dom.removeEventListener("mousemove",this.mousemove)}}var C7=4;function xY(Z,$){let{left:J,right:X,top:Y,bottom:K}=Z.getBoundingClientRect(),Q;if(Q=Z.querySelector(".cm-tooltip-arrow")){let U=Q.getBoundingClientRect();Y=Math.min(U.top,Y),K=Math.max(U.bottom,K)}return $.clientX>=J-C7&&$.clientX<=X+C7&&$.clientY>=Y-C7&&$.clientY<=K+C7}function wY(Z,$,J,X,Y,K){let Q=Z.scrollDOM.getBoundingClientRect(),U=Z.documentTop+Z.documentPadding.top+Z.contentHeight;if(Q.left>X||Q.right<X||Q.top>Y||Math.min(Q.bottom,U)<Y)return!1;let q=Z.posAtCoords({x:X,y:Y},!1);return q>=$&&q<=J}function g6(Z,$={}){let J=k.define(),X=a.define({create(){return[]},update(Y,K){if(Y.length){if($.hideOnChange&&(K.docChanged||K.selection))Y=[];else if($.hideOn)Y=Y.filter((Q)=>!$.hideOn(K,Q));if(K.docChanged){let Q=[];for(let U of Y){let q=K.changes.mapPos(U.pos,-1,q9.TrackDel);if(q!=null){let G=Object.assign(Object.create(null),U);if(G.pos=q,G.end!=null)G.end=K.changes.mapPos(G.end);Q.push(G)}}Y=Q}}for(let Q of K.effects){if(Q.is(J))Y=Q.value;if(Q.is(hY))Y=[]}return Y},provide:(Y)=>s7.from(Y)});return{active:X,extension:[X,o.define((Y)=>new f6(Y,Z,X,J,$.hoverTime||300)),bY]}}function a3(Z,$){let J=Z.plugin(i3);if(!J)return null;let X=J.manager.tooltips.indexOf($);return X<0?null:J.manager.tooltipViews[X]}var hY=k.define();var z1=L.define({combine(Z){let $,J;for(let X of Z)$=$||X.topContainer,J=J||X.bottomContainer;return{topContainer:$,bottomContainer:J}}});function r5(Z,$){let J=Z.plugin(p6),X=J?J.specs.indexOf($):-1;return X>-1?J.panels[X]:null}var p6=o.fromClass(class{constructor(Z){this.input=Z.state.facet(v0),this.specs=this.input.filter((J)=>J),this.panels=this.specs.map((J)=>J(Z));let $=Z.state.facet(z1);this.top=new b5(Z,!0,$.topContainer),this.bottom=new b5(Z,!1,$.bottomContainer),this.top.sync(this.panels.filter((J)=>J.top)),this.bottom.sync(this.panels.filter((J)=>!J.top));for(let J of this.panels)if(J.dom.classList.add("cm-panel"),J.mount)J.mount()}update(Z){let $=Z.state.facet(z1);if(this.top.container!=$.topContainer)this.top.sync([]),this.top=new b5(Z.view,!0,$.topContainer);if(this.bottom.container!=$.bottomContainer)this.bottom.sync([]),this.bottom=new b5(Z.view,!1,$.bottomContainer);this.top.syncClasses(),this.bottom.syncClasses();let J=Z.state.facet(v0);if(J!=this.input){let X=J.filter((q)=>q),Y=[],K=[],Q=[],U=[];for(let q of X){let G=this.specs.indexOf(q),z;if(G<0)z=q(Z.view),U.push(z);else if(z=this.panels[G],z.update)z.update(Z);Y.push(z),(z.top?K:Q).push(z)}this.specs=X,this.panels=Y,this.top.sync(K),this.bottom.sync(Q);for(let q of U)if(q.dom.classList.add("cm-panel"),q.mount)q.mount()}else for(let X of this.panels)if(X.update)X.update(Z)}destroy(){this.top.sync([]),this.bottom.sync([])}},{provide:(Z)=>E.scrollMargins.of(($)=>{let J=$.plugin(Z);return J&&{top:J.top.scrollMargin(),bottom:J.bottom.scrollMargin()}})});class b5{constructor(Z,$,J){this.view=Z,this.top=$,this.container=J,this.dom=void 0,this.classes="",this.panels=[],this.syncClasses()}sync(Z){for(let $ of this.panels)if($.destroy&&Z.indexOf($)<0)$.destroy();this.panels=Z,this.syncDOM()}syncDOM(){if(this.panels.length==0){if(this.dom)this.dom.remove(),this.dom=void 0;return}if(!this.dom){this.dom=document.createElement("div"),this.dom.className=this.top?"cm-panels cm-panels-top":"cm-panels cm-panels-bottom",this.dom.style[this.top?"top":"bottom"]="0";let $=this.container||this.view.dom;$.insertBefore(this.dom,this.top?$.firstChild:null)}let Z=this.dom.firstChild;for(let $ of this.panels)if($.dom.parentNode==this.dom){while(Z!=$.dom)Z=j1(Z);Z=Z.nextSibling}else this.dom.insertBefore($.dom,Z);while(Z)Z=j1(Z)}scrollMargin(){return!this.dom||this.container?0:Math.max(0,this.top?this.dom.getBoundingClientRect().bottom-Math.max(0,this.view.scrollDOM.getBoundingClientRect().top):Math.min(innerHeight,this.view.scrollDOM.getBoundingClientRect().bottom)-this.dom.getBoundingClientRect().top)}syncClasses(){if(!this.container||this.classes==this.view.themeClasses)return;for(let Z of this.classes.split(" "))if(Z)this.container.classList.remove(Z);for(let Z of(this.classes=this.view.themeClasses).split(" "))if(Z)this.container.classList.add(Z)}}function j1(Z){let $=Z.nextSibling;return Z.remove(),$}var v0=L.define({enables:p6});function l6(Z,$){let J,X=new Promise((Q)=>J=Q),Y=(Q)=>vY(Q,$,J);if(Z.state.field(q3,!1))Z.dispatch({effects:d6.of(Y)});else Z.dispatch({effects:k.appendConfig.of(q3.init(()=>[Y]))});let K=c6.of(Y);return{close:K,result:X.then((Q)=>{return(Z.win.queueMicrotask||((q)=>Z.win.setTimeout(q,10)))(()=>{if(Z.state.field(q3).indexOf(Y)>-1)Z.dispatch({effects:K})}),Q})}}var q3=a.define({create(){return[]},update(Z,$){for(let J of $.effects)if(J.is(d6))Z=[J.value].concat(Z);else if(J.is(c6))Z=Z.filter((X)=>X!=J.value);return Z},provide:(Z)=>v0.computeN([Z],($)=>$.field(Z))}),d6=k.define(),c6=k.define();function vY(Z,$,J){let X=$.content?$.content(Z,()=>Q(null)):null;if(!X){if(X=f("form"),$.input){let U=f("input",$.input);if(/^(text|password|number|email|tel|url)$/.test(U.type))U.classList.add("cm-textfield");if(!U.name)U.name="input";X.appendChild(f("label",($.label||"")+": ",U))}else X.appendChild(document.createTextNode($.label||""));X.appendChild(document.createTextNode(" ")),X.appendChild(f("button",{class:"cm-button",type:"submit"},$.submitLabel||"OK"))}let Y=X.nodeName=="FORM"?[X]:X.querySelectorAll("form");for(let U=0;U<Y.length;U++){let q=Y[U];q.addEventListener("keydown",(G)=>{if(G.keyCode==27)G.preventDefault(),Q(null);else if(G.keyCode==13)G.preventDefault(),Q(q)}),q.addEventListener("submit",(G)=>{G.preventDefault(),Q(q)})}let K=f("div",X,f("button",{onclick:()=>Q(null),"aria-label":Z.state.phrase("close"),class:"cm-dialog-close",type:"button"},["×"]));if($.class)K.className=$.class;K.classList.add("cm-dialog");function Q(U){if(K.contains(K.ownerDocument.activeElement))Z.focus();J(U)}return{dom:K,top:$.top,mount:()=>{if($.focus){let U;if(typeof $.focus=="string")U=X.querySelector($.focus);else U=X.querySelector("input")||X.querySelector("button");if(U&&"select"in U)U.select();else if(U&&"focus"in U)U.focus()}}}}class w9 extends l9{compare(Z){return this==Z||this.constructor==Z.constructor&&this.eq(Z)}eq(Z){return!1}destroy(Z){}}w9.prototype.elementClass="";w9.prototype.toDOM=void 0;w9.prototype.mapMode=q9.TrackBefore;w9.prototype.startSide=w9.prototype.endSide=-1;w9.prototype.point=!0;var h7=L.define(),mY=L.define(),uY={class:"",renderEmptyElements:!1,elementStyle:"",markers:()=>b.empty,lineMarker:()=>null,widgetMarker:()=>null,lineMarkerChange:null,initialSpacer:null,updateSpacer:null,domEventHandlers:{},side:"before"},v5=L.define();function r3(Z){return[s6(),v5.of({...uY,...Z})]}var S3=L.define({combine:(Z)=>Z.some(($)=>$)});function s6(Z){let $=[fY];if(Z&&Z.fixed===!1)$.push(S3.of(!0));return $}var fY=o.fromClass(class{constructor(Z){this.view=Z,this.domAfter=null,this.prevViewport=Z.viewport,this.dom=document.createElement("div"),this.dom.className="cm-gutters cm-gutters-before",this.dom.setAttribute("aria-hidden","true"),this.dom.style.minHeight=this.view.contentHeight/this.view.scaleY+"px",this.gutters=Z.state.facet(v5).map(($)=>new x3(Z,$)),this.fixed=!Z.state.facet(S3);for(let $ of this.gutters)if($.config.side=="after")this.getDOMAfter().appendChild($.dom);else this.dom.appendChild($.dom);if(this.fixed)this.dom.style.position="sticky";this.syncGutters(!1),Z.scrollDOM.insertBefore(this.dom,Z.contentDOM)}getDOMAfter(){if(!this.domAfter)this.domAfter=document.createElement("div"),this.domAfter.className="cm-gutters cm-gutters-after",this.domAfter.setAttribute("aria-hidden","true"),this.domAfter.style.minHeight=this.view.contentHeight/this.view.scaleY+"px",this.domAfter.style.position=this.fixed?"sticky":"",this.view.scrollDOM.appendChild(this.domAfter);return this.domAfter}update(Z){if(this.updateGutters(Z)){let $=this.prevViewport,J=Z.view.viewport,X=Math.min($.to,J.to)-Math.max($.from,J.from);this.syncGutters(X<(J.to-J.from)*0.8)}if(Z.geometryChanged){let $=this.view.contentHeight/this.view.scaleY+"px";if(this.dom.style.minHeight=$,this.domAfter)this.domAfter.style.minHeight=$}if(this.view.state.facet(S3)!=!this.fixed){if(this.fixed=!this.fixed,this.dom.style.position=this.fixed?"sticky":"",this.domAfter)this.domAfter.style.position=this.fixed?"sticky":""}this.prevViewport=Z.view.viewport}syncGutters(Z){let $=this.dom.nextSibling;if(Z){if(this.dom.remove(),this.domAfter)this.domAfter.remove()}let J=b.iter(this.view.state.facet(h7),this.view.viewport.from),X=[],Y=this.gutters.map((K)=>new n6(K,this.view.viewport,-this.view.documentPadding.top));for(let K of this.view.viewportLineBlocks){if(X.length)X=[];if(Array.isArray(K.type)){let Q=!0;for(let U of K.type)if(U.type==W9.Text&&Q){b3(J,X,U.from);for(let q of Y)q.line(this.view,U,X);Q=!1}else if(U.widget)for(let q of Y)q.widget(this.view,U)}else if(K.type==W9.Text){b3(J,X,K.from);for(let Q of Y)Q.line(this.view,K,X)}else if(K.widget)for(let Q of Y)Q.widget(this.view,K)}for(let K of Y)K.finish();if(Z){if(this.view.scrollDOM.insertBefore(this.dom,$),this.domAfter)this.view.scrollDOM.appendChild(this.domAfter)}}updateGutters(Z){let $=Z.startState.facet(v5),J=Z.state.facet(v5),X=Z.docChanged||Z.heightChanged||Z.viewportChanged||!b.eq(Z.startState.facet(h7),Z.state.facet(h7),Z.view.viewport.from,Z.view.viewport.to);if($==J){for(let Y of this.gutters)if(Y.update(Z))X=!0}else{X=!0;let Y=[];for(let K of J){let Q=$.indexOf(K);if(Q<0)Y.push(new x3(this.view,K));else this.gutters[Q].update(Z),Y.push(this.gutters[Q])}for(let K of this.gutters)if(K.dom.remove(),Y.indexOf(K)<0)K.destroy();for(let K of Y)if(K.config.side=="after")this.getDOMAfter().appendChild(K.dom);else this.dom.appendChild(K.dom);this.gutters=Y}return X}destroy(){for(let Z of this.gutters)Z.destroy();if(this.dom.remove(),this.domAfter)this.domAfter.remove()}},{provide:(Z)=>E.scrollMargins.of(($)=>{let J=$.plugin(Z);if(!J||J.gutters.length==0||!J.fixed)return null;let X=J.dom.offsetWidth*$.scaleX,Y=J.domAfter?J.domAfter.offsetWidth*$.scaleX:0;return $.textDirection==p.LTR?{left:X,right:Y}:{right:X,left:Y}})});function W1(Z){return Array.isArray(Z)?Z:[Z]}function b3(Z,$,J){while(Z.value&&Z.from<=J){if(Z.from==J)$.push(Z.value);Z.next()}}class n6{constructor(Z,$,J){this.gutter=Z,this.height=J,this.i=0,this.cursor=b.iter(Z.markers,$.from)}addElement(Z,$,J){let{gutter:X}=this,Y=($.top-this.height)/Z.scaleY,K=$.height/Z.scaleY;if(this.i==X.elements.length){let Q=new o3(Z,K,Y,J);X.elements.push(Q),X.dom.appendChild(Q.dom)}else X.elements[this.i].update(Z,K,Y,J);this.height=$.bottom,this.i++}line(Z,$,J){let X=[];if(b3(this.cursor,X,$.from),J.length)X=X.concat(J);let Y=this.gutter.config.lineMarker(Z,$,X);if(Y)X.unshift(Y);let K=this.gutter;if(X.length==0&&!K.config.renderEmptyElements)return;this.addElement(Z,$,X)}widget(Z,$){let J=this.gutter.config.widgetMarker(Z,$.widget,$),X=J?[J]:null;for(let Y of Z.state.facet(mY)){let K=Y(Z,$.widget,$);if(K)(X||(X=[])).push(K)}if(X)this.addElement(Z,$,X)}finish(){let Z=this.gutter;while(Z.elements.length>this.i){let $=Z.elements.pop();Z.dom.removeChild($.dom),$.destroy()}}}class x3{constructor(Z,$){this.view=Z,this.config=$,this.elements=[],this.spacer=null,this.dom=document.createElement("div"),this.dom.className="cm-gutter"+(this.config.class?" "+this.config.class:"");for(let J in $.domEventHandlers)this.dom.addEventListener(J,(X)=>{let Y=X.target,K;if(Y!=this.dom&&this.dom.contains(Y)){while(Y.parentNode!=this.dom)Y=Y.parentNode;let U=Y.getBoundingClientRect();K=(U.top+U.bottom)/2}else K=X.clientY;let Q=Z.lineBlockAtHeight(K-Z.documentTop);if($.domEventHandlers[J](Z,Q,X))X.preventDefault()});if(this.markers=W1($.markers(Z)),$.initialSpacer)this.spacer=new o3(Z,0,0,[$.initialSpacer(Z)]),this.dom.appendChild(this.spacer.dom),this.spacer.dom.style.cssText+="visibility: hidden; pointer-events: none"}update(Z){let $=this.markers;if(this.markers=W1(this.config.markers(Z.view)),this.spacer&&this.config.updateSpacer){let X=this.config.updateSpacer(this.spacer.markers[0],Z);if(X!=this.spacer.markers[0])this.spacer.update(Z.view,0,0,[X])}let J=Z.view.viewport;return!b.eq(this.markers,$,J.from,J.to)||(this.config.lineMarkerChange?this.config.lineMarkerChange(Z):!1)}destroy(){for(let Z of this.elements)Z.destroy()}}class o3{constructor(Z,$,J,X){this.height=-1,this.above=0,this.markers=[],this.dom=document.createElement("div"),this.dom.className="cm-gutterElement",this.update(Z,$,J,X)}update(Z,$,J,X){if(this.height!=$)this.height=$,this.dom.style.height=$+"px";if(this.above!=J)this.dom.style.marginTop=(this.above=J)?J+"px":"";if(!gY(this.markers,X))this.setMarkers(Z,X)}setMarkers(Z,$){let J="cm-gutterElement",X=this.dom.firstChild;for(let Y=0,K=0;;){let Q=K,U=Y<$.length?$[Y++]:null,q=!1;if(U){let G=U.elementClass;if(G)J+=" "+G;for(let z=K;z<this.markers.length;z++)if(this.markers[z].compare(U)){Q=z,q=!0;break}}else Q=this.markers.length;while(K<Q){let G=this.markers[K++];if(G.toDOM){G.destroy(X);let z=X.nextSibling;X.remove(),X=z}}if(!U)break;if(U.toDOM)if(q)X=X.nextSibling;else this.dom.insertBefore(U.toDOM(Z),X);if(q)K++}this.dom.className=J,this.markers=$}destroy(){this.setMarkers(null,[])}}function gY(Z,$){if(Z.length!=$.length)return!1;for(let J=0;J<Z.length;J++)if(!Z[J].compare($[J]))return!1;return!0}var pY=L.define(),lY=L.define(),Z5=L.define({combine(Z){return _9(Z,{formatNumber:String,domEventHandlers:{}},{domEventHandlers($,J){let X=Object.assign({},$);for(let Y in J){let K=X[Y],Q=J[Y];X[Y]=K?(U,q,G)=>K(U,q,G)||Q(U,q,G):Q}return X}})}});class v7 extends w9{constructor(Z){super();this.number=Z}eq(Z){return this.number==Z.number}toDOM(){return document.createTextNode(this.number)}}function G3(Z,$){return Z.state.facet(Z5).formatNumber($,Z.state)}var dY=v5.compute([Z5],(Z)=>({class:"cm-lineNumbers",renderEmptyElements:!1,markers($){return $.state.facet(pY)},lineMarker($,J,X){if(X.some((Y)=>Y.toDOM))return null;return new v7(G3($,$.state.doc.lineAt(J.from).number))},widgetMarker:($,J,X)=>{for(let Y of $.state.facet(lY)){let K=Y($,J,X);if(K)return K}return null},lineMarkerChange:($)=>$.startState.facet(Z5)!=$.state.facet(Z5),initialSpacer($){return new v7(G3($,O1($.state.doc.lines)))},updateSpacer($,J){let X=G3(J.view,O1(J.view.state.doc.lines));return X==$.number?$:new v7(X)},domEventHandlers:Z.facet(Z5).domEventHandlers,side:"before"}));function i6(Z={}){return[Z5.of(Z),s6(),dY]}function O1(Z){let $=9;while($<Z)$=$*10+9;return $}var cY=new class extends w9{constructor(){super(...arguments);this.elementClass="cm-activeLineGutter"}},sY=h7.compute(["selection"],(Z)=>{let $=[],J=-1;for(let X of Z.selection.ranges){let Y=Z.doc.lineAt(X.head).from;if(Y>J)J=Y,$.push(cY.range(Y))}return b.of($)});function a6(){return sY}var nY=0;class t7{constructor(Z,$){this.from=Z,this.to=$}}class w{constructor(Z={}){this.id=nY++,this.perNode=!!Z.perNode,this.deserialize=Z.deserialize||(()=>{throw Error("This node type doesn't define a deserialize function")}),this.combine=Z.combine||null}add(Z){if(this.perNode)throw RangeError("Can't add per-node props to node types");if(typeof Z!="function")Z=I9.match(Z);return($)=>{let J=Z($);return J===void 0?null:[this,J]}}}w.closedBy=new w({deserialize:(Z)=>Z.split(" ")});w.openedBy=new w({deserialize:(Z)=>Z.split(" ")});w.group=new w({deserialize:(Z)=>Z.split(" ")});w.isolate=new w({deserialize:(Z)=>{if(Z&&Z!="rtl"&&Z!="ltr"&&Z!="auto")throw RangeError("Invalid value for isolate: "+Z);return Z||"auto"}});w.contextHash=new w({perNode:!0});w.lookAhead=new w({perNode:!0});w.mounted=new w({perNode:!0});class Q5{constructor(Z,$,J,X=!1){this.tree=Z,this.overlay=$,this.parser=J,this.bracketed=X}static get(Z){return Z&&Z.props&&Z.props[w.mounted.id]}}var iY=Object.create(null);class I9{constructor(Z,$,J,X=0){this.name=Z,this.props=$,this.id=J,this.flags=X}static define(Z){let $=Z.props&&Z.props.length?Object.create(null):iY,J=(Z.top?1:0)|(Z.skipped?2:0)|(Z.error?4:0)|(Z.name==null?8:0),X=new I9(Z.name||"",$,Z.id,J);if(Z.props)for(let Y of Z.props){if(!Array.isArray(Y))Y=Y(X);if(Y){if(Y[0].perNode)throw RangeError("Can't store a per-node prop on a node type");$[Y[0].id]=Y[1]}}return X}prop(Z){return this.props[Z.id]}get isTop(){return(this.flags&1)>0}get isSkipped(){return(this.flags&2)>0}get isError(){return(this.flags&4)>0}get isAnonymous(){return(this.flags&8)>0}is(Z){if(typeof Z=="string"){if(this.name==Z)return!0;let $=this.prop(w.group);return $?$.indexOf(Z)>-1:!1}return this.id==Z}static match(Z){let $=Object.create(null);for(let J in Z)for(let X of J.split(" "))$[X]=Z[J];return(J)=>{for(let X=J.prop(w.group),Y=-1;Y<(X?X.length:0);Y++){let K=$[Y<0?J.name:X[Y]];if(K)return K}}}}I9.none=new I9("",Object.create(null),0,8);class $Z{constructor(Z){this.types=Z;for(let $=0;$<Z.length;$++)if(Z[$].id!=$)throw RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...Z){let $=[];for(let J of this.types){let X=null;for(let Y of Z){let K=Y(J);if(K){if(!X)X=Object.assign({},J.props);let Q=K[1],U=K[0];if(U.combine&&U.id in X)Q=U.combine(X[U.id],Q);X[U.id]=Q}}$.push(X?new I9(J.name,X,J.id,J.flags):J)}return new $Z($)}}var o7=new WeakMap,r6=new WeakMap,Z9;(function(Z){Z[Z.ExcludeBuffers=1]="ExcludeBuffers",Z[Z.IncludeAnonymous=2]="IncludeAnonymous",Z[Z.IgnoreMounts=4]="IgnoreMounts",Z[Z.IgnoreOverlays=8]="IgnoreOverlays",Z[Z.EnterBracketed=16]="EnterBracketed"})(Z9||(Z9={}));class r{constructor(Z,$,J,X,Y){if(this.type=Z,this.children=$,this.positions=J,this.length=X,this.props=null,Y&&Y.length){this.props=Object.create(null);for(let[K,Q]of Y)this.props[typeof K=="number"?K:K.id]=Q}}toString(){let Z=Q5.get(this);if(Z&&!Z.overlay)return Z.tree.toString();let $="";for(let J of this.children){let X=J.toString();if(X){if($)$+=",";$+=X}}return!this.type.name?$:(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+($.length?"("+$+")":"")}cursor(Z=0){return new ZZ(this.topNode,Z)}cursorAt(Z,$=0,J=0){let X=o7.get(this)||this.topNode,Y=new ZZ(X);return Y.moveTo(Z,$),o7.set(this,Y._tree),Y}get topNode(){return new h9(this,0,0,null)}resolve(Z,$=0){let J=o5(o7.get(this)||this.topNode,Z,$,!1);return o7.set(this,J),J}resolveInner(Z,$=0){let J=o5(r6.get(this)||this.topNode,Z,$,!0);return r6.set(this,J),J}resolveStack(Z,$=0){return aY(this,Z,$)}iterate(Z){let{enter:$,leave:J,from:X=0,to:Y=this.length}=Z,K=Z.mode||0,Q=(K&Z9.IncludeAnonymous)>0;for(let U=this.cursor(K|Z9.IncludeAnonymous);;){let q=!1;if(U.from<=Y&&U.to>=X&&(!Q&&U.type.isAnonymous||$(U)!==!1)){if(U.firstChild())continue;q=!0}for(;;){if(q&&J&&(Q||!U.type.isAnonymous))J(U);if(U.nextSibling())break;if(!U.parent())return;q=!0}}}prop(Z){return!Z.perNode?this.type.prop(Z):this.props?this.props[Z.id]:void 0}get propValues(){let Z=[];if(this.props)for(let $ in this.props)Z.push([+$,this.props[$]]);return Z}balance(Z={}){return this.children.length<=8?this:J4(I9.none,this.children,this.positions,0,this.children.length,0,this.length,($,J,X)=>new r(this.type,$,J,X,this.propValues),Z.makeTree||(($,J,X)=>new r(I9.none,$,J,X)))}static build(Z){return rY(Z)}}r.empty=new r(I9.none,[],[],0);class e3{constructor(Z,$){this.buffer=Z,this.index=$}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new e3(this.buffer,this.index)}}class R0{constructor(Z,$,J){this.buffer=Z,this.length=$,this.set=J}get type(){return I9.none}toString(){let Z=[];for(let $=0;$<this.buffer.length;)Z.push(this.childString($)),$=this.buffer[$+3];return Z.join(",")}childString(Z){let $=this.buffer[Z],J=this.buffer[Z+3],X=this.set.types[$],Y=X.name;if(/\W/.test(Y)&&!X.isError)Y=JSON.stringify(Y);if(Z+=4,J==Z)return Y;let K=[];while(Z<J)K.push(this.childString(Z)),Z=this.buffer[Z+3];return Y+"("+K.join(",")+")"}findChild(Z,$,J,X,Y){let{buffer:K}=this,Q=-1;for(let U=Z;U!=$;U=K[U+3])if(e6(Y,X,K[U+1],K[U+2])){if(Q=U,J>0)break}return Q}slice(Z,$,J){let X=this.buffer,Y=new Uint16Array($-Z),K=0;for(let Q=Z,U=0;Q<$;){Y[U++]=X[Q++],Y[U++]=X[Q++]-J;let q=Y[U++]=X[Q++]-J;Y[U++]=X[Q++]-Z,K=Math.max(K,q)}return new R0(Y,K,this.set)}}function e6(Z,$,J,X){switch(Z){case-2:return J<$;case-1:return X>=$&&J<$;case 0:return J<$&&X>$;case 1:return J<=$&&X>$;case 2:return X>$;case 4:return!0}}function o5(Z,$,J,X){var Y;while(Z.from==Z.to||(J<1?Z.from>=$:Z.from>$)||(J>-1?Z.to<=$:Z.to<$)){let Q=!X&&Z instanceof h9&&Z.index<0?null:Z.parent;if(!Q)return Z;Z=Q}let K=X?0:Z9.IgnoreOverlays;if(X){for(let Q=Z,U=Q.parent;U;Q=U,U=Q.parent)if(Q instanceof h9&&Q.index<0&&((Y=U.enter($,J,K))===null||Y===void 0?void 0:Y.from)!=Q.from)Z=U}for(;;){let Q=Z.enter($,J,K);if(!Q)return Z;Z=Q}}class Z4{cursor(Z=0){return new ZZ(this,Z)}getChild(Z,$=null,J=null){let X=o6(this,Z,$,J);return X.length?X[0]:null}getChildren(Z,$=null,J=null){return o6(this,Z,$,J)}resolve(Z,$=0){return o5(this,Z,$,!1)}resolveInner(Z,$=0){return o5(this,Z,$,!0)}matchContext(Z){return t3(this.parent,Z)}enterUnfinishedNodesBefore(Z){let $=this.childBefore(Z),J=this;while($){let X=$.lastChild;if(!X||X.to!=$.to)break;if(X.type.isError&&X.from==X.to)J=$,$=X.prevSibling;else $=X}return J}get node(){return this}get next(){return this.parent}}class h9 extends Z4{constructor(Z,$,J,X){super();this._tree=Z,this.from=$,this.index=J,this._parent=X}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(Z,$,J,X,Y=0){for(let K=this;;){for(let{children:Q,positions:U}=K._tree,q=$>0?Q.length:-1;Z!=q;Z+=$){let G=Q[Z],z=U[Z]+K.from,j;if(!(Y&Z9.EnterBracketed&&G instanceof r&&(j=Q5.get(G))&&!j.overlay&&j.bracketed&&J>=z&&J<=z+G.length)&&!e6(X,J,z,z+G.length))continue;if(G instanceof R0){if(Y&Z9.ExcludeBuffers)continue;let W=G.findChild(0,G.buffer.length,$,J-z,X);if(W>-1)return new N0(new Z$(K,G,Z,z),null,W)}else if(Y&Z9.IncludeAnonymous||(!G.type.isAnonymous||$4(G))){let W;if(!(Y&Z9.IgnoreMounts)&&(W=Q5.get(G))&&!W.overlay)return new h9(W.tree,z,Z,K);let O=new h9(G,z,Z,K);return Y&Z9.IncludeAnonymous||!O.type.isAnonymous?O:O.nextChild($<0?G.children.length-1:0,$,J,X,Y)}}if(Y&Z9.IncludeAnonymous||!K.type.isAnonymous)return null;if(K.index>=0)Z=K.index+$;else Z=$<0?-1:K._parent._tree.children.length;if(K=K._parent,!K)return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(Z){return this.nextChild(0,1,Z,2)}childBefore(Z){return this.nextChild(this._tree.children.length-1,-1,Z,-2)}prop(Z){return this._tree.prop(Z)}enter(Z,$,J=0){let X;if(!(J&Z9.IgnoreOverlays)&&(X=Q5.get(this._tree))&&X.overlay){let Y=Z-this.from,K=J&Z9.EnterBracketed&&X.bracketed;for(let{from:Q,to:U}of X.overlay)if(($>0||K?Q<=Y:Q<Y)&&($<0||K?U>=Y:U>Y))return new h9(X.tree,X.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,Z,$,J)}nextSignificantParent(){let Z=this;while(Z.type.isAnonymous&&Z._parent)Z=Z._parent;return Z}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}get tree(){return this._tree}toTree(){return this._tree}toString(){return this._tree.toString()}}function o6(Z,$,J,X){let Y=Z.cursor(),K=[];if(!Y.firstChild())return K;if(J!=null){for(let Q=!1;!Q;)if(Q=Y.type.is(J),!Y.nextSibling())return K}for(;;){if(X!=null&&Y.type.is(X))return K;if(Y.type.is($))K.push(Y.node);if(!Y.nextSibling())return X==null?K:[]}}function t3(Z,$,J=$.length-1){for(let X=Z;J>=0;X=X.parent){if(!X)return!1;if(!X.type.isAnonymous){if($[J]&&$[J]!=X.name)return!1;J--}}return!0}class Z${constructor(Z,$,J,X){this.parent=Z,this.buffer=$,this.index=J,this.start=X}}class N0 extends Z4{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(Z,$,J){super();this.context=Z,this._parent=$,this.index=J,this.type=Z.buffer.set.types[Z.buffer.buffer[J]]}child(Z,$,J){let{buffer:X}=this.context,Y=X.findChild(this.index+4,X.buffer[this.index+3],Z,$-this.context.start,J);return Y<0?null:new N0(this.context,this,Y)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(Z){return this.child(1,Z,2)}childBefore(Z){return this.child(-1,Z,-2)}prop(Z){return this.type.prop(Z)}enter(Z,$,J=0){if(J&Z9.ExcludeBuffers)return null;let{buffer:X}=this.context,Y=X.findChild(this.index+4,X.buffer[this.index+3],$>0?1:-1,Z-this.context.start,$);return Y<0?null:new N0(this.context,this,Y)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(Z){return this._parent?null:this.context.parent.nextChild(this.context.index+Z,Z,0,4)}get nextSibling(){let{buffer:Z}=this.context,$=Z.buffer[this.index+3];if($<(this._parent?Z.buffer[this._parent.index+3]:Z.buffer.length))return new N0(this.context,this._parent,$);return this.externalSibling(1)}get prevSibling(){let{buffer:Z}=this.context,$=this._parent?this._parent.index+4:0;if(this.index==$)return this.externalSibling(-1);return new N0(this.context,this._parent,Z.findChild($,this.index,-1,0,4))}get tree(){return null}toTree(){let Z=[],$=[],{buffer:J}=this.context,X=this.index+4,Y=J.buffer[this.index+3];if(Y>X){let K=J.buffer[this.index+1];Z.push(J.slice(X,Y,K)),$.push(0)}return new r(this.type,Z,$,this.to-this.from)}toString(){return this.context.buffer.childString(this.index)}}function $$(Z){if(!Z.length)return null;let $=0,J=Z[0];for(let K=1;K<Z.length;K++){let Q=Z[K];if(Q.from>J.from||Q.to<J.to)J=Q,$=K}let X=J instanceof h9&&J.index<0?null:J.parent,Y=Z.slice();if(X)Y[$]=X;else Y.splice($,1);return new J$(Y,J)}class J${constructor(Z,$){this.heads=Z,this.node=$}get next(){return $$(this.heads)}}function aY(Z,$,J){let X=Z.resolveInner($,J),Y=null;for(let K=X instanceof h9?X:X.context.parent;K;K=K.parent)if(K.index<0){let Q=K.parent;(Y||(Y=[X])).push(Q.resolve($,J)),K=Q}else{let Q=Q5.get(K.tree);if(Q&&Q.overlay&&Q.overlay[0].from<=$&&Q.overlay[Q.overlay.length-1].to>=$){let U=new h9(Q.tree,Q.overlay[0].from+K.from,-1,K);(Y||(Y=[X])).push(o5(U,$,J,!1))}}return Y?$$(Y):X}class ZZ{get name(){return this.type.name}constructor(Z,$=0){if(this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,this.mode=$&~Z9.EnterBracketed,Z instanceof h9)this.yieldNode(Z);else{this._tree=Z.context.parent,this.buffer=Z.context;for(let J=Z._parent;J;J=J._parent)this.stack.unshift(J.index);this.bufferNode=Z,this.yieldBuf(Z.index)}}yieldNode(Z){if(!Z)return!1;return this._tree=Z,this.type=Z.type,this.from=Z.from,this.to=Z.to,!0}yieldBuf(Z,$){this.index=Z;let{start:J,buffer:X}=this.buffer;return this.type=$||X.set.types[X.buffer[Z]],this.from=J+X.buffer[Z+1],this.to=J+X.buffer[Z+2],!0}yield(Z){if(!Z)return!1;if(Z instanceof h9)return this.buffer=null,this.yieldNode(Z);return this.buffer=Z.context,this.yieldBuf(Z.index,Z.type)}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(Z,$,J){if(!this.buffer)return this.yield(this._tree.nextChild(Z<0?this._tree._tree.children.length-1:0,Z,$,J,this.mode));let{buffer:X}=this.buffer,Y=X.findChild(this.index+4,X.buffer[this.index+3],Z,$-this.buffer.start,J);if(Y<0)return!1;return this.stack.push(this.index),this.yieldBuf(Y)}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(Z){return this.enterChild(1,Z,2)}childBefore(Z){return this.enterChild(-1,Z,-2)}enter(Z,$,J=this.mode){if(!this.buffer)return this.yield(this._tree.enter(Z,$,J));return J&Z9.ExcludeBuffers?!1:this.enterChild(1,Z,$)}parent(){if(!this.buffer)return this.yieldNode(this.mode&Z9.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let Z=this.mode&Z9.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(Z)}sibling(Z){if(!this.buffer)return!this._tree._parent?!1:this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+Z,Z,0,4,this.mode));let{buffer:$}=this.buffer,J=this.stack.length-1;if(Z<0){let X=J<0?0:this.stack[J]+4;if(this.index!=X)return this.yieldBuf($.findChild(X,this.index,-1,0,4))}else{let X=$.buffer[this.index+3];if(X<(J<0?$.buffer.length:$.buffer[this.stack[J]+3]))return this.yieldBuf(X)}return J<0?this.yield(this.buffer.parent.nextChild(this.buffer.index+Z,Z,0,4,this.mode)):!1}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(Z){let $,J,{buffer:X}=this;if(X){if(Z>0){if(this.index<X.buffer.buffer.length)return!1}else for(let Y=0;Y<this.index;Y++)if(X.buffer.buffer[Y+3]<this.index)return!1;({index:$,parent:J}=X)}else({index:$,_parent:J}=this._tree);for(;J;{index:$,_parent:J}=J)if($>-1)for(let Y=$+Z,K=Z<0?-1:J._tree.children.length;Y!=K;Y+=Z){let Q=J._tree.children[Y];if(this.mode&Z9.IncludeAnonymous||Q instanceof R0||!Q.type.isAnonymous||$4(Q))return!1}return!0}move(Z,$){if($&&this.enterChild(Z,0,4))return!0;for(;;){if(this.sibling(Z))return!0;if(this.atLastNode(Z)||!this.parent())return!1}}next(Z=!0){return this.move(1,Z)}prev(Z=!0){return this.move(-1,Z)}moveTo(Z,$=0){while(this.from==this.to||($<1?this.from>=Z:this.from>Z)||($>-1?this.to<=Z:this.to<Z))if(!this.parent())break;while(this.enterChild(1,Z,$));return this}get node(){if(!this.buffer)return this._tree;let Z=this.bufferNode,$=null,J=0;if(Z&&Z.context==this.buffer)Z:for(let X=this.index,Y=this.stack.length;Y>=0;){for(let K=Z;K;K=K._parent)if(K.index==X){if(X==this.index)return K;$=K,J=Y+1;break Z}X=this.stack[--Y]}for(let X=J;X<this.stack.length;X++)$=new N0(this.buffer,$,this.stack[X]);return this.bufferNode=new N0(this.buffer,$,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(Z,$){for(let J=0;;){let X=!1;if(this.type.isAnonymous||Z(this)!==!1){if(this.firstChild()){J++;continue}if(!this.type.isAnonymous)X=!0}for(;;){if(X&&$)$(this);if(X=this.type.isAnonymous,!J)return;if(this.nextSibling())break;this.parent(),J--,X=!0}}}matchContext(Z){if(!this.buffer)return t3(this.node.parent,Z);let{buffer:$}=this.buffer,{types:J}=$.set;for(let X=Z.length-1,Y=this.stack.length-1;X>=0;Y--){if(Y<0)return t3(this._tree,Z,X);let K=J[$.buffer[this.stack[Y]]];if(!K.isAnonymous){if(Z[X]&&Z[X]!=K.name)return!1;X--}}return!0}}function $4(Z){return Z.children.some(($)=>$ instanceof R0||!$.type.isAnonymous||$4($))}function rY(Z){var $;let{buffer:J,nodeSet:X,maxBufferLength:Y=1024,reused:K=[],minRepeatType:Q=X.types.length}=Z,U=Array.isArray(J)?new e3(J,J.length):J,q=X.types,G=0,z=0;function j(M,T,P,x,m,c){let{id:v,start:S,end:l,size:g}=U,n=z,H9=G;if(g<0)if(U.next(),g==-1){let q0=K[v];P.push(q0),x.push(S-M);return}else if(g==-3){G=v;return}else if(g==-4){z=v;return}else throw RangeError(`Unrecognized record size: ${g}`);let L9=q[v],Z0,U9,k9=S-M;if(l-S<=Y&&(U9=H(U.pos-T,m))){let q0=new Uint16Array(U9.size-U9.skip),S9=U.pos-U9.size,$0=q0.length;while(U.pos>S9)$0=I(U9.start,q0,$0);Z0=new R0(q0,l-U9.start,X),k9=U9.start-M}else{let q0=U.pos-g;U.next();let S9=[],$0=[],C0=v>=Q?v:-1,c0=0,j7=l;while(U.pos>q0)if(C0>=0&&U.id==C0&&U.size>=0){if(U.end<=j7-Y)_(S9,$0,S,c0,U.end,j7,C0,n,H9),c0=S9.length,j7=U.end;U.next()}else if(c>2500)W(S,q0,S9,$0);else j(S,q0,S9,$0,C0,c+1);if(C0>=0&&c0>0&&c0<S9.length)_(S9,$0,S,c0,S,j7,C0,n,H9);if(S9.reverse(),$0.reverse(),C0>-1&&c0>0){let o4=O(L9,H9);Z0=J4(L9,S9,$0,0,S9.length,0,l-S,o4,o4)}else Z0=V(L9,S9,$0,l-S,n-l,H9)}P.push(Z0),x.push(k9)}function W(M,T,P,x){let m=[],c=0,v=-1;while(U.pos>T){let{id:S,start:l,end:g,size:n}=U;if(n>4)U.next();else if(v>-1&&l<v)break;else{if(v<0)v=g-Y;m.push(S,l,g),c++,U.next()}}if(c){let S=new Uint16Array(c*4),l=m[m.length-2];for(let g=m.length-3,n=0;g>=0;g-=3)S[n++]=m[g],S[n++]=m[g+1]-l,S[n++]=m[g+2]-l,S[n++]=n;P.push(new R0(S,m[2]-l,X)),x.push(l-M)}}function O(M,T){return(P,x,m)=>{let c=0,v=P.length-1,S,l;if(v>=0&&(S=P[v])instanceof r){if(!v&&S.type==M&&S.length==m)return S;if(l=S.prop(w.lookAhead))c=x[v]+S.length+l}return V(M,P,x,m,c,T)}}function _(M,T,P,x,m,c,v,S,l){let g=[],n=[];while(M.length>x)g.push(M.pop()),n.push(T.pop()+P-m);M.push(V(X.types[v],g,n,c-m,S-c,l)),T.push(m-P)}function V(M,T,P,x,m,c,v){if(c){let S=[w.contextHash,c];v=v?[S].concat(v):[S]}if(m>25){let S=[w.lookAhead,m];v=v?[S].concat(v):[S]}return new r(M,T,P,x,v)}function H(M,T){let P=U.fork(),x=0,m=0,c=0,v=P.end-Y,S={size:0,start:0,skip:0};Z:for(let l=P.pos-M;P.pos>l;){let g=P.size;if(P.id==T&&g>=0){S.size=x,S.start=m,S.skip=c,c+=4,x+=4,P.next();continue}let n=P.pos-g;if(g<0||n<l||P.start<v)break;let H9=P.id>=Q?4:0,L9=P.start;P.next();while(P.pos>n){if(P.size<0)if(P.size==-3||P.size==-4)H9+=4;else break Z;else if(P.id>=Q)H9+=4;P.next()}m=L9,x+=g,c+=H9}if(T<0||x==M)S.size=x,S.start=m,S.skip=c;return S.size>4?S:void 0}function I(M,T,P){let{id:x,start:m,end:c,size:v}=U;if(U.next(),v>=0&&x<Q){let S=P;if(v>4){let l=U.pos-(v-4);while(U.pos>l)P=I(M,T,P)}T[--P]=S,T[--P]=c-M,T[--P]=m-M,T[--P]=x}else if(v==-3)G=x;else if(v==-4)z=x;return P}let D=[],F=[];while(U.pos>0)j(Z.start||0,Z.bufferStart||0,D,F,-1,0);let C=($=Z.length)!==null&&$!==void 0?$:D.length?F[0]+D[0].length:0;return new r(q[Z.topID],D.reverse(),F.reverse(),C)}var t6=new WeakMap;function e7(Z,$){if(!Z.isAnonymous||$ instanceof R0||$.type!=Z)return 1;let J=t6.get($);if(J==null){J=1;for(let X of $.children){if(X.type!=Z||!(X instanceof r)){J=1;break}J+=e7(Z,X)}t6.set($,J)}return J}function J4(Z,$,J,X,Y,K,Q,U,q){let G=0;for(let _=X;_<Y;_++)G+=e7(Z,$[_]);let z=Math.ceil(G*1.5/8),j=[],W=[];function O(_,V,H,I,D){for(let F=H;F<I;){let C=F,M=V[F],T=e7(Z,_[F]);F++;for(;F<I;F++){let P=e7(Z,_[F]);if(T+P>=z)break;T+=P}if(F==C+1){if(T>z){let P=_[C];O(P.children,P.positions,0,P.children.length,V[C]+D);continue}j.push(_[C])}else{let P=V[F-1]+_[F-1].length-M;j.push(J4(Z,_,V,C,F,M,P,null,q))}W.push(M+D-K)}}return O($,J,X,Y,0),(U||q)(j,W,Q)}class I0{constructor(Z,$,J,X,Y=!1,K=!1){this.from=Z,this.to=$,this.tree=J,this.offset=X,this.open=(Y?1:0)|(K?2:0)}get openStart(){return(this.open&1)>0}get openEnd(){return(this.open&2)>0}static addTree(Z,$=[],J=!1){let X=[new I0(0,Z.length,Z,0,!1,J)];for(let Y of $)if(Y.to>Z.length)X.push(Y);return X}static applyChanges(Z,$,J=128){if(!$.length)return Z;let X=[],Y=1,K=Z.length?Z[0]:null;for(let Q=0,U=0,q=0;;Q++){let G=Q<$.length?$[Q]:null,z=G?G.fromA:1e9;if(z-U>=J)while(K&&K.from<z){let j=K;if(U>=j.from||z<=j.to||q){let W=Math.max(j.from,U)-q,O=Math.min(j.to,z)-q;j=W>=O?null:new I0(W,O,j.tree,j.offset+q,Q>0,!!G)}if(j)X.push(j);if(K.to>z)break;K=Y<Z.length?Z[Y++]:null}if(!G)break;U=G.toA,q=G.toA-G.toB}return X}}class JZ{startParse(Z,$,J){if(typeof Z=="string")Z=new X$(Z);return J=!J?[new t7(0,Z.length)]:J.length?J.map((X)=>new t7(X.from,X.to)):[new t7(0,0)],this.createParse(Z,$||[],J)}parse(Z,$,J){let X=this.startParse(Z,$,J);for(;;){let Y=X.advance();if(Y)return Y}}}class X${constructor(Z){this.string=Z}get length(){return this.string.length}chunk(Z){return this.string.slice(Z)}get lineChunks(){return!1}read(Z,$){return this.string.slice(Z,$)}}var dq=new w({perNode:!0});var oY=0;class v9{constructor(Z,$,J,X){this.name=Z,this.set=$,this.base=J,this.modified=X,this.id=oY++}toString(){let{name:Z}=this;for(let $ of this.modified)if($.name)Z=`${$.name}(${Z})`;return Z}static define(Z,$){let J=typeof Z=="string"?Z:"?";if(Z instanceof v9)$=Z;if($===null||$===void 0?void 0:$.base)throw Error("Can not derive from a modified tag");let X=new v9(J,[],null,[]);if(X.set.push(X),$)for(let Y of $.set)X.set.push(Y);return X}static defineModifier(Z){let $=new QZ(Z);return(J)=>{if(J.modified.indexOf($)>-1)return J;return QZ.get(J.base||J,J.modified.concat($).sort((X,Y)=>X.id-Y.id))}}}var tY=0;class QZ{constructor(Z){this.name=Z,this.instances=[],this.id=tY++}static get(Z,$){if(!$.length)return Z;let J=$[0].instances.find((Q)=>Q.base==Z&&eY($,Q.modified));if(J)return J;let X=[],Y=new v9(Z.name,X,Z,$);for(let Q of $)Q.instances.push(Y);let K=ZK($);for(let Q of Z.set)if(!Q.modified.length)for(let U of K)X.push(QZ.get(Q,U));return Y}}function eY(Z,$){return Z.length==$.length&&Z.every((J,X)=>J==$[X])}function ZK(Z){let $=[[]];for(let J=0;J<Z.length;J++)for(let X=0,Y=$.length;X<Y;X++)$.push($[X].concat(Z[J]));return $.sort((J,X)=>X.length-J.length)}function Q$(Z){let $=Object.create(null);for(let J in Z){let X=Z[J];if(!Array.isArray(X))X=[X];for(let Y of J.split(" "))if(Y){let K=[],Q=2,U=Y;for(let j=0;;){if(U=="..."&&j>0&&j+3==Y.length){Q=1;break}let W=/^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(U);if(!W)throw RangeError("Invalid path: "+Y);if(K.push(W[0]=="*"?"":W[0][0]=='"'?JSON.parse(W[0]):W[0]),j+=W[0].length,j==Y.length)break;let O=Y[j++];if(j==Y.length&&O=="!"){Q=0;break}if(O!="/")throw RangeError("Invalid path: "+Y);U=Y.slice(j)}let q=K.length-1,G=K[q];if(!G)throw RangeError("Invalid path: "+Y);let z=new U5(X,Q,q>0?K.slice(0,q):null);$[G]=z.sort($[G])}}return U$.add($)}var U$=new w({combine(Z,$){let J,X,Y;while(Z||$){if(!Z||$&&Z.depth>=$.depth)Y=$,$=$.next;else Y=Z,Z=Z.next;if(J&&J.mode==Y.mode&&!Y.context&&!J.context)continue;let K=new U5(Y.tags,Y.mode,Y.context);if(J)J.next=K;else X=K;J=K}return X}});class U5{constructor(Z,$,J,X){this.tags=Z,this.mode=$,this.context=J,this.next=X}get opaque(){return this.mode==0}get inherit(){return this.mode==1}sort(Z){if(!Z||Z.depth<this.depth)return this.next=Z,this;return Z.next=this.sort(Z.next),Z}get depth(){return this.context?this.context.length:0}}U5.empty=new U5([],2,null);function K4(Z,$){let J=Object.create(null);for(let K of Z)if(!Array.isArray(K.tag))J[K.tag.id]=K.class;else for(let Q of K.tag)J[Q.id]=K.class;let{scope:X,all:Y=null}=$||{};return{style:(K)=>{let Q=Y;for(let U of K)for(let q of U.set){let G=J[q.id];if(G){Q=Q?Q+" "+G:G;break}}return Q},scope:X}}function $K(Z,$){let J=null;for(let X of Z){let Y=X.style($);if(Y)J=J?J+" "+Y:Y}return J}function q$(Z,$,J,X=0,Y=Z.length){let K=new G$(X,Array.isArray($)?$:[$],J);K.highlightRange(Z.cursor(),X,Y,"",K.highlighters),K.flush(Y)}class G${constructor(Z,$,J){this.at=Z,this.highlighters=$,this.span=J,this.class=""}startSpan(Z,$){if($!=this.class){if(this.flush(Z),Z>this.at)this.at=Z;this.class=$}}flush(Z){if(Z>this.at&&this.class)this.span(this.at,Z,this.class)}highlightRange(Z,$,J,X,Y){let{type:K,from:Q,to:U}=Z;if(Q>=J||U<=$)return;if(K.isTop)Y=this.highlighters.filter((W)=>!W.scope||W.scope(K));let q=X,G=JK(Z)||U5.empty,z=$K(Y,G.tags);if(z){if(q)q+=" ";if(q+=z,G.mode==1)X+=(X?" ":"")+z}if(this.startSpan(Math.max($,Q),q),G.opaque)return;let j=Z.tree&&Z.tree.prop(w.mounted);if(j&&j.overlay){let W=Z.node.enter(j.overlay[0].from+Q,1),O=this.highlighters.filter((V)=>!V.scope||V.scope(j.tree.type)),_=Z.firstChild();for(let V=0,H=Q;;V++){let I=V<j.overlay.length?j.overlay[V]:null,D=I?I.from+Q:U,F=Math.max($,H),C=Math.min(J,D);if(F<C&&_){while(Z.from<C)if(this.highlightRange(Z,F,C,X,Y),this.startSpan(Math.min(C,Z.to),q),Z.to>=D||!Z.nextSibling())break}if(!I||D>J)break;if(H=I.to+Q,H>$)this.highlightRange(W.cursor(),Math.max($,I.from+Q),Math.min(J,H),"",O),this.startSpan(Math.min(J,H),q)}if(_)Z.parent()}else if(Z.firstChild()){if(j)X="";do{if(Z.to<=$)continue;if(Z.from>=J)break;this.highlightRange(Z,$,J,X,Y),this.startSpan(Math.min(J,Z.to),q)}while(Z.nextSibling());Z.parent()}}}function JK(Z){let $=Z.type.prop(U$);while($&&$.context&&!Z.matchContext($.context))$=$.next;return $||null}var A=v9.define,XZ=A(),D0=A(),Y$=A(D0),K$=A(D0),F0=A(),YZ=A(F0),X4=A(F0),Q0=A(),u0=A(Q0),Y0=A(),K0=A(),Y4=A(),t5=A(Y4),KZ=A(),N={comment:XZ,lineComment:A(XZ),blockComment:A(XZ),docComment:A(XZ),name:D0,variableName:A(D0),typeName:Y$,tagName:A(Y$),propertyName:K$,attributeName:A(K$),className:A(D0),labelName:A(D0),namespace:A(D0),macroName:A(D0),literal:F0,string:YZ,docString:A(YZ),character:A(YZ),attributeValue:A(YZ),number:X4,integer:A(X4),float:A(X4),bool:A(F0),regexp:A(F0),escape:A(F0),color:A(F0),url:A(F0),keyword:Y0,self:A(Y0),null:A(Y0),atom:A(Y0),unit:A(Y0),modifier:A(Y0),operatorKeyword:A(Y0),controlKeyword:A(Y0),definitionKeyword:A(Y0),moduleKeyword:A(Y0),operator:K0,derefOperator:A(K0),arithmeticOperator:A(K0),logicOperator:A(K0),bitwiseOperator:A(K0),compareOperator:A(K0),updateOperator:A(K0),definitionOperator:A(K0),typeOperator:A(K0),controlOperator:A(K0),punctuation:Y4,separator:A(Y4),bracket:t5,angleBracket:A(t5),squareBracket:A(t5),paren:A(t5),brace:A(t5),content:Q0,heading:u0,heading1:A(u0),heading2:A(u0),heading3:A(u0),heading4:A(u0),heading5:A(u0),heading6:A(u0),contentSeparator:A(Q0),list:A(Q0),quote:A(Q0),emphasis:A(Q0),strong:A(Q0),link:A(Q0),monospace:A(Q0),strikethrough:A(Q0),inserted:A(),deleted:A(),changed:A(),invalid:A(),meta:KZ,documentMeta:A(KZ),annotation:A(KZ),processingInstruction:A(KZ),definition:v9.defineModifier("definition"),constant:v9.defineModifier("constant"),function:v9.defineModifier("function"),standard:v9.defineModifier("standard"),local:v9.defineModifier("local"),special:v9.defineModifier("special")};for(let Z in N){let $=N[Z];if($ instanceof v9)$.name=Z}var nq=K4([{tag:N.link,class:"tok-link"},{tag:N.heading,class:"tok-heading"},{tag:N.emphasis,class:"tok-emphasis"},{tag:N.strong,class:"tok-strong"},{tag:N.keyword,class:"tok-keyword"},{tag:N.atom,class:"tok-atom"},{tag:N.bool,class:"tok-bool"},{tag:N.url,class:"tok-url"},{tag:N.labelName,class:"tok-labelName"},{tag:N.inserted,class:"tok-inserted"},{tag:N.deleted,class:"tok-deleted"},{tag:N.literal,class:"tok-literal"},{tag:N.string,class:"tok-string"},{tag:N.number,class:"tok-number"},{tag:[N.regexp,N.escape,N.special(N.string)],class:"tok-string2"},{tag:N.variableName,class:"tok-variableName"},{tag:N.local(N.variableName),class:"tok-variableName tok-local"},{tag:N.definition(N.variableName),class:"tok-variableName tok-definition"},{tag:N.special(N.variableName),class:"tok-variableName2"},{tag:N.definition(N.propertyName),class:"tok-propertyName tok-definition"},{tag:N.typeName,class:"tok-typeName"},{tag:N.namespace,class:"tok-namespace"},{tag:N.className,class:"tok-className"},{tag:N.macroName,class:"tok-macroName"},{tag:N.propertyName,class:"tok-propertyName"},{tag:N.operator,class:"tok-operator"},{tag:N.comment,class:"tok-comment"},{tag:N.meta,class:"tok-meta"},{tag:N.invalid,class:"tok-invalid"},{tag:N.punctuation,class:"tok-punctuation"}]);var Q4,q5=new w;function XK(Z){return L.define({combine:Z?($)=>$.concat(Z):void 0})}var YK=new w;class m9{constructor(Z,$,J=[],X=""){if(this.data=Z,this.name=X,!h.prototype.hasOwnProperty("tree"))Object.defineProperty(h.prototype,"tree",{get(){return K9(this)}});this.parser=$,this.extension=[A0.of(this),h.languageData.of((Y,K,Q)=>{let U=z$(Y,K,Q),q=U.type.prop(q5);if(!q)return[];let G=Y.facet(q),z=U.type.prop(YK);if(z){let j=U.resolve(K-U.from,Q);for(let W of z)if(W.test(j,Y)){let O=Y.facet(W.facet);return W.type=="replace"?O:O.concat(G)}}return G})].concat(J)}isActiveAt(Z,$,J=-1){return z$(Z,$,J).type.prop(q5)==this.data}findRegions(Z){let $=Z.facet(A0);if(($===null||$===void 0?void 0:$.data)==this.data)return[{from:0,to:Z.doc.length}];if(!$||!$.allowsNesting)return[];let J=[],X=(Y,K)=>{if(Y.prop(q5)==this.data){J.push({from:K,to:K+Y.length});return}let Q=Y.prop(w.mounted);if(Q){if(Q.tree.prop(q5)==this.data){if(Q.overlay)for(let U of Q.overlay)J.push({from:U.from+K,to:U.to+K});else J.push({from:K,to:K+Y.length});return}else if(Q.overlay){let U=J.length;if(X(Q.tree,Q.overlay[0].from+K),J.length>U)return}}for(let U=0;U<Y.children.length;U++){let q=Y.children[U];if(q instanceof r)X(q,Y.positions[U]+K)}};return X(K9(Z),0),J}get allowsNesting(){return!0}}m9.setState=k.define();function z$(Z,$,J){let X=Z.facet(A0),Y=K9(Z).topNode;if(!X||X.allowsNesting){for(let K=Y;K;K=K.enter($,J,Z9.ExcludeBuffers|Z9.EnterBracketed))if(K.type.isTop)Y=K}return Y}function K9(Z){let $=Z.field(m9.state,!1);return $?$.tree:r.empty}class R${constructor(Z){this.doc=Z,this.cursorPos=0,this.string="",this.cursor=Z.iter()}get length(){return this.doc.length}syncTo(Z){return this.string=this.cursor.next(Z-this.cursorPos).value,this.cursorPos=Z+this.string.length,this.cursorPos-this.string.length}chunk(Z){return this.syncTo(Z),this.string}get lineChunks(){return!0}read(Z,$){let J=this.cursorPos-this.string.length;if(Z<J||$>=this.cursorPos)return this.doc.sliceString(Z,$);else return this.string.slice(Z-J,$-J)}}var e5=null;class G5{constructor(Z,$,J=[],X,Y,K,Q,U){this.parser=Z,this.state=$,this.fragments=J,this.tree=X,this.treeLen=Y,this.viewport=K,this.skipped=Q,this.scheduleOn=U,this.parse=null,this.tempSkipped=[]}static create(Z,$,J){return new G5(Z,$,[],r.empty,0,J,[],null)}startParse(){return this.parser.startParse(new R$(this.state.doc),this.fragments)}work(Z,$){if($!=null&&$>=this.state.doc.length)$=void 0;if(this.tree!=r.empty&&this.isDone($!==null&&$!==void 0?$:this.state.doc.length))return this.takeTree(),!0;return this.withContext(()=>{var J;if(typeof Z=="number"){let X=Date.now()+Z;Z=()=>Date.now()>X}if(!this.parse)this.parse=this.startParse();if($!=null&&(this.parse.stoppedAt==null||this.parse.stoppedAt>$)&&$<this.state.doc.length)this.parse.stopAt($);for(;;){let X=this.parse.advance();if(X)if(this.fragments=this.withoutTempSkipped(I0.addTree(X,this.fragments,this.parse.stoppedAt!=null)),this.treeLen=(J=this.parse.stoppedAt)!==null&&J!==void 0?J:this.state.doc.length,this.tree=X,this.parse=null,this.treeLen<($!==null&&$!==void 0?$:this.state.doc.length))this.parse=this.startParse();else return!0;if(Z())return!1}})}takeTree(){let Z,$;if(this.parse&&(Z=this.parse.parsedPos)>=this.treeLen){if(this.parse.stoppedAt==null||this.parse.stoppedAt>Z)this.parse.stopAt(Z);this.withContext(()=>{while(!($=this.parse.advance()));}),this.treeLen=Z,this.tree=$,this.fragments=this.withoutTempSkipped(I0.addTree(this.tree,this.fragments,!0)),this.parse=null}}withContext(Z){let $=e5;e5=this;try{return Z()}finally{e5=$}}withoutTempSkipped(Z){for(let $;$=this.tempSkipped.pop();)Z=j$(Z,$.from,$.to);return Z}changes(Z,$){let{fragments:J,tree:X,treeLen:Y,viewport:K,skipped:Q}=this;if(this.takeTree(),!Z.empty){let U=[];if(Z.iterChangedRanges((q,G,z,j)=>U.push({fromA:q,toA:G,fromB:z,toB:j})),J=I0.applyChanges(J,U),X=r.empty,Y=0,K={from:Z.mapPos(K.from,-1),to:Z.mapPos(K.to,1)},this.skipped.length){Q=[];for(let q of this.skipped){let G=Z.mapPos(q.from,1),z=Z.mapPos(q.to,-1);if(G<z)Q.push({from:G,to:z})}}}return new G5(this.parser,$,J,X,Y,K,Q,this.scheduleOn)}updateViewport(Z){if(this.viewport.from==Z.from&&this.viewport.to==Z.to)return!1;this.viewport=Z;let $=this.skipped.length;for(let J=0;J<this.skipped.length;J++){let{from:X,to:Y}=this.skipped[J];if(X<Z.to&&Y>Z.from)this.fragments=j$(this.fragments,X,Y),this.skipped.splice(J--,1)}if(this.skipped.length>=$)return!1;return this.reset(),!0}reset(){if(this.parse)this.takeTree(),this.parse=null}skipUntilInView(Z,$){this.skipped.push({from:Z,to:$})}static getSkippingParser(Z){return new class extends JZ{createParse($,J,X){let Y=X[0].from,K=X[X.length-1].to;return{parsedPos:Y,advance(){let U=e5;if(U){for(let q of X)U.tempSkipped.push(q);if(Z)U.scheduleOn=U.scheduleOn?Promise.all([U.scheduleOn,Z]):Z}return this.parsedPos=K,new r(I9.none,[],[],K-Y)},stoppedAt:null,stopAt(){}}}}}isDone(Z){Z=Math.min(Z,this.state.doc.length);let $=this.fragments;return this.treeLen>=Z&&$.length&&$[0].from==0&&$[0].to>=Z}static get(){return e5}}function j$(Z,$,J){return I0.applyChanges(Z,[{fromA:$,toA:J,fromB:$,toB:J}])}class z5{constructor(Z){this.context=Z,this.tree=Z.tree}apply(Z){if(!Z.docChanged&&this.tree==this.context.tree)return this;let $=this.context.changes(Z.changes,Z.state),J=this.context.treeLen==Z.startState.doc.length?void 0:Math.max(Z.changes.mapPos(this.context.treeLen),$.viewport.to);if(!$.work(20,J))$.takeTree();return new z5($)}static init(Z){let $=Math.min(3000,Z.doc.length),J=G5.create(Z.facet(A0).parser,Z,{from:0,to:$});if(!J.work(20,$))J.takeTree();return new z5(J)}}m9.state=a.define({create:z5.init,update(Z,$){for(let J of $.effects)if(J.is(m9.setState))return J.value;if($.startState.facet(A0)!=$.state.facet(A0))return z5.init($.state);return Z.apply($)}});var I$=(Z)=>{let $=setTimeout(()=>Z(),500);return()=>clearTimeout($)};if(typeof requestIdleCallback<"u")I$=(Z)=>{let $=-1,J=setTimeout(()=>{$=requestIdleCallback(Z,{timeout:400})},100);return()=>$<0?clearTimeout(J):cancelIdleCallback($)};var U4=typeof navigator<"u"&&((Q4=navigator.scheduling)===null||Q4===void 0?void 0:Q4.isInputPending)?()=>navigator.scheduling.isInputPending():null,KK=o.fromClass(class{constructor($){this.view=$,this.working=null,this.workScheduled=0,this.chunkEnd=-1,this.chunkBudget=-1,this.work=this.work.bind(this),this.scheduleWork()}update($){let J=this.view.state.field(m9.state).context;if(J.updateViewport($.view.viewport)||this.view.viewport.to>J.treeLen)this.scheduleWork();if($.docChanged||$.selectionSet){if(this.view.hasFocus)this.chunkBudget+=50;this.scheduleWork()}this.checkAsyncSchedule(J)}scheduleWork(){if(this.working)return;let{state:$}=this.view,J=$.field(m9.state);if(J.tree!=J.context.tree||!J.context.isDone($.doc.length))this.working=I$(this.work)}work($){this.working=null;let J=Date.now();if(this.chunkEnd<J&&(this.chunkEnd<0||this.view.hasFocus))this.chunkEnd=J+30000,this.chunkBudget=3000;if(this.chunkBudget<=0)return;let{state:X,viewport:{to:Y}}=this.view,K=X.field(m9.state);if(K.tree==K.context.tree&&K.context.isDone(Y+1e5))return;let Q=Date.now()+Math.min(this.chunkBudget,100,$&&!U4?Math.max(25,$.timeRemaining()-5):1e9),U=K.context.treeLen<Y&&X.doc.length>Y+1000,q=K.context.work(()=>{return U4&&U4()||Date.now()>Q},Y+(U?0:1e5));if(this.chunkBudget-=Date.now()-J,q||this.chunkBudget<=0)K.context.takeTree(),this.view.dispatch({effects:m9.setState.of(new z5(K.context))});if(this.chunkBudget>0&&!(q&&!U))this.scheduleWork();this.checkAsyncSchedule(K.context)}checkAsyncSchedule($){if($.scheduleOn)this.workScheduled++,$.scheduleOn.then(()=>this.scheduleWork()).catch((J)=>j9(this.view.state,J)).then(()=>this.workScheduled--),$.scheduleOn=null}destroy(){if(this.working)this.working()}isWorking(){return!!(this.working||this.workScheduled>0)}},{eventHandlers:{focus(){this.scheduleWork()}}}),A0=L.define({combine(Z){return Z.length?Z[0]:null},enables:(Z)=>[m9.state,KK,E.contentAttributes.compute([Z],($)=>{let J=$.facet(Z);return J&&J.name?{"data-language":J.name}:{}})]});var QK=L.define(),$7=L.define({combine:(Z)=>{if(!Z.length)return"  ";let $=Z[0];if(!$||/\S/.test($)||Array.from($).some((J)=>J!=$[0]))throw Error("Invalid indent unit: "+JSON.stringify(Z[0]));return $}});function L0(Z){let $=Z.facet($7);return $.charCodeAt(0)==9?Z.tabSize*$.length:$.length}function j5(Z,$){let J="",X=Z.tabSize,Y=Z.facet($7)[0];if(Y=="\t"){while($>=X)J+="\t",$-=X;Y=" "}for(let K=0;K<$;K++)J+=Y;return J}function zZ(Z,$){if(Z instanceof h)Z=new W5(Z);for(let X of Z.state.facet(QK)){let Y=X(Z,$);if(Y!==void 0)return Y}let J=K9(Z.state);return J.length>=$?UK(Z,J,$):null}class W5{constructor(Z,$={}){this.state=Z,this.options=$,this.unit=L0(Z)}lineAt(Z,$=1){let J=this.state.doc.lineAt(Z),{simulateBreak:X,simulateDoubleBreak:Y}=this.options;if(X!=null&&X>=J.from&&X<=J.to)if(Y&&X==Z)return{text:"",from:Z};else if($<0?X<Z:X<=Z)return{text:J.text.slice(X-J.from),from:X};else return{text:J.text.slice(0,X-J.from),from:J.from};return J}textAfterPos(Z,$=1){if(this.options.simulateDoubleBreak&&Z==this.options.simulateBreak)return"";let{text:J,from:X}=this.lineAt(Z,$);return J.slice(Z-X,Math.min(J.length,Z+100-X))}column(Z,$=1){let{text:J,from:X}=this.lineAt(Z,$),Y=this.countColumn(J,Z-X),K=this.options.overrideIndentation?this.options.overrideIndentation(X):-1;if(K>-1)Y+=K-this.countColumn(J,J.search(/\S|$/));return Y}countColumn(Z,$=Z.length){return G0(Z,this.state.tabSize,$)}lineIndent(Z,$=1){let{text:J,from:X}=this.lineAt(Z,$),Y=this.options.overrideIndentation;if(Y){let K=Y(X);if(K>-1)return K}return this.countColumn(J,J.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}}var D$=new w;function UK(Z,$,J){let X=$.resolveStack(J),Y=$.resolveInner(J,-1).resolve(J,0).enterUnfinishedNodesBefore(J);if(Y!=X.node){let K=[];for(let Q=Y;Q&&!(Q.from<X.node.from||Q.to>X.node.to||Q.from==X.node.from&&Q.type==X.node.type);Q=Q.parent)K.push(Q);for(let Q=K.length-1;Q>=0;Q--)X={node:K[Q],next:X}}return F$(X,Z,J)}function F$(Z,$,J){for(let X=Z;X;X=X.next){let Y=GK(X.node);if(Y)return Y(O4.create($,J,X))}return 0}function qK(Z){return Z.pos==Z.options.simulateBreak&&Z.options.simulateDoubleBreak}function GK(Z){let $=Z.type.prop(D$);if($)return $;let J=Z.firstChild,X;if(J&&(X=J.type.prop(w.closedBy))){let Y=Z.lastChild,K=Y&&X.indexOf(Y.name)>-1;return(Q)=>OK(Q,!0,1,void 0,K&&!qK(Q)?Y.from:void 0)}return Z.parent==null?zK:null}function zK(){return 0}class O4 extends W5{constructor(Z,$,J){super(Z.state,Z.options);this.base=Z,this.pos=$,this.context=J}get node(){return this.context.node}static create(Z,$,J){return new O4(Z,$,J)}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){return this.baseIndentFor(this.node)}baseIndentFor(Z){let $=this.state.doc.lineAt(Z.from);for(;;){let J=Z.resolve($.from);while(J.parent&&J.parent.from==J.from)J=J.parent;if(jK(J,Z))break;$=this.state.doc.lineAt(J.from)}return this.lineIndent($.from)}continue(){return F$(this.context.next,this.base,this.pos)}}function jK(Z,$){for(let J=$;J;J=J.parent)if(Z==J)return!0;return!1}function WK(Z){let $=Z.node,J=$.childAfter($.from),X=$.lastChild;if(!J)return null;let Y=Z.options.simulateBreak,K=Z.state.doc.lineAt(J.from),Q=Y==null||Y<=K.from?K.to:Math.min(K.to,Y);for(let U=J.to;;){let q=$.childAfter(U);if(!q||q==X)return null;if(!q.type.isSkipped){if(q.from>=Q)return null;let G=/^ */.exec(K.text.slice(J.to-K.from))[0].length;return{from:J.from,to:J.to+G}}U=q.to}}function OK(Z,$,J,X,Y){let K=Z.textAfter,Q=K.match(/^\s*/)[0].length,U=X&&K.slice(Q,Q+X.length)==X||Y==Z.pos+Q,q=$?WK(Z):null;if(q)return U?Z.column(q.from):Z.column(q.to);return Z.baseIndent+(U?0:Z.unit*J)}var _K=200;function A$(){return h.transactionFilter.of((Z)=>{if(!Z.docChanged||!Z.isUserEvent("input.type")&&!Z.isUserEvent("input.complete"))return Z;let $=Z.startState.languageDataAt("indentOnInput",Z.startState.selection.main.head);if(!$.length)return Z;let J=Z.newDoc,{head:X}=Z.newSelection.main,Y=J.lineAt(X);if(X>Y.from+_K)return Z;let K=J.sliceString(Y.from,X);if(!$.some((G)=>G.test(K)))return Z;let{state:Q}=Z,U=-1,q=[];for(let{head:G}of Q.selection.ranges){let z=Q.doc.lineAt(G);if(z.from==U)continue;U=z.from;let j=zZ(Q,z.from);if(j==null)continue;let W=/^\s*/.exec(z.text)[0],O=j5(Q,j);if(W!=O)q.push({from:z.from,to:z.from+W.length,insert:O})}return q.length?[Z,{changes:q,sequential:!0}]:Z})}var VK=L.define(),HK=new w;function NK(Z,$,J){let X=K9(Z);if(X.length<J)return null;let Y=X.resolveStack(J,1),K=null;for(let Q=Y;Q;Q=Q.next){let U=Q.node;if(U.to<=J||U.from>J)continue;if(K&&U.from<$)break;let q=U.type.prop(HK);if(q&&(U.to<X.length-50||X.length==Z.doc.length||!RK(U))){let G=q(U,Z);if(G&&G.from<=J&&G.from>=$&&G.to>J)K=G}}return K}function RK(Z){let $=Z.lastChild;return $&&$.to==Z.to&&$.type.isError}function qZ(Z,$,J){for(let X of Z.facet(VK)){let Y=X(Z,$,J);if(Y)return Y}return NK(Z,$,J)}function L$(Z,$){let J=$.mapPos(Z.from,1),X=$.mapPos(Z.to,-1);return J>=X?void 0:{from:J,to:X}}var jZ=k.define({map:L$}),J7=k.define({map:L$});function M$(Z){let $=[];for(let{head:J}of Z.state.selection.ranges){if($.some((X)=>X.from<=J&&X.to>=J))continue;$.push(Z.lineBlockAt(J))}return $}var f0=a.define({create(){return y.none},update(Z,$){if($.isUserEvent("delete"))$.changes.iterChangedRanges((J,X)=>Z=W$(Z,J,X));Z=Z.map($.changes);for(let J of $.effects)if(J.is(jZ)&&!IK(Z,J.value.from,J.value.to)){let{preparePlaceholder:X}=$.state.facet(_4),Y=!X?O$:y.replace({widget:new y$(X($.state,J.value))});Z=Z.update({add:[Y.range(J.value.from,J.value.to)]})}else if(J.is(J7))Z=Z.update({filter:(X,Y)=>J.value.from!=X||J.value.to!=Y,filterFrom:J.value.from,filterTo:J.value.to});if($.selection)Z=W$(Z,$.selection.main.head);return Z},provide:(Z)=>E.decorations.from(Z),toJSON(Z,$){let J=[];return Z.between(0,$.doc.length,(X,Y)=>{J.push(X,Y)}),J},fromJSON(Z){if(!Array.isArray(Z)||Z.length%2)throw RangeError("Invalid JSON for fold state");let $=[];for(let J=0;J<Z.length;){let X=Z[J++],Y=Z[J++];if(typeof X!="number"||typeof Y!="number")throw RangeError("Invalid JSON for fold state");$.push(O$.range(X,Y))}return y.set($,!0)}});function W$(Z,$,J=$){let X=!1;return Z.between($,J,(Y,K)=>{if(Y<J&&K>$)X=!0}),!X?Z:Z.update({filterFrom:$,filterTo:J,filter:(Y,K)=>Y>=J||K<=$})}function GZ(Z,$,J){var X;let Y=null;return(X=Z.field(f0,!1))===null||X===void 0||X.between($,J,(K,Q)=>{if(!Y||Y.from>K)Y={from:K,to:Q}}),Y}function IK(Z,$,J){let X=!1;return Z.between($,$,(Y,K)=>{if(Y==$&&K==J)X=!0}),X}function E$(Z,$){return Z.field(f0,!1)?$:$.concat(k.appendConfig.of(C$()))}var DK=(Z)=>{for(let $ of M$(Z)){let J=qZ(Z.state,$.from,$.to);if(J)return Z.dispatch({effects:E$(Z.state,[jZ.of(J),B$(Z,J)])}),!0}return!1},FK=(Z)=>{if(!Z.state.field(f0,!1))return!1;let $=[];for(let J of M$(Z)){let X=GZ(Z.state,J.from,J.to);if(X)$.push(J7.of(X),B$(Z,X,!1))}if($.length)Z.dispatch({effects:$});return $.length>0};function B$(Z,$,J=!0){let X=Z.state.doc.lineAt($.from).number,Y=Z.state.doc.lineAt($.to).number;return E.announce.of(`${Z.state.phrase(J?"Folded lines":"Unfolded lines")} ${X} ${Z.state.phrase("to")} ${Y}.`)}var AK=(Z)=>{let{state:$}=Z,J=[];for(let X=0;X<$.doc.length;){let Y=Z.lineBlockAt(X),K=qZ($,Y.from,Y.to);if(K)J.push(jZ.of(K));X=(K?Z.lineBlockAt(K.to):Y).to+1}if(J.length)Z.dispatch({effects:E$(Z.state,J)});return!!J.length},LK=(Z)=>{let $=Z.state.field(f0,!1);if(!$||!$.size)return!1;let J=[];return $.between(0,Z.state.doc.length,(X,Y)=>{J.push(J7.of({from:X,to:Y}))}),Z.dispatch({effects:J}),!0};var P$=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:DK},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:FK},{key:"Ctrl-Alt-[",run:AK},{key:"Ctrl-Alt-]",run:LK}],MK={placeholderDOM:null,preparePlaceholder:null,placeholderText:"…"},_4=L.define({combine(Z){return _9(Z,MK)}});function C$(Z){let $=[f0,BK];if(Z)$.push(_4.of(Z));return $}function T$(Z,$){let{state:J}=Z,X=J.facet(_4),Y=(Q)=>{let U=Z.lineBlockAt(Z.posAtDOM(Q.target)),q=GZ(Z.state,U.from,U.to);if(q)Z.dispatch({effects:J7.of(q)});Q.preventDefault()};if(X.placeholderDOM)return X.placeholderDOM(Z,Y,$);let K=document.createElement("span");return K.textContent=X.placeholderText,K.setAttribute("aria-label",J.phrase("folded code")),K.title=J.phrase("unfold"),K.className="cm-foldPlaceholder",K.onclick=Y,K}var O$=y.replace({widget:new class extends C9{toDOM(Z){return T$(Z,null)}}});class y$ extends C9{constructor(Z){super();this.value=Z}eq(Z){return this.value==Z.value}toDOM(Z){return T$(Z,this.value)}}var EK={openText:"⌄",closedText:"›",markerDOM:null,domEventHandlers:{},foldingChanged:()=>!1};class UZ extends w9{constructor(Z,$){super();this.config=Z,this.open=$}eq(Z){return this.config==Z.config&&this.open==Z.open}toDOM(Z){if(this.config.markerDOM)return this.config.markerDOM(this.open);let $=document.createElement("span");return $.textContent=this.open?this.config.openText:this.config.closedText,$.title=Z.state.phrase(this.open?"Fold line":"Unfold line"),$}}function k$(Z={}){let $={...EK,...Z},J=new UZ($,!0),X=new UZ($,!1),Y=o.fromClass(class{constructor(Q){this.from=Q.viewport.from,this.markers=this.buildMarkers(Q)}update(Q){if(Q.docChanged||Q.viewportChanged||Q.startState.facet(A0)!=Q.state.facet(A0)||Q.startState.field(f0,!1)!=Q.state.field(f0,!1)||K9(Q.startState)!=K9(Q.state)||$.foldingChanged(Q))this.markers=this.buildMarkers(Q.view)}buildMarkers(Q){let U=new M9;for(let q of Q.viewportLineBlocks){let G=GZ(Q.state,q.from,q.to)?X:qZ(Q.state,q.from,q.to)?J:null;if(G)U.add(q.from,q.from,G)}return U.finish()}}),{domEventHandlers:K}=$;return[Y,r3({class:"cm-foldGutter",markers(Q){var U;return((U=Q.plugin(Y))===null||U===void 0?void 0:U.markers)||b.empty},initialSpacer(){return new UZ($,!1)},domEventHandlers:{...K,click:(Q,U,q)=>{if(K.click&&K.click(Q,U,q))return!0;let G=GZ(Q.state,U.from,U.to);if(G)return Q.dispatch({effects:J7.of(G)}),!0;let z=qZ(Q.state,U.from,U.to);if(z)return Q.dispatch({effects:jZ.of(z)}),!0;return!1}}}),C$()]}var BK=E.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});class M0{constructor(Z,$){this.specs=Z;let J;function X(Q){let U=c9.newName();return(J||(J=Object.create(null)))["."+U]=Q,U}let Y=typeof $.all=="string"?$.all:$.all?X($.all):void 0,K=$.scope;this.scope=K instanceof m9?(Q)=>Q.prop(q5)==K.data:K?(Q)=>Q==K:void 0,this.style=K4(Z.map((Q)=>({tag:Q.tag,class:Q.class||X(Object.assign({},Q,{tag:null}))})),{all:Y}).style,this.module=J?new c9(J):null,this.themeType=$.themeType}static define(Z,$){return new M0(Z,$||{})}}var z4=L.define(),S$=L.define({combine(Z){return Z.length?[Z[0]]:null}});function q4(Z){let $=Z.facet(z4);return $.length?$:Z.facet(S$)}function O5(Z,$){let J=[PK],X;if(Z instanceof M0){if(Z.module)J.push(E.styleModule.of(Z.module));X=Z.themeType}if($===null||$===void 0?void 0:$.fallback)J.push(S$.of(Z));else if(X)J.push(z4.computeN([E.darkTheme],(Y)=>{return Y.facet(E.darkTheme)==(X=="dark")?[Z]:[]}));else J.push(z4.of(Z));return J}class b${constructor(Z){this.markCache=Object.create(null),this.tree=K9(Z.state),this.decorations=this.buildDeco(Z,q4(Z.state)),this.decoratedTo=Z.viewport.to}update(Z){let $=K9(Z.state),J=q4(Z.state),X=J!=q4(Z.startState),{viewport:Y}=Z.view,K=Z.changes.mapPos(this.decoratedTo,1);if($.length<Y.to&&!X&&$.type==this.tree.type&&K>=Y.to)this.decorations=this.decorations.map(Z.changes),this.decoratedTo=K;else if($!=this.tree||Z.viewportChanged||X)this.tree=$,this.decorations=this.buildDeco(Z.view,J),this.decoratedTo=Y.to}buildDeco(Z,$){if(!$||!this.tree.length)return y.none;let J=new M9;for(let{from:X,to:Y}of Z.visibleRanges)q$(this.tree,$,(K,Q,U)=>{J.add(K,Q,this.markCache[U]||(this.markCache[U]=y.mark({class:U})))},X,Y);return J.finish()}}var PK=d9.high(o.fromClass(b$,{decorations:(Z)=>Z.decorations})),x$=M0.define([{tag:N.meta,color:"#404740"},{tag:N.link,textDecoration:"underline"},{tag:N.heading,textDecoration:"underline",fontWeight:"bold"},{tag:N.emphasis,fontStyle:"italic"},{tag:N.strong,fontWeight:"bold"},{tag:N.strikethrough,textDecoration:"line-through"},{tag:N.keyword,color:"#708"},{tag:[N.atom,N.bool,N.url,N.contentSeparator,N.labelName],color:"#219"},{tag:[N.literal,N.inserted],color:"#164"},{tag:[N.string,N.deleted],color:"#a11"},{tag:[N.regexp,N.escape,N.special(N.string)],color:"#e40"},{tag:N.definition(N.variableName),color:"#00f"},{tag:N.local(N.variableName),color:"#30a"},{tag:[N.typeName,N.namespace],color:"#085"},{tag:N.className,color:"#167"},{tag:[N.special(N.variableName),N.macroName],color:"#256"},{tag:N.definition(N.propertyName),color:"#00c"},{tag:N.comment,color:"#940"},{tag:N.invalid,color:"#f00"}]),CK=E.baseTheme({"&.cm-focused .cm-matchingBracket":{backgroundColor:"#328c8252"},"&.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bb555544"}}),w$=1e4,h$="()[]{}",v$=L.define({combine(Z){return _9(Z,{afterCursor:!0,brackets:h$,maxScanDistance:w$,renderMatch:kK})}}),TK=y.mark({class:"cm-matchingBracket"}),yK=y.mark({class:"cm-nonmatchingBracket"});function kK(Z){let $=[],J=Z.matched?TK:yK;if($.push(J.range(Z.start.from,Z.start.to)),Z.end)$.push(J.range(Z.end.from,Z.end.to));return $}var SK=a.define({create(){return y.none},update(Z,$){if(!$.docChanged&&!$.selection)return Z;let J=[],X=$.state.facet(v$);for(let Y of $.state.selection.ranges){if(!Y.empty)continue;let K=o9($.state,Y.head,-1,X)||Y.head>0&&o9($.state,Y.head-1,1,X)||X.afterCursor&&(o9($.state,Y.head,1,X)||Y.head<$.state.doc.length&&o9($.state,Y.head+1,-1,X));if(K)J=J.concat(X.renderMatch(K,$.state))}return y.set(J,!0)},provide:(Z)=>E.decorations.from(Z)}),bK=[SK,CK];function m$(Z={}){return[v$.of(Z),bK]}var xK=new w;function j4(Z,$,J){let X=Z.prop($<0?w.openedBy:w.closedBy);if(X)return X;if(Z.name.length==1){let Y=J.indexOf(Z.name);if(Y>-1&&Y%2==($<0?1:0))return[J[Y+$]]}return null}function W4(Z){let $=Z.type.prop(xK);return $?$(Z.node):Z}function o9(Z,$,J,X={}){let Y=X.maxScanDistance||w$,K=X.brackets||h$,Q=K9(Z),U=Q.resolveInner($,J);for(let q=U;q;q=q.parent){let G=j4(q.type,J,K);if(G&&q.from<q.to){let z=W4(q);if(z&&(J>0?$>=z.from&&$<z.to:$>z.from&&$<=z.to))return wK(Z,$,J,q,z,G,K)}}return hK(Z,$,J,Q,U.type,Y,K)}function wK(Z,$,J,X,Y,K,Q){let U=X.parent,q={from:Y.from,to:Y.to},G=0,z=U===null||U===void 0?void 0:U.cursor();if(z&&(J<0?z.childBefore(X.from):z.childAfter(X.to)))do if(J<0?z.to<=X.from:z.from>=X.to){if(G==0&&K.indexOf(z.type.name)>-1&&z.from<z.to){let j=W4(z);return{start:q,end:j?{from:j.from,to:j.to}:void 0,matched:!0}}else if(j4(z.type,J,Q))G++;else if(j4(z.type,-J,Q)){if(G==0){let j=W4(z);return{start:q,end:j&&j.from<j.to?{from:j.from,to:j.to}:void 0,matched:!1}}G--}}while(J<0?z.prevSibling():z.nextSibling());return{start:q,matched:!1}}function hK(Z,$,J,X,Y,K,Q){let U=J<0?Z.sliceDoc($-1,$):Z.sliceDoc($,$+1),q=Q.indexOf(U);if(q<0||q%2==0!=J>0)return null;let G={from:J<0?$-1:$,to:J>0?$+1:$},z=Z.doc.iterRange($,J>0?Z.doc.length:0),j=0;for(let W=0;!z.next().done&&W<=K;){let O=z.value;if(J<0)W+=O.length;let _=$+W*J;for(let V=J>0?0:O.length-1,H=J>0?O.length:-1;V!=H;V+=J){let I=Q.indexOf(O[V]);if(I<0||X.resolveInner(_+V,1).type!=Y)continue;if(I%2==0==J>0)j++;else if(j==1)return{start:G,end:{from:_+V,to:_+V+1},matched:I>>1==q>>1};else j--}if(J>0)W+=O.length}return z.done?{start:G,matched:!1}:null}function _$(Z,$,J,X=0,Y=0){if($==null){if($=Z.search(/[^\s\u00a0]/),$==-1)$=Z.length}let K=Y;for(let Q=X;Q<$;Q++)if(Z.charCodeAt(Q)==9)K+=J-K%J;else K++;return K}class V4{constructor(Z,$,J,X){this.string=Z,this.tabSize=$,this.indentUnit=J,this.overrideIndent=X,this.pos=0,this.start=0,this.lastColumnPos=0,this.lastColumnValue=0}eol(){return this.pos>=this.string.length}sol(){return this.pos==0}peek(){return this.string.charAt(this.pos)||void 0}next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}eat(Z){let $=this.string.charAt(this.pos),J;if(typeof Z=="string")J=$==Z;else J=$&&(Z instanceof RegExp?Z.test($):Z($));if(J)return++this.pos,$}eatWhile(Z){let $=this.pos;while(this.eat(Z));return this.pos>$}eatSpace(){let Z=this.pos;while(/[\s\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;return this.pos>Z}skipToEnd(){this.pos=this.string.length}skipTo(Z){let $=this.string.indexOf(Z,this.pos);if($>-1)return this.pos=$,!0}backUp(Z){this.pos-=Z}column(){if(this.lastColumnPos<this.start)this.lastColumnValue=_$(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start;return this.lastColumnValue}indentation(){var Z;return(Z=this.overrideIndent)!==null&&Z!==void 0?Z:_$(this.string,null,this.tabSize)}match(Z,$,J){if(typeof Z=="string"){let X=(K)=>J?K.toLowerCase():K,Y=this.string.substr(this.pos,Z.length);if(X(Y)==X(Z)){if($!==!1)this.pos+=Z.length;return!0}else return null}else{let X=this.string.slice(this.pos).match(Z);if(X&&X.index>0)return null;if(X&&$!==!1)this.pos+=X[0].length;return X}}current(){return this.string.slice(this.start,this.pos)}}function vK(Z){return{name:Z.name||"",token:Z.token,blankLine:Z.blankLine||(()=>{}),startState:Z.startState||(()=>!0),copyState:Z.copyState||mK,indent:Z.indent||(()=>null),languageData:Z.languageData||{},tokenTable:Z.tokenTable||N4,mergeTokens:Z.mergeTokens!==!1}}function mK(Z){if(typeof Z!="object")return Z;let $={};for(let J in Z){let X=Z[J];$[J]=X instanceof Array?X.slice():X}return $}var V$=new WeakMap;class WZ extends m9{constructor(Z){let $=XK(Z.languageData),J=vK(Z),X,Y=new class extends JZ{createParse(K,Q,U){return new f$(X,K,Q,U)}};super($,Y,[],Z.name);this.topNode=pK($,this),X=this,this.streamParser=J,this.stateAfter=new w({perNode:!0}),this.tokenTable=Z.tokenTable?new R4(J.tokenTable):gK}static define(Z){return new WZ(Z)}getIndent(Z){let $=void 0,{overrideIndentation:J}=Z.options;if(J){if($=V$.get(Z.state),$!=null&&$<Z.pos-1e4)$=void 0}let X=H4(this,Z.node.tree,Z.node.from,Z.node.from,$!==null&&$!==void 0?$:Z.pos),Y,K;if(X)K=X.state,Y=X.pos+1;else K=this.streamParser.startState(Z.unit),Y=Z.node.from;if(Z.pos-Y>1e4)return null;while(Y<Z.pos){let U=Z.state.doc.lineAt(Y),q=Math.min(Z.pos,U.to);if(U.length){let G=J?J(U.from):-1,z=new V4(U.text,Z.state.tabSize,Z.unit,G<0?void 0:G);while(z.pos<q-U.from)g$(this.streamParser.token,z,K)}else this.streamParser.blankLine(K,Z.unit);if(q==Z.pos)break;Y=U.to+1}let Q=Z.lineAt(Z.pos);if(J&&$==null)V$.set(Z.state,Q.from);return this.streamParser.indent(K,/^\s*(.*)/.exec(Q.text)[1],Z)}get allowsNesting(){return!1}}function H4(Z,$,J,X,Y){let K=J>=X&&J+$.length<=Y&&$.prop(Z.stateAfter);if(K)return{state:Z.streamParser.copyState(K),pos:J+$.length};for(let Q=$.children.length-1;Q>=0;Q--){let U=$.children[Q],q=J+$.positions[Q],G=U instanceof r&&q<Y&&H4(Z,U,q,X,Y);if(G)return G}return null}function u$(Z,$,J,X,Y){if(Y&&J<=0&&X>=$.length)return $;if(!Y&&J==0&&$.type==Z.topNode)Y=!0;for(let K=$.children.length-1;K>=0;K--){let Q=$.positions[K],U=$.children[K],q;if(Q<X&&U instanceof r){if(!(q=u$(Z,U,J-Q,X-Q,Y)))break;return!Y?q:new r($.type,$.children.slice(0,K).concat(q),$.positions.slice(0,K+1),Q+q.length)}}return null}function uK(Z,$,J,X,Y){for(let K of $){let Q=K.from+(K.openStart?25:0),U=K.to-(K.openEnd?25:0),q=Q<=J&&U>J&&H4(Z,K.tree,0-K.offset,J,U),G;if(q&&q.pos<=X&&(G=u$(Z,K.tree,J+K.offset,q.pos+K.offset,!1)))return{state:q.state,tree:G}}return{state:Z.streamParser.startState(Y?L0(Y):4),tree:r.empty}}class f${constructor(Z,$,J,X){this.lang=Z,this.input=$,this.fragments=J,this.ranges=X,this.stoppedAt=null,this.chunks=[],this.chunkPos=[],this.chunk=[],this.chunkReused=void 0,this.rangeIndex=0,this.to=X[X.length-1].to;let Y=G5.get(),K=X[0].from,{state:Q,tree:U}=uK(Z,J,K,this.to,Y===null||Y===void 0?void 0:Y.state);this.state=Q,this.parsedPos=this.chunkStart=K+U.length;for(let q=0;q<U.children.length;q++)this.chunks.push(U.children[q]),this.chunkPos.push(U.positions[q]);if(Y&&this.parsedPos<Y.viewport.from-1e5&&X.some((q)=>q.from<=Y.viewport.from&&q.to>=Y.viewport.from))this.state=this.lang.streamParser.startState(L0(Y.state)),Y.skipUntilInView(this.parsedPos,Y.viewport.from),this.parsedPos=Y.viewport.from;this.moveRangeIndex()}advance(){let Z=G5.get(),$=this.stoppedAt==null?this.to:Math.min(this.to,this.stoppedAt),J=Math.min($,this.chunkStart+512);if(Z)J=Math.min(J,Z.viewport.to);while(this.parsedPos<J)this.parseLine(Z);if(this.chunkStart<this.parsedPos)this.finishChunk();if(this.parsedPos>=$)return this.finish();if(Z&&this.parsedPos>=Z.viewport.to)return Z.skipUntilInView(this.parsedPos,$),this.finish();return null}stopAt(Z){this.stoppedAt=Z}lineAfter(Z){let $=this.input.chunk(Z);if(!this.input.lineChunks){let J=$.indexOf(`
`);if(J>-1)$=$.slice(0,J)}else if($==`
`)$="";return Z+$.length<=this.to?$:$.slice(0,this.to-Z)}nextLine(){let Z=this.parsedPos,$=this.lineAfter(Z),J=Z+$.length;for(let X=this.rangeIndex;;){let Y=this.ranges[X].to;if(Y>=J)break;if($=$.slice(0,Y-(J-$.length)),X++,X==this.ranges.length)break;let K=this.ranges[X].from,Q=this.lineAfter(K);$+=Q,J=K+Q.length}return{line:$,end:J}}skipGapsTo(Z,$,J){for(;;){let X=this.ranges[this.rangeIndex].to,Y=Z+$;if(J>0?X>Y:X>=Y)break;let K=this.ranges[++this.rangeIndex].from;$+=K-X}return $}moveRangeIndex(){while(this.ranges[this.rangeIndex].to<this.parsedPos)this.rangeIndex++}emitToken(Z,$,J,X){let Y=4;if(this.ranges.length>1){X=this.skipGapsTo($,X,1),$+=X;let Q=this.chunk.length;X=this.skipGapsTo(J,X,-1),J+=X,Y+=this.chunk.length-Q}let K=this.chunk.length-4;if(this.lang.streamParser.mergeTokens&&Y==4&&K>=0&&this.chunk[K]==Z&&this.chunk[K+2]==$)this.chunk[K+2]=J;else this.chunk.push(Z,$,J,Y);return X}parseLine(Z){let{line:$,end:J}=this.nextLine(),X=0,{streamParser:Y}=this.lang,K=new V4($,Z?Z.state.tabSize:4,Z?L0(Z.state):2);if(K.eol())Y.blankLine(this.state,K.indentUnit);else while(!K.eol()){let Q=g$(Y.token,K,this.state);if(Q)X=this.emitToken(this.lang.tokenTable.resolve(Q),this.parsedPos+K.start,this.parsedPos+K.pos,X);if(K.start>1e4)break}if(this.parsedPos=J,this.moveRangeIndex(),this.parsedPos<this.to)this.parsedPos++}finishChunk(){let Z=r.build({buffer:this.chunk,start:this.chunkStart,length:this.parsedPos-this.chunkStart,nodeSet:fK,topID:0,maxBufferLength:512,reused:this.chunkReused});Z=new r(Z.type,Z.children,Z.positions,Z.length,[[this.lang.stateAfter,this.lang.streamParser.copyState(this.state)]]),this.chunks.push(Z),this.chunkPos.push(this.chunkStart-this.ranges[0].from),this.chunk=[],this.chunkReused=void 0,this.chunkStart=this.parsedPos}finish(){return new r(this.lang.topNode,this.chunks,this.chunkPos,this.parsedPos-this.ranges[0].from).balance()}}function g$(Z,$,J){$.start=$.pos;for(let X=0;X<10;X++){let Y=Z($,J);if($.pos>$.start)return Y}throw Error("Stream parser failed to advance stream.")}var N4=Object.create(null),Z7=[I9.none],fK=new $Z(Z7),H$=[],N$=Object.create(null),p$=Object.create(null);for(let[Z,$]of[["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","tagName"],["attribute","attributeName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])p$[Z]=l$(N4,$);class R4{constructor(Z){this.extra=Z,this.table=Object.assign(Object.create(null),p$)}resolve(Z){return!Z?0:this.table[Z]||(this.table[Z]=l$(this.extra,Z))}}var gK=new R4(N4);function G4(Z,$){if(H$.indexOf(Z)>-1)return;H$.push(Z),console.warn($)}function l$(Z,$){let J=[];for(let U of $.split(" ")){let q=[];for(let G of U.split(".")){let z=Z[G]||N[G];if(!z)G4(G,`Unknown highlighting tag ${G}`);else if(typeof z=="function")if(!q.length)G4(G,`Modifier ${G} used at start of tag`);else q=q.map(z);else if(q.length)G4(G,`Tag ${G} used as modifier`);else q=Array.isArray(z)?z:[z]}for(let G of q)J.push(G)}if(!J.length)return 0;let X=$.replace(/ /g,"_"),Y=X+" "+J.map((U)=>U.id),K=N$[Y];if(K)return K.id;let Q=N$[Y]=I9.define({id:Z7.length,name:X,props:[Q$({[X]:J})]});return Z7.push(Q),Q.id}function pK(Z,$){let J=I9.define({id:Z7.length,name:"Document",props:[q5.add(()=>Z),D$.add(()=>(X)=>$.getIndent(X))],top:!0});return Z7.push(J),J}var ZG={rtl:y.mark({class:"cm-iso",inclusive:!0,attributes:{dir:"rtl"},bidiIsolate:p.RTL}),ltr:y.mark({class:"cm-iso",inclusive:!0,attributes:{dir:"ltr"},bidiIsolate:p.LTR}),auto:y.mark({class:"cm-iso",inclusive:!0,attributes:{dir:"auto"},bidiIsolate:null})};var lK=(Z)=>{let{state:$}=Z,J=$.doc.lineAt($.selection.main.from),X=E4(Z.state,J.from);return X.line?dK(Z):X.block?sK(Z):!1};function M4(Z,$){return({state:J,dispatch:X})=>{if(J.readOnly)return!1;let Y=Z($,J);if(!Y)return!1;return X(J.update(Y)),!0}}var dK=M4(aK,0);var cK=M4(t$,0);var sK=M4((Z,$)=>t$(Z,$,iK($)),0);function E4(Z,$){let J=Z.languageDataAt("commentTokens",$,1);return J.length?J[0]:{}}var X7=50;function nK(Z,{open:$,close:J},X,Y){let K=Z.sliceDoc(X-X7,X),Q=Z.sliceDoc(Y,Y+X7),U=/\s*$/.exec(K)[0].length,q=/^\s*/.exec(Q)[0].length,G=K.length-U;if(K.slice(G-$.length,G)==$&&Q.slice(q,q+J.length)==J)return{open:{pos:X-U,margin:U&&1},close:{pos:Y+q,margin:q&&1}};let z,j;if(Y-X<=2*X7)z=j=Z.sliceDoc(X,Y);else z=Z.sliceDoc(X,X+X7),j=Z.sliceDoc(Y-X7,Y);let W=/^\s*/.exec(z)[0].length,O=/\s*$/.exec(j)[0].length,_=j.length-O-J.length;if(z.slice(W,W+$.length)==$&&j.slice(_,_+J.length)==J)return{open:{pos:X+W+$.length,margin:/\s/.test(z.charAt(W+$.length))?1:0},close:{pos:Y-O-J.length,margin:/\s/.test(j.charAt(_-1))?1:0}};return null}function iK(Z){let $=[];for(let J of Z.selection.ranges){let X=Z.doc.lineAt(J.from),Y=J.to<=X.to?X:Z.doc.lineAt(J.to);if(Y.from>X.from&&Y.from==J.to)Y=J.to==X.to+1?X:Z.doc.lineAt(J.to-1);let K=$.length-1;if(K>=0&&$[K].to>X.from)$[K].to=Y.to;else $.push({from:X.from+/^\s*/.exec(X.text)[0].length,to:Y.to})}return $}function t$(Z,$,J=$.selection.ranges){let X=J.map((K)=>E4($,K.from).block);if(!X.every((K)=>K))return null;let Y=J.map((K,Q)=>nK($,X[Q],K.from,K.to));if(Z!=2&&!Y.every((K)=>K))return{changes:$.changes(J.map((K,Q)=>{if(Y[Q])return[];return[{from:K.from,insert:X[Q].open+" "},{from:K.to,insert:" "+X[Q].close}]}))};else if(Z!=1&&Y.some((K)=>K)){let K=[];for(let Q=0,U;Q<Y.length;Q++)if(U=Y[Q]){let q=X[Q],{open:G,close:z}=U;K.push({from:G.pos-q.open.length,to:G.pos+G.margin},{from:z.pos-z.margin,to:z.pos+q.close.length})}return{changes:K}}return null}function aK(Z,$,J=$.selection.ranges){let X=[],Y=-1;Z:for(let{from:K,to:Q}of J){let U=X.length,q=1e9,G;for(let z=K;z<=Q;){let j=$.doc.lineAt(z);if(G==null){if(G=E4($,j.from).line,!G)continue Z}if(j.from>Y&&(K==Q||Q>j.from)){Y=j.from;let W=/^\s*/.exec(j.text)[0].length,O=W==j.length,_=j.text.slice(W,W+G.length)==G?W:-1;if(W<j.text.length&&W<q)q=W;X.push({line:j,comment:_,token:G,indent:W,empty:O,single:!1})}z=j.to+1}if(q<1e9){for(let z=U;z<X.length;z++)if(X[z].indent<X[z].line.text.length)X[z].indent=q}if(X.length==U+1)X[U].single=!0}if(Z!=2&&X.some((K)=>K.comment<0&&(!K.empty||K.single))){let K=[];for(let{line:U,token:q,indent:G,empty:z,single:j}of X)if(j||!z)K.push({from:U.from+G,insert:q+" "});let Q=$.changes(K);return{changes:Q,selection:$.selection.map(Q,1)}}else if(Z!=1&&X.some((K)=>K.comment>=0)){let K=[];for(let{line:Q,comment:U,token:q}of X)if(U>=0){let G=Q.from+U,z=G+q.length;if(Q.text[z-Q.from]==" ")z++;K.push({from:G,to:z})}return{changes:K}}return null}var D4=B9.define(),rK=B9.define(),oK=L.define(),e$=L.define({combine(Z){return _9(Z,{minDepth:100,newGroupDelay:500,joinToEvent:($,J)=>J},{minDepth:Math.max,newGroupDelay:Math.min,joinToEvent:($,J)=>(X,Y)=>$(X,Y)||J(X,Y)})}}),ZJ=a.define({create(){return U0.empty},update(Z,$){let J=$.state.facet(e$),X=$.annotation(D4);if(X){let q=F9.fromTransaction($,X.selection),G=X.side,z=G==0?Z.undone:Z.done;if(q)z=_Z(z,z.length,J.minDepth,q);else z=YJ(z,$.startState.selection);return new U0(G==0?X.rest:z,G==0?z:X.rest)}let Y=$.annotation(rK);if(Y=="full"||Y=="before")Z=Z.isolate();if($.annotation(e.addToHistory)===!1)return!$.changes.empty?Z.addMapping($.changes.desc):Z;let K=F9.fromTransaction($),Q=$.annotation(e.time),U=$.annotation(e.userEvent);if(K)Z=Z.addChanges(K,Q,U,J,$);else if($.selection)Z=Z.addSelection($.startState.selection,Q,U,J.newGroupDelay);if(Y=="full"||Y=="after")Z=Z.isolate();return Z},toJSON(Z){return{done:Z.done.map(($)=>$.toJSON()),undone:Z.undone.map(($)=>$.toJSON())}},fromJSON(Z){return new U0(Z.done.map(F9.fromJSON),Z.undone.map(F9.fromJSON))}});function $J(Z={}){return[ZJ,e$.of(Z),E.domEventHandlers({beforeinput($,J){let X=$.inputType=="historyUndo"?JJ:$.inputType=="historyRedo"?F4:null;if(!X)return!1;return $.preventDefault(),X(J)}})]}function VZ(Z,$){return function({state:J,dispatch:X}){if(!$&&J.readOnly)return!1;let Y=J.field(ZJ,!1);if(!Y)return!1;let K=Y.pop(Z,J,$);if(!K)return!1;return X(K),!0}}var JJ=VZ(0,!1),F4=VZ(1,!1),tK=VZ(0,!0),eK=VZ(1,!0);class F9{constructor(Z,$,J,X,Y){this.changes=Z,this.effects=$,this.mapped=J,this.startSelection=X,this.selectionsAfter=Y}setSelAfter(Z){return new F9(this.changes,this.effects,this.mapped,this.startSelection,Z)}toJSON(){var Z,$,J;return{changes:(Z=this.changes)===null||Z===void 0?void 0:Z.toJSON(),mapped:($=this.mapped)===null||$===void 0?void 0:$.toJSON(),startSelection:(J=this.startSelection)===null||J===void 0?void 0:J.toJSON(),selectionsAfter:this.selectionsAfter.map((X)=>X.toJSON())}}static fromJSON(Z){return new F9(Z.changes&&J9.fromJSON(Z.changes),[],Z.mapped&&p9.fromJSON(Z.mapped),Z.startSelection&&R.fromJSON(Z.startSelection),Z.selectionsAfter.map(R.fromJSON))}static fromTransaction(Z,$){let J=u9;for(let X of Z.startState.facet(oK)){let Y=X(Z);if(Y.length)J=J.concat(Y)}if(!J.length&&Z.changes.empty)return null;return new F9(Z.changes.invert(Z.startState.doc),J,void 0,$||Z.startState.selection,u9)}static selection(Z){return new F9(void 0,u9,void 0,void 0,Z)}}function _Z(Z,$,J,X){let Y=$+1>J+20?$-J-1:0,K=Z.slice(Y,$);return K.push(X),K}function ZQ(Z,$){let J=[],X=!1;return Z.iterChangedRanges((Y,K)=>J.push(Y,K)),$.iterChangedRanges((Y,K,Q,U)=>{for(let q=0;q<J.length;){let G=J[q++],z=J[q++];if(U>=G&&Q<=z)X=!0}}),X}function $Q(Z,$){return Z.ranges.length==$.ranges.length&&Z.ranges.filter((J,X)=>J.empty!=$.ranges[X].empty).length===0}function XJ(Z,$){return!Z.length?$:!$.length?Z:Z.concat($)}var u9=[],JQ=200;function YJ(Z,$){if(!Z.length)return[F9.selection([$])];else{let J=Z[Z.length-1],X=J.selectionsAfter.slice(Math.max(0,J.selectionsAfter.length-JQ));if(X.length&&X[X.length-1].eq($))return Z;return X.push($),_Z(Z,Z.length-1,1e9,J.setSelAfter(X))}}function XQ(Z){let $=Z[Z.length-1],J=Z.slice();return J[Z.length-1]=$.setSelAfter($.selectionsAfter.slice(0,$.selectionsAfter.length-1)),J}function I4(Z,$){if(!Z.length)return Z;let J=Z.length,X=u9;while(J){let Y=YQ(Z[J-1],$,X);if(Y.changes&&!Y.changes.empty||Y.effects.length){let K=Z.slice(0,J);return K[J-1]=Y,K}else $=Y.mapped,J--,X=Y.selectionsAfter}return X.length?[F9.selection(X)]:u9}function YQ(Z,$,J){let X=XJ(Z.selectionsAfter.length?Z.selectionsAfter.map((U)=>U.map($)):u9,J);if(!Z.changes)return F9.selection(X);let Y=Z.changes.map($),K=$.mapDesc(Z.changes,!0),Q=Z.mapped?Z.mapped.composeDesc(K):K;return new F9(Y,k.mapEffects(Z.effects,$),Q,Z.startSelection.map(K),X)}var KQ=/^(input\.type|delete)($|\.)/;class U0{constructor(Z,$,J=0,X=void 0){this.done=Z,this.undone=$,this.prevTime=J,this.prevUserEvent=X}isolate(){return this.prevTime?new U0(this.done,this.undone):this}addChanges(Z,$,J,X,Y){let K=this.done,Q=K[K.length-1];if(Q&&Q.changes&&!Q.changes.empty&&Z.changes&&(!J||KQ.test(J))&&(!Q.selectionsAfter.length&&$-this.prevTime<X.newGroupDelay&&X.joinToEvent(Y,ZQ(Q.changes,Z.changes))||J=="input.type.compose"))K=_Z(K,K.length-1,X.minDepth,new F9(Z.changes.compose(Q.changes),XJ(k.mapEffects(Z.effects,Q.changes),Q.effects),Q.mapped,Q.startSelection,u9));else K=_Z(K,K.length,X.minDepth,Z);return new U0(K,u9,$,J)}addSelection(Z,$,J,X){let Y=this.done.length?this.done[this.done.length-1].selectionsAfter:u9;if(Y.length>0&&$-this.prevTime<X&&J==this.prevUserEvent&&J&&/^select($|\.)/.test(J)&&$Q(Y[Y.length-1],Z))return this;return new U0(YJ(this.done,Z),this.undone,$,J)}addMapping(Z){return new U0(I4(this.done,Z),I4(this.undone,Z),this.prevTime,this.prevUserEvent)}pop(Z,$,J){let X=Z==0?this.done:this.undone;if(X.length==0)return null;let Y=X[X.length-1],K=Y.selectionsAfter[0]||(Y.startSelection?Y.startSelection.map(Y.changes.invertedDesc,1):$.selection);if(J&&Y.selectionsAfter.length)return $.update({selection:Y.selectionsAfter[Y.selectionsAfter.length-1],annotations:D4.of({side:Z,rest:XQ(X),selection:K}),userEvent:Z==0?"select.undo":"select.redo",scrollIntoView:!0});else if(!Y.changes)return null;else{let Q=X.length==1?u9:X.slice(0,X.length-1);if(Y.mapped)Q=I4(Q,Y.mapped);return $.update({changes:Y.changes,selection:Y.startSelection,effects:Y.effects,annotations:D4.of({side:Z,rest:Q,selection:K}),filter:!1,userEvent:Z==0?"undo":"redo",scrollIntoView:!0})}}}U0.empty=new U0(u9,u9);var KJ=[{key:"Mod-z",run:JJ,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:F4,preventDefault:!0},{linux:"Ctrl-Shift-z",run:F4,preventDefault:!0},{key:"Mod-u",run:tK,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:eK,preventDefault:!0}];function _5(Z,$){return R.create(Z.ranges.map($),Z.mainIndex)}function t9(Z,$){return Z.update({selection:$,scrollIntoView:!0,userEvent:"select"})}function e9({state:Z,dispatch:$},J){let X=_5(Z.selection,J);if(X.eq(Z.selection,!0))return!1;return $(t9(Z,X)),!0}function HZ(Z,$){return R.cursor($?Z.to:Z.from)}function QJ(Z,$){return e9(Z,(J)=>J.empty?Z.moveByChar(J,$):HZ(J,$))}function V9(Z){return Z.textDirectionAt(Z.state.selection.main.head)==p.LTR}var UJ=(Z)=>QJ(Z,!V9(Z)),qJ=(Z)=>QJ(Z,V9(Z));function GJ(Z,$){return e9(Z,(J)=>J.empty?Z.moveByGroup(J,$):HZ(J,$))}var QQ=(Z)=>GJ(Z,!V9(Z)),UQ=(Z)=>GJ(Z,V9(Z));var zG=typeof Intl<"u"&&Intl.Segmenter?new Intl.Segmenter(void 0,{granularity:"word"}):null;function qQ(Z,$,J){if($.type.prop(J))return!0;let X=$.to-$.from;return X&&(X>2||/[^\s,.;:]/.test(Z.sliceDoc($.from,$.to)))||$.firstChild}function NZ(Z,$,J){let X=K9(Z).resolveInner($.head),Y=J?w.closedBy:w.openedBy;for(let q=$.head;;){let G=J?X.childAfter(q):X.childBefore(q);if(!G)break;if(qQ(Z,G,Y))X=G;else q=J?G.to:G.from}let K=X.type.prop(Y),Q,U;if(K&&(Q=J?o9(Z,X.from,1):o9(Z,X.to,-1))&&Q.matched)U=J?Q.end.to:Q.end.from;else U=J?X.to:X.from;return R.cursor(U,J?-1:1)}var GQ=(Z)=>e9(Z,($)=>NZ(Z.state,$,!V9(Z))),zQ=(Z)=>e9(Z,($)=>NZ(Z.state,$,V9(Z)));function zJ(Z,$){return e9(Z,(J)=>{if(!J.empty)return HZ(J,$);let X=Z.moveVertically(J,$);return X.head!=J.head?X:Z.moveToLineBoundary(J,$)})}var jJ=(Z)=>zJ(Z,!1),WJ=(Z)=>zJ(Z,!0);function OJ(Z){let $=Z.scrollDOM.clientHeight<Z.scrollDOM.scrollHeight-2,J=0,X=0,Y;if($){for(let K of Z.state.facet(E.scrollMargins)){let Q=K(Z);if(Q===null||Q===void 0?void 0:Q.top)J=Math.max(Q===null||Q===void 0?void 0:Q.top,J);if(Q===null||Q===void 0?void 0:Q.bottom)X=Math.max(Q===null||Q===void 0?void 0:Q.bottom,X)}Y=Z.scrollDOM.clientHeight-J-X}else Y=(Z.dom.ownerDocument.defaultView||window).innerHeight;return{marginTop:J,marginBottom:X,selfScroll:$,height:Math.max(Z.defaultLineHeight,Y-5)}}function _J(Z,$){let J=OJ(Z),{state:X}=Z,Y=_5(X.selection,(Q)=>{return Q.empty?Z.moveVertically(Q,$,J.height):HZ(Q,$)});if(Y.eq(X.selection))return!1;let K;if(J.selfScroll){let Q=Z.coordsAtPos(X.selection.main.head),U=Z.scrollDOM.getBoundingClientRect(),q=U.top+J.marginTop,G=U.bottom-J.marginBottom;if(Q&&Q.top>q&&Q.bottom<G)K=E.scrollIntoView(Y.main.head,{y:"start",yMargin:Q.top-q})}return Z.dispatch(t9(X,Y),{effects:K}),!0}var d$=(Z)=>_J(Z,!1),A4=(Z)=>_J(Z,!0);function E0(Z,$,J){let X=Z.lineBlockAt($.head),Y=Z.moveToLineBoundary($,J);if(Y.head==$.head&&Y.head!=(J?X.to:X.from))Y=Z.moveToLineBoundary($,J,!1);if(!J&&Y.head==X.from&&X.length){let K=/^\s*/.exec(Z.state.sliceDoc(X.from,Math.min(X.from+100,X.to)))[0].length;if(K&&$.head!=X.from+K)Y=R.cursor(X.from+K)}return Y}var jQ=(Z)=>e9(Z,($)=>E0(Z,$,!0)),WQ=(Z)=>e9(Z,($)=>E0(Z,$,!1)),OQ=(Z)=>e9(Z,($)=>E0(Z,$,!V9(Z))),_Q=(Z)=>e9(Z,($)=>E0(Z,$,V9(Z))),VQ=(Z)=>e9(Z,($)=>R.cursor(Z.lineBlockAt($.head).from,1)),HQ=(Z)=>e9(Z,($)=>R.cursor(Z.lineBlockAt($.head).to,-1));function NQ(Z,$,J){let X=!1,Y=_5(Z.selection,(K)=>{let Q=o9(Z,K.head,-1)||o9(Z,K.head,1)||K.head>0&&o9(Z,K.head-1,1)||K.head<Z.doc.length&&o9(Z,K.head+1,-1);if(!Q||!Q.end)return K;X=!0;let U=Q.start.from==K.head?Q.end.to:Q.end.from;return J?R.range(K.anchor,U):R.cursor(U)});if(!X)return!1;return $(t9(Z,Y)),!0}var RQ=({state:Z,dispatch:$})=>NQ(Z,$,!1);function f9(Z,$){let J=_5(Z.state.selection,(X)=>{let Y=$(X);return R.range(X.anchor,Y.head,Y.goalColumn,Y.bidiLevel||void 0)});if(J.eq(Z.state.selection))return!1;return Z.dispatch(t9(Z.state,J)),!0}function VJ(Z,$){return f9(Z,(J)=>Z.moveByChar(J,$))}var HJ=(Z)=>VJ(Z,!V9(Z)),NJ=(Z)=>VJ(Z,V9(Z));function RJ(Z,$){return f9(Z,(J)=>Z.moveByGroup(J,$))}var IQ=(Z)=>RJ(Z,!V9(Z)),DQ=(Z)=>RJ(Z,V9(Z));var FQ=(Z)=>f9(Z,($)=>NZ(Z.state,$,!V9(Z))),AQ=(Z)=>f9(Z,($)=>NZ(Z.state,$,V9(Z)));function IJ(Z,$){return f9(Z,(J)=>Z.moveVertically(J,$))}var DJ=(Z)=>IJ(Z,!1),FJ=(Z)=>IJ(Z,!0);function AJ(Z,$){return f9(Z,(J)=>Z.moveVertically(J,$,OJ(Z).height))}var c$=(Z)=>AJ(Z,!1),s$=(Z)=>AJ(Z,!0),LQ=(Z)=>f9(Z,($)=>E0(Z,$,!0)),MQ=(Z)=>f9(Z,($)=>E0(Z,$,!1)),EQ=(Z)=>f9(Z,($)=>E0(Z,$,!V9(Z))),BQ=(Z)=>f9(Z,($)=>E0(Z,$,V9(Z))),PQ=(Z)=>f9(Z,($)=>R.cursor(Z.lineBlockAt($.head).from)),CQ=(Z)=>f9(Z,($)=>R.cursor(Z.lineBlockAt($.head).to)),n$=({state:Z,dispatch:$})=>{return $(t9(Z,{anchor:0})),!0},i$=({state:Z,dispatch:$})=>{return $(t9(Z,{anchor:Z.doc.length})),!0},a$=({state:Z,dispatch:$})=>{return $(t9(Z,{anchor:Z.selection.main.anchor,head:0})),!0},r$=({state:Z,dispatch:$})=>{return $(t9(Z,{anchor:Z.selection.main.anchor,head:Z.doc.length})),!0},TQ=({state:Z,dispatch:$})=>{return $(Z.update({selection:{anchor:0,head:Z.doc.length},userEvent:"select"})),!0},yQ=({state:Z,dispatch:$})=>{let J=RZ(Z).map(({from:X,to:Y})=>R.range(X,Math.min(Y+1,Z.doc.length)));return $(Z.update({selection:R.create(J),userEvent:"select"})),!0},kQ=({state:Z,dispatch:$})=>{let J=_5(Z.selection,(X)=>{let Y=K9(Z),K=Y.resolveStack(X.from,1);if(X.empty){let Q=Y.resolveStack(X.from,-1);if(Q.node.from>=K.node.from&&Q.node.to<=K.node.to)K=Q}for(let Q=K;Q;Q=Q.next){let{node:U}=Q;if((U.from<X.from&&U.to>=X.to||U.to>X.to&&U.from<=X.from)&&Q.next)return R.range(U.to,U.from)}return X});if(J.eq(Z.selection))return!1;return $(t9(Z,J)),!0};function LJ(Z,$){let{state:J}=Z,X=J.selection,Y=J.selection.ranges.slice();for(let K of J.selection.ranges){let Q=J.doc.lineAt(K.head);if($?Q.to<Z.state.doc.length:Q.from>0)for(let U=K;;){let q=Z.moveVertically(U,$);if(q.head<Q.from||q.head>Q.to){if(!Y.some((G)=>G.head==q.head))Y.push(q);break}else if(q.head==U.head)break;else U=q}}if(Y.length==X.ranges.length)return!1;return Z.dispatch(t9(J,R.create(Y,Y.length-1))),!0}var SQ=(Z)=>LJ(Z,!1),bQ=(Z)=>LJ(Z,!0),xQ=({state:Z,dispatch:$})=>{let J=Z.selection,X=null;if(J.ranges.length>1)X=R.create([J.main]);else if(!J.main.empty)X=R.create([R.cursor(J.main.head)]);if(!X)return!1;return $(t9(Z,X)),!0};function Y7(Z,$){if(Z.state.readOnly)return!1;let J="delete.selection",{state:X}=Z,Y=X.changeByRange((K)=>{let{from:Q,to:U}=K;if(Q==U){let q=$(K);if(q<Q)J="delete.backward",q=OZ(Z,q,!1);else if(q>Q)J="delete.forward",q=OZ(Z,q,!0);Q=Math.min(Q,q),U=Math.max(U,q)}else Q=OZ(Z,Q,!1),U=OZ(Z,U,!0);return Q==U?{range:K}:{changes:{from:Q,to:U},range:R.cursor(Q,Q<K.head?-1:1)}});if(Y.changes.empty)return!1;return Z.dispatch(X.update(Y,{scrollIntoView:!0,userEvent:J,effects:J=="delete.selection"?E.announce.of(X.phrase("Selection deleted")):void 0})),!0}function OZ(Z,$,J){if(Z instanceof E)for(let X of Z.state.facet(E.atomicRanges).map((Y)=>Y(Z)))X.between($,$,(Y,K)=>{if(Y<$&&K>$)$=J?K:Y});return $}var MJ=(Z,$,J)=>Y7(Z,(X)=>{let Y=X.from,{state:K}=Z,Q=K.doc.lineAt(Y),U,q;if(J&&!$&&Y>Q.from&&Y<Q.from+200&&!/[^ \t]/.test(U=Q.text.slice(0,Y-Q.from))){if(U[U.length-1]=="\t")return Y-1;let G=G0(U,K.tabSize),z=G%L0(K)||L0(K);for(let j=0;j<z&&U[U.length-1-j]==" ";j++)Y--;q=Y}else if(q=X9(Q.text,Y-Q.from,$,$)+Q.from,q==Y&&Q.number!=($?K.doc.lines:1))q+=$?1:-1;else if(!$&&/[\ufe00-\ufe0f]/.test(Q.text.slice(q-Q.from,Y-Q.from)))q=X9(Q.text,q-Q.from,!1,!1)+Q.from;return q}),L4=(Z)=>MJ(Z,!1,!0);var EJ=(Z)=>MJ(Z,!0,!1),BJ=(Z,$)=>Y7(Z,(J)=>{let X=J.head,{state:Y}=Z,K=Y.doc.lineAt(X),Q=Y.charCategorizer(X);for(let U=null;;){if(X==($?K.to:K.from)){if(X==J.head&&K.number!=($?Y.doc.lines:1))X+=$?1:-1;break}let q=X9(K.text,X-K.from,$)+K.from,G=K.text.slice(Math.min(X,q)-K.from,Math.max(X,q)-K.from),z=Q(G);if(U!=null&&z!=U)break;if(G!=" "||X!=J.head)U=z;X=q}return X}),PJ=(Z)=>BJ(Z,!1),wQ=(Z)=>BJ(Z,!0);var hQ=(Z)=>Y7(Z,($)=>{let J=Z.lineBlockAt($.head).to;return $.head<J?J:Math.min(Z.state.doc.length,$.head+1)});var vQ=(Z)=>Y7(Z,($)=>{let J=Z.moveToLineBoundary($,!1).head;return $.head>J?J:Math.max(0,$.head-1)}),mQ=(Z)=>Y7(Z,($)=>{let J=Z.moveToLineBoundary($,!0).head;return $.head<J?J:Math.min(Z.state.doc.length,$.head+1)});var uQ=({state:Z,dispatch:$})=>{if(Z.readOnly)return!1;let J=Z.changeByRange((X)=>{return{changes:{from:X.from,to:X.to,insert:u.of(["",""])},range:R.cursor(X.from)}});return $(Z.update(J,{scrollIntoView:!0,userEvent:"input"})),!0},fQ=({state:Z,dispatch:$})=>{if(Z.readOnly)return!1;let J=Z.changeByRange((X)=>{if(!X.empty||X.from==0||X.from==Z.doc.length)return{range:X};let Y=X.from,K=Z.doc.lineAt(Y),Q=Y==K.from?Y-1:X9(K.text,Y-K.from,!1)+K.from,U=Y==K.to?Y+1:X9(K.text,Y-K.from,!0)+K.from;return{changes:{from:Q,to:U,insert:Z.doc.slice(Y,U).append(Z.doc.slice(Q,Y))},range:R.cursor(U)}});if(J.changes.empty)return!1;return $(Z.update(J,{scrollIntoView:!0,userEvent:"move.character"})),!0};function RZ(Z){let $=[],J=-1;for(let X of Z.selection.ranges){let Y=Z.doc.lineAt(X.from),K=Z.doc.lineAt(X.to);if(!X.empty&&X.to==K.from)K=Z.doc.lineAt(X.to-1);if(J>=Y.number){let Q=$[$.length-1];Q.to=K.to,Q.ranges.push(X)}else $.push({from:Y.from,to:K.to,ranges:[X]});J=K.number+1}return $}function CJ(Z,$,J){if(Z.readOnly)return!1;let X=[],Y=[];for(let K of RZ(Z)){if(J?K.to==Z.doc.length:K.from==0)continue;let Q=Z.doc.lineAt(J?K.to+1:K.from-1),U=Q.length+1;if(J){X.push({from:K.to,to:Q.to},{from:K.from,insert:Q.text+Z.lineBreak});for(let q of K.ranges)Y.push(R.range(Math.min(Z.doc.length,q.anchor+U),Math.min(Z.doc.length,q.head+U)))}else{X.push({from:Q.from,to:K.from},{from:K.to,insert:Z.lineBreak+Q.text});for(let q of K.ranges)Y.push(R.range(q.anchor-U,q.head-U))}}if(!X.length)return!1;return $(Z.update({changes:X,scrollIntoView:!0,selection:R.create(Y,Z.selection.mainIndex),userEvent:"move.line"})),!0}var gQ=({state:Z,dispatch:$})=>CJ(Z,$,!1),pQ=({state:Z,dispatch:$})=>CJ(Z,$,!0);function TJ(Z,$,J){if(Z.readOnly)return!1;let X=[];for(let K of RZ(Z))if(J)X.push({from:K.from,insert:Z.doc.slice(K.from,K.to)+Z.lineBreak});else X.push({from:K.to,insert:Z.lineBreak+Z.doc.slice(K.from,K.to)});let Y=Z.changes(X);return $(Z.update({changes:Y,selection:Z.selection.map(Y,J?1:-1),scrollIntoView:!0,userEvent:"input.copyline"})),!0}var lQ=({state:Z,dispatch:$})=>TJ(Z,$,!1),dQ=({state:Z,dispatch:$})=>TJ(Z,$,!0),cQ=(Z)=>{if(Z.state.readOnly)return!1;let{state:$}=Z,J=$.changes(RZ($).map(({from:Y,to:K})=>{if(Y>0)Y--;else if(K<$.doc.length)K++;return{from:Y,to:K}})),X=_5($.selection,(Y)=>{let K=void 0;if(Z.lineWrapping){let Q=Z.lineBlockAt(Y.head),U=Z.coordsAtPos(Y.head,Y.assoc||1);if(U)K=Q.bottom+Z.documentTop-U.bottom+Z.defaultLineHeight/2}return Z.moveVertically(Y,!0,K)}).map(J);return Z.dispatch({changes:J,selection:X,scrollIntoView:!0,userEvent:"delete.line"}),!0};function sQ(Z,$){if(/\(\)|\[\]|\{\}/.test(Z.sliceDoc($-1,$+1)))return{from:$,to:$};let J=K9(Z).resolveInner($),X=J.childBefore($),Y=J.childAfter($),K;if(X&&Y&&X.to<=$&&Y.from>=$&&(K=X.type.prop(w.closedBy))&&K.indexOf(Y.name)>-1&&Z.doc.lineAt(X.to).from==Z.doc.lineAt(Y.from).from&&!/\S/.test(Z.sliceDoc(X.to,Y.from)))return{from:X.to,to:Y.from};return null}var o$=yJ(!1),nQ=yJ(!0);function yJ(Z){return({state:$,dispatch:J})=>{if($.readOnly)return!1;let X=$.changeByRange((Y)=>{let{from:K,to:Q}=Y,U=$.doc.lineAt(K),q=!Z&&K==Q&&sQ($,K);if(Z)K=Q=(Q<=U.to?U:$.doc.lineAt(Q)).to;let G=new W5($,{simulateBreak:K,simulateDoubleBreak:!!q}),z=zZ(G,K);if(z==null)z=G0(/^\s*/.exec($.doc.lineAt(K).text)[0],$.tabSize);while(Q<U.to&&/\s/.test(U.text[Q-U.from]))Q++;if(q)({from:K,to:Q}=q);else if(K>U.from&&K<U.from+100&&!/\S/.test(U.text.slice(0,K)))K=U.from;let j=["",j5($,z)];if(q)j.push(j5($,G.lineIndent(U.from,-1)));return{changes:{from:K,to:Q,insert:u.of(j)},range:R.cursor(K+1+j[1].length)}});return J($.update(X,{scrollIntoView:!0,userEvent:"input"})),!0}}function B4(Z,$){let J=-1;return Z.changeByRange((X)=>{let Y=[];for(let Q=X.from;Q<=X.to;){let U=Z.doc.lineAt(Q);if(U.number>J&&(X.empty||X.to>U.from))$(U,Y,X),J=U.number;Q=U.to+1}let K=Z.changes(Y);return{changes:Y,range:R.range(K.mapPos(X.anchor,1),K.mapPos(X.head,1))}})}var iQ=({state:Z,dispatch:$})=>{if(Z.readOnly)return!1;let J=Object.create(null),X=new W5(Z,{overrideIndentation:(K)=>{let Q=J[K];return Q==null?-1:Q}}),Y=B4(Z,(K,Q,U)=>{let q=zZ(X,K.from);if(q==null)return;if(!/\S/.test(K.text))q=0;let G=/^\s*/.exec(K.text)[0],z=j5(Z,q);if(G!=z||U.from<K.from+G.length)J[K.from]=q,Q.push({from:K.from,to:K.from+G.length,insert:z})});if(!Y.changes.empty)$(Z.update(Y,{userEvent:"indent"}));return!0},aQ=({state:Z,dispatch:$})=>{if(Z.readOnly)return!1;return $(Z.update(B4(Z,(J,X)=>{X.push({from:J.from,insert:Z.facet($7)})}),{userEvent:"input.indent"})),!0},rQ=({state:Z,dispatch:$})=>{if(Z.readOnly)return!1;return $(Z.update(B4(Z,(J,X)=>{let Y=/^\s*/.exec(J.text)[0];if(!Y)return;let K=G0(Y,Z.tabSize),Q=0,U=j5(Z,Math.max(0,K-L0(Z)));while(Q<Y.length&&Q<U.length&&Y.charCodeAt(Q)==U.charCodeAt(Q))Q++;X.push({from:J.from+Q,to:J.from+Y.length,insert:U.slice(Q)})}),{userEvent:"delete.dedent"})),!0},oQ=(Z)=>{return Z.setTabFocusMode(),!0};var tQ=[{key:"Ctrl-b",run:UJ,shift:HJ,preventDefault:!0},{key:"Ctrl-f",run:qJ,shift:NJ},{key:"Ctrl-p",run:jJ,shift:DJ},{key:"Ctrl-n",run:WJ,shift:FJ},{key:"Ctrl-a",run:VQ,shift:PQ},{key:"Ctrl-e",run:HQ,shift:CQ},{key:"Ctrl-d",run:EJ},{key:"Ctrl-h",run:L4},{key:"Ctrl-k",run:hQ},{key:"Ctrl-Alt-h",run:PJ},{key:"Ctrl-o",run:uQ},{key:"Ctrl-t",run:fQ},{key:"Ctrl-v",run:A4}],eQ=[{key:"ArrowLeft",run:UJ,shift:HJ,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:QQ,shift:IQ,preventDefault:!0},{mac:"Cmd-ArrowLeft",run:OQ,shift:EQ,preventDefault:!0},{key:"ArrowRight",run:qJ,shift:NJ,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:UQ,shift:DQ,preventDefault:!0},{mac:"Cmd-ArrowRight",run:_Q,shift:BQ,preventDefault:!0},{key:"ArrowUp",run:jJ,shift:DJ,preventDefault:!0},{mac:"Cmd-ArrowUp",run:n$,shift:a$},{mac:"Ctrl-ArrowUp",run:d$,shift:c$},{key:"ArrowDown",run:WJ,shift:FJ,preventDefault:!0},{mac:"Cmd-ArrowDown",run:i$,shift:r$},{mac:"Ctrl-ArrowDown",run:A4,shift:s$},{key:"PageUp",run:d$,shift:c$},{key:"PageDown",run:A4,shift:s$},{key:"Home",run:WQ,shift:MQ,preventDefault:!0},{key:"Mod-Home",run:n$,shift:a$},{key:"End",run:jQ,shift:LQ,preventDefault:!0},{key:"Mod-End",run:i$,shift:r$},{key:"Enter",run:o$,shift:o$},{key:"Mod-a",run:TQ},{key:"Backspace",run:L4,shift:L4,preventDefault:!0},{key:"Delete",run:EJ,preventDefault:!0},{key:"Mod-Backspace",mac:"Alt-Backspace",run:PJ,preventDefault:!0},{key:"Mod-Delete",mac:"Alt-Delete",run:wQ,preventDefault:!0},{mac:"Mod-Backspace",run:vQ,preventDefault:!0},{mac:"Mod-Delete",run:mQ,preventDefault:!0}].concat(tQ.map((Z)=>({mac:Z.key,run:Z.run,shift:Z.shift}))),kJ=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:GQ,shift:FQ},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:zQ,shift:AQ},{key:"Alt-ArrowUp",run:gQ},{key:"Shift-Alt-ArrowUp",run:lQ},{key:"Alt-ArrowDown",run:pQ},{key:"Shift-Alt-ArrowDown",run:dQ},{key:"Mod-Alt-ArrowUp",run:SQ},{key:"Mod-Alt-ArrowDown",run:bQ},{key:"Escape",run:xQ},{key:"Mod-Enter",run:nQ},{key:"Alt-l",mac:"Ctrl-l",run:yQ},{key:"Mod-i",run:kQ,preventDefault:!0},{key:"Mod-[",run:rQ},{key:"Mod-]",run:aQ},{key:"Mod-Alt-\\",run:iQ},{key:"Shift-Mod-k",run:cQ},{key:"Shift-Mod-\\",run:RQ},{key:"Mod-/",run:lK},{key:"Alt-A",run:cK},{key:"Ctrl-m",mac:"Shift-Alt-m",run:oQ}].concat(eQ);var SJ=typeof String.prototype.normalize=="function"?(Z)=>Z.normalize("NFKD"):(Z)=>Z;class g0{constructor(Z,$,J=0,X=Z.length,Y,K){this.test=K,this.value={from:0,to:0},this.done=!1,this.matches=[],this.buffer="",this.bufferPos=0,this.iter=Z.iterRange(J,X),this.bufferStart=J,this.normalize=Y?(Q)=>Y(SJ(Q)):SJ,this.query=this.normalize($)}peek(){if(this.bufferPos==this.buffer.length){if(this.bufferStart+=this.buffer.length,this.iter.next(),this.iter.done)return-1;this.bufferPos=0,this.buffer=this.iter.value}return G9(this.buffer,this.bufferPos)}next(){while(this.matches.length)this.matches.pop();return this.nextOverlapping()}nextOverlapping(){for(;;){let Z=this.peek();if(Z<0)return this.done=!0,this;let $=B5(Z),J=this.bufferStart+this.bufferPos;this.bufferPos+=E9(Z);let X=this.normalize($);if(X.length)for(let Y=0,K=J;;Y++){let Q=X.charCodeAt(Y),U=this.match(Q,K,this.bufferPos+this.bufferStart);if(Y==X.length-1){if(U)return this.value=U,this;break}if(K==J&&Y<$.length&&$.charCodeAt(Y)==Q)K++}}}match(Z,$,J){let X=null;for(let Y=0;Y<this.matches.length;Y+=2){let K=this.matches[Y],Q=!1;if(this.query.charCodeAt(K)==Z)if(K==this.query.length-1)X={from:this.matches[Y+1],to:J};else this.matches[Y]++,Q=!0;if(!Q)this.matches.splice(Y,2),Y-=2}if(this.query.charCodeAt(0)==Z)if(this.query.length==1)X={from:$,to:J};else this.matches.push(1,$);if(X&&this.test&&!this.test(X.from,X.to,this.buffer,this.bufferStart))X=null;return X}}if(typeof Symbol<"u")g0.prototype[Symbol.iterator]=function(){return this};var wJ={from:-1,to:-1,match:/.*/.exec("")},T4="gm"+(/x/.unicode==null?"":"u");class y4{constructor(Z,$,J,X=0,Y=Z.length){if(this.text=Z,this.to=Y,this.curLine="",this.done=!1,this.value=wJ,/\\[sWDnr]|\n|\r|\[\^/.test($))return new k4(Z,$,J,X,Y);this.re=new RegExp($,T4+((J===null||J===void 0?void 0:J.ignoreCase)?"i":"")),this.test=J===null||J===void 0?void 0:J.test,this.iter=Z.iter();let K=Z.lineAt(X);this.curLineStart=K.from,this.matchPos=AZ(Z,X),this.getLine(this.curLineStart)}getLine(Z){if(this.iter.next(Z),this.iter.lineBreak)this.curLine="";else{if(this.curLine=this.iter.value,this.curLineStart+this.curLine.length>this.to)this.curLine=this.curLine.slice(0,this.to-this.curLineStart);this.iter.next()}}nextLine(){if(this.curLineStart=this.curLineStart+this.curLine.length+1,this.curLineStart>this.to)this.curLine="";else this.getLine(0)}next(){for(let Z=this.matchPos-this.curLineStart;;){this.re.lastIndex=Z;let $=this.matchPos<=this.to&&this.re.exec(this.curLine);if($){let J=this.curLineStart+$.index,X=J+$[0].length;if(this.matchPos=AZ(this.text,X+(J==X?1:0)),J==this.curLineStart+this.curLine.length)this.nextLine();if((J<X||J>this.value.to)&&(!this.test||this.test(J,X,$)))return this.value={from:J,to:X,match:$},this;Z=this.matchPos-this.curLineStart}else if(this.curLineStart+this.curLine.length<this.to)this.nextLine(),Z=0;else return this.done=!0,this}}}var P4=new WeakMap;class N5{constructor(Z,$){this.from=Z,this.text=$}get to(){return this.from+this.text.length}static get(Z,$,J){let X=P4.get(Z);if(!X||X.from>=J||X.to<=$){let Q=new N5($,Z.sliceString($,J));return P4.set(Z,Q),Q}if(X.from==$&&X.to==J)return X;let{text:Y,from:K}=X;if(K>$)Y=Z.sliceString($,K)+Y,K=$;if(X.to<J)Y+=Z.sliceString(X.to,J);return P4.set(Z,new N5(K,Y)),new N5($,Y.slice($-K,J-K))}}class k4{constructor(Z,$,J,X,Y){this.text=Z,this.to=Y,this.done=!1,this.value=wJ,this.matchPos=AZ(Z,X),this.re=new RegExp($,T4+((J===null||J===void 0?void 0:J.ignoreCase)?"i":"")),this.test=J===null||J===void 0?void 0:J.test,this.flat=N5.get(Z,X,this.chunkEnd(X+5000))}chunkEnd(Z){return Z>=this.to?this.to:this.text.lineAt(Z).to}next(){for(;;){let Z=this.re.lastIndex=this.matchPos-this.flat.from,$=this.re.exec(this.flat.text);if($&&!$[0]&&$.index==Z)this.re.lastIndex=Z+1,$=this.re.exec(this.flat.text);if($){let J=this.flat.from+$.index,X=J+$[0].length;if((this.flat.to>=this.to||$.index+$[0].length<=this.flat.text.length-10)&&(!this.test||this.test(J,X,$)))return this.value={from:J,to:X,match:$},this.matchPos=AZ(this.text,X+(J==X?1:0)),this}if(this.flat.to==this.to)return this.done=!0,this;this.flat=N5.get(this.text,this.flat.from,this.chunkEnd(this.flat.from+this.flat.text.length*2))}}}if(typeof Symbol<"u")y4.prototype[Symbol.iterator]=k4.prototype[Symbol.iterator]=function(){return this};function ZU(Z){try{return new RegExp(Z,T4),!0}catch($){return!1}}function AZ(Z,$){if($>=Z.length)return $;let J=Z.lineAt($),X;while($<J.to&&(X=J.text.charCodeAt($-J.from))>=56320&&X<57344)$++;return $}var $U=(Z)=>{let{state:$}=Z,J=String($.doc.lineAt(Z.state.selection.main.head).number),{close:X,result:Y}=l6(Z,{label:$.phrase("Go to line"),input:{type:"text",name:"line",value:J},focus:!0,submitLabel:$.phrase("go")});return Y.then((K)=>{let Q=K&&/^([+-])?(\d+)?(:\d+)?(%)?$/.exec(K.elements.line.value);if(!Q){Z.dispatch({effects:X});return}let U=$.doc.lineAt($.selection.main.head),[,q,G,z,j]=Q,W=z?+z.slice(1):0,O=G?+G:U.number;if(G&&j){let H=O/100;if(q)H=H*(q=="-"?-1:1)+U.number/$.doc.lines;O=Math.round($.doc.lines*H)}else if(G&&q)O=O*(q=="-"?-1:1)+U.number;let _=$.doc.line(Math.max(1,Math.min($.doc.lines,O))),V=R.cursor(_.from+Math.max(0,Math.min(W,_.length)));Z.dispatch({effects:[X,E.scrollIntoView(V.from,{y:"center"})],selection:V})}),!0},JU={highlightWordAroundCursor:!1,minSelectionLength:1,maxMatches:100,wholeWords:!1},hJ=L.define({combine(Z){return _9(Z,JU,{highlightWordAroundCursor:($,J)=>$||J,minSelectionLength:Math.min,maxMatches:Math.min})}});function vJ(Z){let $=[UU,QU];if(Z)$.push(hJ.of(Z));return $}var XU=y.mark({class:"cm-selectionMatch"}),YU=y.mark({class:"cm-selectionMatch cm-selectionMatch-main"});function bJ(Z,$,J,X){return(J==0||Z($.sliceDoc(J-1,J))!=d.Word)&&(X==$.doc.length||Z($.sliceDoc(X,X+1))!=d.Word)}function KU(Z,$,J,X){return Z($.sliceDoc(J,J+1))==d.Word&&Z($.sliceDoc(X-1,X))==d.Word}var QU=o.fromClass(class{constructor(Z){this.decorations=this.getDeco(Z)}update(Z){if(Z.selectionSet||Z.docChanged||Z.viewportChanged)this.decorations=this.getDeco(Z.view)}getDeco(Z){let $=Z.state.facet(hJ),{state:J}=Z,X=J.selection;if(X.ranges.length>1)return y.none;let Y=X.main,K,Q=null;if(Y.empty){if(!$.highlightWordAroundCursor)return y.none;let q=J.wordAt(Y.head);if(!q)return y.none;Q=J.charCategorizer(Y.head),K=J.sliceDoc(q.from,q.to)}else{let q=Y.to-Y.from;if(q<$.minSelectionLength||q>200)return y.none;if($.wholeWords){if(K=J.sliceDoc(Y.from,Y.to),Q=J.charCategorizer(Y.head),!(bJ(Q,J,Y.from,Y.to)&&KU(Q,J,Y.from,Y.to)))return y.none}else if(K=J.sliceDoc(Y.from,Y.to),!K)return y.none}let U=[];for(let q of Z.visibleRanges){let G=new g0(J.doc,K,q.from,q.to);while(!G.next().done){let{from:z,to:j}=G.value;if(!Q||bJ(Q,J,z,j)){if(Y.empty&&z<=Y.from&&j>=Y.to)U.push(YU.range(z,j));else if(z>=Y.to||j<=Y.from)U.push(XU.range(z,j));if(U.length>$.maxMatches)return y.none}}}return y.set(U)}},{decorations:(Z)=>Z.decorations}),UU=E.baseTheme({".cm-selectionMatch":{backgroundColor:"#99ff7780"},".cm-searchMatch .cm-selectionMatch":{backgroundColor:"transparent"}}),qU=({state:Z,dispatch:$})=>{let{selection:J}=Z,X=R.create(J.ranges.map((Y)=>Z.wordAt(Y.head)||R.cursor(Y.head)),J.mainIndex);if(X.eq(J))return!1;return $(Z.update({selection:X})),!0};function GU(Z,$){let{main:J,ranges:X}=Z.selection,Y=Z.wordAt(J.head),K=Y&&Y.from==J.from&&Y.to==J.to;for(let Q=!1,U=new g0(Z.doc,$,X[X.length-1].to);;)if(U.next(),U.done){if(Q)return null;U=new g0(Z.doc,$,0,Math.max(0,X[X.length-1].from-1)),Q=!0}else{if(Q&&X.some((q)=>q.from==U.value.from))continue;if(K){let q=Z.wordAt(U.value.from);if(!q||q.from!=U.value.from||q.to!=U.value.to)continue}return U.value}}var zU=({state:Z,dispatch:$})=>{let{ranges:J}=Z.selection;if(J.some((K)=>K.from===K.to))return qU({state:Z,dispatch:$});let X=Z.sliceDoc(J[0].from,J[0].to);if(Z.selection.ranges.some((K)=>Z.sliceDoc(K.from,K.to)!=X))return!1;let Y=GU(Z,X);if(!Y)return!1;return $(Z.update({selection:Z.selection.addRange(R.range(Y.from,Y.to),!1),effects:E.scrollIntoView(Y.to)})),!0},R5=L.define({combine(Z){return _9(Z,{top:!1,caseSensitive:!1,literal:!1,regexp:!1,wholeWord:!1,createPanel:($)=>new cJ($),scrollToMatch:($)=>E.scrollIntoView($)})}});class S4{constructor(Z){this.search=Z.search,this.caseSensitive=!!Z.caseSensitive,this.literal=!!Z.literal,this.regexp=!!Z.regexp,this.replace=Z.replace||"",this.valid=!!this.search&&(!this.regexp||ZU(this.search)),this.unquoted=this.unquote(this.search),this.wholeWord=!!Z.wholeWord,this.test=Z.test}unquote(Z){return this.literal?Z:Z.replace(/\\([nrt\\])/g,($,J)=>J=="n"?`
`:J=="r"?"\r":J=="t"?"\t":"\\")}eq(Z){return this.search==Z.search&&this.replace==Z.replace&&this.caseSensitive==Z.caseSensitive&&this.regexp==Z.regexp&&this.wholeWord==Z.wholeWord&&this.test==Z.test}create(){return this.regexp?new uJ(this):new mJ(this)}getCursor(Z,$=0,J){let X=Z.doc?Z:h.create({doc:Z});if(J==null)J=X.doc.length;return this.regexp?H5(this,X,$,J):V5(this,X,$,J)}}class b4{constructor(Z){this.spec=Z}}function jU(Z,$,J){return(X,Y,K,Q)=>{if(J&&!J(X,Y,K,Q))return!1;let U=X>=Q&&Y<=Q+K.length?K.slice(X-Q,Y-Q):$.doc.sliceString(X,Y);return Z(U,$,X,Y)}}function V5(Z,$,J,X){let Y;if(Z.wholeWord)Y=WU($.doc,$.charCategorizer($.selection.main.head));if(Z.test)Y=jU(Z.test,$,Y);return new g0($.doc,Z.unquoted,J,X,Z.caseSensitive?void 0:(K)=>K.toLowerCase(),Y)}function WU(Z,$){return(J,X,Y,K)=>{if(K>J||K+Y.length<X)K=Math.max(0,J-2),Y=Z.sliceString(K,Math.min(Z.length,X+2));return($(LZ(Y,J-K))!=d.Word||$(MZ(Y,J-K))!=d.Word)&&($(MZ(Y,X-K))!=d.Word||$(LZ(Y,X-K))!=d.Word)}}class mJ extends b4{constructor(Z){super(Z)}nextMatch(Z,$,J){let X=V5(this.spec,Z,J,Z.doc.length).nextOverlapping();if(X.done){let Y=Math.min(Z.doc.length,$+this.spec.unquoted.length);X=V5(this.spec,Z,0,Y).nextOverlapping()}return X.done||X.value.from==$&&X.value.to==J?null:X.value}prevMatchInRange(Z,$,J){for(let X=J;;){let Y=Math.max($,X-1e4-this.spec.unquoted.length),K=V5(this.spec,Z,Y,X),Q=null;while(!K.nextOverlapping().done)Q=K.value;if(Q)return Q;if(Y==$)return null;X-=1e4}}prevMatch(Z,$,J){let X=this.prevMatchInRange(Z,0,$);if(!X)X=this.prevMatchInRange(Z,Math.max(0,J-this.spec.unquoted.length),Z.doc.length);return X&&(X.from!=$||X.to!=J)?X:null}getReplacement(Z){return this.spec.unquote(this.spec.replace)}matchAll(Z,$){let J=V5(this.spec,Z,0,Z.doc.length),X=[];while(!J.next().done){if(X.length>=$)return null;X.push(J.value)}return X}highlight(Z,$,J,X){let Y=V5(this.spec,Z,Math.max(0,$-this.spec.unquoted.length),Math.min(J+this.spec.unquoted.length,Z.doc.length));while(!Y.next().done)X(Y.value.from,Y.value.to)}}function OU(Z,$,J){return(X,Y,K)=>{return(!J||J(X,Y,K))&&Z(K[0],$,X,Y)}}function H5(Z,$,J,X){let Y;if(Z.wholeWord)Y=_U($.charCategorizer($.selection.main.head));if(Z.test)Y=OU(Z.test,$,Y);return new y4($.doc,Z.search,{ignoreCase:!Z.caseSensitive,test:Y},J,X)}function LZ(Z,$){return Z.slice(X9(Z,$,!1),$)}function MZ(Z,$){return Z.slice($,X9(Z,$))}function _U(Z){return($,J,X)=>!X[0].length||(Z(LZ(X.input,X.index))!=d.Word||Z(MZ(X.input,X.index))!=d.Word)&&(Z(MZ(X.input,X.index+X[0].length))!=d.Word||Z(LZ(X.input,X.index+X[0].length))!=d.Word)}class uJ extends b4{nextMatch(Z,$,J){let X=H5(this.spec,Z,J,Z.doc.length).next();if(X.done)X=H5(this.spec,Z,0,$).next();return X.done?null:X.value}prevMatchInRange(Z,$,J){for(let X=1;;X++){let Y=Math.max($,J-X*1e4),K=H5(this.spec,Z,Y,J),Q=null;while(!K.next().done)Q=K.value;if(Q&&(Y==$||Q.from>Y+10))return Q;if(Y==$)return null}}prevMatch(Z,$,J){return this.prevMatchInRange(Z,0,$)||this.prevMatchInRange(Z,J,Z.doc.length)}getReplacement(Z){return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g,($,J)=>{if(J=="&")return Z.match[0];if(J=="$")return"$";for(let X=J.length;X>0;X--){let Y=+J.slice(0,X);if(Y>0&&Y<Z.match.length)return Z.match[Y]+J.slice(X)}return $})}matchAll(Z,$){let J=H5(this.spec,Z,0,Z.doc.length),X=[];while(!J.next().done){if(X.length>=$)return null;X.push(J.value)}return X}highlight(Z,$,J,X){let Y=H5(this.spec,Z,Math.max(0,$-250),Math.min(J+250,Z.doc.length));while(!Y.next().done)X(Y.value.from,Y.value.to)}}var K7=k.define(),x4=k.define(),B0=a.define({create(Z){return new FZ(C4(Z).create(),null)},update(Z,$){for(let J of $.effects)if(J.is(K7))Z=new FZ(J.value.create(),Z.panel);else if(J.is(x4))Z=new FZ(Z.query,J.value?w4:null);return Z},provide:(Z)=>v0.from(Z,($)=>$.panel)});class FZ{constructor(Z,$){this.query=Z,this.panel=$}}var VU=y.mark({class:"cm-searchMatch"}),HU=y.mark({class:"cm-searchMatch cm-searchMatch-selected"}),NU=o.fromClass(class{constructor(Z){this.view=Z,this.decorations=this.highlight(Z.state.field(B0))}update(Z){let $=Z.state.field(B0);if($!=Z.startState.field(B0)||Z.docChanged||Z.selectionSet||Z.viewportChanged)this.decorations=this.highlight($)}highlight({query:Z,panel:$}){if(!$||!Z.spec.valid)return y.none;let{view:J}=this,X=new M9;for(let Y=0,K=J.visibleRanges,Q=K.length;Y<Q;Y++){let{from:U,to:q}=K[Y];while(Y<Q-1&&q>K[Y+1].from-500)q=K[++Y].to;Z.highlight(J.state,U,q,(G,z)=>{let j=J.state.selection.ranges.some((W)=>W.from==G&&W.to==z);X.add(G,z,j?HU:VU)})}return X.finish()}},{decorations:(Z)=>Z.decorations});function Q7(Z){return($)=>{let J=$.state.field(B0,!1);return J&&J.query.spec.valid?Z($,J):pJ($)}}var EZ=Q7((Z,{query:$})=>{let{to:J}=Z.state.selection.main,X=$.nextMatch(Z.state,J,J);if(!X)return!1;let Y=R.single(X.from,X.to),K=Z.state.facet(R5);return Z.dispatch({selection:Y,effects:[h4(Z,X),K.scrollToMatch(Y.main,Z)],userEvent:"select.search"}),gJ(Z),!0}),BZ=Q7((Z,{query:$})=>{let{state:J}=Z,{from:X}=J.selection.main,Y=$.prevMatch(J,X,X);if(!Y)return!1;let K=R.single(Y.from,Y.to),Q=Z.state.facet(R5);return Z.dispatch({selection:K,effects:[h4(Z,Y),Q.scrollToMatch(K.main,Z)],userEvent:"select.search"}),gJ(Z),!0}),RU=Q7((Z,{query:$})=>{let J=$.matchAll(Z.state,1000);if(!J||!J.length)return!1;return Z.dispatch({selection:R.create(J.map((X)=>R.range(X.from,X.to))),userEvent:"select.search.matches"}),!0}),IU=({state:Z,dispatch:$})=>{let J=Z.selection;if(J.ranges.length>1||J.main.empty)return!1;let{from:X,to:Y}=J.main,K=[],Q=0;for(let U=new g0(Z.doc,Z.sliceDoc(X,Y));!U.next().done;){if(K.length>1000)return!1;if(U.value.from==X)Q=K.length;K.push(R.range(U.value.from,U.value.to))}return $(Z.update({selection:R.create(K,Q),userEvent:"select.search.matches"})),!0},xJ=Q7((Z,{query:$})=>{let{state:J}=Z,{from:X,to:Y}=J.selection.main;if(J.readOnly)return!1;let K=$.nextMatch(J,X,X);if(!K)return!1;let Q=K,U=[],q,G,z=[];if(Q.from==X&&Q.to==Y)G=J.toText($.getReplacement(Q)),U.push({from:Q.from,to:Q.to,insert:G}),Q=$.nextMatch(J,Q.from,Q.to),z.push(E.announce.of(J.phrase("replaced match on line $",J.doc.lineAt(X).number)+"."));let j=Z.state.changes(U);if(Q)q=R.single(Q.from,Q.to).map(j),z.push(h4(Z,Q)),z.push(J.facet(R5).scrollToMatch(q.main,Z));return Z.dispatch({changes:j,selection:q,effects:z,userEvent:"input.replace"}),!0}),DU=Q7((Z,{query:$})=>{if(Z.state.readOnly)return!1;let J=$.matchAll(Z.state,1e9).map((Y)=>{let{from:K,to:Q}=Y;return{from:K,to:Q,insert:$.getReplacement(Y)}});if(!J.length)return!1;let X=Z.state.phrase("replaced $ matches",J.length)+".";return Z.dispatch({changes:J,effects:E.announce.of(X),userEvent:"input.replace.all"}),!0});function w4(Z){return Z.state.facet(R5).createPanel(Z)}function C4(Z,$){var J,X,Y,K,Q;let U=Z.selection.main,q=U.empty||U.to>U.from+100?"":Z.sliceDoc(U.from,U.to);if($&&!q)return $;let G=Z.facet(R5);return new S4({search:((J=$===null||$===void 0?void 0:$.literal)!==null&&J!==void 0?J:G.literal)?q:q.replace(/\n/g,"\\n"),caseSensitive:(X=$===null||$===void 0?void 0:$.caseSensitive)!==null&&X!==void 0?X:G.caseSensitive,literal:(Y=$===null||$===void 0?void 0:$.literal)!==null&&Y!==void 0?Y:G.literal,regexp:(K=$===null||$===void 0?void 0:$.regexp)!==null&&K!==void 0?K:G.regexp,wholeWord:(Q=$===null||$===void 0?void 0:$.wholeWord)!==null&&Q!==void 0?Q:G.wholeWord})}function fJ(Z){let $=r5(Z,w4);return $&&$.dom.querySelector("[main-field]")}function gJ(Z){let $=fJ(Z);if($&&$==Z.root.activeElement)$.select()}var pJ=(Z)=>{let $=Z.state.field(B0,!1);if($&&$.panel){let J=fJ(Z);if(J&&J!=Z.root.activeElement){let X=C4(Z.state,$.query.spec);if(X.valid)Z.dispatch({effects:K7.of(X)});J.focus(),J.select()}}else Z.dispatch({effects:[x4.of(!0),$?K7.of(C4(Z.state,$.query.spec)):k.appendConfig.of(AU)]});return!0},lJ=(Z)=>{let $=Z.state.field(B0,!1);if(!$||!$.panel)return!1;let J=r5(Z,w4);if(J&&J.dom.contains(Z.root.activeElement))Z.focus();return Z.dispatch({effects:x4.of(!1)}),!0},dJ=[{key:"Mod-f",run:pJ,scope:"editor search-panel"},{key:"F3",run:EZ,shift:BZ,scope:"editor search-panel",preventDefault:!0},{key:"Mod-g",run:EZ,shift:BZ,scope:"editor search-panel",preventDefault:!0},{key:"Escape",run:lJ,scope:"editor search-panel"},{key:"Mod-Shift-l",run:IU},{key:"Mod-Alt-g",run:$U},{key:"Mod-d",run:zU,preventDefault:!0}];class cJ{constructor(Z){this.view=Z;let $=this.query=Z.state.field(B0).query.spec;this.commit=this.commit.bind(this),this.searchField=f("input",{value:$.search,placeholder:T9(Z,"Find"),"aria-label":T9(Z,"Find"),class:"cm-textfield",name:"search",form:"","main-field":"true",onchange:this.commit,onkeyup:this.commit}),this.replaceField=f("input",{value:$.replace,placeholder:T9(Z,"Replace"),"aria-label":T9(Z,"Replace"),class:"cm-textfield",name:"replace",form:"",onchange:this.commit,onkeyup:this.commit}),this.caseField=f("input",{type:"checkbox",name:"case",form:"",checked:$.caseSensitive,onchange:this.commit}),this.reField=f("input",{type:"checkbox",name:"re",form:"",checked:$.regexp,onchange:this.commit}),this.wordField=f("input",{type:"checkbox",name:"word",form:"",checked:$.wholeWord,onchange:this.commit});function J(X,Y,K){return f("button",{class:"cm-button",name:X,onclick:Y,type:"button"},K)}this.dom=f("div",{onkeydown:(X)=>this.keydown(X),class:"cm-search"},[this.searchField,J("next",()=>EZ(Z),[T9(Z,"next")]),J("prev",()=>BZ(Z),[T9(Z,"previous")]),J("select",()=>RU(Z),[T9(Z,"all")]),f("label",null,[this.caseField,T9(Z,"match case")]),f("label",null,[this.reField,T9(Z,"regexp")]),f("label",null,[this.wordField,T9(Z,"by word")]),...Z.state.readOnly?[]:[f("br"),this.replaceField,J("replace",()=>xJ(Z),[T9(Z,"replace")]),J("replaceAll",()=>DU(Z),[T9(Z,"replace all")])],f("button",{name:"close",onclick:()=>lJ(Z),"aria-label":T9(Z,"close"),type:"button"},["×"])])}commit(){let Z=new S4({search:this.searchField.value,caseSensitive:this.caseField.checked,regexp:this.reField.checked,wholeWord:this.wordField.checked,replace:this.replaceField.value});if(!Z.eq(this.query))this.query=Z,this.view.dispatch({effects:K7.of(Z)})}keydown(Z){if(M6(this.view,Z,"search-panel"))Z.preventDefault();else if(Z.keyCode==13&&Z.target==this.searchField)Z.preventDefault(),(Z.shiftKey?BZ:EZ)(this.view);else if(Z.keyCode==13&&Z.target==this.replaceField)Z.preventDefault(),xJ(this.view)}update(Z){for(let $ of Z.transactions)for(let J of $.effects)if(J.is(K7)&&!J.value.eq(this.query))this.setQuery(J.value)}setQuery(Z){this.query=Z,this.searchField.value=Z.search,this.replaceField.value=Z.replace,this.caseField.checked=Z.caseSensitive,this.reField.checked=Z.regexp,this.wordField.checked=Z.wholeWord}mount(){this.searchField.select()}get pos(){return 80}get top(){return this.view.state.facet(R5).top}}function T9(Z,$){return Z.state.phrase($)}var IZ=30,DZ=/[\s\.,:;?!]/;function h4(Z,{from:$,to:J}){let X=Z.state.doc.lineAt($),Y=Z.state.doc.lineAt(J).to,K=Math.max(X.from,$-IZ),Q=Math.min(Y,J+IZ),U=Z.state.sliceDoc(K,Q);if(K!=X.from){for(let q=0;q<IZ;q++)if(!DZ.test(U[q+1])&&DZ.test(U[q])){U=U.slice(q);break}}if(Q!=Y){for(let q=U.length-1;q>U.length-IZ;q--)if(!DZ.test(U[q-1])&&DZ.test(U[q])){U=U.slice(0,q);break}}return E.announce.of(`${Z.state.phrase("current match")}. ${U} ${Z.state.phrase("on line")} ${X.number}.`)}var FU=E.baseTheme({".cm-panel.cm-search":{padding:"2px 6px 4px",position:"relative","& [name=close]":{position:"absolute",top:"0",right:"4px",backgroundColor:"inherit",border:"none",font:"inherit",padding:0,margin:0},"& input, & button, & label":{margin:".2em .6em .2em 0"},"& input[type=checkbox]":{marginRight:".2em"},"& label":{fontSize:"80%",whiteSpace:"pre"}},"&light .cm-searchMatch":{backgroundColor:"#ffff0054"},"&dark .cm-searchMatch":{backgroundColor:"#00ffff8a"},"&light .cm-searchMatch-selected":{backgroundColor:"#ff6a0054"},"&dark .cm-searchMatch-selected":{backgroundColor:"#ff00ff8a"}}),AU=[B0,d9.low(NU),FU];class g4{constructor(Z,$,J,X){this.state=Z,this.pos=$,this.explicit=J,this.view=X,this.abortListeners=[],this.abortOnDocChange=!1}tokenBefore(Z){let $=K9(this.state).resolveInner(this.pos,-1);while($&&Z.indexOf($.name)<0)$=$.parent;return $?{from:$.from,to:this.pos,text:this.state.sliceDoc($.from,this.pos),type:$.type}:null}matchBefore(Z){let $=this.state.doc.lineAt(this.pos),J=Math.max($.from,this.pos-250),X=$.text.slice(J-$.from,this.pos-$.from),Y=X.search(eJ(Z,!1));return Y<0?null:{from:J+Y,to:this.pos,text:X.slice(Y)}}get aborted(){return this.abortListeners==null}addEventListener(Z,$,J){if(Z=="abort"&&this.abortListeners){if(this.abortListeners.push($),J&&J.onDocChange)this.abortOnDocChange=!0}}}function sJ(Z){let $=Object.keys(Z).join(""),J=/\w/.test($);if(J)$=$.replace(/\w/g,"");return`[${J?"\\w":""}${$.replace(/[^\w\s]/g,"\\$&")}]`}function LU(Z){let $=Object.create(null),J=Object.create(null);for(let{label:Y}of Z){$[Y[0]]=!0;for(let K=1;K<Y.length;K++)J[Y[K]]=!0}let X=sJ($)+sJ(J)+"*$";return[new RegExp("^"+X),new RegExp(X)]}function MU(Z){let $=Z.map((Y)=>typeof Y=="string"?{label:Y}:Y),[J,X]=$.every((Y)=>/^\w+$/.test(Y.label))?[/\w*$/,/\w+$/]:LU($);return(Y)=>{let K=Y.matchBefore(X);return K||Y.explicit?{from:K?K.from:Y.pos,options:$,validFor:J}:null}}class f4{constructor(Z,$,J,X){this.completion=Z,this.source=$,this.match=J,this.score=X}}function l0(Z){return Z.selection.main.from}function eJ(Z,$){var J;let{source:X}=Z,Y=$&&X[0]!="^",K=X[X.length-1]!="$";if(!Y&&!K)return Z;return new RegExp(`${Y?"^":""}(?:${X})${K?"$":""}`,(J=Z.flags)!==null&&J!==void 0?J:Z.ignoreCase?"i":"")}var Z2=B9.define();function EU(Z,$,J,X){let{main:Y}=Z.selection,K=J-Y.from,Q=X-Y.from;return{...Z.changeByRange((U)=>{if(U!=Y&&J!=X&&Z.sliceDoc(U.from+K,U.from+Q)!=Z.sliceDoc(J,X))return{range:U};let q=Z.toText($);return{changes:{from:U.from+K,to:X==Y.from?U.to:U.from+Q,insert:q},range:R.cursor(U.from+K+q.length)}}),scrollIntoView:!0,userEvent:"input.complete"}}var nJ=new WeakMap;function BU(Z){if(!Array.isArray(Z))return Z;let $=nJ.get(Z);if(!$)nJ.set(Z,$=MU(Z));return $}var CZ=k.define(),U7=k.define();class $2{constructor(Z){this.pattern=Z,this.chars=[],this.folded=[],this.any=[],this.precise=[],this.byWord=[],this.score=0,this.matched=[];for(let $=0;$<Z.length;){let J=G9(Z,$),X=E9(J);this.chars.push(J);let Y=Z.slice($,$+X),K=Y.toUpperCase();this.folded.push(G9(K==Y?Y.toLowerCase():K,0)),$+=X}this.astral=Z.length!=this.chars.length}ret(Z,$){return this.score=Z,this.matched=$,this}match(Z){if(this.pattern.length==0)return this.ret(-100,[]);if(Z.length<this.pattern.length)return null;let{chars:$,folded:J,any:X,precise:Y,byWord:K}=this;if($.length==1){let I=G9(Z,0),D=E9(I),F=D==Z.length?0:-100;if(I==$[0]);else if(I==J[0])F+=-200;else return null;return this.ret(F,[0,D])}let Q=Z.indexOf(this.pattern);if(Q==0)return this.ret(Z.length==this.pattern.length?0:-100,[0,this.pattern.length]);let U=$.length,q=0;if(Q<0){for(let I=0,D=Math.min(Z.length,200);I<D&&q<U;){let F=G9(Z,I);if(F==$[q]||F==J[q])X[q++]=I;I+=E9(F)}if(q<U)return null}let G=0,z=0,j=!1,W=0,O=-1,_=-1,V=/[a-z]/.test(Z),H=!0;for(let I=0,D=Math.min(Z.length,200),F=0;I<D&&z<U;){let C=G9(Z,I);if(Q<0){if(G<U&&C==$[G])Y[G++]=I;if(W<U)if(C==$[W]||C==J[W]){if(W==0)O=I;_=I+1,W++}else W=0}let M,T=C<255?C>=48&&C<=57||C>=97&&C<=122?2:C>=65&&C<=90?1:0:(M=B5(C))!=M.toLowerCase()?1:M!=M.toUpperCase()?2:0;if(!I||T==1&&V||F==0&&T!=0){if($[z]==C||J[z]==C&&(j=!0))K[z++]=I;else if(K.length)H=!1}F=T,I+=E9(C)}if(z==U&&K[0]==0&&H)return this.result(-100+(j?-200:0),K,Z);if(W==U&&O==0)return this.ret(-200-Z.length+(_==Z.length?0:-100),[0,_]);if(Q>-1)return this.ret(-700-Z.length,[Q,Q+this.pattern.length]);if(W==U)return this.ret(-900-Z.length,[O,_]);if(z==U)return this.result(-100+(j?-200:0)+-700+(H?0:-1100),K,Z);return $.length==2?null:this.result((X[0]?-700:0)+-200+-1100,X,Z)}result(Z,$,J){let X=[],Y=0;for(let K of $){let Q=K+(this.astral?E9(G9(J,K)):1);if(Y&&X[Y-1]==K)X[Y-1]=Q;else X[Y++]=K,X[Y++]=Q}return this.ret(Z-J.length,X)}}class J2{constructor(Z){this.pattern=Z,this.matched=[],this.score=0,this.folded=Z.toLowerCase()}match(Z){if(Z.length<this.pattern.length)return null;let $=Z.slice(0,this.pattern.length),J=$==this.pattern?0:$.toLowerCase()==this.folded?-200:null;if(J==null)return null;return this.matched=[0,$.length],this.score=J+(Z.length==this.pattern.length?0:-100),this}}var Q9=L.define({combine(Z){return _9(Z,{activateOnTyping:!0,activateOnCompletion:()=>!1,activateOnTypingDelay:100,selectOnOpen:!0,override:null,closeOnBlur:!0,maxRenderedOptions:100,defaultKeymap:!0,tooltipClass:()=>"",optionClass:()=>"",aboveCursor:!1,icons:!0,addToOptions:[],positionInfo:PU,filterStrict:!1,compareCompletions:($,J)=>($.sortText||$.label).localeCompare(J.sortText||J.label),interactionDelay:75,updateSyncTime:100},{defaultKeymap:($,J)=>$&&J,closeOnBlur:($,J)=>$&&J,icons:($,J)=>$&&J,tooltipClass:($,J)=>(X)=>iJ($(X),J(X)),optionClass:($,J)=>(X)=>iJ($(X),J(X)),addToOptions:($,J)=>$.concat(J),filterStrict:($,J)=>$||J})}});function iJ(Z,$){return Z?$?Z+" "+$:Z:$}function PU(Z,$,J,X,Y,K){let Q=Z.textDirection==p.RTL,U=Q,q=!1,G="top",z,j,W=$.left-Y.left,O=Y.right-$.right,_=X.right-X.left,V=X.bottom-X.top;if(U&&W<Math.min(_,O))U=!1;else if(!U&&O<Math.min(_,W))U=!0;if(_<=(U?W:O))z=Math.max(Y.top,Math.min(J.top,Y.bottom-V))-$.top,j=Math.min(400,U?W:O);else{q=!0,j=Math.min(400,(Q?$.right:Y.right-$.left)-30);let D=Y.bottom-$.bottom;if(D>=V||D>$.top)z=J.bottom-$.top;else G="bottom",z=$.bottom-J.top}let H=($.bottom-$.top)/K.offsetHeight,I=($.right-$.left)/K.offsetWidth;return{style:`${G}: ${z/H}px; max-width: ${j/I}px`,class:"cm-completionInfo-"+(q?Q?"left-narrow":"right-narrow":U?"left":"right")}}function CU(Z){let $=Z.addToOptions.slice();if(Z.icons)$.push({render(J){let X=document.createElement("div");if(X.classList.add("cm-completionIcon"),J.type)X.classList.add(...J.type.split(/\s+/g).map((Y)=>"cm-completionIcon-"+Y));return X.setAttribute("aria-hidden","true"),X},position:20});return $.push({render(J,X,Y,K){let Q=document.createElement("span");Q.className="cm-completionLabel";let U=J.displayLabel||J.label,q=0;for(let G=0;G<K.length;){let z=K[G++],j=K[G++];if(z>q)Q.appendChild(document.createTextNode(U.slice(q,z)));let W=Q.appendChild(document.createElement("span"));W.appendChild(document.createTextNode(U.slice(z,j))),W.className="cm-completionMatchedText",q=j}if(q<U.length)Q.appendChild(document.createTextNode(U.slice(q)));return Q},position:50},{render(J){if(!J.detail)return null;let X=document.createElement("span");return X.className="cm-completionDetail",X.textContent=J.detail,X},position:80}),$.sort((J,X)=>J.position-X.position).map((J)=>J.render)}function v4(Z,$,J){if(Z<=J)return{from:0,to:Z};if($<0)$=0;if($<=Z>>1){let Y=Math.floor($/J);return{from:Y*J,to:(Y+1)*J}}let X=Math.floor((Z-$)/J);return{from:Z-(X+1)*J,to:Z-X*J}}class X2{constructor(Z,$,J){this.view=Z,this.stateField=$,this.applyCompletion=J,this.info=null,this.infoDestroy=null,this.placeInfoReq={read:()=>this.measureInfo(),write:(U)=>this.placeInfo(U),key:this},this.space=null,this.currentClass="";let X=Z.state.field($),{options:Y,selected:K}=X.open,Q=Z.state.facet(Q9);this.optionContent=CU(Q),this.optionClass=Q.optionClass,this.tooltipClass=Q.tooltipClass,this.range=v4(Y.length,K,Q.maxRenderedOptions),this.dom=document.createElement("div"),this.dom.className="cm-tooltip-autocomplete",this.updateTooltipClass(Z.state),this.dom.addEventListener("mousedown",(U)=>{let{options:q}=Z.state.field($).open;for(let G=U.target,z;G&&G!=this.dom;G=G.parentNode)if(G.nodeName=="LI"&&(z=/-(\d+)$/.exec(G.id))&&+z[1]<q.length){this.applyCompletion(Z,q[+z[1]]),U.preventDefault();return}}),this.dom.addEventListener("focusout",(U)=>{let q=Z.state.field(this.stateField,!1);if(q&&q.tooltip&&Z.state.facet(Q9).closeOnBlur&&U.relatedTarget!=Z.contentDOM)Z.dispatch({effects:U7.of(null)})}),this.showOptions(Y,X.id)}mount(){this.updateSel()}showOptions(Z,$){if(this.list)this.list.remove();this.list=this.dom.appendChild(this.createListBox(Z,$,this.range)),this.list.addEventListener("scroll",()=>{if(this.info)this.view.requestMeasure(this.placeInfoReq)})}update(Z){var $;let J=Z.state.field(this.stateField),X=Z.startState.field(this.stateField);if(this.updateTooltipClass(Z.state),J!=X){let{options:Y,selected:K,disabled:Q}=J.open;if(!X.open||X.open.options!=Y)this.range=v4(Y.length,K,Z.state.facet(Q9).maxRenderedOptions),this.showOptions(Y,J.id);if(this.updateSel(),Q!=(($=X.open)===null||$===void 0?void 0:$.disabled))this.dom.classList.toggle("cm-tooltip-autocomplete-disabled",!!Q)}}updateTooltipClass(Z){let $=this.tooltipClass(Z);if($!=this.currentClass){for(let J of this.currentClass.split(" "))if(J)this.dom.classList.remove(J);for(let J of $.split(" "))if(J)this.dom.classList.add(J);this.currentClass=$}}positioned(Z){if(this.space=Z,this.info)this.view.requestMeasure(this.placeInfoReq)}updateSel(){let Z=this.view.state.field(this.stateField),$=Z.open;if($.selected>-1&&$.selected<this.range.from||$.selected>=this.range.to)this.range=v4($.options.length,$.selected,this.view.state.facet(Q9).maxRenderedOptions),this.showOptions($.options,Z.id);let J=this.updateSelectedOption($.selected);if(J){this.destroyInfo();let{completion:X}=$.options[$.selected],{info:Y}=X;if(!Y)return;let K=typeof Y==="string"?document.createTextNode(Y):Y(X);if(!K)return;if("then"in K)K.then((Q)=>{if(Q&&this.view.state.field(this.stateField,!1)==Z)this.addInfoPane(Q,X)}).catch((Q)=>j9(this.view.state,Q,"completion info"));else this.addInfoPane(K,X),J.setAttribute("aria-describedby",this.info.id)}}addInfoPane(Z,$){this.destroyInfo();let J=this.info=document.createElement("div");if(J.className="cm-tooltip cm-completionInfo",J.id="cm-completionInfo-"+Math.floor(Math.random()*65535).toString(16),Z.nodeType!=null)J.appendChild(Z),this.infoDestroy=null;else{let{dom:X,destroy:Y}=Z;J.appendChild(X),this.infoDestroy=Y||null}this.dom.appendChild(J),this.view.requestMeasure(this.placeInfoReq)}updateSelectedOption(Z){let $=null;for(let J=this.list.firstChild,X=this.range.from;J;J=J.nextSibling,X++)if(J.nodeName!="LI"||!J.id)X--;else if(X==Z){if(!J.hasAttribute("aria-selected"))J.setAttribute("aria-selected","true"),$=J}else if(J.hasAttribute("aria-selected"))J.removeAttribute("aria-selected"),J.removeAttribute("aria-describedby");if($)yU(this.list,$);return $}measureInfo(){let Z=this.dom.querySelector("[aria-selected]");if(!Z||!this.info)return null;let $=this.dom.getBoundingClientRect(),J=this.info.getBoundingClientRect(),X=Z.getBoundingClientRect(),Y=this.space;if(!Y){let K=this.dom.ownerDocument.documentElement;Y={left:0,top:0,right:K.clientWidth,bottom:K.clientHeight}}if(X.top>Math.min(Y.bottom,$.bottom)-10||X.bottom<Math.max(Y.top,$.top)+10)return null;return this.view.state.facet(Q9).positionInfo(this.view,$,X,J,Y,this.dom)}placeInfo(Z){if(this.info)if(Z){if(Z.style)this.info.style.cssText=Z.style;this.info.className="cm-tooltip cm-completionInfo "+(Z.class||"")}else this.info.style.cssText="top: -1e6px"}createListBox(Z,$,J){let X=document.createElement("ul");X.id=$,X.setAttribute("role","listbox"),X.setAttribute("aria-expanded","true"),X.setAttribute("aria-label",this.view.state.phrase("Completions")),X.addEventListener("mousedown",(K)=>{if(K.target==X)K.preventDefault()});let Y=null;for(let K=J.from;K<J.to;K++){let{completion:Q,match:U}=Z[K],{section:q}=Q;if(q){let j=typeof q=="string"?q:q.name;if(j!=Y&&(K>J.from||J.from==0))if(Y=j,typeof q!="string"&&q.header)X.appendChild(q.header(q));else{let W=X.appendChild(document.createElement("completion-section"));W.textContent=j}}let G=X.appendChild(document.createElement("li"));G.id=$+"-"+K,G.setAttribute("role","option");let z=this.optionClass(Q);if(z)G.className=z;for(let j of this.optionContent){let W=j(Q,this.view.state,this.view,U);if(W)G.appendChild(W)}}if(J.from)X.classList.add("cm-completionListIncompleteTop");if(J.to<Z.length)X.classList.add("cm-completionListIncompleteBottom");return X}destroyInfo(){if(this.info){if(this.infoDestroy)this.infoDestroy();this.info.remove(),this.info=null}}destroy(){this.destroyInfo()}}function TU(Z,$){return(J)=>new X2(J,Z,$)}function yU(Z,$){let J=Z.getBoundingClientRect(),X=$.getBoundingClientRect(),Y=J.height/Z.offsetHeight;if(X.top<J.top)Z.scrollTop-=(J.top-X.top)/Y;else if(X.bottom>J.bottom)Z.scrollTop+=(X.bottom-J.bottom)/Y}function aJ(Z){return(Z.boost||0)*100+(Z.apply?10:0)+(Z.info?5:0)+(Z.type?1:0)}function kU(Z,$){let J=[],X=null,Y=null,K=(z)=>{J.push(z);let{section:j}=z.completion;if(j){if(!X)X=[];let W=typeof j=="string"?j:j.name;if(!X.some((O)=>O.name==W))X.push(typeof j=="string"?{name:W}:j)}},Q=$.facet(Q9);for(let z of Z)if(z.hasResult()){let j=z.result.getMatch;if(z.result.filter===!1)for(let W of z.result.options)K(new f4(W,z.source,j?j(W):[],1e9-J.length));else{let W=$.sliceDoc(z.from,z.to),O,_=Q.filterStrict?new J2(W):new $2(W);for(let V of z.result.options)if(O=_.match(V.label)){let H=!V.displayLabel?O.matched:j?j(V,O.matched):[],I=O.score+(V.boost||0);if(K(new f4(V,z.source,H,I)),typeof V.section=="object"&&V.section.rank==="dynamic"){let{name:D}=V.section;if(!Y)Y=Object.create(null);Y[D]=Math.max(I,Y[D]||-1e9)}}}}if(X){let z=Object.create(null),j=0,W=(O,_)=>{return(O.rank==="dynamic"&&_.rank==="dynamic"?Y[_.name]-Y[O.name]:0)||(typeof O.rank=="number"?O.rank:1e9)-(typeof _.rank=="number"?_.rank:1e9)||(O.name<_.name?-1:1)};for(let O of X.sort(W))j-=1e5,z[O.name]=j;for(let O of J){let{section:_}=O.completion;if(_)O.score+=z[typeof _=="string"?_:_.name]}}let U=[],q=null,G=Q.compareCompletions;for(let z of J.sort((j,W)=>W.score-j.score||G(j.completion,W.completion))){let j=z.completion;if(!q||q.label!=j.label||q.detail!=j.detail||q.type!=null&&j.type!=null&&q.type!=j.type||q.apply!=j.apply||q.boost!=j.boost)U.push(z);else if(aJ(z.completion)>aJ(q))U[U.length-1]=z;q=z.completion}return U}class I5{constructor(Z,$,J,X,Y,K){this.options=Z,this.attrs=$,this.tooltip=J,this.timestamp=X,this.selected=Y,this.disabled=K}setSelected(Z,$){return Z==this.selected||Z>=this.options.length?this:new I5(this.options,rJ($,Z),this.tooltip,this.timestamp,Z,this.disabled)}static build(Z,$,J,X,Y,K){if(X&&!K&&Z.some((q)=>q.isPending))return X.setDisabled();let Q=kU(Z,$);if(!Q.length)return X&&Z.some((q)=>q.isPending)?X.setDisabled():null;let U=$.facet(Q9).selectOnOpen?0:-1;if(X&&X.selected!=U&&X.selected!=-1){let q=X.options[X.selected].completion;for(let G=0;G<Q.length;G++)if(Q[G].completion==q){U=G;break}}return new I5(Q,rJ(J,U),{pos:Z.reduce((q,G)=>G.hasResult()?Math.min(q,G.from):q,1e8),create:vU,above:Y.aboveCursor},X?X.timestamp:Date.now(),U,!1)}map(Z){return new I5(this.options,this.attrs,{...this.tooltip,pos:Z.mapPos(this.tooltip.pos)},this.timestamp,this.selected,this.disabled)}setDisabled(){return new I5(this.options,this.attrs,this.tooltip,this.timestamp,this.selected,!0)}}class TZ{constructor(Z,$,J){this.active=Z,this.id=$,this.open=J}static start(){return new TZ(wU,"cm-ac-"+Math.floor(Math.random()*2000000).toString(36),null)}update(Z){let{state:$}=Z,J=$.facet(Q9),Y=(J.override||$.languageDataAt("autocomplete",l0($)).map(BU)).map((U)=>{return(this.active.find((G)=>G.source==U)||new g9(U,this.active.some((G)=>G.state!=0)?1:0)).update(Z,J)});if(Y.length==this.active.length&&Y.every((U,q)=>U==this.active[q]))Y=this.active;let K=this.open,Q=Z.effects.some((U)=>U.is(p4));if(K&&Z.docChanged)K=K.map(Z.changes);if(Z.selection||Y.some((U)=>U.hasResult()&&Z.changes.touchesRange(U.from,U.to))||!SU(Y,this.active)||Q)K=I5.build(Y,$,this.id,K,J,Q);else if(K&&K.disabled&&!Y.some((U)=>U.isPending))K=null;if(!K&&Y.every((U)=>!U.isPending)&&Y.some((U)=>U.hasResult()))Y=Y.map((U)=>U.hasResult()?new g9(U.source,0):U);for(let U of Z.effects)if(U.is(K2))K=K&&K.setSelected(U.value,this.id);return Y==this.active&&K==this.open?this:new TZ(Y,this.id,K)}get tooltip(){return this.open?this.open.tooltip:null}get attrs(){return this.open?this.open.attrs:this.active.length?bU:xU}}function SU(Z,$){if(Z==$)return!0;for(let J=0,X=0;;){while(J<Z.length&&!Z[J].hasResult())J++;while(X<$.length&&!$[X].hasResult())X++;let Y=J==Z.length,K=X==$.length;if(Y||K)return Y==K;if(Z[J++].result!=$[X++].result)return!1}}var bU={"aria-autocomplete":"list"},xU={};function rJ(Z,$){let J={"aria-autocomplete":"list","aria-haspopup":"listbox","aria-controls":Z};if($>-1)J["aria-activedescendant"]=Z+"-"+$;return J}var wU=[];function Y2(Z,$){if(Z.isUserEvent("input.complete")){let X=Z.annotation(Z2);if(X&&$.activateOnCompletion(X))return 12}let J=Z.isUserEvent("input.type");return J&&$.activateOnTyping?5:J?1:Z.isUserEvent("delete.backward")?2:Z.selection?8:Z.docChanged?16:0}class g9{constructor(Z,$,J=!1){this.source=Z,this.state=$,this.explicit=J}hasResult(){return!1}get isPending(){return this.state==1}update(Z,$){let J=Y2(Z,$),X=this;if(J&8||J&16&&this.touches(Z))X=new g9(X.source,0);if(J&4&&X.state==0)X=new g9(this.source,1);X=X.updateFor(Z,J);for(let Y of Z.effects)if(Y.is(CZ))X=new g9(X.source,1,Y.value);else if(Y.is(U7))X=new g9(X.source,0);else if(Y.is(p4)){for(let K of Y.value)if(K.source==X.source)X=K}return X}updateFor(Z,$){return this.map(Z.changes)}map(Z){return this}touches(Z){return Z.changes.touchesRange(l0(Z.state))}}class D5 extends g9{constructor(Z,$,J,X,Y,K){super(Z,3,$);this.limit=J,this.result=X,this.from=Y,this.to=K}hasResult(){return!0}updateFor(Z,$){var J;if(!($&3))return this.map(Z.changes);let X=this.result;if(X.map&&!Z.changes.empty)X=X.map(X,Z.changes);let Y=Z.changes.mapPos(this.from),K=Z.changes.mapPos(this.to,1),Q=l0(Z.state);if(Q>K||!X||$&2&&(l0(Z.startState)==this.from||Q<this.limit))return new g9(this.source,$&4?1:0);let U=Z.changes.mapPos(this.limit);if(hU(X.validFor,Z.state,Y,K))return new D5(this.source,this.explicit,U,X,Y,K);if(X.update&&(X=X.update(X,Y,K,new g4(Z.state,Q,!1))))return new D5(this.source,this.explicit,U,X,X.from,(J=X.to)!==null&&J!==void 0?J:l0(Z.state));return new g9(this.source,1,this.explicit)}map(Z){if(Z.empty)return this;if(!(this.result.map?this.result.map(this.result,Z):this.result))return new g9(this.source,0);return new D5(this.source,this.explicit,Z.mapPos(this.limit),this.result,Z.mapPos(this.from),Z.mapPos(this.to,1))}touches(Z){return Z.changes.touchesRange(this.from,this.to)}}function hU(Z,$,J,X){if(!Z)return!1;let Y=$.sliceDoc(J,X);return typeof Z=="function"?Z(Y,J,X,$):eJ(Z,!0).test(Y)}var p4=k.define({map(Z,$){return Z.map((J)=>J.map($))}}),K2=k.define(),A9=a.define({create(){return TZ.start()},update(Z,$){return Z.update($)},provide:(Z)=>[a5.from(Z,($)=>$.tooltip),E.contentAttributes.from(Z,($)=>$.attrs)]});function l4(Z,$){let J=$.completion.apply||$.completion.label,X=Z.state.field(A9).active.find((Y)=>Y.source==$.source);if(!(X instanceof D5))return!1;if(typeof J=="string")Z.dispatch({...EU(Z.state,J,X.from,X.to),annotations:Z2.of($.completion)});else J(Z,$.completion,X.from,X.to);return!0}var vU=TU(A9,l4);function PZ(Z,$="option"){return(J)=>{let X=J.state.field(A9,!1);if(!X||!X.open||X.open.disabled||Date.now()-X.open.timestamp<J.state.facet(Q9).interactionDelay)return!1;let Y=1,K;if($=="page"&&(K=a3(J,X.open.tooltip)))Y=Math.max(2,Math.floor(K.dom.offsetHeight/K.dom.querySelector("li").offsetHeight)-1);let{length:Q}=X.open.options,U=X.open.selected>-1?X.open.selected+Y*(Z?1:-1):Z?0:Q-1;if(U<0)U=$=="page"?0:Q-1;else if(U>=Q)U=$=="page"?Q-1:0;return J.dispatch({effects:K2.of(U)}),!0}}var mU=(Z)=>{let $=Z.state.field(A9,!1);if(Z.state.readOnly||!$||!$.open||$.open.selected<0||$.open.disabled||Date.now()-$.open.timestamp<Z.state.facet(Q9).interactionDelay)return!1;return l4(Z,$.open.options[$.open.selected])},m4=(Z)=>{if(!Z.state.field(A9,!1))return!1;return Z.dispatch({effects:CZ.of(!0)}),!0},uU=(Z)=>{let $=Z.state.field(A9,!1);if(!$||!$.active.some((J)=>J.state!=0))return!1;return Z.dispatch({effects:U7.of(null)}),!0};class Q2{constructor(Z,$){this.active=Z,this.context=$,this.time=Date.now(),this.updates=[],this.done=void 0}}var fU=50,gU=1000,pU=o.fromClass(class{constructor(Z){this.view=Z,this.debounceUpdate=-1,this.running=[],this.debounceAccept=-1,this.pendingStart=!1,this.composing=0;for(let $ of Z.state.field(A9).active)if($.isPending)this.startQuery($)}update(Z){let $=Z.state.field(A9),J=Z.state.facet(Q9);if(!Z.selectionSet&&!Z.docChanged&&Z.startState.field(A9)==$)return;let X=Z.transactions.some((K)=>{let Q=Y2(K,J);return Q&8||(K.selection||K.docChanged)&&!(Q&3)});for(let K=0;K<this.running.length;K++){let Q=this.running[K];if(X||Q.context.abortOnDocChange&&Z.docChanged||Q.updates.length+Z.transactions.length>fU&&Date.now()-Q.time>gU){for(let U of Q.context.abortListeners)try{U()}catch(q){j9(this.view.state,q)}Q.context.abortListeners=null,this.running.splice(K--,1)}else Q.updates.push(...Z.transactions)}if(this.debounceUpdate>-1)clearTimeout(this.debounceUpdate);if(Z.transactions.some((K)=>K.effects.some((Q)=>Q.is(CZ))))this.pendingStart=!0;let Y=this.pendingStart?50:J.activateOnTypingDelay;if(this.debounceUpdate=$.active.some((K)=>K.isPending&&!this.running.some((Q)=>Q.active.source==K.source))?setTimeout(()=>this.startUpdate(),Y):-1,this.composing!=0){for(let K of Z.transactions)if(K.isUserEvent("input.type"))this.composing=2;else if(this.composing==2&&K.selection)this.composing=3}}startUpdate(){this.debounceUpdate=-1,this.pendingStart=!1;let{state:Z}=this.view,$=Z.field(A9);for(let J of $.active)if(J.isPending&&!this.running.some((X)=>X.active.source==J.source))this.startQuery(J);if(this.running.length&&$.open&&$.open.disabled)this.debounceAccept=setTimeout(()=>this.accept(),this.view.state.facet(Q9).updateSyncTime)}startQuery(Z){let{state:$}=this.view,J=l0($),X=new g4($,J,Z.explicit,this.view),Y=new Q2(Z,X);this.running.push(Y),Promise.resolve(Z.source(X)).then((K)=>{if(!Y.context.aborted)Y.done=K||null,this.scheduleAccept()},(K)=>{this.view.dispatch({effects:U7.of(null)}),j9(this.view.state,K)})}scheduleAccept(){if(this.running.every((Z)=>Z.done!==void 0))this.accept();else if(this.debounceAccept<0)this.debounceAccept=setTimeout(()=>this.accept(),this.view.state.facet(Q9).updateSyncTime)}accept(){var Z;if(this.debounceAccept>-1)clearTimeout(this.debounceAccept);this.debounceAccept=-1;let $=[],J=this.view.state.facet(Q9),X=this.view.state.field(A9);for(let Y=0;Y<this.running.length;Y++){let K=this.running[Y];if(K.done===void 0)continue;if(this.running.splice(Y--,1),K.done){let U=l0(K.updates.length?K.updates[0].startState:this.view.state),q=Math.min(U,K.done.from+(K.active.explicit?0:1)),G=new D5(K.active.source,K.active.explicit,q,K.done,K.done.from,(Z=K.done.to)!==null&&Z!==void 0?Z:U);for(let z of K.updates)G=G.update(z,J);if(G.hasResult()){$.push(G);continue}}let Q=X.active.find((U)=>U.source==K.active.source);if(Q&&Q.isPending)if(K.done==null){let U=new g9(K.active.source,0);for(let q of K.updates)U=U.update(q,J);if(!U.isPending)$.push(U)}else this.startQuery(Q)}if($.length||X.open&&X.open.disabled)this.view.dispatch({effects:p4.of($)})}},{eventHandlers:{blur(Z){let $=this.view.state.field(A9,!1);if($&&$.tooltip&&this.view.state.facet(Q9).closeOnBlur){let J=$.open&&a3(this.view,$.open.tooltip);if(!J||!J.dom.contains(Z.relatedTarget))setTimeout(()=>this.view.dispatch({effects:U7.of(null)}),10)}},compositionstart(){this.composing=1},compositionend(){if(this.composing==3)setTimeout(()=>this.view.dispatch({effects:CZ.of(!1)}),20);this.composing=0}}}),lU=typeof navigator=="object"&&/Win/.test(navigator.platform),dU=d9.highest(E.domEventHandlers({keydown(Z,$){let J=$.state.field(A9,!1);if(!J||!J.open||J.open.disabled||J.open.selected<0||Z.key.length>1||Z.ctrlKey&&!(lU&&Z.altKey)||Z.metaKey)return!1;let X=J.open.options[J.open.selected],Y=J.active.find((Q)=>Q.source==X.source),K=X.completion.commitCharacters||Y.result.commitCharacters;if(K&&K.indexOf(Z.key)>-1)l4($,X);return!1}})),cU=E.baseTheme({".cm-tooltip.cm-tooltip-autocomplete":{"& > ul":{fontFamily:"monospace",whiteSpace:"nowrap",overflow:"hidden auto",maxWidth_fallback:"700px",maxWidth:"min(700px, 95vw)",minWidth:"250px",maxHeight:"10em",height:"100%",listStyle:"none",margin:0,padding:0,"& > li, & > completion-section":{padding:"1px 3px",lineHeight:1.2},"& > li":{overflowX:"hidden",textOverflow:"ellipsis",cursor:"pointer"},"& > completion-section":{display:"list-item",borderBottom:"1px solid silver",paddingLeft:"0.5em",opacity:0.7}}},"&light .cm-tooltip-autocomplete ul li[aria-selected]":{background:"#17c",color:"white"},"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]":{background:"#777"},"&dark .cm-tooltip-autocomplete ul li[aria-selected]":{background:"#347",color:"white"},"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]":{background:"#444"},".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after":{content:'"···"',opacity:0.5,display:"block",textAlign:"center"},".cm-tooltip.cm-completionInfo":{position:"absolute",padding:"3px 9px",width:"max-content",maxWidth:"400px",boxSizing:"border-box",whiteSpace:"pre-line"},".cm-completionInfo.cm-completionInfo-left":{right:"100%"},".cm-completionInfo.cm-completionInfo-right":{left:"100%"},".cm-completionInfo.cm-completionInfo-left-narrow":{right:"30px"},".cm-completionInfo.cm-completionInfo-right-narrow":{left:"30px"},"&light .cm-snippetField":{backgroundColor:"#00000022"},"&dark .cm-snippetField":{backgroundColor:"#ffffff22"},".cm-snippetFieldPosition":{verticalAlign:"text-top",width:0,height:"1.15em",display:"inline-block",margin:"0 -0.7px -.7em",borderLeft:"1.4px dotted #888"},".cm-completionMatchedText":{textDecoration:"underline"},".cm-completionDetail":{marginLeft:"0.5em",fontStyle:"italic"},".cm-completionIcon":{fontSize:"90%",width:".8em",display:"inline-block",textAlign:"center",paddingRight:".6em",opacity:"0.6",boxSizing:"content-box"},".cm-completionIcon-function, .cm-completionIcon-method":{"&:after":{content:"'ƒ'"}},".cm-completionIcon-class":{"&:after":{content:"'○'"}},".cm-completionIcon-interface":{"&:after":{content:"'◌'"}},".cm-completionIcon-variable":{"&:after":{content:"'\uD835\uDC65'"}},".cm-completionIcon-constant":{"&:after":{content:"'\uD835\uDC36'"}},".cm-completionIcon-type":{"&:after":{content:"'\uD835\uDC61'"}},".cm-completionIcon-enum":{"&:after":{content:"'∪'"}},".cm-completionIcon-property":{"&:after":{content:"'□'"}},".cm-completionIcon-keyword":{"&:after":{content:"'\uD83D\uDD11︎'"}},".cm-completionIcon-namespace":{"&:after":{content:"'▢'"}},".cm-completionIcon-text":{"&:after":{content:"'abc'",fontSize:"50%",verticalAlign:"middle"}}});var q7={brackets:["(","[","{","'",'"'],before:")]}:;>",stringPrefixes:[]},p0=k.define({map(Z,$){let J=$.mapPos(Z,-1,q9.TrackAfter);return J==null?void 0:J}}),d4=new class extends l9{};d4.startSide=1;d4.endSide=-1;var U2=a.define({create(){return b.empty},update(Z,$){if(Z=Z.map($.changes),$.selection){let J=$.state.doc.lineAt($.selection.main.head);Z=Z.update({filter:(X)=>X>=J.from&&X<=J.to})}for(let J of $.effects)if(J.is(p0))Z=Z.update({add:[d4.range(J.value,J.value+1)]});return Z}});function q2(){return[nU,U2]}var u4="()[]{}<>«»»«［］｛｝";function G2(Z){for(let $=0;$<u4.length;$+=2)if(u4.charCodeAt($)==Z)return u4.charAt($+1);return B5(Z<128?Z:Z+1)}function z2(Z,$){return Z.languageDataAt("closeBrackets",$)[0]||q7}var sU=typeof navigator=="object"&&/Android\b/.test(navigator.userAgent),nU=E.inputHandler.of((Z,$,J,X)=>{if((sU?Z.composing:Z.compositionStarted)||Z.state.readOnly)return!1;let Y=Z.state.selection.main;if(X.length>2||X.length==2&&E9(G9(X,0))==1||$!=Y.from||J!=Y.to)return!1;let K=aU(Z.state,X);if(!K)return!1;return Z.dispatch(K),!0}),iU=({state:Z,dispatch:$})=>{if(Z.readOnly)return!1;let X=z2(Z,Z.selection.main.head).brackets||q7.brackets,Y=null,K=Z.changeByRange((Q)=>{if(Q.empty){let U=rU(Z.doc,Q.head);for(let q of X)if(q==U&&yZ(Z.doc,Q.head)==G2(G9(q,0)))return{changes:{from:Q.head-q.length,to:Q.head+q.length},range:R.cursor(Q.head-q.length)}}return{range:Y=Q}});if(!Y)$(Z.update(K,{scrollIntoView:!0,userEvent:"delete.backward"}));return!Y},j2=[{key:"Backspace",run:iU}];function aU(Z,$){let J=z2(Z,Z.selection.main.head),X=J.brackets||q7.brackets;for(let Y of X){let K=G2(G9(Y,0));if($==Y)return K==Y?eU(Z,Y,X.indexOf(Y+Y+Y)>-1,J):oU(Z,Y,K,J.before||q7.before);if($==K&&W2(Z,Z.selection.main.from))return tU(Z,Y,K)}return null}function W2(Z,$){let J=!1;return Z.field(U2).between(0,Z.doc.length,(X)=>{if(X==$)J=!0}),J}function yZ(Z,$){let J=Z.sliceString($,$+2);return J.slice(0,E9(G9(J,0)))}function rU(Z,$){let J=Z.sliceString($-2,$);return E9(G9(J,0))==J.length?J:J.slice(1)}function oU(Z,$,J,X){let Y=null,K=Z.changeByRange((Q)=>{if(!Q.empty)return{changes:[{insert:$,from:Q.from},{insert:J,from:Q.to}],effects:p0.of(Q.to+$.length),range:R.range(Q.anchor+$.length,Q.head+$.length)};let U=yZ(Z.doc,Q.head);if(!U||/\s/.test(U)||X.indexOf(U)>-1)return{changes:{insert:$+J,from:Q.head},effects:p0.of(Q.head+$.length),range:R.cursor(Q.head+$.length)};return{range:Y=Q}});return Y?null:Z.update(K,{scrollIntoView:!0,userEvent:"input.type"})}function tU(Z,$,J){let X=null,Y=Z.changeByRange((K)=>{if(K.empty&&yZ(Z.doc,K.head)==J)return{changes:{from:K.head,to:K.head+J.length,insert:J},range:R.cursor(K.head+J.length)};return X={range:K}});return X?null:Z.update(Y,{scrollIntoView:!0,userEvent:"input.type"})}function eU(Z,$,J,X){let Y=X.stringPrefixes||q7.stringPrefixes,K=null,Q=Z.changeByRange((U)=>{if(!U.empty)return{changes:[{insert:$,from:U.from},{insert:$,from:U.to}],effects:p0.of(U.to+$.length),range:R.range(U.anchor+$.length,U.head+$.length)};let q=U.head,G=yZ(Z.doc,q),z;if(G==$){if(oJ(Z,q))return{changes:{insert:$+$,from:q},effects:p0.of(q+$.length),range:R.cursor(q+$.length)};else if(W2(Z,q)){let W=J&&Z.sliceDoc(q,q+$.length*3)==$+$+$?$+$+$:$;return{changes:{from:q,to:q+W.length,insert:W},range:R.cursor(q+W.length)}}}else if(J&&Z.sliceDoc(q-2*$.length,q)==$+$&&(z=tJ(Z,q-2*$.length,Y))>-1&&oJ(Z,z))return{changes:{insert:$+$+$+$,from:q},effects:p0.of(q+$.length),range:R.cursor(q+$.length)};else if(Z.charCategorizer(q)(G)!=d.Word){if(tJ(Z,q,Y)>-1&&!Zq(Z,q,$,Y))return{changes:{insert:$+$,from:q},effects:p0.of(q+$.length),range:R.cursor(q+$.length)}}return{range:K=U}});return K?null:Z.update(Q,{scrollIntoView:!0,userEvent:"input.type"})}function oJ(Z,$){let J=K9(Z).resolveInner($+1);return J.parent&&J.from==$}function Zq(Z,$,J,X){let Y=K9(Z).resolveInner($,-1),K=X.reduce((Q,U)=>Math.max(Q,U.length),0);for(let Q=0;Q<5;Q++){let U=Z.sliceDoc(Y.from,Math.min(Y.to,Y.from+J.length+K)),q=U.indexOf(J);if(!q||q>-1&&X.indexOf(U.slice(0,q))>-1){let z=Y.firstChild;while(z&&z.from==Y.from&&z.to-z.from>J.length+q){if(Z.sliceDoc(z.to-J.length,z.to)==J)return!1;z=z.firstChild}return!0}let G=Y.to==$&&Y.parent;if(!G)break;Y=G}return!1}function tJ(Z,$,J){let X=Z.charCategorizer($);if(X(Z.sliceDoc($-1,$))!=d.Word)return $;for(let Y of J){let K=$-Y.length;if(Z.sliceDoc(K,$)==Y&&X(Z.sliceDoc(K-1,K))!=d.Word)return K}return-1}function kZ(Z={}){return[dU,A9,Q9.of(Z),pU,$q,cU]}var c4=[{key:"Ctrl-Space",run:m4},{mac:"Alt-`",run:m4},{mac:"Alt-i",run:m4},{key:"Escape",run:uU},{key:"ArrowDown",run:PZ(!0)},{key:"ArrowUp",run:PZ(!1)},{key:"PageDown",run:PZ(!0,"page")},{key:"PageUp",run:PZ(!1,"page")},{key:"Enter",run:mU}],$q=d9.highest(m0.computeN([Q9],(Z)=>Z.facet(Q9).defaultKeymap?[c4]:[]));class s4{constructor(Z,$,J){this.from=Z,this.to=$,this.diagnostic=J}}class d0{constructor(Z,$,J){this.diagnostics=Z,this.panel=$,this.selected=J}static init(Z,$,J){let X=J.facet(G7).markerFilter;if(X)Z=X(Z,J);let Y=Z.slice().sort((W,O)=>W.from-O.from||W.to-O.to),K=new M9,Q=[],U=0,q=J.doc.iter(),G=0,z=J.doc.length;for(let W=0;;){let O=W==Y.length?null:Y[W];if(!O&&!Q.length)break;let _,V;if(Q.length)_=U,V=Q.reduce((D,F)=>Math.min(D,F.to),O&&O.from>_?O.from:1e8);else{if(_=O.from,_>z)break;V=O.to,Q.push(O),W++}while(W<Y.length){let D=Y[W];if(D.from==_&&(D.to>D.from||D.to==_))Q.push(D),W++,V=Math.min(D.to,V);else{V=Math.min(D.from,V);break}}V=Math.min(V,z);let H=!1;if(Q.some((D)=>D.from==_&&(D.to==V||V==z))){if(H=_==V,!H&&V-_<10){let D=_-(G+q.value.length);if(D>0)q.next(D),G=_;for(let F=_;;){if(F>=V){H=!0;break}if(!q.lineBreak&&G+q.value.length>F)break;F=G+q.value.length,G+=q.value.length,q.next()}}}let I=Wq(Q);if(H)K.add(_,_,y.widget({widget:new D2(I),diagnostics:Q.slice()}));else{let D=Q.reduce((F,C)=>C.markClass?F+" "+C.markClass:F,"");K.add(_,V,y.mark({class:"cm-lintRange cm-lintRange-"+I+D,diagnostics:Q.slice(),inclusiveEnd:Q.some((F)=>F.to>V)}))}if(U=V,U==z)break;for(let D=0;D<Q.length;D++)if(Q[D].to<=U)Q.splice(D--,1)}let j=K.finish();return new d0(j,$,P0(j))}}function P0(Z,$=null,J=0){let X=null;return Z.between(J,1e9,(Y,K,{spec:Q})=>{if($&&Q.diagnostics.indexOf($)<0)return;if(!X)X=new s4(Y,K,$||Q.diagnostics[0]);else if(Q.diagnostics.indexOf(X.diagnostic)<0)return!1;else X=new s4(X.from,K,X.diagnostic)}),X}function Jq(Z,$){let J=$.pos,X=$.end||J,Y=Z.state.facet(G7).hideOn(Z,J,X);if(Y!=null)return Y;let K=Z.startState.doc.lineAt($.pos);return!!(Z.effects.some((Q)=>Q.is(V2))||Z.changes.touchesRange(K.from,Math.max(K.to,X)))}function Xq(Z,$){return Z.field(y9,!1)?$:$.concat(k.appendConfig.of(Oq))}var V2=k.define(),i4=k.define(),H2=k.define(),y9=a.define({create(){return new d0(y.none,null,null)},update(Z,$){if($.docChanged&&Z.diagnostics.size){let J=Z.diagnostics.map($.changes),X=null,Y=Z.panel;if(Z.selected){let K=$.changes.mapPos(Z.selected.from,1);X=P0(J,Z.selected.diagnostic,K)||P0(J,null,K)}if(!J.size&&Y&&$.state.facet(G7).autoPanel)Y=null;Z=new d0(J,Y,X)}for(let J of $.effects)if(J.is(V2)){let X=!$.state.facet(G7).autoPanel?Z.panel:J.value.length?z7.open:null;Z=d0.init(J.value,X,$.state)}else if(J.is(i4))Z=new d0(Z.diagnostics,J.value?z7.open:null,Z.selected);else if(J.is(H2))Z=new d0(Z.diagnostics,Z.panel,J.value);return Z},provide:(Z)=>[v0.from(Z,($)=>$.panel),E.decorations.from(Z,($)=>$.diagnostics)]});var Yq=y.mark({class:"cm-lintRange cm-lintRange-active"});function Kq(Z,$,J){let{diagnostics:X}=Z.state.field(y9),Y,K=-1,Q=-1;X.between($-(J<0?1:0),$+(J>0?1:0),(q,G,{spec:z})=>{if($>=q&&$<=G&&(q==G||($>q||J>0)&&($<G||J<0)))return Y=z.diagnostics,K=q,Q=G,!1});let U=Z.state.facet(G7).tooltipFilter;if(Y&&U)Y=U(Y,Z.state);if(!Y)return null;return{pos:K,end:Q,above:Z.state.doc.lineAt(K).to<Q,create(){return{dom:Qq(Z,Y)}}}}function Qq(Z,$){return f("ul",{class:"cm-tooltip-lint"},$.map((J)=>I2(Z,J,!1)))}var Uq=(Z)=>{let $=Z.state.field(y9,!1);if(!$||!$.panel)Z.dispatch({effects:Xq(Z.state,[i4.of(!0)])});let J=r5(Z,z7.open);if(J)J.dom.querySelector(".cm-panel-lint ul").focus();return!0},O2=(Z)=>{let $=Z.state.field(y9,!1);if(!$||!$.panel)return!1;return Z.dispatch({effects:i4.of(!1)}),!0},qq=(Z)=>{let $=Z.state.field(y9,!1);if(!$)return!1;let J=Z.state.selection.main,X=P0($.diagnostics,null,J.to+1);if(!X){if(X=P0($.diagnostics,null,0),!X||X.from==J.from&&X.to==J.to)return!1}return Z.dispatch({selection:{anchor:X.from,head:X.to},scrollIntoView:!0}),!0};var N2=[{key:"Mod-Shift-m",run:Uq,preventDefault:!0},{key:"F8",run:qq}];var G7=L.define({combine(Z){return{sources:Z.map(($)=>$.source).filter(($)=>$!=null),..._9(Z.map(($)=>$.config),{delay:750,markerFilter:null,tooltipFilter:null,needsRefresh:null,hideOn:()=>null},{delay:Math.max,markerFilter:_2,tooltipFilter:_2,needsRefresh:($,J)=>!$?J:!J?$:(X)=>$(X)||J(X),hideOn:($,J)=>!$?J:!J?$:(X,Y,K)=>$(X,Y,K)||J(X,Y,K),autoPanel:($,J)=>$||J})}}});function _2(Z,$){return!Z?$:!$?Z:(J,X)=>$(Z(J,X),X)}function R2(Z){let $=[];if(Z)Z:for(let{name:J}of Z){for(let X=0;X<J.length;X++){let Y=J[X];if(/[a-zA-Z]/.test(Y)&&!$.some((K)=>K.toLowerCase()==Y.toLowerCase())){$.push(Y);continue Z}}$.push("")}return $}function I2(Z,$,J){var X;let Y=J?R2($.actions):[];return f("li",{class:"cm-diagnostic cm-diagnostic-"+$.severity},f("span",{class:"cm-diagnosticText"},$.renderMessage?$.renderMessage(Z):$.message),(X=$.actions)===null||X===void 0?void 0:X.map((K,Q)=>{let U=!1,q=(O)=>{if(O.preventDefault(),U)return;U=!0;let _=P0(Z.state.field(y9).diagnostics,$);if(_)K.apply(Z,_.from,_.to)},{name:G}=K,z=Y[Q]?G.indexOf(Y[Q]):-1,j=z<0?G:[G.slice(0,z),f("u",G.slice(z,z+1)),G.slice(z+1)],W=K.markClass?" "+K.markClass:"";return f("button",{type:"button",class:"cm-diagnosticAction"+W,onclick:q,onmousedown:q,"aria-label":` Action: ${G}${z<0?"":` (access key "${Y[Q]})"`}.`},j)}),$.source&&f("div",{class:"cm-diagnosticSource"},$.source))}class D2 extends C9{constructor(Z){super();this.sev=Z}eq(Z){return Z.sev==this.sev}toDOM(){return f("span",{class:"cm-lintPoint cm-lintPoint-"+this.sev})}}class n4{constructor(Z,$){this.diagnostic=$,this.id="item_"+Math.floor(Math.random()*4294967295).toString(16),this.dom=I2(Z,$,!0),this.dom.id=this.id,this.dom.setAttribute("role","option")}}class z7{constructor(Z){this.view=Z,this.items=[];let $=(X)=>{if(X.ctrlKey||X.altKey||X.metaKey)return;if(X.keyCode==27)O2(this.view),this.view.focus();else if(X.keyCode==38||X.keyCode==33)this.moveSelection((this.selectedIndex-1+this.items.length)%this.items.length);else if(X.keyCode==40||X.keyCode==34)this.moveSelection((this.selectedIndex+1)%this.items.length);else if(X.keyCode==36)this.moveSelection(0);else if(X.keyCode==35)this.moveSelection(this.items.length-1);else if(X.keyCode==13)this.view.focus();else if(X.keyCode>=65&&X.keyCode<=90&&this.selectedIndex>=0){let{diagnostic:Y}=this.items[this.selectedIndex],K=R2(Y.actions);for(let Q=0;Q<K.length;Q++)if(K[Q].toUpperCase().charCodeAt(0)==X.keyCode){let U=P0(this.view.state.field(y9).diagnostics,Y);if(U)Y.actions[Q].apply(Z,U.from,U.to)}}else return;X.preventDefault()},J=(X)=>{for(let Y=0;Y<this.items.length;Y++)if(this.items[Y].dom.contains(X.target))this.moveSelection(Y)};this.list=f("ul",{tabIndex:0,role:"listbox","aria-label":this.view.state.phrase("Diagnostics"),onkeydown:$,onclick:J}),this.dom=f("div",{class:"cm-panel-lint"},this.list,f("button",{type:"button",name:"close","aria-label":this.view.state.phrase("close"),onclick:()=>O2(this.view)},"×")),this.update()}get selectedIndex(){let Z=this.view.state.field(y9).selected;if(!Z)return-1;for(let $=0;$<this.items.length;$++)if(this.items[$].diagnostic==Z.diagnostic)return $;return-1}update(){let{diagnostics:Z,selected:$}=this.view.state.field(y9),J=0,X=!1,Y=null,K=new Set;Z.between(0,this.view.state.doc.length,(Q,U,{spec:q})=>{for(let G of q.diagnostics){if(K.has(G))continue;K.add(G);let z=-1,j;for(let W=J;W<this.items.length;W++)if(this.items[W].diagnostic==G){z=W;break}if(z<0)j=new n4(this.view,G),this.items.splice(J,0,j),X=!0;else if(j=this.items[z],z>J)this.items.splice(J,z-J),X=!0;if($&&j.diagnostic==$.diagnostic){if(!j.dom.hasAttribute("aria-selected"))j.dom.setAttribute("aria-selected","true"),Y=j}else if(j.dom.hasAttribute("aria-selected"))j.dom.removeAttribute("aria-selected");J++}});while(J<this.items.length&&!(this.items.length==1&&this.items[0].diagnostic.from<0))X=!0,this.items.pop();if(this.items.length==0)this.items.push(new n4(this.view,{from:-1,to:-1,severity:"info",message:this.view.state.phrase("No diagnostics")})),X=!0;if(Y)this.list.setAttribute("aria-activedescendant",Y.id),this.view.requestMeasure({key:this,read:()=>({sel:Y.dom.getBoundingClientRect(),panel:this.list.getBoundingClientRect()}),write:({sel:Q,panel:U})=>{let q=U.height/this.list.offsetHeight;if(Q.top<U.top)this.list.scrollTop-=(U.top-Q.top)/q;else if(Q.bottom>U.bottom)this.list.scrollTop+=(Q.bottom-U.bottom)/q}});else if(this.selectedIndex<0)this.list.removeAttribute("aria-activedescendant");if(X)this.sync()}sync(){let Z=this.list.firstChild;function $(){let J=Z;Z=J.nextSibling,J.remove()}for(let J of this.items)if(J.dom.parentNode==this.list){while(Z!=J.dom)$();Z=J.dom.nextSibling}else this.list.insertBefore(J.dom,Z);while(Z)$()}moveSelection(Z){if(this.selectedIndex<0)return;let $=this.view.state.field(y9),J=P0($.diagnostics,this.items[Z].diagnostic);if(!J)return;this.view.dispatch({selection:{anchor:J.from,head:J.to},scrollIntoView:!0,effects:H2.of(J)})}static open(Z){return new z7(Z)}}function Gq(Z,$='viewBox="0 0 40 40"'){return`url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${$}>${encodeURIComponent(Z)}</svg>')`}function SZ(Z){return Gq(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${Z}" fill="none" stroke-width=".7"/>`,'width="6" height="3"')}var zq=E.baseTheme({".cm-diagnostic":{padding:"3px 6px 3px 8px",marginLeft:"-1px",display:"block",whiteSpace:"pre-wrap"},".cm-diagnostic-error":{borderLeft:"5px solid #d11"},".cm-diagnostic-warning":{borderLeft:"5px solid orange"},".cm-diagnostic-info":{borderLeft:"5px solid #999"},".cm-diagnostic-hint":{borderLeft:"5px solid #66d"},".cm-diagnosticAction":{font:"inherit",border:"none",padding:"2px 4px",backgroundColor:"#444",color:"white",borderRadius:"3px",marginLeft:"8px",cursor:"pointer"},".cm-diagnosticSource":{fontSize:"70%",opacity:0.7},".cm-lintRange":{backgroundPosition:"left bottom",backgroundRepeat:"repeat-x",paddingBottom:"0.7px"},".cm-lintRange-error":{backgroundImage:SZ("#d11")},".cm-lintRange-warning":{backgroundImage:SZ("orange")},".cm-lintRange-info":{backgroundImage:SZ("#999")},".cm-lintRange-hint":{backgroundImage:SZ("#66d")},".cm-lintRange-active":{backgroundColor:"#ffdd9980"},".cm-tooltip-lint":{padding:0,margin:0},".cm-lintPoint":{position:"relative","&:after":{content:'""',position:"absolute",bottom:0,left:"-2px",borderLeft:"3px solid transparent",borderRight:"3px solid transparent",borderBottom:"4px solid #d11"}},".cm-lintPoint-warning":{"&:after":{borderBottomColor:"orange"}},".cm-lintPoint-info":{"&:after":{borderBottomColor:"#999"}},".cm-lintPoint-hint":{"&:after":{borderBottomColor:"#66d"}},".cm-panel.cm-panel-lint":{position:"relative","& ul":{maxHeight:"100px",overflowY:"auto","& [aria-selected]":{backgroundColor:"#ddd","& u":{textDecoration:"underline"}},"&:focus [aria-selected]":{background_fallback:"#bdf",backgroundColor:"Highlight",color_fallback:"white",color:"HighlightText"},"& u":{textDecoration:"none"},padding:0,margin:0},"& [name=close]":{position:"absolute",top:"0",right:"2px",background:"inherit",border:"none",font:"inherit",padding:0,margin:0}}});function jq(Z){return Z=="error"?4:Z=="warning"?3:Z=="info"?2:1}function Wq(Z){let $="hint",J=1;for(let X of Z){let Y=jq(X.severity);if(Y>J)J=Y,$=X.severity}return $}var Oq=[y9,E.decorations.compute([y9],(Z)=>{let{selected:$,panel:J}=Z.field(y9);return!$||!J||$.from==$.to?y.none:y.set([Yq.range($.from,$.to)])}),g6(Kq,{hideOn:Jq}),zq];var F2=(()=>[i6(),a6(),x6(),$J(),k$(),T6(),S6(),h.allowMultipleSelections.of(!0),A$(),O5(x$,{fallback:!0}),m$(),q2(),kZ(),m6(),u6(),v6(),vJ(),m0.of([...j2,...kJ,...dJ,...KJ,...P$,...c4,...N2])])();var _q="#e5c07b",A2="#e06c75",Vq="#56b6c2",Hq="#ffffff",bZ="#abb2bf",r4="#7d8799",Nq="#61afef",Rq="#98c379",L2="#d19a66",Iq="#c678dd",Dq="#21252b",M2="#2c313a",E2="#282c34",a4="#353a42",Fq="#3E4451",B2="#528bff";var Aq=E.theme({"&":{color:bZ,backgroundColor:E2},".cm-content":{caretColor:B2},".cm-cursor, .cm-dropCursor":{borderLeftColor:B2},"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection":{backgroundColor:Fq},".cm-panels":{backgroundColor:Dq,color:bZ},".cm-panels.cm-panels-top":{borderBottom:"2px solid black"},".cm-panels.cm-panels-bottom":{borderTop:"2px solid black"},".cm-searchMatch":{backgroundColor:"#72a1ff59",outline:"1px solid #457dff"},".cm-searchMatch.cm-searchMatch-selected":{backgroundColor:"#6199ff2f"},".cm-activeLine":{backgroundColor:"#6699ff0b"},".cm-selectionMatch":{backgroundColor:"#aafe661a"},"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bad0f847"},".cm-gutters":{backgroundColor:E2,color:r4,border:"none"},".cm-activeLineGutter":{backgroundColor:M2},".cm-foldPlaceholder":{backgroundColor:"transparent",border:"none",color:"#ddd"},".cm-tooltip":{border:"none",backgroundColor:a4},".cm-tooltip .cm-tooltip-arrow:before":{borderTopColor:"transparent",borderBottomColor:"transparent"},".cm-tooltip .cm-tooltip-arrow:after":{borderTopColor:a4,borderBottomColor:a4},".cm-tooltip-autocomplete":{"& > ul > li[aria-selected]":{backgroundColor:M2,color:bZ}}},{dark:!0}),Lq=M0.define([{tag:N.keyword,color:Iq},{tag:[N.name,N.deleted,N.character,N.propertyName,N.macroName],color:A2},{tag:[N.function(N.variableName),N.labelName],color:Nq},{tag:[N.color,N.constant(N.name),N.standard(N.name)],color:L2},{tag:[N.definition(N.name),N.separator],color:bZ},{tag:[N.typeName,N.className,N.number,N.changed,N.annotation,N.modifier,N.self,N.namespace],color:_q},{tag:[N.operator,N.operatorKeyword,N.url,N.escape,N.regexp,N.link,N.special(N.string)],color:Vq},{tag:[N.meta,N.comment],color:r4},{tag:N.strong,fontWeight:"bold"},{tag:N.emphasis,fontStyle:"italic"},{tag:N.strikethrough,textDecoration:"line-through"},{tag:N.link,color:r4,textDecoration:"underline"},{tag:N.heading,fontWeight:"bold",color:A2},{tag:[N.atom,N.bool,N.special(N.variableName)],color:L2},{tag:[N.processingInstruction,N.string,N.inserted],color:Rq},{tag:N.invalid,color:Hq}]),P2=[Aq,O5(Lq)];Object.assign(window,{basicSetup:F2,EditorState:h,StateField:a,StateEffect:k,Compartment:o0,EditorView:E,keymap:m0,Decoration:y,StreamLanguage:WZ,HighlightStyle:M0,syntaxHighlighting:O5,oneDark:P2,autocompletion:kZ,tags:N});})();


// ─── Tova Syntax Highlighting ────────────────────────
const tovaLanguage = StreamLanguage.define({
  startState() { return { inComment: false, commentDepth: 0 }; },
  token(stream, state) {
    // Block comment (nestable)
    if (state.inComment) {
      if (stream.match('/*')) { state.commentDepth++; return 'blockComment'; }
      if (stream.match('*/')) { state.commentDepth--; if (state.commentDepth <= 0) { state.inComment = false; state.commentDepth = 0; } return 'blockComment'; }
      stream.next(); return 'blockComment';
    }
    // Docstring
    if (stream.match('///')) { stream.skipToEnd(); return 'docString'; }
    // Line comment
    if (stream.match('//')) { stream.skipToEnd(); return 'lineComment'; }
    // Block comment start
    if (stream.match('/*')) { state.inComment = true; state.commentDepth = 1; return 'blockComment'; }
    // Strings with interpolation
    if (stream.match('"')) {
      while (!stream.eol()) {
        const ch = stream.next();
        if (ch === '\\') { stream.next(); continue; }
        if (ch === '{') { return 'string'; }
        if (ch === '"') return 'string';
      }
      return 'string';
    }
    // Simple strings
    if (stream.match("'")) {
      while (!stream.eol()) { const ch = stream.next(); if (ch === '\\') { stream.next(); continue; } if (ch === "'") return 'string'; }
      return 'string';
    }
    // Braces (interpolation)
    if (stream.match('{')) return 'brace';
    if (stream.match('}')) return 'brace';
    // Numbers
    if (stream.match(/^0[xX][0-9a-fA-F]+/)) return 'number';
    if (stream.match(/^0[bB][01]+/)) return 'number';
    if (stream.match(/^\d+\.\d+([eE][+-]?\d+)?/)) return 'number';
    if (stream.match(/^\d+([eE][+-]?\d+)?/)) return 'number';
    // Multi-char operators
    if (stream.match('|>')) return 'operator';
    if (stream.match('=>')) return 'operator';
    if (stream.match('->')) return 'operator';
    if (stream.match('..=')) return 'operator';
    if (stream.match('...')) return 'operator';
    if (stream.match('..')) return 'operator';
    if (stream.match('?.')) return 'operator';
    if (stream.match('??')) return 'operator';
    if (stream.match('::')) return 'operator';
    if (stream.match('**')) return 'operator';
    if (stream.match(/^[+\-*\/%]=?/)) return 'operator';
    if (stream.match(/^[<>!=]=?/)) return 'operator';
    if (stream.match(/^&&|\|\|/)) return 'operator';
    if (stream.match('=')) return 'operator';
    // JSX close tag
    if (stream.match(/^<\/[A-Za-z][A-Za-z0-9]*/)) { stream.match('>'); return 'tagName'; }
    // Identifiers and keywords
    if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
      const w = stream.current();
      if (['fn','let','var','if','elif','else','for','while','in','not','and','or','match',
           'return','type','import','from','export','as','true','false','nil',
           'server','browser','client','shared','state','computed','effect','component',
           'route','GET','POST','PUT','DELETE','PATCH'].includes(w)) return 'keyword';
      if (/^[A-Z]/.test(w)) return 'typeName';
      return 'variableName';
    }
    // JSX
    if (stream.match('/>')) return 'angleBracket';
    if (stream.peek() === '<' && /[A-Za-z]/.test(stream.string.charAt(stream.pos + 1) || '')) {
      stream.next(); return 'angleBracket';
    }
    stream.next();
    return null;
  }
});

// ─── Autocompletion ─────────────────────────────────
const tovaKeywords = [
  'fn', 'let', 'var', 'if', 'elif', 'else', 'for', 'while', 'match',
  'type', 'state', 'computed', 'effect', 'component', 'server', 'browser', 'client',
  'shared', 'route', 'return', 'import', 'from', 'in', 'and', 'or', 'not',
  'true', 'false', 'nil', 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'as', 'export'
];

const tovaStdlib = [
  { label: 'print', detail: '(...args)', info: 'Print values to console' },
  { label: 'len', detail: '(v)', info: 'Length of string, array, or object' },
  { label: 'range', detail: '(start?, end, step?)', info: 'Generate number array' },
  { label: 'sum', detail: '(arr)', info: 'Sum of array elements' },
  { label: 'min', detail: '(arr)', info: 'Minimum value in array' },
  { label: 'max', detail: '(arr)', info: 'Maximum value in array' },
  { label: 'sorted', detail: '(arr, key?)', info: 'Sort array (with optional key fn)' },
  { label: 'reversed', detail: '(arr)', info: 'Reverse array' },
  { label: 'enumerate', detail: '(arr)', info: 'Index-value pairs' },
  { label: 'zip', detail: '(...arrs)', info: 'Combine arrays element-wise' },
  { label: 'type_of', detail: '(v)', info: 'Runtime type name as string' },
  { label: 'filter', detail: '(arr, fn)', info: 'Filter array by predicate' },
  { label: 'map', detail: '(arr, fn)', info: 'Transform each element' },
  { label: 'flat_map', detail: '(arr, fn)', info: 'Map then flatten one level' },
  { label: 'any', detail: '(arr, fn)', info: 'True if any element matches' },
  { label: 'all', detail: '(arr, fn)', info: 'True if all elements match' },
];

const tovaSnippets = [
  { label: 'fn', detail: 'function', apply: 'fn name() {\n  \n}', boost: -1 },
  { label: 'for', detail: 'for-in loop', apply: 'for item in items {\n  \n}', boost: -1 },
  { label: 'match', detail: 'match expression', apply: 'match value {\n  _ => \n}', boost: -1 },
  { label: 'type', detail: 'type definition', apply: 'type Name {\n  \n}', boost: -1 },
  { label: 'browser', detail: 'browser block', apply: 'browser {\n  state counter = 0\n\n  component App {\n    <div>\n      \n    </div>\n  }\n}', boost: -1 },
  { label: 'component', detail: 'component', apply: 'component App {\n  <div>\n    \n  </div>\n}', boost: -1 },
  { label: 'server', detail: 'server block', apply: 'server {\n  \n}', boost: -1 },
  { label: 'effect', detail: 'side effect', apply: 'effect {\n  \n}', boost: -1 },
  { label: 'if', detail: 'conditional', apply: 'if condition {\n  \n}', boost: -1 },
  { label: 'while', detail: 'while loop', apply: 'while condition {\n  \n}', boost: -1 },
  { label: 'route', detail: 'HTTP route', apply: 'route GET "/path" => fn(req) {\n  \n}', boost: -1 },
];

function tovaCompletions(context) {
  const word = context.matchBefore(/[a-zA-Z_]\w*/);
  if (!word && !context.explicit) return null;
  const from = word ? word.from : context.pos;
  const text = word ? word.text : '';

  const options = [];

  // Keywords
  for (const kw of tovaKeywords) {
    if (!text || kw.startsWith(text)) {
      // Check if there's a matching snippet
      const snippet = tovaSnippets.find(s => s.label === kw);
      if (snippet) {
        options.push({ label: kw, type: 'keyword', detail: snippet.detail, apply: snippet.apply, boost: 1 });
      } else {
        options.push({ label: kw, type: 'keyword', boost: 0 });
      }
    }
  }

  // Stdlib functions
  for (const fn of tovaStdlib) {
    if (!text || fn.label.startsWith(text)) {
      options.push({ label: fn.label, type: 'function', detail: fn.detail, info: fn.info, boost: 2 });
    }
  }

  return { from, options, filter: true };
}

// ─── Error Decorations ──────────────────────────────
const setErrorEffect = StateEffect.define();
const clearErrorEffect = StateEffect.define();

const errorLineDeco = Decoration.line({ class: 'cm-error-line' });

const errorField = StateField.define({
  create() { return Decoration.none; },
  update(decos, tr) {
    for (const e of tr.effects) {
      if (e.is(clearErrorEffect)) return Decoration.none;
      if (e.is(setErrorEffect)) {
        const lines = e.value;
        const ranges = [];
        for (const lineNum of lines) {
          try {
            const line = tr.state.doc.line(lineNum);
            ranges.push(errorLineDeco.range(line.from));
          } catch(ex) {}
        }
        return ranges.length ? Decoration.set(ranges) : Decoration.none;
      }
    }
    return decos;
  },
  provide: f => EditorView.decorations.from(f)
});

// ─── Light Theme for CodeMirror ──────────────────────
const tovaLightTheme = EditorView.theme({
  '&': { backgroundColor: '#f8f9fa', color: '#212529' },
  '.cm-content': { caretColor: '#7c3aed' },
  '.cm-cursor, .cm-dropCursor': { borderLeftColor: '#7c3aed' },
  '&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection': { backgroundColor: 'rgba(124,58,237,0.15)' },
  '.cm-activeLine': { backgroundColor: 'rgba(124,58,237,0.06)' },
  '.cm-gutters': { backgroundColor: '#f1f3f5', color: '#868e96', borderRight: '1px solid #dee2e6' },
  '.cm-activeLineGutter': { backgroundColor: 'rgba(124,58,237,0.08)' },
}, { dark: false });

// Light syntax highlighting colors defined below using HighlightStyle
const lightHighlightStyle = HighlightStyle.define([
  { tag: tags.keyword, color: '#7c3aed', fontWeight: '600' },
  { tag: tags.string, color: '#2b8a3e' },
  { tag: tags.number, color: '#e67700' },
  { tag: tags.bool, color: '#7c3aed' },
  { tag: tags.null, color: '#868e96' },
  { tag: tags.comment, color: '#868e96', fontStyle: 'italic' },
  { tag: tags.lineComment, color: '#868e96', fontStyle: 'italic' },
  { tag: tags.blockComment, color: '#868e96', fontStyle: 'italic' },
  { tag: tags.variableName, color: '#212529' },
  { tag: tags.typeName, color: '#e8590c' },
  { tag: tags.operator, color: '#495057' },
  { tag: tags.brace, color: '#495057' },
  { tag: tags.tagName, color: '#1971c2' },
  { tag: tags.angleBracket, color: '#1971c2' },
  { tag: tags.docString, color: '#0ca678', fontStyle: 'italic' },
]);

const themeCompartment = new Compartment();
const jsThemeCompartment = new Compartment();
var lightTheme = false;
try { lightTheme = localStorage.getItem('tova-playground-theme') === 'light'; } catch(e) {}
function getEditorTheme() {
  return lightTheme
    ? [tovaLightTheme, syntaxHighlighting(lightHighlightStyle)]
    : [oneDark];
}

// ─── Data ───────────────────────────────────────────
const EXAMPLES = [
  {
    "category": "Getting Started",
    "name": "Hello World",
    "code": "// Welcome to Tova! A modern language that transpiles to JavaScript.\n// Click \"Run\" or press Cmd/Ctrl+Enter to execute.\n\nname = \"World\"\ngreeting = \"Hello, {name}!\"\nprint(greeting)\n\n// Tova uses string interpolation with {expressions}\nx = 42\npi = 3.14159\nprint(\"x is {x} and pi is {pi}\")\n\n// Variables: immutable by default, use 'var' for mutable\nlanguage = \"Tova\"         // immutable\nvar version = 1          // mutable\nversion += 1\nprint(\"{language} v{version}\")\n"
  },
  {
    "category": "Getting Started",
    "name": "Variables & Types",
    "code": "// Immutable bindings (default)\nname = \"Alice\"\nage = 30\npi = 3.14159\nis_active = true\nnothing = nil\n\n// Mutable bindings\nvar counter = 0\ncounter += 1\ncounter += 1\nprint(\"counter = {counter}\")\n\n// Multiple assignment\na, b, c = 1, 2, 3\nprint(\"a={a}, b={b}, c={c}\")\n\n// Swap\nvar x = 10\nvar y = 20\nx, y = y, x\nprint(\"After swap: x={x}, y={y}\")\n\n// Type checking\nprint(type_of(42))\nprint(type_of(\"hello\"))\nprint(type_of(true))\nprint(type_of([1, 2, 3]))\nprint(type_of(nil))\n"
  },
  {
    "category": "Getting Started",
    "name": "String Operations",
    "code": "// String interpolation with expressions\nname = \"hello world\"\nprint(\"Upper: {name.upper()}\")\nprint(\"Capitalized: {name.capitalize()}\")\nprint(\"Title: {name.title_case()}\")\n\n// String methods\nsentence = \"the quick brown fox jumps\"\nprint(\"Words: {sentence.words()}\")\nprint(\"Starts with 'the': {sentence.starts_with(\"the\")}\")\nprint(\"Contains 'brown': {sentence.contains(\"brown\")}\")\n\n// Useful conversions\nprint(\"snake_case: {\"helloWorld\".snake_case()}\")\nprint(\"camelCase: {\"hello_world\".camel_case()}\")\n\n// String multiply (repeat)\nborder = \"-\" * 30\nprint(border)\nprint(\"  Tova Language\")\nprint(border)\n\n// Characters and lines\ntext = \"Tova\"\nprint(\"Chars: {text.chars()}\")\n"
  },
  {
    "category": "Functions",
    "name": "Functions & Lambdas",
    "code": "// Functions return the last expression (implicit return)\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"friend\") {\n  \"Hey, {name}!\"\n}\n\nprint(add(1, 2))\nprint(greet())\nprint(greet(\"Alice\"))\n\n// Lambda / anonymous functions\ndouble = fn(x) x * 2\nsquare = fn(x) x * x\nprint(\"double(7) = {double(7)}\")\nprint(\"square(5) = {square(5)}\")\n\n// Arrow syntax\nadd3 = fn(a, b, c) a + b + c\nprint(\"add3(1,2,3) = {add3(1, 2, 3)}\")\n\n// Functions are first-class\nfn apply(f, x) { f(x) }\nprint(\"apply(double, 21) = {apply(double, 21)}\")\n\n// Explicit return\nfn first_positive(items) {\n  for item in items {\n    if item > 0 { return item }\n  }\n  nil\n}\nprint(\"First positive: {first_positive([-3, -1, 0, 4, 7])}\")\n"
  },
  {
    "category": "Functions",
    "name": "Higher-Order Functions",
    "code": "// Map, filter, and reduce with lambdas\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndoubled = map(numbers, fn(x) x * 2)\nprint(\"Doubled: {doubled}\")\n\nevens = filter(numbers, fn(x) x % 2 == 0)\nprint(\"Evens: {evens}\")\n\ntotal = sum(numbers)\nprint(\"Sum: {total}\")\n\n// Composition\nfn compose(f, g) {\n  fn(x) f(g(x))\n}\n\ndouble = fn(x) x * 2\nadd_one = fn(x) x + 1\ndouble_then_add = compose(add_one, double)\nprint(\"double_then_add(5) = {double_then_add(5)}\")\n\n// Sorting with key function\nfruit_names = [\"banana\", \"apple\", \"cherry\", \"date\"]\nby_length = sorted(fruit_names, fn(w) len(w))\nprint(\"By length: {by_length}\")\n\n// Checking conditions\nhas_negative = any([-1, 2, 3], fn(x) x < 0)\nall_positive = all([1, 2, 3], fn(x) x > 0)\nprint(\"Has negative: {has_negative}\")\nprint(\"All positive: {all_positive}\")\n"
  },
  {
    "category": "Functions",
    "name": "Pipe Operator",
    "code": "// The pipe operator |> chains function calls beautifully\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Another example\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\", \"Eve\"]\nresult2 = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\n  |> reversed()\nprint(\"Long names (Z-A): {result2}\")\n\n// Simple pipeline\n42 |> fn(x) x * 2 |> fn(x) \"The answer is {x}\" |> print()\n"
  },
  {
    "category": "Data Structures",
    "name": "Lists & Comprehensions",
    "code": "// List literals\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"Fruits: {fruits}\")\nprint(\"Length: {len(fruits)}\")\n\n// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// With filter\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Build pairs with flat_map\npairs = flat_map(range(1, 4), fn(x) [[x, y] for y in range(1, 4) if x != y])\nprint(\"Pairs: {pairs}\")\n\n// Dict comprehension\nsquare_map = {x: x * x for x in range(1, 6)}\nprint(\"Square map: {square_map}\")\n\n// Slice operations\nnums = [10, 20, 30, 40, 50, 60, 70]\nprint(\"nums[1:4] = {nums[1:4]}\")\nprint(\"nums[:3]  = {nums[:3]}\")\nprint(\"nums[4:]  = {nums[4:]}\")\nprint(\"nums[::-1] = {nums[::-1]}\")\n"
  },
  {
    "category": "Data Structures",
    "name": "Spread & Destructuring",
    "code": "// Array spread\nlist_a = [1, 2, 3]\nlist_b = [4, 5, 6]\ncombined = [...list_a, ...list_b]\nprint(\"Combined: {combined}\")\n\n// Object literals\nconfig = {\n  theme: \"blue\",\n  size: \"medium\",\n  enabled: false,\n  level: 42\n}\nprint(\"Config: {config}\")\n\n// Destructuring objects\nlet {theme, size, enabled} = config\nprint(\"Theme: {theme}\")\nprint(\"Size: {size}\")\n\n// Destructuring arrays\nlet [a, b, c] = [10, 20, 30]\nprint(\"a={a}, b={b}, c={c}\")\n\n// Membership testing\nfruits = [\"apple\", \"banana\", \"cherry\"]\nif \"banana\" in fruits {\n  print(\"We have bananas!\")\n}\nif \"grape\" not in fruits {\n  print(\"No grapes available\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "If / Elif / Else",
    "code": "// If expressions (they return values!)\nfn grade(score) {\n  if score >= 90 {\n    \"A\"\n  } elif score >= 80 {\n    \"B\"\n  } elif score >= 70 {\n    \"C\"\n  } elif score >= 60 {\n    \"D\"\n  } else {\n    \"F\"\n  }\n}\n\nfor s in [95, 85, 72, 65, 45] {\n  print(\"Score {s} = Grade {grade(s)}\")\n}\n\n// Chained comparisons (Python-style!)\ny = 5\nif 1 < y < 10 {\n  print(\"{y} is between 1 and 10\")\n}\n\nage = 25\nif 18 <= age < 65 {\n  print(\"Working age\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Loops",
    "code": "// For loops with range\nprint(\"Counting:\")\nfor i in range(1, 6) {\n  print(\"  {i}\")\n}\n\n// For-in with arrays\ncolors = [\"red\", \"green\", \"blue\"]\nfor color in colors {\n  print(\"Color: {color}\")\n}\n\n// Enumerate (get index + value)\nfor pair in enumerate(colors) {\n  print(\"  {pair[0]}: {pair[1]}\")\n}\n\n// While loops\nvar n = 1\nwhile n < 100 {\n  n = n * 2\n}\nprint(\"First power of 2 >= 100: {n}\")\n\n// FizzBuzz\nfn fizzbuzz(n) {\n  if n % 15 == 0 { \"FizzBuzz\" }\n  elif n % 3 == 0 { \"Fizz\" }\n  elif n % 5 == 0 { \"Buzz\" }\n  else { \"{n}\" }\n}\n\nfor i in range(1, 21) {\n  print(fizzbuzz(i))\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Pattern Matching",
    "code": "// Pattern matching — Tova's most powerful feature!\n\n// Simple value matching\nfn describe(value) {\n  match value {\n    0 => \"zero\"\n    1..10 => \"small (1-9)\"\n    n if n > 100 => \"big: {n}\"\n    _ => \"other: {value}\"\n  }\n}\n\nprint(describe(0))\nprint(describe(5))\nprint(describe(200))\nprint(describe(50))\n\n// Pattern matching on algebraic types\ntype Shape {\n  Circle(radius: Float),\n  Rect(w: Float, h: Float),\n  Triangle(base: Float, height: Float),\n  Point\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n    Triangle(b, h) => 0.5 * b * h\n    Point => 0.0\n  }\n}\n\nfn describe_shape(s) {\n  match s {\n    Circle(r) => \"Circle with radius {r}\"\n    Rect(w, h) => \"Rectangle {w}x{h}\"\n    Triangle(b, h) => \"Triangle base={b} height={h}\"\n    Point => \"Just a point\"\n  }\n}\n\nshapes = [Circle(5.0), Rect(3.0, 4.0), Triangle(6.0, 3.0), Point]\nfor shape in shapes {\n  print(\"{describe_shape(shape)} => area = {area(shape)}\")\n}\n"
  },
  {
    "category": "Types",
    "name": "Algebraic Data Types",
    "code": "// Algebraic Data Types (tagged unions / sum types)\ntype Color {\n  Red,\n  Green,\n  Blue,\n  Custom(r: Int, g: Int, b: Int)\n}\n\nfn to_hex(c) {\n  match c {\n    Red => \"#FF0000\"\n    Green => \"#00FF00\"\n    Blue => \"#0000FF\"\n    Custom(r, g, b) => \"rgb({r},{g},{b})\"\n  }\n}\n\nprint(to_hex(Red))\nprint(to_hex(Custom(255, 128, 0)))\n\n// Option — built-in type: Some(value) or None\nfn safe_divide(a, b) {\n  if b == 0 { None }\n  else { Some(a / b) }\n}\n\nprint(safe_divide(10, 3).unwrapOr(0))\nprint(safe_divide(10, 0).unwrapOr(0))\n\n// Result — built-in type: Ok(value) or Err(error)\nfn parse_age(input) {\n  if input > 0 and input < 150 {\n    Ok(input)\n  } else {\n    Err(\"Invalid age: {input}\")\n  }\n}\n\nmatch parse_age(25) {\n  Ok(v) => print(\"Valid: {v}\")\n  Err(e) => print(\"Error: {e}\")\n}\nmatch parse_age(-5) {\n  Ok(v) => print(\"Valid: {v}\")\n  Err(e) => print(\"Error: {e}\")\n}\n"
  },
  {
    "category": "Types",
    "name": "Struct Types",
    "code": "// Struct-like types with named fields\ntype Point {\n  x: Float\n  y: Float\n}\n\ntype User {\n  name: String\n  age: Int\n}\n\n// Creating instances\np1 = Point(3.0, 4.0)\np2 = Point(1.0, 2.0)\nprint(\"p1 = ({p1.x}, {p1.y})\")\nprint(\"p2 = ({p2.x}, {p2.y})\")\n\n// Distance function\nfn distance(a, b) {\n  dx = a.x - b.x\n  dy = a.y - b.y\n  (dx ** 2 + dy ** 2) ** 0.5\n}\nprint(\"Distance: {distance(p1, p2)}\")\n\n// User records\nusers = [\n  User(\"Alice\", 30),\n  User(\"Bob\", 25),\n  User(\"Charlie\", 35)\n]\n\n// Sort by age\nby_age = sorted(users, fn(u) u.age)\nfor u in by_age {\n  print(\"{u.name}: {u.age}\")\n}\n"
  },
  {
    "category": "Standard Library",
    "name": "Built-in Functions",
    "code": "// Tova comes with useful built-in functions\n\n// range(start?, end, step?)\nprint(\"range(5): {range(5)}\")\nprint(\"range(2,8): {range(2, 8)}\")\nprint(\"range(0,20,3): {range(0, 20, 3)}\")\n\n// len — works on strings, arrays, objects\nprint(\"len('hello'): {len(\"hello\")}\")\nprint(\"len([1,2,3]): {len([1, 2, 3])}\")\n\n// sum, min, max\nnums = [4, 2, 7, 1, 9, 3]\nprint(\"sum: {sum(nums)}\")\nprint(\"min: {min(nums)}\")\nprint(\"max: {max(nums)}\")\n\n// sorted, reversed\nprint(\"sorted: {sorted(nums)}\")\nprint(\"reversed: {reversed(nums)}\")\n\n// enumerate — get index,value pairs\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor pair in enumerate(fruits) {\n  print(\"  [{pair[0]}] {pair[1]}\")\n}\n\n// zip — combine arrays\nlabels = [\"name\", \"age\", \"city\"]\nvals = [\"Alice\", 30, \"NYC\"]\nprint(\"zipped: {zip(labels, vals)}\")\n\n// type_of — runtime type checking\nprint(\"type_of(42): {type_of(42)}\")\nprint(\"type_of(3.14): {type_of(3.14)}\")\nprint(\"type_of('hi'): {type_of(\"hi\")}\")\nprint(\"type_of(true): {type_of(true)}\")\nprint(\"type_of(nil): {type_of(nil)}\")\nprint(\"type_of([1]): {type_of([1, 2])}\")\n"
  },
  {
    "category": "Reactive UI",
    "name": "Counter App",
    "code": "// Counter App in Tova — demonstrates reactive UI\n\nbrowser {\n  state counter = 0\n\n  computed doubled = counter * 2\n  computed message = match counter {\n    0 => \"Click the button!\"\n    1..5 => \"Keep going...\"\n    n if n >= 10 => \"You're on fire! 🔥\"\n    _ => \"Nice!\"\n  }\n\n  component App {\n    <div class=\"counter-app\">\n      <h1>\"Tova Counter\"</h1>\n      <p class=\"count\">\"{counter}\"</p>\n      <p class=\"doubled\">\"Doubled: {doubled}\"</p>\n      <p class=\"message\">\"{message}\"</p>\n      <div class=\"buttons\">\n        <button on:click={fn() counter -= 1}>\"-\"</button>\n        <button on:click={fn() counter += 1}>\"+\"</button>\n        <button on:click={fn() counter = 0}>\"Reset\"</button>\n      </div>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Todo App (Full-Stack)",
    "code": "// Full-Stack Todo App in Tova — demonstrates server/client/shared blocks\n\nshared {\n  type Todo {\n    id: Int\n    title: String\n    completed: Bool\n  }\n}\n\nserver {\n  // In-memory store for demo (use db.query for real apps)\n  var todos = []\n  var next_id = 1\n\n  fn get_todos() -> [Todo] {\n    todos\n  }\n\n  fn add_todo(title: String) -> Todo {\n    todo = Todo(next_id, title, false)\n    next_id += 1\n    todos = [...todos, todo]\n    todo\n  }\n\n  fn toggle_todo(id: Int) -> Todo {\n    for t in todos {\n      if t.id == id {\n        return Todo(t.id, t.title, not t.completed)\n      }\n    }\n    nil\n  }\n\n  fn delete_todo(id: Int) {\n    todos = [t for t in todos if t.id != id]\n  }\n\n  route GET \"/api/todos\" => get_todos\n}\n\nbrowser {\n  state todos: [Todo] = []\n  state new_title = \"\"\n\n  computed remaining = len([t for t in todos if not t.completed])\n  computed total = len(todos)\n\n  effect {\n    todos = server.get_todos()\n  }\n\n  fn handle_add() {\n    if new_title != \"\" {\n      server.add_todo(new_title)\n      new_title = \"\"\n      todos = server.get_todos()\n    }\n  }\n\n  fn handle_toggle(id) {\n    server.toggle_todo(id)\n    todos = server.get_todos()\n  }\n\n  fn handle_delete(id) {\n    server.delete_todo(id)\n    todos = server.get_todos()\n  }\n\n  component TodoItem(todo) {\n    <li class=\"todo-item\">\n      <input type=\"checkbox\" checked={todo.completed} on:change={fn() handle_toggle(todo.id)} />\n      <span class=\"todo-text\">\"{todo.title}\"</span>\n      <button on:click={fn() handle_delete(todo.id)}>\"×\"</button>\n    </li>\n  }\n\n  component App {\n    <div class=\"todo-app\">\n      <h1>\"Tova Todo\"</h1>\n      <div class=\"input-row\">\n        <input\n          type=\"text\"\n          placeholder=\"What needs to be done?\"\n          value={new_title}\n          on:input={fn(e) new_title = e.target.value}\n        />\n        <button on:click={handle_add}>\"Add\"</button>\n      </div>\n      <ul class=\"todo-list\">\n        for todo in todos {\n          <TodoItem todo={todo} />\n        }\n      </ul>\n      <p class=\"status\">\"{remaining} of {total} remaining\"</p>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Temperature Converter",
    "code": "// Temperature converter — reactive two-way conversion\nbrowser {\n  state celsius = 20\n  computed fahrenheit = celsius * 9 / 5 + 32\n  computed kelvin = celsius + 273.15\n\n  computed description = match celsius {\n    c if c <= 0 => \"Freezing!\"\n    c if c <= 15 => \"Cold\"\n    c if c <= 25 => \"Comfortable\"\n    c if c <= 35 => \"Warm\"\n    _ => \"Hot!\"\n  }\n\n  component App {\n    <div class=\"converter\">\n      <h1>\"Temperature Converter\"</h1>\n      <div class=\"input-group\">\n        <label>\"Celsius\"</label>\n        <input type=\"range\" min=\"-40\" max=\"60\" value={celsius}\n               on:input={fn(e) celsius = e.target.value * 1} />\n        <span class=\"value\">\"{celsius}C\"</span>\n      </div>\n      <div class=\"results\">\n        <p>\"{celsius}C = {fahrenheit}F = {kelvin}K\"</p>\n        <p class=\"desc\">\"{description}\"</p>\n      </div>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Reactive UI",
    "name": "Stopwatch",
    "code": "// Interactive stopwatch with reactive state\nbrowser {\n  state elapsed = 0\n\n  fn reset_timer() {\n    elapsed = 0\n  }\n\n  computed minutes = elapsed / 60\n  computed seconds = elapsed % 60\n\n  computed display = match elapsed {\n    0 => \"0s\"\n    t if t < 60 => \"{t}s\"\n    _ => \"{minutes}m {seconds}s\"\n  }\n\n  component App {\n    <div class=\"stopwatch\">\n      <h1>\"Stopwatch\"</h1>\n      <p class=\"time\">\"{display}\"</p>\n      <div class=\"controls\">\n        <button on:click={fn() elapsed += 1}>\"+1s\"</button>\n        <button on:click={fn() elapsed += 10}>\"+10s\"</button>\n        <button on:click={fn() elapsed += 60}>\"+1m\"</button>\n        <button on:click={reset_timer}>\"Reset\"</button>\n      </div>\n      <p class=\"hint\">\"(Click buttons to add time)\"</p>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Reactive UI",
    "name": "Form Validation",
    "code": "// Declarative form with built-in validation\n// Forms are first-class — fields, groups, validators, submit handling\nbrowser {\n  component App() {\n    form signup {\n      field username: String = \"\" {\n        required(\"Username is required\")\n        minLength(3, \"At least 3 characters\")\n        maxLength(20, \"Max 20 characters\")\n      }\n\n      field email: String = \"\" {\n        required(\"Email is required\")\n        email(\"Must be a valid email\")\n      }\n\n      field password: String = \"\" {\n        required(\"Password is required\")\n        minLength(8, \"At least 8 characters\")\n      }\n\n      field confirmPassword: String = \"\" {\n        required(\"Please confirm\")\n        matches(password, \"Passwords don't match\")\n      }\n\n      field age: Int = 0 {\n        min(18, \"Must be 18 or older\")\n      }\n\n      on submit {\n        print(\"Form submitted!\")\n      }\n    }\n\n    <form bind:form={signup}>\n      <h2>\"Sign Up\"</h2>\n\n      <FormField field={signup.username}>\n        <label>\"Username\"</label>\n        <input />\n        <ErrorMessage />\n      </FormField>\n\n      <FormField field={signup.email}>\n        <label>\"Email\"</label>\n        <input type=\"email\" />\n        <ErrorMessage />\n      </FormField>\n\n      <FormField field={signup.password}>\n        <label>\"Password\"</label>\n        <input type=\"password\" />\n        <ErrorMessage />\n      </FormField>\n\n      <FormField field={signup.confirmPassword}>\n        <label>\"Confirm Password\"</label>\n        <input type=\"password\" />\n        <ErrorMessage />\n      </FormField>\n\n      <FormField field={signup.age}>\n        <label>\"Age\"</label>\n        <input type=\"number\" />\n        <ErrorMessage />\n      </FormField>\n\n      <button type=\"submit\" disabled={!signup.isValid}>\n        \"Create Account\"\n      </button>\n      <ErrorMessage form={signup} />\n    </form>\n  }\n}\n"
  },
  {
    "category": "Algorithms",
    "name": "Fibonacci",
    "code": "// Fibonacci sequence — multiple approaches\n\n// Recursive (simple but slow)\nfn fib_recursive(n) {\n  if n <= 1 { n }\n  else { fib_recursive(n - 1) + fib_recursive(n - 2) }\n}\n\n// Iterative (fast)\nfn fib(n) {\n  if n <= 1 { return n }\n  var a = 0\n  var b = 1\n  for _i in range(2, n + 1) {\n    var temp = b\n    b = a + b\n    a = temp\n  }\n  b\n}\n\n// Print first 15 Fibonacci numbers\nprint(\"Fibonacci sequence:\")\nfor i in range(15) {\n  print(\"  fib({i}) = {fib(i)}\")\n}\n\n// Using list comprehension\nfibs = [fib(i) for i in range(20)]\nprint(\"\\nFirst 20: {fibs}\")\nprint(\"Sum: {sum(fibs)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Binary Search",
    "code": "// Binary search on sorted array\nfn binary_search(items, target) {\n  var lo = 0\n  var hi = len(items) - 1\n  while lo <= hi {\n    mid = Math.floor((lo + hi) / 2)\n    if items[mid] == target {\n      return mid\n    } elif items[mid] < target {\n      lo = mid + 1\n    } else {\n      hi = mid - 1\n    }\n  }\n  -1\n}\n\n// Test it\nnums = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\nprint(\"Array: {nums}\")\n\nfor target in [23, 72, 15, 2, 91] {\n  idx = binary_search(nums, target)\n  if idx >= 0 {\n    print(\"Found {target} at index {idx}\")\n  } else {\n    print(\"{target} not found\")\n  }\n}\n\n// Sorting + searching\nword_list = [\"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\", \"fig\"]\nsorted_words = sorted(word_list)\nprint(\"\\nSorted: {sorted_words}\")\nprint(\"Index of 'cherry': {binary_search(sorted_words, \"cherry\")}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Linked List with ADTs",
    "code": "// Linked List using algebraic data types\ntype List {\n  Cons(head: Any, tail: Any),\n  Empty\n}\n\n// Constructor helper\nfn list_of(arr) {\n  var result = Empty\n  for i in range(len(arr) - 1, -1, -1) {\n    result = Cons(arr[i], result)\n  }\n  result\n}\n\n// Operations\nfn list_len(lst) {\n  match lst {\n    Empty => 0\n    Cons(_, tail) => 1 + list_len(tail)\n  }\n}\n\nfn list_map(lst, f) {\n  match lst {\n    Empty => Empty\n    Cons(h, t) => Cons(f(h), list_map(t, f))\n  }\n}\n\nfn list_to_array(lst) {\n  var result = []\n  var current = lst\n  while current != Empty {\n    match current {\n      Cons(h, t) => {\n        result = [...result, h]\n        current = t\n      }\n      _ => { current = Empty }\n    }\n  }\n  result\n}\n\n// Test it\nmy_list = list_of([1, 2, 3, 4, 5])\nprint(\"Length: {list_len(my_list)}\")\n\ndoubled = list_map(my_list, fn(x) x * 2)\nprint(\"Doubled: {list_to_array(doubled)}\")\n\nsquared = list_map(my_list, fn(x) x * x)\nprint(\"Squared: {list_to_array(squared)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Game of Life",
    "code": "// Conway's Game of Life — one generation step\n\nfn make_grid(rows, cols) {\n  [[0 for _c in range(cols)] for _r in range(rows)]\n}\n\nfn count_neighbors(grid, r, c) {\n  rows = len(grid)\n  cols = len(grid[0])\n  var total = 0\n  for dr in [-1, 0, 1] {\n    for dc in [-1, 0, 1] {\n      if dr == 0 and dc == 0 { }\n      else {\n        nr = (r + dr + rows) % rows\n        nc = (c + dc + cols) % cols\n        total = total + grid[nr][nc]\n      }\n    }\n  }\n  total\n}\n\nfn step(grid) {\n  rows = len(grid)\n  cols = len(grid[0])\n  [\n    [\n      match [grid[r][c], count_neighbors(grid, r, c)] {\n        [1, n] if n < 2 => 0\n        [1, n] if n > 3 => 0\n        [1, _] => 1\n        [0, 3] => 1\n        _ => grid[r][c]\n      }\n    for c in range(cols)]\n  for r in range(rows)]\n}\n\nfn display(grid) {\n  for row in grid {\n    line = [match cell { 0 => \".\" _ => \"#\" } for cell in row]\n    print(line)\n  }\n}\n\n// Glider pattern\nvar grid = make_grid(8, 8)\ngrid[1][2] = 1\ngrid[2][3] = 1\ngrid[3][1] = 1\ngrid[3][2] = 1\ngrid[3][3] = 1\n\nprint(\"Generation 0:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 1:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 2:\")\ndisplay(grid)\n"
  }
];
const REFERENCE = [
  {
    "title": "Variables",
    "items": [
      {
        "syntax": "name = \"Alice\"",
        "desc": "Immutable binding"
      },
      {
        "syntax": "var count = 0",
        "desc": "Mutable binding"
      },
      {
        "syntax": "a, b = 1, 2",
        "desc": "Multiple assignment"
      },
      {
        "syntax": "x, y = y, x",
        "desc": "Swap values"
      }
    ]
  },
  {
    "title": "Types",
    "items": [
      {
        "syntax": "Int, Float, String, Bool, Nil",
        "desc": "Primitive types"
      },
      {
        "syntax": "type Point { x: Float, y: Float }",
        "desc": "Struct type"
      },
      {
        "syntax": "type Color { Red, Blue, Custom(r: Int) }",
        "desc": "Algebraic type (ADT)"
      }
    ]
  },
  {
    "title": "Functions",
    "items": [
      {
        "syntax": "fn add(a, b) { a + b }",
        "desc": "Function (implicit return)"
      },
      {
        "syntax": "fn greet(name = \"world\") { ... }",
        "desc": "Default parameters"
      },
      {
        "syntax": "double = fn(x) x * 2",
        "desc": "Lambda expression"
      },
      {
        "syntax": "return value",
        "desc": "Early return"
      }
    ]
  },
  {
    "title": "Control Flow",
    "items": [
      {
        "syntax": "if cond { } elif { } else { }",
        "desc": "Conditionals"
      },
      {
        "syntax": "for item in items { }",
        "desc": "For-in loop"
      },
      {
        "syntax": "for i in range(10) { }",
        "desc": "Range loop"
      },
      {
        "syntax": "while cond { }",
        "desc": "While loop"
      }
    ]
  },
  {
    "title": "Pattern Matching",
    "items": [
      {
        "syntax": "match value { 0 => \"zero\", _ => \"other\" }",
        "desc": "Value matching"
      },
      {
        "syntax": "1..10 => \"small\"",
        "desc": "Range pattern"
      },
      {
        "syntax": "n if n > 100 => \"big\"",
        "desc": "Guard clause"
      },
      {
        "syntax": "Circle(r) => 3.14 * r ** 2",
        "desc": "Destructure ADT"
      }
    ]
  },
  {
    "title": "Strings",
    "items": [
      {
        "syntax": "\"Hello, {name}!\"",
        "desc": "Interpolation"
      },
      {
        "syntax": ".upper() .lower() .trim()",
        "desc": "Case methods"
      },
      {
        "syntax": ".contains(s) .starts_with(s)",
        "desc": "Search methods"
      },
      {
        "syntax": ".words() .chars() .lines()",
        "desc": "Split methods"
      },
      {
        "syntax": ".capitalize() .title_case()",
        "desc": "Format methods"
      },
      {
        "syntax": "\"-\" * 20",
        "desc": "String repeat"
      }
    ]
  },
  {
    "title": "Collections",
    "items": [
      {
        "syntax": "[1, 2, 3]",
        "desc": "Array literal"
      },
      {
        "syntax": "{key: value}",
        "desc": "Object literal"
      },
      {
        "syntax": "[x*2 for x in items if x > 0]",
        "desc": "List comprehension"
      },
      {
        "syntax": "{k: v for k in keys}",
        "desc": "Dict comprehension"
      },
      {
        "syntax": "arr[1:3]  arr[::-1]",
        "desc": "Slice syntax"
      },
      {
        "syntax": "[...a, ...b]",
        "desc": "Spread operator"
      }
    ]
  },
  {
    "title": "Operators",
    "items": [
      {
        "syntax": "+ - * / % **",
        "desc": "Arithmetic (** is power)"
      },
      {
        "syntax": "== != < <= > >=",
        "desc": "Comparison"
      },
      {
        "syntax": "and  or  not",
        "desc": "Logical"
      },
      {
        "syntax": "|>",
        "desc": "Pipe operator"
      },
      {
        "syntax": "x in list / x not in list",
        "desc": "Membership"
      },
      {
        "syntax": "1 < x < 10",
        "desc": "Chained comparison"
      },
      {
        "syntax": "a?.b",
        "desc": "Optional chaining"
      }
    ]
  },
  {
    "title": "Stdlib Functions",
    "items": [
      {
        "syntax": "print(...args)",
        "desc": "Print to console"
      },
      {
        "syntax": "len(v)",
        "desc": "Length of string/array/object"
      },
      {
        "syntax": "range(start?, end, step?)",
        "desc": "Generate number array"
      },
      {
        "syntax": "sum(arr) min(arr) max(arr)",
        "desc": "Aggregation"
      },
      {
        "syntax": "sorted(arr, key?) reversed(arr)",
        "desc": "Ordering"
      },
      {
        "syntax": "enumerate(arr)",
        "desc": "Index-value pairs"
      },
      {
        "syntax": "zip(a, b, ...)",
        "desc": "Combine arrays"
      },
      {
        "syntax": "map(arr, fn) filter(arr, fn)",
        "desc": "Transform/filter"
      },
      {
        "syntax": "type_of(value)",
        "desc": "Runtime type name"
      }
    ]
  },
  {
    "title": "Reactive (browser)",
    "items": [
      {
        "syntax": "state counter = 0",
        "desc": "Reactive variable (signal)"
      },
      {
        "syntax": "computed doubled = counter * 2",
        "desc": "Derived value"
      },
      {
        "syntax": "effect { ... }",
        "desc": "Side effect (auto-tracks deps)"
      },
      {
        "syntax": "component App { <div>...</div> }",
        "desc": "UI component"
      },
      {
        "syntax": "on:click={fn() ...}",
        "desc": "Event handler"
      },
      {
        "syntax": "server.method()",
        "desc": "RPC call to server"
      }
    ]
  },
  {
    "title": "Full-Stack Blocks",
    "items": [
      {
        "syntax": "server { ... }",
        "desc": "Server-side code (Bun)"
      },
      {
        "syntax": "browser { ... }",
        "desc": "Browser-side code"
      },
      {
        "syntax": "shared { ... }",
        "desc": "Shared code (both)"
      },
      {
        "syntax": "route GET \"/path\" => handler",
        "desc": "HTTP route"
      }
    ]
  }
];
const TUTORIAL = [
  {
    "title": "Welcome to Tova",
    "description": "Tova is a modern language that compiles to JavaScript. It combines Python's readability with ML-style pattern matching and built-in reactivity.",
    "code": "// Try running this! Press Cmd/Ctrl+Enter or click Run.\nprint(\"Welcome to Tova!\")\n\n// Variables are immutable by default\nname = \"Developer\"\nprint(\"Hello, {name}!\")\n\n// Use 'var' for mutable variables\nvar counter = 0\ncounter += 1\nprint(\"Counter: {counter}\")"
  },
  {
    "title": "Functions",
    "description": "Functions use the fn keyword and return their last expression. No \"return\" needed!",
    "code": "// Implicit return — the last expression is returned\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"World\") {\n  \"Hello, {name}!\"\n}\n\nprint(add(3, 4))\nprint(greet())\nprint(greet(\"Tova\"))\n\n// Lambdas for short functions\ndouble = fn(x) x * 2\nprint(double(21))"
  },
  {
    "title": "Collections",
    "description": "Tova has powerful collection features: list comprehensions, slicing, and the pipe operator.",
    "code": "// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// Filter with comprehension\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Pipe operator for readable chains\nresult = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Slicing\narr = [10, 20, 30, 40, 50]\nprint(\"First 3: {arr[:3]}\")\nprint(\"Last 2: {arr[3:]}\")"
  },
  {
    "title": "Pattern Matching",
    "description": "Match expressions are like switch on steroids. They support values, ranges, guards, and destructuring.",
    "code": "// Match on values and ranges\nfn classify(n) {\n  match n {\n    0 => \"zero\"\n    1..10 => \"small\"\n    n if n > 100 => \"huge: {n}\"\n    _ => \"medium: {n}\"\n  }\n}\n\nfor n in [0, 3, 50, 200] {\n  print(\"{n} -> {classify(n)}\")\n}\n\n// Match on algebraic types\ntype Shape {\n  Circle(r: Float),\n  Rect(w: Float, h: Float)\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n  }\n}\n\nprint(\"Circle area: {area(Circle(5.0))}\")\nprint(\"Rect area: {area(Rect(3.0, 4.0))}\")"
  },
  {
    "title": "Types & ADTs",
    "description": "Define struct-like types and algebraic data types (tagged unions) for type-safe data modeling.",
    "code": "// Struct type\ntype User {\n  name: String\n  age: Int\n}\n\n// Algebraic type (sum type)\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn validate_age(age) {\n  if age >= 0 and age <= 150 {\n    Ok(User(\"Valid\", age))\n  } else {\n    Err(\"Age must be 0-150, got {age}\")\n  }\n}\n\nfor age in [25, -5, 200, 42] {\n  result = validate_age(age)\n  match result {\n    Ok(user) => print(\"Valid: age {user.age}\")\n    Err(msg) => print(\"Error: {msg}\")\n  }\n}"
  },
  {
    "title": "Reactive UI",
    "description": "Tova has built-in reactivity for building UIs. State changes automatically update the DOM!",
    "code": "// Switch to the \"Preview\" tab to see this in action!\nbrowser {\n  state clicks = 0\n  computed doubled = clicks * 2\n  computed emoji = match clicks {\n    0 => \"Start clicking!\"\n    c if c < 5 => \"Getting started...\"\n    c if c < 10 => \"Nice!\"\n    _ => \"On fire!\"\n  }\n\n  component App {\n    <div style=\"text-align: center; padding: 20px;\">\n      <h1>\"Tova Reactive Demo\"</h1>\n      <p style=\"font-size: 48px;\">\"{clicks}\"</p>\n      <p>\"Doubled: {doubled}\"</p>\n      <p>\"{emoji}\"</p>\n      <button on:click={fn() clicks += 1}>\"+ Add\"</button>\n      <button on:click={fn() clicks -= 1}>\"- Sub\"</button>\n      <button on:click={fn() clicks = 0}>\"Reset\"</button>\n    </div>\n  }\n}"
  },
  {
    "title": "Strings & Interpolation",
    "description": "Tova strings support interpolation with {expressions}, plus Python-style methods like .upper(), .contains(), and even string repetition.",
    "code": "// String interpolation with any expression\nname = \"World\"\nprint(\"Hello, {name}!\")\n\n// Expressions inside interpolation\nx = 7\nprint(\"{x} squared is {x * x}\")\n\n// String methods\ngreeting = \"hello world\"\nprint(greeting.upper())\nprint(greeting.capitalize())\nprint(greeting.title_case())\n\n// Useful checks\nprint(\"contains 'world': {greeting.contains(\"world\")}\")\nprint(\"starts with 'hello': {greeting.starts_with(\"hello\")}\")\n\n// String repetition\nborder = \"=\" * 30\nprint(border)\nprint(\"  Tova is great!\")\nprint(border)"
  },
  {
    "title": "Pipe Operator",
    "description": "The pipe operator |> chains function calls, making data transformations read top-to-bottom instead of inside-out.",
    "code": "// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\n\nprint(\"Sum of squares of evens: {result}\")\n\n// Name pipeline\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\"]\nsorted_long = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\nprint(\"Long names sorted: {sorted_long}\")\n\n// Simple value pipeline\n42 |> fn(x) x * 2 |> fn(x) \"Answer: {x}\" |> print()"
  },
  {
    "title": "Full-Stack App",
    "description": "Tova has built-in full-stack blocks: server, browser, and shared. In the playground, server features are simulated.",
    "code": "// A full-stack app has server + browser blocks.\n// In playground mode, server calls are stubbed.\n\nbrowser {\n  state name = \"World\"\n  computed greeting = \"Hello, {name}!\"\n\n  component App {\n    <div style=\"padding: 20px;\">\n      <h1>\"Full-Stack Demo\"</h1>\n      <div class=\"input-group\">\n        <label>\"Your name:\"</label>\n        <input type=\"text\" value={name}\n               on:input={fn(e) name = e.target.value} />\n      </div>\n      <p style=\"font-size: 24px; margin-top: 16px;\">\"{greeting}\"</p>\n      <p class=\"hint\">\"(Type to see reactive updates!)\"</p>\n    </div>\n  }\n}"
  },
  {
    "title": "Advanced Patterns",
    "description": "Combine pattern matching with algebraic types, guards, and destructuring for expressive code.",
    "code": "// Result type with pattern matching\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_number(s) {\n  n = s * 1  // coerce to number\n  if n != n { Err(\"Not a number: {s}\") }\n  else { Ok(n) }\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { Err(\"Division by zero\") }\n  else { Ok(a / b) }\n}\n\n// Chain operations with match\ninputs = [[\"10\", \"2\"], [\"42\", \"0\"], [\"abc\", \"5\"], [\"100\", \"4\"]]\nfor pair in inputs {\n  result = match parse_number(pair[0]) {\n    Err(msg) => Err(msg)\n    Ok(a) => match parse_number(pair[1]) {\n      Err(msg) => Err(msg)\n      Ok(b) => safe_divide(a, b)\n    }\n  }\n  match result {\n    Ok(v) => print(\"{pair[0]} / {pair[1]} = {v}\")\n    Err(msg) => print(\"{pair[0]} / {pair[1]} -> Error: {msg}\")\n  }\n}"
  }
];

// ─── State ──────────────────────────────────────────
let autoCompile = true;
let autoRun = true;
let sidebarMode = null; // 'reference' | 'tutorial' | null
let tutorialStep = 0;
let compileTimer = null;
var layoutVertical = false;
try { layoutVertical = localStorage.getItem('tova-playground-layout') === 'vertical'; } catch(e) {}

// ─── Early embed mode detection ─────────────────────
const __isEmbed = new URLSearchParams(location.search).get('embed') === 'true';

// ─── Restore settings from localStorage ─────────────
try {
  const saved = JSON.parse(localStorage.getItem('tova-playground-settings') || '{}');
  if (saved.fontSize) document.documentElement.style.setProperty('--editor-font-size', saved.fontSize + 'px');
  if (saved.fontSize) document.getElementById('setting-fontsize').value = saved.fontSize;
  if (saved.autoCompile === false) { autoCompile = false; document.getElementById('setting-autocompile').classList.remove('on'); }
  if (saved.autoRun === false) { autoRun = false; document.getElementById('setting-autorun').classList.remove('on'); }
} catch(e) {}

function saveSettings() {
  try {
    localStorage.setItem('tova-playground-settings', JSON.stringify({
      fontSize: parseInt(document.getElementById('setting-fontsize').value),
      autoCompile,
      autoRun
    }));
  } catch(e) {}
}

// ─── Editor Setup ───────────────────────────────────
const statusCursor = document.getElementById('status-cursor');

// Restore last code or use first example (skip localStorage in embed mode)
let initialCode = EXAMPLES[0].code;
if (!__isEmbed) {
  try {
    const lastCode = localStorage.getItem('tova-playground-code');
    if (lastCode && lastCode.trim()) initialCode = lastCode;
  } catch(e) {}
}

const editor = new EditorView({
  state: EditorState.create({
    doc: initialCode,
    extensions: [
      basicSetup,
      themeCompartment.of(getEditorTheme()),
      tovaLanguage,
      errorField,
      autocompletion({
        override: [tovaCompletions],
        icons: true,
        activateOnTyping: true,
      }),
      EditorView.updateListener.of(update => {
        if (update.docChanged) {
          try { localStorage.setItem('tova-playground-code', update.state.doc.toString()); } catch(e) {}
          if (autoCompile) scheduleCompile();
        }
        if (update.selectionSet) {
          const pos = update.state.selection.main.head;
          const line = update.state.doc.lineAt(pos);
          const lines = update.state.doc.lines;
          const chars = update.state.doc.length;
          statusCursor.textContent = 'Ln ' + line.number + ', Col ' + (pos - line.from + 1) + '  |  ' + lines + ' lines, ' + chars + ' chars';
        }
      }),
      keymap.of([
        { key: 'Mod-Enter', run: () => { compile(); return true; } },
        { key: 'Mod-k', run: () => { toggleCommandPalette(); return true; } },
        { key: 'Mod-s', run: () => {
          try { localStorage.setItem('tova-playground-code', editor.state.doc.toString()); } catch(e) {}
          const s = document.getElementById('status-compile');
          s.className = 'success'; s.textContent = 'Saved to browser';
          return true;
        }},
        { key: 'Mod-Shift-r', run: () => { toggleSidebar('reference'); return true; } },
        { key: 'Mod-Shift-s', run: () => { downloadCode(); return true; } },
        { key: 'Mod-/', run: () => { toggleModal('shortcuts-modal'); return true; } },
        { key: 'Mod-j', run: () => { toggleLayout(); return true; } },
      ]),
    ],
  }),
  parent: document.getElementById('editor'),
});

// Remove loading indicator
const loadingEl = document.getElementById('editor-loading');
if (loadingEl) loadingEl.remove();

// ─── Populate Examples (with optgroups) ─────────────
const exSelect = document.getElementById('examples-select');
let optgroup = null;
let currentCat = null;
EXAMPLES.forEach((ex, i) => {
  if (ex.category !== currentCat) {
    currentCat = ex.category;
    optgroup = document.createElement('optgroup');
    optgroup.label = currentCat;
    exSelect.appendChild(optgroup);
  }
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = ex.name;
  optgroup.appendChild(opt);
});
exSelect.addEventListener('change', () => {
  const code = EXAMPLES[+exSelect.value].code;
  setEditorCode(code);
});

function setEditorCode(code) {
  editor.dispatch({ changes: { from: 0, to: editor.state.doc.length, insert: code } });
  compile();
}

// ─── Output Tabs ────────────────────────────────────
function switchTab(tabName) {
  document.querySelectorAll('#output-tabs .tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.output-panel').forEach(p => p.classList.remove('active'));
  const tab = document.querySelector('#output-tabs .tab[data-tab="' + tabName + '"]');
  if (tab) tab.classList.add('active');
  const panel = document.getElementById('panel-' + tabName);
  if (panel) panel.classList.add('active');
}

document.querySelectorAll('#output-tabs .tab').forEach(tab => {
  tab.addEventListener('click', () => switchTab(tab.dataset.tab));
});

// ─── Drag Handle ────────────────────────────────────
const dragHandle = document.getElementById('drag-handle');
const mainEl = document.querySelector('.main');
const editorPane = document.querySelector('.pane-editor');
const outputPane = document.querySelector('.pane-output');

let dragging = false;
dragHandle.addEventListener('mousedown', e => { dragging = true; dragHandle.classList.add('active'); e.preventDefault(); });
document.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = mainEl.getBoundingClientRect();
  const sidebarW = sidebarMode ? parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w')) : 0;
  if (layoutVertical) {
    const availH = rect.height;
    const pct = ((e.clientY - rect.top) / availH) * 100;
    const clamped = Math.max(20, Math.min(80, pct));
    editorPane.style.flex = 'none';
    editorPane.style.width = '';
    editorPane.style.height = clamped + '%';
    outputPane.style.flex = '1';
  } else {
    const availW = rect.width - sidebarW;
    const pct = ((e.clientX - rect.left) / availW) * 100;
    const clamped = Math.max(20, Math.min(80, pct));
    editorPane.style.flex = 'none';
    editorPane.style.height = '';
    editorPane.style.width = clamped + '%';
    outputPane.style.flex = '1';
  }
});
document.addEventListener('mouseup', () => { dragging = false; dragHandle.classList.remove('active'); });

// ─── Share ──────────────────────────────────────────
document.getElementById('btn-share').addEventListener('click', () => {
  const code = editor.state.doc.toString();
  const compressed = LZString.compressToEncodedURIComponent(code);
  const url = location.origin + location.pathname + '#code=' + compressed;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('btn-share');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Share'; }, 2000);
  });
});

// ─── Download ───────────────────────────────────────
function downloadCode() {
  const code = editor.state.doc.toString();
  const blob = new Blob([code], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'playground.tova';
  a.click();
  URL.revokeObjectURL(a.href);
}
document.getElementById('btn-download').addEventListener('click', downloadCode);

// ─── Reset to Default ───────────────────────────────
document.getElementById('btn-reset').addEventListener('click', () => {
  const defaultCode = EXAMPLES[0].code;
  if (editor.state.doc.toString() === defaultCode) return;
  setEditorCode(defaultCode);
  try { localStorage.setItem('tova-playground-code', defaultCode); } catch(e) {}
  const statusEl = document.getElementById('status-compile');
  statusEl.className = 'success';
  statusEl.textContent = 'Reset to default';
});

// ─── Load from URL hash ─────────────────────────────
function loadFromHash() {
  const hash = location.hash.slice(1);
  if (hash.startsWith('code=')) {
    try {
      const code = LZString.decompressFromEncodedURIComponent(hash.slice(5));
      if (code) { setEditorCode(code); return true; }
    } catch (e) {}
  }
  return false;
}
loadFromHash();
window.addEventListener('hashchange', loadFromHash);

// ─── Run Button ─────────────────────────────────────
document.getElementById('btn-run').addEventListener('click', compile);

// ─── Debounced Compile ──────────────────────────────
function scheduleCompile() {
  clearTimeout(compileTimer);
  compileTimer = setTimeout(() => compile(false), 350);
}

// ─── Compiler ───────────────────────────────────────
let lastJsText = '';

function compile(isManual = true) {
  const source = editor.state.doc.toString();
  const statusEl = document.getElementById('status-compile');
  const statusSize = document.getElementById('status-size');
  const errorBanner = document.getElementById('error-banner');
  const errorText = document.getElementById('error-text');
  const errorHint = document.getElementById('error-hint');
  const consoleOutput = document.getElementById('console-output');
  const consoleBadge = document.getElementById('console-badge');
  const consoleTimingEl = document.getElementById('console-timing');
  const astOutput = document.getElementById('ast-output');
  const previewFrame = document.getElementById('preview-frame');

  errorBanner.classList.remove('visible');
  errorText.textContent = '';
  if (errorHint) errorHint.textContent = '';
  consoleOutput.innerHTML = '';
  consoleBadge.style.display = 'none';

  // Clear error decorations
  editor.dispatch({ effects: clearErrorEffect.of(null) });

  const start = performance.now();

  try {
    const lexer = new Lexer(source, 'playground.tova');
    const tokens = lexer.tokenize();

    const parser = new Parser(tokens, 'playground.tova');
    const ast = parser.parse();

    const analyzer = new Analyzer(ast, 'playground.tova');
    const { warnings } = analyzer.analyze();

    const codegen = new CodeGenerator(ast, 'playground.tova');
    const result = codegen.generate();

    const elapsed = (performance.now() - start).toFixed(1);

    // JS Output
    let jsText = '';
    if (result.shared) jsText += '// ── Shared ──\n' + result.shared + '\n\n';
    if (result.server) jsText += '// ── Server ──\n' + result.server + '\n\n';
    if (result.browser) jsText += '// ── Browser ──\n' + result.browser + '\n\n';
    if (!result.shared && !result.server && !result.browser && result.code) {
      jsText = result.code;
    }
    lastJsText = jsText || '// No output';

    // Update JS output (use CodeMirror read-only editor if available, else pre tag)
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: lastJsText } });
    } else {
      document.getElementById('js-output').textContent = lastJsText;
    }

    // Status bar output size
    if (statusSize) statusSize.textContent = (lastJsText.length / 1024).toFixed(1) + ' KB output';

    // AST
    astOutput.innerHTML = '';
    astOutput.appendChild(renderAST(ast));

    // Console + Preview
    if (autoRun) {
      executeCode(result, consoleOutput, previewFrame, consoleBadge, consoleTimingEl);
    }

    // Warnings
    const warnCount = warnings ? warnings.length : 0;
    if (warnCount) {
      for (const w of warnings) {
        const div = document.createElement('div');
        div.className = 'log-warn';
        div.innerHTML = '<span class="log-icon">\u26A0</span> Warning: ' + escapeHtml(w.message || String(w));
        consoleOutput.appendChild(div);
      }
    }

    statusEl.className = 'success';
    statusEl.textContent = '\u2713 Compiled in ' + elapsed + 'ms' + (warnCount ? ' (' + warnCount + ' warning' + (warnCount > 1 ? 's' : '') + ')' : '');

  } catch (err) {
    const elapsed = (performance.now() - start).toFixed(1);
    statusEl.className = 'error';
    statusEl.textContent = '\u2717 Error (' + elapsed + 'ms)';
    errorText.textContent = err.message;

    // Error hints for common mistakes
    const hints = getErrorHint(err.message);
    if (errorHint && hints) errorHint.textContent = hints;

    errorBanner.classList.add('visible');
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: '// Compilation error\n// ' + err.message } });
    } else {
      document.getElementById('js-output').textContent = '// Compilation error\n// ' + err.message;
    }
    previewFrame.srcdoc = '';

    // Highlight error line in editor with decorations
    const lineMatch = err.message.match(/:(\d+):/);
    if (lineMatch) {
      const lineNum = parseInt(lineMatch[1]);
      editor.dispatch({ effects: setErrorEffect.of([lineNum]) });
      // Scroll to error line only on manual compile to avoid cursor jumping during typing
      if (isManual) {
        try {
          const lineInfo = editor.state.doc.line(lineNum);
          editor.dispatch({ selection: { anchor: lineInfo.from } });
        } catch(e) {}
      }
    }
  }
}

function getErrorHint(msg) {
  if (msg.includes('Unexpected token')) return 'Tip: Check for missing closing brackets or semicolons';
  if (msg.includes('not defined')) return 'Tip: Make sure the variable is declared before use';
  if (msg.includes('Expected')) return 'Tip: The compiler expected a different token here';
  return null;
}

// ─── Execute Code ───────────────────────────────────
function executeCode(result, consoleEl, previewFrame, consoleBadge, consoleTimingEl) {
  const logs = [];
  const fakeConsole = {
    log: (...args) => logs.push({ type: 'log', args }),
    warn: (...args) => logs.push({ type: 'warn', args }),
    error: (...args) => logs.push({ type: 'error', args }),
    info: (...args) => logs.push({ type: 'info', args }),
  };

  const execStart = performance.now();
  const codeToRun = result.code || result.shared || '';
  if (codeToRun.trim()) {
    try {
      // Run in a blob Worker with a 3-second timeout to catch infinite loops
      const workerCode = STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n' + ARRAY_PROTO_CODE + '\n' +
        'const __logs = [];\n' +
        'const console = {\n' +
        '  log: (...a) => __logs.push({type:"log",args:a.map(__ser)}),\n' +
        '  warn: (...a) => __logs.push({type:"warn",args:a.map(__ser)}),\n' +
        '  error: (...a) => __logs.push({type:"error",args:a.map(__ser)}),\n' +
        '  info: (...a) => __logs.push({type:"info",args:a.map(__ser)}),\n' +
        '};\n' +
        'function __ser(v) { if (v === null) return "null"; if (v === undefined) return "undefined"; if (typeof v === "object") { try { return JSON.stringify(v); } catch(e) { return String(v); } } return String(v); }\n' +
        codeToRun + '\n' +
        'postMessage({type:"done",logs:__logs});';
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      const w = new Worker(url);
      let finished = false;
      const timeout = setTimeout(() => {
        if (!finished) {
          finished = true;
          w.terminate();
          URL.revokeObjectURL(url);
          logs.push({ type: 'error', args: ['Execution timed out (3s limit). Possible infinite loop.'] });
          renderLogs();
        }
      }, 3000);
      w.onmessage = (e) => {
        if (finished) return;
        finished = true;
        clearTimeout(timeout);
        w.terminate();
        URL.revokeObjectURL(url);
        if (e.data.type === 'done') {
          for (const log of e.data.logs) {
            logs.push({ type: log.type, args: [log.args.join(' ')] });
          }
        }
        renderLogs();
      };
      w.onerror = (e) => {
        if (finished) return;
        finished = true;
        clearTimeout(timeout);
        w.terminate();
        URL.revokeObjectURL(url);
        logs.push({ type: 'error', args: ['Runtime Error: ' + (e.message || 'Unknown error')] });
        renderLogs();
      };
    } catch (e) {
      logs.push({ type: 'error', args: ['Runtime Error: ' + e.message] });
    }
  }
  const execTime = (performance.now() - execStart).toFixed(2);

  // Render logs (called sync or async from worker)
  function renderLogs() {
    const elapsed = (performance.now() - execStart).toFixed(2);
    if (consoleTimingEl) consoleTimingEl.textContent = 'Executed in ' + elapsed + 'ms';

    const icons = { log: '\u203A', warn: '\u26A0', error: '\u2717', info: '\u2139' };
    let errorCount = 0;
    for (const log of logs) {
      const div = document.createElement('div');
      div.className = 'log-' + log.type;
      const icon = document.createElement('span');
      icon.className = 'log-icon';
      icon.textContent = icons[log.type] || '';
      div.appendChild(icon);
      const content = document.createElement('span');
      content.className = 'log-content';
      const textParts = log.args.map(a => {
        if (a === null) return 'null';
        if (a === undefined) return 'undefined';
        if (typeof a === 'object') {
          try { return JSON.stringify(a, null, 2); } catch(e) { return String(a); }
        }
        return String(a);
      });
      content.textContent = textParts.join(' ');
      div.appendChild(content);
      consoleEl.appendChild(div);
      if (log.type === 'error') errorCount++;
    }

    if (errorCount > 0) {
      consoleBadge.textContent = errorCount;
      consoleBadge.style.display = 'inline';
      switchTab('console');
    }

    if (logs.length > 0 && !result.browser) {
      switchTab('console');
    }
  }

  // For non-worker code paths (browser code), render immediately
  if (!codeToRun.trim() || result.browser) {
    renderLogs();
  }

  // Live Preview for browser code
  if (result.browser) {
    const browserCode = result.browser
      .replace(/import\s+.*from\s+['"].*['"];?/g, '')
      .replace(/import\s+['"].*['"];?/g, '');

    const previewCSS = '*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }' +
      'body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding: 20px; color: #333; }' +
      'button { cursor: pointer; padding: 8px 16px; margin: 4px; border-radius: 6px; border: 1px solid #ddd; background: #f5f5f5; font-size: 14px; transition: all 0.15s; }' +
      'button:hover { background: #e8e8e8; border-color: #ccc; }' +
      'button:active { transform: scale(0.97); }' +
      'input[type="text"], input[type="number"] { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; margin: 4px; font-size: 14px; outline: none; }' +
      'input[type="text"]:focus, input[type="number"]:focus { border-color: #7c3aed; box-shadow: 0 0 0 3px rgba(124,58,237,0.1); }' +
      'input[type="range"] { width: 200px; margin: 8px 0; }' +
      'input[type="checkbox"] { margin: 4px 8px 4px 0; }' +
      'ul { list-style: none; } li { padding: 6px 0; }' +
      'h1 { margin-bottom: 16px; font-size: 24px; } h2 { margin-bottom: 12px; font-size: 20px; }' +
      'p { margin: 6px 0; line-height: 1.5; }' +
      '.status { color: #666; font-size: 14px; margin-top: 12px; }' +
      '.counter-app, .todo-app, .converter, .stopwatch { max-width: 400px; }' +
      '.count { font-size: 48px; font-weight: 700; color: #7c3aed; }' +
      '.buttons { display: flex; gap: 4px; margin-top: 8px; }' +
      '.input-row { display: flex; gap: 4px; margin-bottom: 12px; }' +
      '.input-row input { flex: 1; }' +
      '.todo-item { display: flex; align-items: center; gap: 8px; }' +
      '.todo-text { flex: 1; }' +
      '.input-group { margin: 12px 0; }' +
      '.input-group label { display: block; font-weight: 600; margin-bottom: 4px; }' +
      '.value { font-size: 18px; font-weight: 600; color: #7c3aed; margin-left: 8px; }' +
      '.desc { font-style: italic; color: #666; }' +
      '.time { font-size: 48px; font-weight: 700; color: #7c3aed; margin: 16px 0; }' +
      '.controls { display: flex; gap: 4px; flex-wrap: wrap; }' +
      '.hint { color: #999; font-size: 12px; margin-top: 12px; }';

    const sharedCode = (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');

    // Build preview HTML using string concatenation — NOT a template literal.
    // Generated browser code may contain backticks (JS template strings from
    // string interpolation) which would break a template-literal wrapper.
    const previewHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8">\n<style>' + previewCSS + '</style>\n</head><body>\n' +
      '<div id="app"></div>\n<script>\n' +
      RUNTIME_CODE + '\n' +
      STDLIB_CODE + '\n' +
      STRING_PROTO_CODE + '\n' +
      ARRAY_PROTO_CODE + '\n' +
      'function rpc(name, args) { console.warn("[Playground] server." + name + "() is not available in playground mode"); return Promise.resolve(null); }\n' +
      sharedCode + '\n' +
      browserCode + '\n' +
      'if (typeof App === "function") {' +
      '  if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", function() { mount(App, document.getElementById("app")); }); }' +
      '  else { mount(App, document.getElementById("app")); }' +
      '}\n' +
      '<\/script>\n</body></html>';
    previewFrame.srcdoc = previewHTML;
    // Auto-switch to preview when there's a browser block
    switchTab('preview');
  } else {
    previewFrame.srcdoc = '<html><body style="font-family:sans-serif;padding:20px;color:#aaa"><p>Write a <code>browser { }</code> block with a <code>component App</code> to see a live preview here.</p></body></html>';
  }
}

// ─── AST Renderer ───────────────────────────────────
function renderAST(node, depth = 0) {
  if (node === null || node === undefined) {
    const span = document.createElement('span');
    span.className = 'ast-null'; span.textContent = 'null'; return span;
  }
  if (typeof node !== 'object') {
    const span = document.createElement('span');
    if (typeof node === 'string') { span.className = 'ast-string'; span.textContent = '"' + node + '"'; }
    else if (typeof node === 'number') { span.className = 'ast-number'; span.textContent = String(node); }
    else if (typeof node === 'boolean') { span.className = 'ast-bool'; span.textContent = String(node); }
    else { span.textContent = String(node); }
    return span;
  }
  if (Array.isArray(node)) {
    if (node.length === 0) { const s = document.createElement('span'); s.className = 'ast-null'; s.textContent = '[]'; return s; }
    const c = document.createElement('div'); c.className = 'ast-node';
    const t = document.createElement('span'); t.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
    t.textContent = 'Array[' + node.length + ']';
    const ch = document.createElement('div'); ch.className = 'ast-children' + (depth < 2 ? ' open' : '');
    t.addEventListener('click', () => { t.classList.toggle('open'); ch.classList.toggle('open'); });
    for (let i = 0; i < node.length; i++) {
      const r = document.createElement('div'); r.className = 'ast-node';
      const k = document.createElement('span'); k.className = 'ast-key'; k.textContent = i + ': ';
      r.appendChild(k); r.appendChild(renderAST(node[i], depth + 1)); ch.appendChild(r);
    }
    c.appendChild(t); c.appendChild(ch); return c;
  }
  const container = document.createElement('div'); container.className = 'ast-node';
  const typeName = node.constructor?.name || 'Object';
  const keys = Object.keys(node).filter(k => k !== 'line' && k !== 'column');
  if (keys.length === 0) { const s = document.createElement('span'); s.className = 'ast-type'; s.textContent = typeName; container.appendChild(s); return container; }
  const toggle = document.createElement('span'); toggle.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
  const typeSpan = document.createElement('span'); typeSpan.className = 'ast-type'; typeSpan.textContent = typeName;
  toggle.appendChild(typeSpan);
  const children = document.createElement('div'); children.className = 'ast-children' + (depth < 2 ? ' open' : '');
  toggle.addEventListener('click', () => { toggle.classList.toggle('open'); children.classList.toggle('open'); });
  for (const key of keys) {
    const row = document.createElement('div'); row.className = 'ast-node';
    const keySpan = document.createElement('span'); keySpan.className = 'ast-key'; keySpan.textContent = key + ': ';
    row.appendChild(keySpan); row.appendChild(renderAST(node[key], depth + 1)); children.appendChild(row);
  }
  container.appendChild(toggle); container.appendChild(children);
  return container;
}

// ─── Sidebar (Reference / Tutorial) ─────────────────
const sidebar = document.getElementById('sidebar');
const sidebarBody = document.getElementById('sidebar-body');
const sidebarTitle = document.getElementById('sidebar-title');
const tutorialNav = document.getElementById('tutorial-nav');

function toggleSidebar(mode) {
  if (sidebarMode === mode) {
    sidebar.classList.remove('open');
    sidebarMode = null;
    document.getElementById('btn-reference').classList.remove('active');
    document.getElementById('btn-tutorial').classList.remove('active');
    return;
  }
  sidebarMode = mode;
  sidebar.classList.add('open');

  document.getElementById('btn-reference').classList.toggle('active', mode === 'reference');
  document.getElementById('btn-tutorial').classList.toggle('active', mode === 'tutorial');

  if (mode === 'reference') {
    sidebarTitle.textContent = 'Tova Reference';
    tutorialNav.style.display = 'none';
    renderReference();
  } else if (mode === 'tutorial') {
    sidebarTitle.textContent = 'Learn Tova';
    tutorialNav.style.display = 'flex';
    renderTutorialStep();
  }
}

function renderTutorialStep() {
  sidebarBody.innerHTML = '';
  const step = TUTORIAL[tutorialStep];
  if (!step) return;

  // Progress dots
  const progress = document.createElement('div');
  progress.className = 'tutorial-progress';
  for (let i = 0; i < TUTORIAL.length; i++) {
    const dot = document.createElement('div');
    dot.className = 'tutorial-dot' + (i === tutorialStep ? ' active' : '') + (i < tutorialStep ? ' completed' : '');
    dot.addEventListener('click', () => { tutorialStep = i; renderTutorialStep(); });
    progress.appendChild(dot);
  }
  sidebarBody.appendChild(progress);

  const div = document.createElement('div');
  div.className = 'tutorial-step';
  div.innerHTML = '<h4>' + (tutorialStep + 1) + '. ' + escapeHtml(step.title) + '</h4>'
    + '<p>' + escapeHtml(step.description) + '</p>';
  const tryBtn = document.createElement('button');
  tryBtn.className = 'try-btn';
  tryBtn.textContent = '\u25B6 Try this code';
  tryBtn.addEventListener('click', () => { setEditorCode(step.code); });
  div.appendChild(tryBtn);
  sidebarBody.appendChild(div);

  // Update nav buttons
  document.getElementById('tut-prev').disabled = tutorialStep === 0;
  document.getElementById('tut-next').textContent = tutorialStep === TUTORIAL.length - 1 ? 'Finish \u2713' : 'Next \u2192';
}

document.getElementById('btn-reference').addEventListener('click', () => toggleSidebar('reference'));
document.getElementById('btn-tutorial').addEventListener('click', () => toggleSidebar('tutorial'));
document.getElementById('sidebar-close').addEventListener('click', () => toggleSidebar(sidebarMode));

document.getElementById('tut-prev').addEventListener('click', () => {
  if (tutorialStep > 0) { tutorialStep--; renderTutorialStep(); }
});
document.getElementById('tut-next').addEventListener('click', () => {
  if (tutorialStep < TUTORIAL.length - 1) { tutorialStep++; renderTutorialStep(); }
  else { toggleSidebar('tutorial'); }
});

// ─── Settings ───────────────────────────────────────
document.getElementById('btn-settings').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('settings-dropdown').classList.toggle('visible');
});
document.addEventListener('click', (e) => {
  if (!e.target.closest('#settings-dropdown') && !e.target.closest('#btn-settings')) {
    document.getElementById('settings-dropdown').classList.remove('visible');
  }
});
document.getElementById('setting-fontsize').addEventListener('change', (e) => {
  document.documentElement.style.setProperty('--editor-font-size', e.target.value + 'px');
  saveSettings();
});
document.getElementById('setting-autocompile').addEventListener('click', function() {
  autoCompile = !autoCompile;
  this.classList.toggle('on', autoCompile);
  saveSettings();
});
document.getElementById('setting-autorun').addEventListener('click', function() {
  autoRun = !autoRun;
  this.classList.toggle('on', autoRun);
  saveSettings();
});

// ─── Keyboard Shortcuts Modal ───────────────────────
function toggleModal(id) {
  document.getElementById(id).classList.toggle('visible');
}
document.getElementById('btn-shortcuts').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-close').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) toggleModal('shortcuts-modal');
});

// ─── Error banner click → jump to error line ────────
document.getElementById('error-banner').addEventListener('click', () => {
  const text = document.getElementById('error-text').textContent;
  const lineMatch = text.match(/:(\d+):/);
  if (lineMatch) {
    const line = parseInt(lineMatch[1]);
    try {
      const lineInfo = editor.state.doc.line(line);
      editor.dispatch({ selection: { anchor: lineInfo.from } });
      editor.focus();
    } catch(e) {}
  }
});

// ─── JS Output Editor (read-only CodeMirror) ────────
try {
  const jsEditorParent = document.getElementById('js-output-editor');
  if (jsEditorParent) {
    window.jsEditor = new EditorView({
      state: EditorState.create({
        doc: '// Compiled JS output will appear here',
        extensions: [
          basicSetup,
          jsThemeCompartment.of(getEditorTheme()),
          EditorState.readOnly.of(true),
          EditorView.editable.of(false),
        ],
      }),
      parent: jsEditorParent,
    });
  }
} catch(e) { console.warn('JS output editor init failed:', e); }

// ─── Console Buttons ────────────────────────────────
document.getElementById('btn-clear-console').addEventListener('click', () => {
  document.getElementById('console-output').innerHTML = '';
  document.getElementById('console-timing').textContent = '';
  const badge = document.getElementById('console-badge');
  badge.style.display = 'none';
});

document.getElementById('btn-copy-console').addEventListener('click', () => {
  const text = document.getElementById('console-output').innerText;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btn-copy-console');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
});

// ─── Copy JS Output ─────────────────────────────────
document.getElementById('btn-copy-js').addEventListener('click', () => {
  const text = lastJsText || '';
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btn-copy-js');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
});

// ─── Command Palette ────────────────────────────────
let cmdPaletteOpen = false;
let cmdSelectedIndex = 0;
let _cmdItems = [];

function getCommandItems(query) {
  const q = query.toLowerCase();
  const items = [];

  // Actions
  const actions = [
    { icon: '\u25B6', label: 'Run Code', category: 'Action', shortcut: '\u2318Enter', action: () => compile() },
    { icon: '\u2197', label: 'Share URL', category: 'Action', action: () => document.getElementById('btn-share').click() },
    { icon: '\u2913', label: 'Download .tova', category: 'Action', shortcut: '\u2318\u21E7S', action: () => downloadCode() },
    { icon: '\u21BA', label: 'Reset to Default Code', category: 'Action', action: () => document.getElementById('btn-reset').click() },
    { icon: '\uD83D\uDCE4', label: 'Export as HTML', category: 'Action', action: () => exportAsHTML() },
    { icon: '\uD83D\uDCD6', label: 'Toggle Reference', category: 'Action', shortcut: '\u2318\u21E7R', action: () => toggleSidebar('reference') },
    { icon: '\uD83C\uDF93', label: 'Start Tutorial', category: 'Action', action: () => toggleSidebar('tutorial') },
    { icon: '\u2699', label: 'Toggle Light Theme', category: 'Action', action: () => document.getElementById('setting-theme').click() },
    { icon: '\u2B12', label: 'Toggle Layout', category: 'Action', shortcut: '\u2318J', action: () => toggleLayout() },
  ];

  for (const a of actions) {
    if (!q || a.label.toLowerCase().includes(q)) items.push(a);
  }

  // Examples
  for (let i = 0; i < EXAMPLES.length; i++) {
    const ex = EXAMPLES[i];
    if (!q || ex.name.toLowerCase().includes(q) || ex.category.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDCC4',
        label: ex.name,
        category: ex.category,
        action: () => { setEditorCode(ex.code); }
      });
    }
  }

  // Reference sections
  for (const section of REFERENCE) {
    if (!q || section.title.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDD0D',
        label: section.title,
        category: 'Reference',
        action: () => { toggleSidebar('reference'); }
      });
    }
  }

  return items;
}

function renderCommandPalette(query) {
  const results = document.getElementById('cmd-results');
  const items = getCommandItems(query || '');
  results.innerHTML = '';
  cmdSelectedIndex = 0;

  if (items.length === 0) {
    results.innerHTML = '<div class="cmd-palette-empty">No results found</div>';
    return;
  }

  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'cmd-palette-item' + (i === 0 ? ' selected' : '');
    div.innerHTML = '<span class="cmd-icon">' + item.icon + '</span>'
      + '<span class="cmd-label">' + escapeHtml(item.label) + '</span>'
      + '<span class="cmd-category">' + escapeHtml(item.category) + '</span>'
      + (item.shortcut ? '<span class="cmd-shortcut">' + item.shortcut + '</span>' : '');
    div.addEventListener('click', () => { item.action(); closeCommandPalette(); });
    div.addEventListener('mouseenter', () => {
      results.querySelectorAll('.cmd-palette-item').forEach(el => el.classList.remove('selected'));
      div.classList.add('selected');
      cmdSelectedIndex = i;
    });
    results.appendChild(div);
  });

  _cmdItems = items;
}

function toggleCommandPalette() {
  if (cmdPaletteOpen) { closeCommandPalette(); return; }
  cmdPaletteOpen = true;
  document.getElementById('cmd-palette').classList.add('visible');
  const input = document.getElementById('cmd-input');
  input.value = '';
  renderCommandPalette('');
  input.focus();
}

function closeCommandPalette() {
  cmdPaletteOpen = false;
  document.getElementById('cmd-palette').classList.remove('visible');
  editor.focus();
}

document.getElementById('cmd-input').addEventListener('input', (e) => {
  renderCommandPalette(e.target.value);
});

document.getElementById('cmd-input').addEventListener('keydown', (e) => {
  const results = document.getElementById('cmd-results');
  const items = results.querySelectorAll('.cmd-palette-item');
  if (e.key === 'Escape') { closeCommandPalette(); e.preventDefault(); return; }
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    cmdSelectedIndex = Math.min(cmdSelectedIndex + 1, items.length - 1);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    cmdSelectedIndex = Math.max(cmdSelectedIndex - 1, 0);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'Enter') {
    e.preventDefault();
    if (_cmdItems && _cmdItems[cmdSelectedIndex]) {
      _cmdItems[cmdSelectedIndex].action();
      closeCommandPalette();
    }
  }
});

document.getElementById('cmd-palette').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) closeCommandPalette();
});

// Global Cmd+K for command palette
document.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
    e.preventDefault();
    toggleCommandPalette();
  }
  if (e.key === 'Escape' && cmdPaletteOpen) {
    closeCommandPalette();
  }
});

// ─── Layout Toggle ──────────────────────────────────
function toggleLayout() {
  layoutVertical = !layoutVertical;
  document.querySelector('.main').classList.toggle('vertical', layoutVertical);
  try { localStorage.setItem('tova-playground-layout', layoutVertical ? 'vertical' : 'horizontal'); } catch(e) {}
}

// Apply saved layout
if (layoutVertical) document.querySelector('.main').classList.add('vertical');

document.getElementById('btn-layout').addEventListener('click', toggleLayout);

// ─── Theme Toggle ───────────────────────────────────
function applyTheme() {
  document.body.classList.toggle('light-theme', lightTheme);
  document.getElementById('setting-theme').classList.toggle('on', lightTheme);
  // Reconfigure CodeMirror theme
  if (typeof editor !== 'undefined' && editor) {
    editor.dispatch({ effects: themeCompartment.reconfigure(getEditorTheme()) });
  }
  if (typeof window.jsEditor !== 'undefined' && window.jsEditor) {
    window.jsEditor.dispatch({ effects: jsThemeCompartment.reconfigure(getEditorTheme()) });
  }
}

document.getElementById('setting-theme').addEventListener('click', function() {
  lightTheme = !lightTheme;
  applyTheme();
  try { localStorage.setItem('tova-playground-theme', lightTheme ? 'light' : 'dark'); } catch(e) {}
  saveSettings();
});

applyTheme();

// ─── Export as HTML ─────────────────────────────────
function exportAsHTML() {
  if (!lastJsText || lastJsText.startsWith('// No output') || lastJsText.startsWith('// Compilation')) {
    alert('Nothing to export — compile your code first.');
    return;
  }
  const source = editor.state.doc.toString();
  const hasBrowser = source.includes('browser {') || source.includes('browser{') || source.includes('client {') || source.includes('client{');

  let exportHTML;
  if (hasBrowser) {
    // Export browser app as standalone HTML
    try {
      const lexer = new Lexer(source, 'export.tova');
      const tokens = lexer.tokenize();
      const parser = new Parser(tokens, 'export.tova');
      const ast = parser.parse();
      const analyzer = new Analyzer(ast, 'export.tova');
      analyzer.analyze();
      const codegen = new CodeGenerator(ast, 'export.tova');
      const result = codegen.generate();
      const browserCode = (result.browser || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');
      exportHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8"><title>Tova App</title>\n'
        + '<style>*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}'
        + 'body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;padding:20px;color:#333}'
        + 'button{cursor:pointer;padding:8px 16px;margin:4px;border-radius:6px;border:1px solid #ddd;background:#f5f5f5;font-size:14px}'
        + 'input[type="text"],input[type="number"]{padding:8px 12px;border:1px solid #ddd;border-radius:6px;margin:4px;font-size:14px}'
        + '</style></head><body><div id="app"></div>\n<script>\n'
        + RUNTIME_CODE + '\n' + STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n' + ARRAY_PROTO_CODE + '\n'
        + (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '') + '\n'
        + browserCode + '\n'
        + 'if(typeof App==="function"){mount(App,document.getElementById("app"));}\n'
        + '<\/script></body></html>';
    } catch(e) {
      exportHTML = '<!-- Export failed: ' + e.message + ' -->';
    }
  } else {
    // Export as Node/Bun script
    exportHTML = '// Generated by Tova Playground\n' + STDLIB_CODE + '\n' + lastJsText;
  }

  const blob = new Blob([exportHTML], { type: hasClient ? 'text/html' : 'text/javascript' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = hasClient ? 'tova-app.html' : 'tova-output.js';
  a.click();
  URL.revokeObjectURL(a.href);
}

document.getElementById('btn-export').addEventListener('click', exportAsHTML);

// ─── Embed Mode ─────────────────────────────────────
if (__isEmbed) {
  document.body.classList.add('embed-mode');
}

// ─── Theme query param override ─────────────────────
const __themeParam = new URLSearchParams(location.search).get('theme');
if (__themeParam === 'light' || __themeParam === 'dark') {
  lightTheme = __themeParam === 'light';
  applyTheme();
}

// ─── postMessage listener for parent integration ────
window.addEventListener('message', function(e) {
  if (!e.data || typeof e.data !== 'object') return;
  if (e.data.type === 'tova-playground-theme') {
    const t = e.data.theme;
    if (t === 'light' || t === 'dark') {
      lightTheme = t === 'light';
      applyTheme();
    }
  } else if (e.data.type === 'tova-playground-set-code') {
    if (typeof e.data.code === 'string') {
      editor.dispatch({
        changes: { from: 0, to: editor.state.doc.length, insert: e.data.code }
      });
    }
  }
});

// ─── Reference Search & Runnable Snippets ───────────
function renderReference() {
  sidebarBody.innerHTML = '';

  // Search box
  const searchBox = document.createElement('input');
  searchBox.type = 'text';
  searchBox.placeholder = 'Search reference...';
  searchBox.style.cssText = 'width:calc(100% - 28px);margin:8px 14px;padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;outline:none;font-family:var(--font-sans);';
  searchBox.addEventListener('input', () => renderRefSections(searchBox.value));
  sidebarBody.appendChild(searchBox);

  const container = document.createElement('div');
  container.id = 'ref-container';
  sidebarBody.appendChild(container);

  renderRefSections('');
}

function renderRefSections(query) {
  const container = document.getElementById('ref-container');
  if (!container) return;
  container.innerHTML = '';
  const q = query.toLowerCase();

  for (const section of REFERENCE) {
    const matchingItems = section.items.filter(item =>
      !q || section.title.toLowerCase().includes(q) || item.syntax.toLowerCase().includes(q) || item.desc.toLowerCase().includes(q)
    );
    if (matchingItems.length === 0) continue;

    const div = document.createElement('div');
    div.className = 'ref-section';
    const title = document.createElement('div');
    title.className = 'ref-title' + (q ? ' open' : '');
    title.textContent = section.title;
    const items = document.createElement('div');
    items.className = 'ref-items' + (q ? ' open' : '');
    for (const item of matchingItems) {
      const row = document.createElement('div');
      row.className = 'ref-item';
      row.style.cursor = 'pointer';
      row.innerHTML = '<code>' + escapeHtml(item.syntax) + '</code><span class="ref-desc"> \u2014 ' + escapeHtml(item.desc) + '</span>';
      row.title = 'Click to insert into editor';
      row.addEventListener('click', () => {
        // Insert the syntax at cursor position
        const pos = editor.state.selection.main.head;
        editor.dispatch({ changes: { from: pos, insert: item.syntax } });
        editor.focus();
      });
      items.appendChild(row);
    }
    title.addEventListener('click', () => { title.classList.toggle('open'); items.classList.toggle('open'); });
    div.appendChild(title);
    div.appendChild(items);
    container.appendChild(div);
  }

  // Open first two sections by default when no search
  if (!q) {
    const titles = container.querySelectorAll('.ref-title');
    const itemSections = container.querySelectorAll('.ref-items');
    if (titles[0]) { titles[0].classList.add('open'); itemSections[0].classList.add('open'); }
    if (titles[1]) { titles[1].classList.add('open'); itemSections[1].classList.add('open'); }
  }
}

// ─── Welcome Toast ──────────────────────────────────
if (!localStorage.getItem('tova-playground-welcomed')) {
  const toast = document.createElement('div');
  toast.className = 'welcome-toast';
  toast.innerHTML = 'Welcome! Try the <strong style="color:var(--accent);margin:0 2px">Learn</strong> button, or press <span class="kbd-hint">Cmd+Enter</span> to run code. <button class="close-toast" aria-label="Close">\u2715</button>';
  document.querySelector('.pane-editor').appendChild(toast);
  toast.querySelector('.close-toast').addEventListener('click', () => { toast.remove(); localStorage.setItem('tova-playground-welcomed', '1'); });
  setTimeout(() => { if (toast.parentNode) { toast.remove(); localStorage.setItem('tova-playground-welcomed', '1'); } }, 15000);
}

// ─── Utility ────────────────────────────────────────
function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ─── Initial Compile ────────────────────────────────
compile();
</script>
</body>
</html>