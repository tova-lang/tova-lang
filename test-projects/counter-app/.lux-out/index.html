<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lux App</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; color: #1a1a1a; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
    #app { max-width: 520px; margin: 0 auto; padding: 2rem 1rem; }
    .app { background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 20px 60px rgba(0,0,0,0.15); }
    header { text-align: center; margin-bottom: 1.5rem; }
    h1 { font-size: 2rem; margin-bottom: 0.25rem; color: #333; }
    h2 { font-size: 1.2rem; margin-bottom: 0.75rem; color: #555; }
    .subtitle { font-size: 0.9rem; color: #888; letter-spacing: 0.1em; text-transform: uppercase; }
    button { cursor: pointer; padding: 0.5rem 1rem; border: 1px solid #ddd; border-radius: 8px; background: white; font-size: 0.9rem; transition: all 0.15s; }
    button:hover { background: #f0f0f0; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    input[type="text"] { padding: 0.6rem 0.75rem; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9rem; width: 100%; outline: none; transition: border-color 0.2s; }
    input[type="text"]:focus { border-color: #667eea; }
    ul { list-style: none; }
    .done { text-decoration: line-through; opacity: 0.5; }
    .timer-section { text-align: center; padding: 1.5rem; margin-bottom: 1.5rem; background: #f8f9ff; border-radius: 12px; }
    .timer-label { font-size: 0.85rem; color: #888; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; }
    .timer-display { font-size: 3.5rem; font-weight: 700; font-variant-numeric: tabular-nums; color: #333; margin-bottom: 0.75rem; font-family: 'SF Mono', 'Fira Code', monospace; }
    .timer-controls { display: flex; gap: 0.5rem; justify-content: center; margin-bottom: 0.75rem; }
    .timer-controls button { min-width: 80px; }
    .btn-start { background: #667eea !important; color: white !important; border-color: #667eea !important; }
    .btn-start:hover { background: #5a6fd6 !important; }
    .btn-pause { background: #f59e0b !important; color: white !important; border-color: #f59e0b !important; }
    .btn-add { background: #667eea; color: white; border-color: #667eea; white-space: nowrap; }
    .btn-add:hover { background: #5a6fd6; }
    .pomodoro-total { font-size: 0.85rem; color: #888; }
    .task-section { border-top: 1px solid #eee; padding-top: 1.5rem; }
    .input-row { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
    .task-list { margin-bottom: 1rem; }
    .task-item { display: flex; align-items: center; justify-content: space-between; padding: 0.6rem 0; border-bottom: 1px solid #f0f0f0; }
    .task-content { display: flex; align-items: center; gap: 0.5rem; flex: 1; }
    .check-btn { background: none !important; border: none !important; padding: 0.25rem !important; font-size: 1.1rem; min-width: auto !important; }
    .task-title { flex: 1; cursor: pointer; }
    .delete-btn { background: none !important; border: none !important; color: #ccc; font-size: 1.2rem; padding: 0.25rem !important; min-width: auto !important; }
    .delete-btn:hover { color: #e74c3c !important; }
    .stats { text-align: center; font-size: 0.85rem; color: #888; }
    .active { background: #f0f4ff; border-radius: 6px; padding-left: 0.5rem !important; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
// ── Lux Runtime: Reactivity ──
// Fine-grained reactivity system for Lux (signals-based)

let currentEffect = null;
const effectStack = [];

// ─── Ownership System ─────────────────────────────────────
let currentOwner = null;
const ownerStack = [];

// ─── Batching ────────────────────────────────────────────
// Default: synchronous flush after each setter (backward compatible).
// Inside batch(): effects are deferred and flushed once when batch ends.
// This means setA(1); setB(2) causes 2 runs by default, but
// batch(() => { setA(1); setB(2); }) causes only 1 run.

let pendingEffects = new Set();
let batchDepth = 0;
let flushing = false;

function flush() {
  if (flushing) return; // prevent re-entrant flush
  flushing = true;
  let iterations = 0;
  try {
    while (pendingEffects.size > 0) {
      if (++iterations > 100) {
        console.error('Lux: Possible infinite loop in reactive updates (>100 flush iterations). Aborting.');
        pendingEffects.clear();
        break;
      }
      const toRun = [...pendingEffects];
      pendingEffects.clear();
      for (const effect of toRun) {
        if (!effect._disposed) {
          effect();
        }
      }
    }
  } finally {
    flushing = false;
  }
}

function batch(fn) {
  batchDepth++;
  try {
    fn();
  } finally {
    batchDepth--;
    if (batchDepth === 0) {
      flush();
    }
  }
}

// ─── Ownership Root ──────────────────────────────────────

function createRoot(fn) {
  const root = {
    _children: [],
    _disposed: false,
    _cleanups: [],
    _contexts: null,
    _owner: currentOwner,
    dispose() {
      if (root._disposed) return;
      root._disposed = true;
      // Dispose children in reverse order
      for (let i = root._children.length - 1; i >= 0; i--) {
        const child = root._children[i];
        if (typeof child.dispose === 'function') child.dispose();
      }
      root._children.length = 0;
      // Run cleanups in reverse order
      for (let i = root._cleanups.length - 1; i >= 0; i--) {
        try { root._cleanups[i](); } catch (e) { console.error('Lux: root cleanup error:', e); }
      }
      root._cleanups.length = 0;
    }
  };
  ownerStack.push(currentOwner);
  currentOwner = root;
  try {
    return fn(root.dispose.bind(root));
  } finally {
    currentOwner = ownerStack.pop();
  }
}

// ─── Dependency Cleanup ──────────────────────────────────

function cleanupDeps(subscriber) {
  if (subscriber._deps) {
    for (const depSet of subscriber._deps) {
      depSet.delete(subscriber);
    }
    subscriber._deps.clear();
  }
}

function trackDep(subscriber, subscriberSet) {
  subscriberSet.add(subscriber);
  if (!subscriber._deps) subscriber._deps = new Set();
  subscriber._deps.add(subscriberSet);
}

// ─── Signals ─────────────────────────────────────────────

function createSignal(initialValue) {
  let value = initialValue;
  const subscribers = new Set();

  function getter() {
    if (currentEffect) {
      trackDep(currentEffect, subscribers);
    }
    return value;
  }

  function setter(newValue) {
    if (typeof newValue === 'function') {
      newValue = newValue(value);
    }
    if (value !== newValue) {
      value = newValue;
      for (const sub of [...subscribers]) {
        if (sub._isComputed) {
          sub(); // propagate dirty flags synchronously through computed graph
        } else {
          pendingEffects.add(sub);
        }
      }
      if (batchDepth === 0) {
        flush();
      }
    }
  }

  return [getter, setter];
}

// ─── Effects ─────────────────────────────────────────────

function runCleanups(effect) {
  if (effect._cleanup) {
    try { effect._cleanup(); } catch (e) { console.error('Lux: cleanup error:', e); }
    effect._cleanup = null;
  }
  if (effect._cleanups && effect._cleanups.length > 0) {
    for (const cb of effect._cleanups) {
      try { cb(); } catch (e) { console.error('Lux: cleanup error:', e); }
    }
    effect._cleanups = [];
  }
}

function createEffect(fn) {
  function effect() {
    if (effect._running) return;
    if (effect._disposed) return;
    effect._running = true;

    // Run cleanups from previous execution
    runCleanups(effect);

    // Remove from all previous dependency subscriber sets
    cleanupDeps(effect);

    effectStack.push(effect);
    currentEffect = effect;
    try {
      const result = fn();
      // If effect returns a function, use as cleanup
      if (typeof result === 'function') {
        effect._cleanup = result;
      }
    } catch (e) {
      console.error('Lux: Error in effect:', e);
      if (currentErrorHandler) {
        currentErrorHandler(e);
      }
    } finally {
      effectStack.pop();
      currentEffect = effectStack[effectStack.length - 1] || null;
      effect._running = false;
    }
  }

  effect._deps = new Set();
  effect._running = false;
  effect._disposed = false;
  effect._cleanup = null;
  effect._cleanups = [];
  effect._owner = currentOwner;

  if (currentOwner && !currentOwner._disposed) {
    currentOwner._children.push(effect);
  }

  effect.dispose = function () {
    effect._disposed = true;
    runCleanups(effect);
    cleanupDeps(effect);
    pendingEffects.delete(effect);
    // Remove from owner's children
    if (effect._owner) {
      const idx = effect._owner._children.indexOf(effect);
      if (idx >= 0) effect._owner._children.splice(idx, 1);
    }
  };

  // Run immediately (synchronous first run)
  effect();
  return effect;
}

// ─── Computed (lazy/pull-based for glitch-free reads) ────

function createComputed(fn) {
  let value;
  let dirty = true;
  const subscribers = new Set();

  // notify is called synchronously when a source signal changes.
  // It marks the computed dirty and propagates to downstream subscribers.
  function notify() {
    if (!dirty) {
      dirty = true;
      for (const sub of [...subscribers]) {
        if (sub._isComputed) {
          sub(); // cascade dirty flags synchronously
        } else {
          pendingEffects.add(sub);
        }
      }
    }
  }

  notify._deps = new Set();
  notify._disposed = false;
  notify._isComputed = true;
  notify._owner = currentOwner;

  if (currentOwner && !currentOwner._disposed) {
    currentOwner._children.push(notify);
  }

  notify.dispose = function () {
    notify._disposed = true;
    cleanupDeps(notify);
    if (notify._owner) {
      const idx = notify._owner._children.indexOf(notify);
      if (idx >= 0) notify._owner._children.splice(idx, 1);
    }
  };

  function recompute() {
    cleanupDeps(notify);

    effectStack.push(notify);
    currentEffect = notify;
    try {
      value = fn();
      dirty = false;
    } finally {
      effectStack.pop();
      currentEffect = effectStack[effectStack.length - 1] || null;
    }
  }

  // Initial computation
  recompute();

  function getter() {
    if (currentEffect) {
      trackDep(currentEffect, subscribers);
    }
    if (dirty) {
      recompute();
    }
    return value;
  }

  return getter;
}

// ─── Lifecycle Hooks ─────────────────────────────────────

function onMount(fn) {
  const owner = currentOwner;
  queueMicrotask(() => {
    const result = fn();
    if (typeof result === 'function' && owner && !owner._disposed) {
      owner._cleanups.push(result);
    }
  });
}

function onUnmount(fn) {
  if (currentOwner && !currentOwner._disposed) {
    currentOwner._cleanups.push(fn);
  }
}

function onCleanup(fn) {
  if (currentEffect) {
    if (!currentEffect._cleanups) currentEffect._cleanups = [];
    currentEffect._cleanups.push(fn);
  }
}

// ─── Untrack ─────────────────────────────────────────────
// Run a function without tracking any signal reads (opt out of reactivity)

function untrack(fn) {
  const prev = currentEffect;
  currentEffect = null;
  try {
    return fn();
  } finally {
    currentEffect = prev;
  }
}

// ─── Watch ───────────────────────────────────────────────
// Watch a reactive expression, calling callback with (newValue, oldValue)
// Returns a dispose function to stop watching.

function watch(getter, callback, options = {}) {
  let oldValue = undefined;
  let initialized = false;

  const effect = createEffect(() => {
    const newValue = getter();
    if (initialized) {
      callback(newValue, oldValue);
    } else if (options.immediate) {
      callback(newValue, undefined);
    }
    oldValue = newValue;
    initialized = true;
  });

  return effect.dispose ? effect.dispose.bind(effect) : () => {
    effect._disposed = true;
    runCleanups(effect);
    cleanupDeps(effect);
    pendingEffects.delete(effect);
  };
}

// ─── Refs ────────────────────────────────────────────────

function createRef(initialValue) {
  return { current: initialValue !== undefined ? initialValue : null };
}

// ─── Error Boundaries ────────────────────────────────────

let currentErrorHandler = null;

function createErrorBoundary() {
  const [error, setError] = createSignal(null);

  function run(fn) {
    const prev = currentErrorHandler;
    currentErrorHandler = (e) => setError(e);
    try {
      return fn();
    } catch (e) {
      setError(e);
      return null;
    } finally {
      currentErrorHandler = prev;
    }
  }

  function reset() {
    setError(null);
  }

  return { error, run, reset };
}

function ErrorBoundary({ fallback, children }) {
  const [error, setError] = createSignal(null);

  const prev = currentErrorHandler;
  currentErrorHandler = (e) => setError(e);

  // Return a reactive wrapper that switches between children and fallback
  // The __lux_dynamic marker tells the renderer to create an effect for this node
  const childContent = children && children.length === 1 ? children[0] : lux_fragment(children || []);

  currentErrorHandler = prev;

  return {
    __lux: true,
    tag: '__dynamic',
    props: {},
    children: [],
    compute: () => {
      const err = error();
      if (err) {
        return typeof fallback === 'function'
          ? fallback({ error: err, reset: () => setError(null) })
          : fallback;
      }
      return childContent;
    },
  };
}

// ─── Dynamic Component ──────────────────────────────────
// Renders a component dynamically based on a reactive signal.
// Usage: Dynamic({ component: mySignal, ...props })

function Dynamic({ component, ...rest }) {
  return {
    __lux: true,
    tag: '__dynamic',
    props: {},
    children: [],
    compute: () => {
      const comp = typeof component === 'function' && !component.__lux ? component() : component;
      if (!comp) return null;
      if (typeof comp === 'function') {
        return comp(rest);
      }
      return comp;
    },
  };
}

// ─── Portal ─────────────────────────────────────────────
// Renders children into a different DOM target.
// Usage: Portal({ target: "#modal-root", children })

function Portal({ target, children }) {
  return {
    __lux: true,
    tag: '__portal',
    props: { target },
    children: children || [],
  };
}

// ─── Lazy ───────────────────────────────────────────────
// Async component loading with optional fallback.
// Usage: const LazyComp = lazy(() => import('./HeavyComponent.js'))

function lazy(loader) {
  let resolved = null;
  let promise = null;

  return function LazyWrapper(props) {
    if (resolved) {
      return resolved(props);
    }

    const [comp, setComp] = createSignal(null);
    const [err, setErr] = createSignal(null);

    if (!promise) {
      promise = loader()
        .then(mod => {
          resolved = mod.default || mod;
          setComp(() => resolved);
        })
        .catch(e => setErr(e));
    }

    return {
      __lux: true,
      tag: '__dynamic',
      props: {},
      children: [],
      compute: () => {
        const e = err();
        if (e) return lux_el('span', { className: 'lux-error' }, [String(e)]);
        const c = comp();
        if (c) return c(props);
        // Fallback while loading
        return props && props.fallback ? props.fallback : null;
      },
    };
  };
}

// ─── Context (Provide/Inject) ────────────────────────────
// Tree-based: values are stored on the ownership tree, inject walks up.

function createContext(defaultValue) {
  const id = Symbol('context');
  return { _id: id, _default: defaultValue };
}

function provide(context, value) {
  const owner = currentOwner;
  if (owner) {
    if (!owner._contexts) owner._contexts = new Map();
    owner._contexts.set(context._id, value);
  }
}

function inject(context) {
  let owner = currentOwner;
  while (owner) {
    if (owner._contexts && owner._contexts.has(context._id)) {
      return owner._contexts.get(context._id);
    }
    owner = owner._owner;
  }
  return context._default;
}

// ─── DOM Rendering ────────────────────────────────────────

// Inject scoped CSS into the page (idempotent — only injects once per id)
const __luxInjectedStyles = new Set();
function lux_inject_css(id, css) {
  if (__luxInjectedStyles.has(id)) return;
  __luxInjectedStyles.add(id);
  const style = document.createElement('style');
  style.setAttribute('data-lux-style', id);
  style.textContent = css;
  document.head.appendChild(style);
}

function lux_el(tag, props = {}, children = []) {
  return { __lux: true, tag, props, children };
}

function lux_fragment(children) {
  return { __lux: true, tag: '__fragment', props: {}, children };
}

// Inject a key prop into a vnode for keyed reconciliation
function lux_keyed(key, vnode) {
  if (vnode && vnode.__lux) {
    vnode.props = { ...vnode.props, key };
  }
  return vnode;
}

// Flatten nested arrays and vnodes into a flat list of vnodes
function flattenVNodes(children) {
  const result = [];
  for (const child of children) {
    if (child === null || child === undefined) {
      continue;
    } else if (Array.isArray(child)) {
      result.push(...flattenVNodes(child));
    } else {
      result.push(child);
    }
  }
  return result;
}

// ─── Marker-based DOM helpers ─────────────────────────────
// Instead of wrapping dynamic blocks/fragments in <span style="display:contents">,
// we use comment node markers. A marker's __luxNodes tracks its content nodes.
// Content nodes have __luxOwner pointing to their owning marker.

// Recursively dispose ownership roots attached to a DOM subtree
function disposeNode(node) {
  if (!node) return;
  if (node.__luxRoot) {
    node.__luxRoot();
    node.__luxRoot = null;
  }
  // If this is a marker, dispose and remove its content nodes
  if (node.__luxNodes) {
    for (const cn of node.__luxNodes) {
      disposeNode(cn);
      if (cn.parentNode) cn.parentNode.removeChild(cn);
    }
    node.__luxNodes = [];
  }
  if (node.childNodes) {
    for (const child of Array.from(node.childNodes)) {
      disposeNode(child);
    }
  }
}

// Check if a node is transitively owned by a marker (walks __luxOwner chain)
function isOwnedBy(node, marker) {
  let owner = node.__luxOwner;
  while (owner) {
    if (owner === marker) return true;
    owner = owner.__luxOwner;
  }
  return false;
}

// Get logical children of a parent element (skips marker content nodes)
function getLogicalChildren(parent) {
  const logical = [];
  for (let i = 0; i < parent.childNodes.length; i++) {
    const node = parent.childNodes[i];
    if (!node.__luxOwner) {
      logical.push(node);
    }
  }
  return logical;
}

// Find the first DOM sibling after all of a marker's content
function nextSiblingAfterMarker(marker) {
  if (!marker.__luxNodes || marker.__luxNodes.length === 0) {
    return marker.nextSibling;
  }
  let last = marker.__luxNodes[marker.__luxNodes.length - 1];
  // If last content is itself a marker, recurse to find physical end
  while (last && last.__luxNodes && last.__luxNodes.length > 0) {
    last = last.__luxNodes[last.__luxNodes.length - 1];
  }
  return last ? last.nextSibling : marker.nextSibling;
}

// Remove a logical node (marker + its content, or a regular node) from the DOM
function removeLogicalNode(parent, node) {
  disposeNode(node);
  if (node.parentNode === parent) parent.removeChild(node);
}

// Insert rendered result (could be single node or DocumentFragment) before ref,
// setting __luxOwner on top-level inserted nodes. Returns array of inserted nodes.
function insertRendered(parent, rendered, ref, owner) {
  if (rendered.nodeType === 11) {
    const nodes = Array.from(rendered.childNodes);
    for (const n of nodes) {
      if (!n.__luxOwner) n.__luxOwner = owner;
    }
    parent.insertBefore(rendered, ref);
    return nodes;
  }
  if (!rendered.__luxOwner) rendered.__luxOwner = owner;
  parent.insertBefore(rendered, ref);
  return [rendered];
}

// Clear a marker's content from the DOM and reset __luxNodes
function clearMarkerContent(marker) {
  for (const node of marker.__luxNodes) {
    disposeNode(node);
    if (node.parentNode) node.parentNode.removeChild(node);
  }
  marker.__luxNodes = [];
}

// ─── Render ───────────────────────────────────────────────

// Create real DOM nodes from a vnode (with fine-grained reactive bindings).
// Returns a single DOM node for elements/text, or a DocumentFragment for
// markers (dynamic blocks, fragments) containing [marker, ...content].
function render(vnode) {
  if (vnode === null || vnode === undefined) {
    return document.createTextNode('');
  }

  // Reactive dynamic block (JSXIf, JSXFor, reactive text, etc.)
  if (typeof vnode === 'function') {
    const marker = document.createComment('');
    marker.__luxDynamic = true;
    marker.__luxNodes = [];

    const frag = document.createDocumentFragment();
    frag.appendChild(marker);

    createEffect(() => {
      const val = vnode();
      const parent = marker.parentNode;
      const ref = nextSiblingAfterMarker(marker);

      // Array: keyed or positional reconciliation within marker range
      if (Array.isArray(val)) {
        const flat = flattenVNodes(val);
        const hasKeys = flat.some(c => getKey(c) != null);
        if (hasKeys) {
          patchKeyedInMarker(marker, flat);
        } else {
          patchPositionalInMarker(marker, flat);
        }
        return;
      }

      // Text: optimize single text node update in place
      if (val == null || typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
        const text = val == null ? '' : String(val);
        if (marker.__luxNodes.length === 1 && marker.__luxNodes[0].nodeType === 3) {
          if (marker.__luxNodes[0].textContent !== text) {
            marker.__luxNodes[0].textContent = text;
          }
          return;
        }
        clearMarkerContent(marker);
        const textNode = document.createTextNode(text);
        textNode.__luxOwner = marker;
        parent.insertBefore(textNode, ref);
        marker.__luxNodes = [textNode];
        return;
      }

      // Vnode or other: clear and re-render
      clearMarkerContent(marker);
      if (val && val.__lux) {
        const rendered = render(val);
        marker.__luxNodes = insertRendered(parent, rendered, ref, marker);
      } else {
        const textNode = document.createTextNode(String(val));
        textNode.__luxOwner = marker;
        parent.insertBefore(textNode, ref);
        marker.__luxNodes = [textNode];
      }
    });

    return frag;
  }

  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {
    return document.createTextNode(String(vnode));
  }

  if (Array.isArray(vnode)) {
    const fragment = document.createDocumentFragment();
    for (const child of vnode) {
      fragment.appendChild(render(child));
    }
    return fragment;
  }

  if (!vnode.__lux) {
    return document.createTextNode(String(vnode));
  }

  // Fragment — marker + children (no wrapper element)
  if (vnode.tag === '__fragment') {
    const marker = document.createComment('');
    marker.__luxFragment = true;
    marker.__luxNodes = [];
    marker.__vnode = vnode;

    const frag = document.createDocumentFragment();
    frag.appendChild(marker);

    for (const child of flattenVNodes(vnode.children)) {
      const rendered = render(child);
      const inserted = insertRendered(frag, rendered, null, marker);
      marker.__luxNodes.push(...inserted);
    }

    return frag;
  }

  // Dynamic reactive node (ErrorBoundary, Dynamic component, etc.)
  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {
    const marker = document.createComment('');
    marker.__luxDynamic = true;
    marker.__luxNodes = [];

    const frag = document.createDocumentFragment();
    frag.appendChild(marker);

    let prevDispose = null;
    createEffect(() => {
      const inner = vnode.compute();
      const parent = marker.parentNode;
      const ref = nextSiblingAfterMarker(marker);

      if (prevDispose) {
        prevDispose();
        prevDispose = null;
      }
      clearMarkerContent(marker);

      createRoot((dispose) => {
        prevDispose = dispose;
        const rendered = render(inner);
        marker.__luxNodes = insertRendered(parent, rendered, ref, marker);
      });
    });

    return frag;
  }

  // Portal — render children into a different DOM target
  if (vnode.tag === '__portal') {
    const placeholder = document.createComment('portal');
    const targetSelector = vnode.props.target;
    queueMicrotask(() => {
      const targetEl = typeof targetSelector === 'string'
        ? document.querySelector(targetSelector)
        : targetSelector;
      if (targetEl) {
        for (const child of flattenVNodes(vnode.children)) {
          targetEl.appendChild(render(child));
        }
      }
    });
    return placeholder;
  }

  // Element
  const el = document.createElement(vnode.tag);
  applyReactiveProps(el, vnode.props);

  // Render children
  for (const child of flattenVNodes(vnode.children)) {
    el.appendChild(render(child));
  }

  // Store vnode reference for patching
  el.__vnode = vnode;

  return el;
}

// Apply reactive props — function-valued props get their own effect
function applyReactiveProps(el, props) {
  for (const [key, value] of Object.entries(props)) {
    if (key === 'ref') {
      if (typeof value === 'object' && value !== null && 'current' in value) {
        value.current = el;
      } else if (typeof value === 'function') {
        value(el);
      }
    } else if (key.startsWith('on')) {
      const eventName = key.slice(2).toLowerCase();
      el.addEventListener(eventName, value);
      if (!el.__handlers) el.__handlers = {};
      el.__handlers[eventName] = value;
    } else if (key === 'key') {
      // Skip
    } else if (typeof value === 'function' && !key.startsWith('on')) {
      // Reactive prop — create effect for fine-grained updates
      createEffect(() => {
        const val = value();
        applyPropValue(el, key, val);
      });
    } else {
      applyPropValue(el, key, value);
    }
  }
}

function applyPropValue(el, key, val) {
  if (key === 'className') {
    if (el.className !== val) el.className = val || '';
  } else if (key === 'innerHTML' || key === 'dangerouslySetInnerHTML') {
    const html = typeof val === 'object' && val !== null ? val.__html || '' : val || '';
    if (el.innerHTML !== html) el.innerHTML = html;
  } else if (key === 'value') {
    if (el !== document.activeElement && el.value !== val) {
      el.value = val;
    }
  } else if (key === 'checked') {
    el.checked = !!val;
  } else if (key === 'disabled' || key === 'readOnly' || key === 'hidden') {
    el[key] = !!val;
  } else if (key === 'style' && typeof val === 'object') {
    Object.assign(el.style, val);
  } else {
    const s = val == null ? '' : String(val);
    if (el.getAttribute(key) !== s) {
      el.setAttribute(key, s);
    }
  }
}

// Apply/update props on a DOM element (used by patcher for full-tree mode)
function applyProps(el, newProps, oldProps) {
  // Remove old props that are no longer present
  for (const key of Object.keys(oldProps)) {
    if (!(key in newProps)) {
      if (key.startsWith('on')) {
        const eventName = key.slice(2).toLowerCase();
        if (el.__handlers && el.__handlers[eventName]) {
          el.removeEventListener(eventName, el.__handlers[eventName]);
          delete el.__handlers[eventName];
        }
      } else if (key === 'className') {
        el.className = '';
      } else if (key === 'style') {
        el.removeAttribute('style');
      } else {
        el.removeAttribute(key);
      }
    }
  }

  // Apply new props
  for (const [key, value] of Object.entries(newProps)) {
    if (key === 'className') {
      const val = typeof value === 'function' ? value() : value;
      if (el.className !== val) el.className = val;
    } else if (key === 'ref') {
      if (typeof value === 'object' && value !== null && 'current' in value) {
        value.current = el;
      } else if (typeof value === 'function') {
        value(el);
      }
    } else if (key.startsWith('on')) {
      const eventName = key.slice(2).toLowerCase();
      const oldHandler = el.__handlers && el.__handlers[eventName];
      if (oldHandler !== value) {
        if (oldHandler) el.removeEventListener(eventName, oldHandler);
        el.addEventListener(eventName, value);
        if (!el.__handlers) el.__handlers = {};
        el.__handlers[eventName] = value;
      }
    } else if (key === 'style' && typeof value === 'object') {
      Object.assign(el.style, value);
    } else if (key === 'key') {
      // Skip
    } else if (key === 'value') {
      const val = typeof value === 'function' ? value() : value;
      if (el !== document.activeElement && el.value !== val) {
        el.value = val;
      }
    } else if (key === 'checked') {
      el.checked = !!value;
    } else {
      const val = typeof value === 'function' ? value() : value;
      if (el.getAttribute(key) !== String(val)) {
        el.setAttribute(key, val);
      }
    }
  }
}

// ─── Keyed Reconciliation ────────────────────────────────

function getKey(vnode) {
  if (vnode && vnode.__lux && vnode.props) return vnode.props.key;
  return undefined;
}

function getNodeKey(node) {
  if (node && node.__vnode && node.__vnode.props) return node.__vnode.props.key;
  return undefined;
}

// Keyed reconciliation within a marker's content range
function patchKeyedInMarker(marker, newVNodes) {
  const parent = marker.parentNode;
  const oldNodes = [...marker.__luxNodes];
  const oldKeyMap = new Map();

  for (const node of oldNodes) {
    const key = getNodeKey(node);
    if (key != null) oldKeyMap.set(key, node);
  }

  const newNodes = [];
  const usedOld = new Set();

  for (const newChild of newVNodes) {
    const key = getKey(newChild);

    if (key != null && oldKeyMap.has(key)) {
      const oldNode = oldKeyMap.get(key);
      usedOld.add(oldNode);

      if (oldNode.nodeType === 1 && newChild.__lux &&
          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {
        const oldVNode = oldNode.__vnode || { props: {}, children: [] };
        applyProps(oldNode, newChild.props, oldVNode.props);
        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));
        oldNode.__vnode = newChild;
        newNodes.push(oldNode);
      } else {
        const node = render(newChild);
        // render may return Fragment — collect nodes
        if (node.nodeType === 11) {
          const nodes = Array.from(node.childNodes);
          for (const n of nodes) { if (!n.__luxOwner) n.__luxOwner = marker; }
          parent.insertBefore(node, nextSiblingAfterMarker(marker));
          newNodes.push(...nodes);
        } else {
          if (!node.__luxOwner) node.__luxOwner = marker;
          newNodes.push(node);
        }
      }
    } else {
      const node = render(newChild);
      if (node.nodeType === 11) {
        const nodes = Array.from(node.childNodes);
        for (const n of nodes) { if (!n.__luxOwner) n.__luxOwner = marker; }
        parent.insertBefore(node, nextSiblingAfterMarker(marker));
        newNodes.push(...nodes);
      } else {
        if (!node.__luxOwner) node.__luxOwner = marker;
        newNodes.push(node);
      }
    }
  }

  // Remove unused old nodes
  for (const node of oldNodes) {
    if (!usedOld.has(node)) {
      disposeNode(node);
      if (node.parentNode === parent) parent.removeChild(node);
    }
  }

  // Arrange in correct order after marker using cursor approach
  let cursor = marker.nextSibling;
  for (const node of newNodes) {
    if (node === cursor) {
      cursor = node.nextSibling;
    } else {
      parent.insertBefore(node, cursor);
    }
  }

  marker.__luxNodes = newNodes;
}

// Positional reconciliation within a marker's content range
function patchPositionalInMarker(marker, newChildren) {
  const parent = marker.parentNode;
  const oldNodes = [...marker.__luxNodes];
  const oldCount = oldNodes.length;
  const newCount = newChildren.length;

  // Patch in place
  const patchCount = Math.min(oldCount, newCount);
  for (let i = 0; i < patchCount; i++) {
    patchSingle(parent, oldNodes[i], newChildren[i]);
  }

  // Append new children
  const ref = nextSiblingAfterMarker(marker);
  for (let i = oldCount; i < newCount; i++) {
    const rendered = render(newChildren[i]);
    const inserted = insertRendered(parent, rendered, ref, marker);
    oldNodes.push(...inserted);
  }

  // Remove excess children
  for (let i = newCount; i < oldCount; i++) {
    disposeNode(oldNodes[i]);
    if (oldNodes[i].parentNode === parent) parent.removeChild(oldNodes[i]);
  }

  marker.__luxNodes = oldNodes.slice(0, Math.max(newCount, oldCount > newCount ? newCount : oldNodes.length));
  // Simplify: rebuild __luxNodes from what should remain
  if (newCount <= oldCount) {
    marker.__luxNodes = oldNodes.slice(0, newCount);
  }
}

// Keyed reconciliation for children of an element (not marker-based)
function patchKeyedChildren(parent, newVNodes) {
  const logical = getLogicalChildren(parent);
  const oldKeyMap = new Map();

  for (const node of logical) {
    const key = getNodeKey(node);
    if (key != null) oldKeyMap.set(key, node);
  }

  const newNodes = [];
  const usedOld = new Set();

  for (const newChild of newVNodes) {
    const key = getKey(newChild);

    if (key != null && oldKeyMap.has(key)) {
      const oldNode = oldKeyMap.get(key);
      usedOld.add(oldNode);

      if (oldNode.nodeType === 1 && newChild.__lux &&
          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {
        const oldVNode = oldNode.__vnode || { props: {}, children: [] };
        applyProps(oldNode, newChild.props, oldVNode.props);
        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));
        oldNode.__vnode = newChild;
        newNodes.push(oldNode);
      } else {
        newNodes.push(render(newChild));
      }
    } else {
      newNodes.push(render(newChild));
    }
  }

  // Remove unused old logical nodes
  for (const node of logical) {
    if (!usedOld.has(node) && node.parentNode === parent) {
      removeLogicalNode(parent, node);
    }
  }

  // Arrange in correct order
  for (let i = 0; i < newNodes.length; i++) {
    const expected = newNodes[i];
    const logicalNow = getLogicalChildren(parent);
    const current = logicalNow[i];
    if (current !== expected) {
      parent.insertBefore(expected, current || null);
    }
  }
}

// Positional reconciliation for children of an element
function patchPositionalChildren(parent, newChildren) {
  const logical = getLogicalChildren(parent);
  const oldCount = logical.length;
  const newCount = newChildren.length;

  for (let i = 0; i < Math.min(oldCount, newCount); i++) {
    patchSingle(parent, logical[i], newChildren[i]);
  }

  for (let i = oldCount; i < newCount; i++) {
    parent.appendChild(render(newChildren[i]));
  }

  // Remove excess logical children
  const currentLogical = getLogicalChildren(parent);
  while (currentLogical.length > newCount) {
    const node = currentLogical.pop();
    removeLogicalNode(parent, node);
  }
}

// Patch children of a regular element
function patchChildrenOfElement(el, newChildren) {
  const hasKeys = newChildren.some(c => getKey(c) != null);
  if (hasKeys) {
    patchKeyedChildren(el, newChildren);
  } else {
    patchPositionalChildren(el, newChildren);
  }
}

// Patch a single logical node in place
function patchSingle(parent, existing, newVNode) {
  if (!existing) {
    parent.appendChild(render(newVNode));
    return;
  }

  if (newVNode === null || newVNode === undefined) {
    removeLogicalNode(parent, existing);
    return;
  }

  // Function vnode — replace with new dynamic block
  if (typeof newVNode === 'function') {
    const rendered = render(newVNode);
    if (existing.__luxNodes) {
      // Existing is a marker — clear its content and replace
      clearMarkerContent(existing);
      parent.replaceChild(rendered, existing);
    } else {
      disposeNode(existing);
      parent.replaceChild(rendered, existing);
    }
    return;
  }

  // Text
  if (typeof newVNode === 'string' || typeof newVNode === 'number' || typeof newVNode === 'boolean') {
    const text = String(newVNode);
    if (existing.nodeType === 3) {
      if (existing.textContent !== text) existing.textContent = text;
    } else {
      removeLogicalNode(parent, existing);
      parent.insertBefore(document.createTextNode(text), null);
    }
    return;
  }

  if (!newVNode.__lux) {
    const text = String(newVNode);
    if (existing.nodeType === 3) {
      if (existing.textContent !== text) existing.textContent = text;
    } else {
      removeLogicalNode(parent, existing);
      parent.insertBefore(document.createTextNode(text), null);
    }
    return;
  }

  // Fragment — patch marker content
  if (newVNode.tag === '__fragment') {
    if (existing.__luxFragment) {
      // Patch children within the marker range
      const oldNodes = [...existing.__luxNodes];
      const newChildren = flattenVNodes(newVNode.children);
      // Simple approach: clear and re-render fragment content
      clearMarkerContent(existing);
      const ref = nextSiblingAfterMarker(existing);
      for (const child of newChildren) {
        const rendered = render(child);
        const inserted = insertRendered(parent, rendered, ref, existing);
        existing.__luxNodes.push(...inserted);
      }
      existing.__vnode = newVNode;
      return;
    }
    removeLogicalNode(parent, existing);
    parent.appendChild(render(newVNode));
    return;
  }

  // Element — patch in place
  if (existing.nodeType === 1 && newVNode.tag &&
      existing.tagName.toLowerCase() === newVNode.tag.toLowerCase()) {
    const oldVNode = existing.__vnode || { props: {}, children: [] };
    applyProps(existing, newVNode.props, oldVNode.props);
    patchChildrenOfElement(existing, flattenVNodes(newVNode.children));
    existing.__vnode = newVNode;
    return;
  }

  // Different type — full replace
  removeLogicalNode(parent, existing);
  parent.appendChild(render(newVNode));
}

// ─── Hydration (SSR) ─────────────────────────────────────
// SSR renders flat HTML without markers. Hydration attaches reactivity
// to existing DOM nodes and inserts markers for dynamic blocks.

function hydrateVNode(domNode, vnode) {
  if (!domNode) return null;
  if (vnode === null || vnode === undefined) return domNode;

  // Function vnode (reactive text, JSXIf, JSXFor)
  if (typeof vnode === 'function') {
    if (domNode.nodeType === 3) {
      // Reactive text: attach effect to existing text node
      domNode.__luxReactive = true;
      createEffect(() => {
        const val = vnode();
        const text = val == null ? '' : String(val);
        if (domNode.textContent !== text) domNode.textContent = text;
      });
      return domNode.nextSibling;
    }
    // Complex dynamic block: insert marker-based render, replace SSR node
    const parent = domNode.parentNode;
    const next = domNode.nextSibling;
    const rendered = render(vnode);
    parent.replaceChild(rendered, domNode);
    // rendered is a DocumentFragment — its children are now in parent
    // Find the next unprocessed node
    return next;
  }

  // Primitive text — already correct from SSR
  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {
    return domNode.nextSibling;
  }

  // Array
  if (Array.isArray(vnode)) {
    let cursor = domNode;
    for (const child of flattenVNodes(vnode)) {
      if (!cursor) break;
      cursor = hydrateVNode(cursor, child);
    }
    return cursor;
  }

  if (!vnode.__lux) return domNode.nextSibling;

  // Fragment — children rendered inline in SSR (no wrapper)
  if (vnode.tag === '__fragment') {
    const children = flattenVNodes(vnode.children);
    let cursor = domNode;
    for (const child of children) {
      if (!cursor) break;
      cursor = hydrateVNode(cursor, child);
    }
    return cursor;
  }

  // Dynamic node — replace SSR content with reactive marker
  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {
    const parent = domNode.parentNode;
    const next = domNode.nextSibling;
    const rendered = render(vnode);
    parent.replaceChild(rendered, domNode);
    return next;
  }

  // Element — attach event handlers, reactive props, refs
  if (domNode.nodeType === 1 && domNode.tagName.toLowerCase() === vnode.tag.toLowerCase()) {
    hydrateProps(domNode, vnode.props);
    domNode.__vnode = vnode;

    const children = flattenVNodes(vnode.children || []);
    let cursor = domNode.firstChild;
    for (const child of children) {
      if (!cursor) break;
      cursor = hydrateVNode(cursor, child);
    }
    return domNode.nextSibling;
  }

  // Tag mismatch — fall back to full render
  const parent = domNode.parentNode;
  const next = domNode.nextSibling;
  const rendered = render(vnode);
  parent.replaceChild(rendered, domNode);
  return next;
}

function hydrateProps(el, props) {
  for (const [key, value] of Object.entries(props)) {
    if (key === 'ref') {
      if (typeof value === 'object' && value !== null && 'current' in value) {
        value.current = el;
      } else if (typeof value === 'function') {
        value(el);
      }
    } else if (key.startsWith('on')) {
      const eventName = key.slice(2).toLowerCase();
      el.addEventListener(eventName, value);
      if (!el.__handlers) el.__handlers = {};
      el.__handlers[eventName] = value;
    } else if (key === 'key') {
      // Skip
    } else if (typeof value === 'function' && !key.startsWith('on')) {
      createEffect(() => {
        const val = value();
        applyPropValue(el, key, val);
      });
    }
  }
}

function hydrate(component, container) {
  if (!container) {
    console.error('Lux: Hydration target not found');
    return;
  }

  return createRoot(() => {
    const vnode = typeof component === 'function' ? component() : component;
    if (container.firstChild) {
      hydrateVNode(container.firstChild, vnode);
    }
  });
}

function mount(component, container) {
  if (!container) {
    console.error('Lux: Mount target not found');
    return;
  }

  return createRoot((dispose) => {
    const vnode = typeof component === 'function' ? component() : component;
    container.innerHTML = '';
    container.appendChild(render(vnode));
    return dispose;
  });
}


// ── Lux Runtime: RPC ──
// RPC bridge — client calls to server functions are auto-routed via HTTP

const RPC_BASE = typeof window !== 'undefined'
  ? (window.__LUX_RPC_BASE || '')
  : 'http://localhost:3000';

async function rpc(functionName, args = []) {
  const url = `${RPC_BASE}/rpc/${functionName}`;

  // Convert positional args to object if needed
  let body;
  if (args.length === 1 && typeof args[0] === 'object' && !Array.isArray(args[0])) {
    body = args[0];
  } else if (args.length > 0) {
    // Send as array, server will handle positional mapping
    body = { __args: args };
  } else {
    body = {};
  }

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`RPC call to '${functionName}' failed: ${response.status} ${errorText}`);
    }

    const data = await response.json();
    return data.result;
  } catch (error) {
    if (error.message.includes('RPC call')) throw error;
    throw new Error(`RPC call to '${functionName}' failed: ${error.message}`);
  }
}

// Configure RPC base URL
function configureRPC(baseUrl) {
  if (typeof window !== 'undefined') {
    window.__LUX_RPC_BASE = baseUrl;
  }
}


// ── App ──
// ── Shared ──
// Lux string methods
(function() {
  const m = {
    upper() { return this.toUpperCase(); },
    lower() { return this.toLowerCase(); },
    contains(s) { return this.includes(s); },
    starts_with(s) { return this.startsWith(s); },
    ends_with(s) { return this.endsWith(s); },
    chars() { return [...this]; },
    words() { return this.split(/\s+/).filter(Boolean); },
    lines() { return this.split('\n'); },
    capitalize() { return this.length ? this.charAt(0).toUpperCase() + this.slice(1) : this; },
    title_case() { return this.replace(/\b\w/g, c => c.toUpperCase()); },
    snake_case() { return this.replace(/[-\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },
    camel_case() { return this.replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },
  };
  for (const [n, fn] of Object.entries(m)) {
    if (!String.prototype[n]) Object.defineProperty(String.prototype, n, { value: fn, writable: true, configurable: true });
  }
})();
const Low = Object.freeze({ __tag: "Low" });
const Medium = Object.freeze({ __tag: "Medium" });
const High = Object.freeze({ __tag: "High" });

// ── Stdlib ──
function print(...args) { console.log(...args); }
function len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }
function range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }
function enumerate(a) { return a.map((v, i) => [i, v]); }
function sum(a) { return a.reduce((x, y) => x + y, 0); }
function sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }
function reversed(a) { return [...a].reverse(); }
function zip(...as) { const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }
function min(a) { return Math.min(...a); }
function max(a) { return Math.max(...a); }

// ── Server RPC Proxy ──
const server = new Proxy({}, {
  get(_, name) {
    return (...args) => rpc(name, args);
  }
});

// ── Reactive State ──
const [count, setCount] = createSignal(0);
const [step, setStep] = createSignal(1);
const [notes, setNotes] = createSignal([]);
const [note_input, setNote_input] = createSignal("");
const [note_count_id, setNote_count_id] = createSignal(0);
const [selected_priority, setSelected_priority] = createSignal("Medium");

// ── Computed Values ──
const doubled = createComputed(() => (count() * 2));
const is_even = createComputed(() => ((count() % 2) == 0));
const parity_text = createComputed(() => ((is_even()) ? ("even") : ("odd")));
const total_notes = createComputed(() => len(notes()));
const high_count = createComputed(() => len(notes().filter((n) => (n.priority == "High"))));

function increment() {
  setCount(__lux_p => __lux_p + step());
}
function decrement() {
  setCount(__lux_p => __lux_p - step());
}
function reset() {
  setCount(0);
}
function add_note() {
  if ((note_input() != "")) {
    setNote_count_id(__lux_p => __lux_p + 1);
    setNotes([...notes(), { id: note_count_id(), text: note_input(), priority: selected_priority(), created_at: count() }]);
    setNote_input("");
  }
}
function remove_note(id) {
  setNotes(notes().filter((n) => (n.id != id)));
}
function priority_color(p) {
  if ((p == "High")) {
    return "#e74c3c";
  } else if ((p == "Medium")) {
    return "#f39c12";
  } else {
    return "#27ae60";
  }
}
// ── Components ──
function Badge(__props) {
  const text = () => __props.text;
  const color = () => __props.color;
  return lux_el("span", {style: () => `background: ${color()}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600;`}, [() => `${text()}`]);
}

function NoteItem(__props) {
  const note = () => __props.note;
  return lux_el("div", {style: () => `display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; margin-bottom: 0.5rem; background: #f8f9fa; border-radius: 8px; border-left: 3px solid ${priority_color(note().priority)};`}, [lux_el("div", {style: "flex: 1;"}, [lux_el("div", {style: "display: flex; align-items: center; gap: 0.5rem;"}, [Badge({get text() { return note().priority; }, get color() { return priority_color(note().priority); }}), lux_el("span", {}, [() => `${note().text}`])]), lux_el("div", {style: "font-size: 0.75rem; color: #888; margin-top: 0.25rem;"}, [() => `Added at count: ${note().created_at}`])]), lux_el("button", {style: "background: none; border: none; color: #ccc; cursor: pointer; font-size: 1.2rem; padding: 0.25rem;", onClick: () => remove_note(note().id)}, ["x"])]);
}

function App() {
  return lux_el("div", {style: "max-width: 520px; margin: 2rem auto; padding: 0 1rem; font-family: system-ui, -apple-system, sans-serif;"}, [lux_el("div", {style: "background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 20px 60px rgba(0,0,0,0.1);"}, [lux_el("header", {style: "text-align: center; margin-bottom: 1.5rem;"}, [lux_el("h1", {style: "margin: 0; font-size: 1.8rem; color: #333;"}, ["Lux Counter"]), lux_el("p", {style: "margin: 0.25rem 0 0; color: #888; font-size: 0.85rem;"}, ["Reactivity Test App"])]), lux_el("div", {id: "counter-display", style: "text-align: center; padding: 1.5rem; background: #f0f4ff; border-radius: 12px; margin-bottom: 1.5rem;"}, [lux_el("div", {style: "font-size: 3.5rem; font-weight: 700; color: #333; font-variant-numeric: tabular-nums;"}, [() => `${count()}`]), lux_el("div", {style: "font-size: 0.85rem; color: #667eea; margin-top: 0.25rem;"}, [() => `doubled: ${doubled()} | ${parity_text()}`])]), lux_el("div", {style: "display: flex; gap: 0.5rem; justify-content: center; margin-bottom: 1rem;"}, [lux_el("button", {id: "btn-dec", style: "padding: 0.5rem 1.25rem; border: 1px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-size: 1rem;", onClick: decrement}, ["-"]), lux_el("button", {id: "btn-reset", style: "padding: 0.5rem 1.25rem; border: 1px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-size: 0.9rem;", onClick: reset}, ["Reset"]), lux_el("button", {id: "btn-inc", style: "padding: 0.5rem 1.25rem; border: 1px solid #667eea; border-radius: 8px; background: #667eea; color: white; cursor: pointer; font-size: 1rem;", onClick: increment}, ["+"])]), lux_el("div", {style: "display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem;"}, [lux_el("label", {style: "font-size: 0.85rem; color: #666;"}, ["Step:"]), lux_el("input", {id: "step-input", type: "text", value: () => step(), style: "width: 50px; padding: 0.4rem; border: 2px solid #e0e0e0; border-radius: 6px; text-align: center; font-size: 0.9rem;", onInput: (e) => { setStep(((__lux_v) => __lux_v != null && __lux_v === __lux_v ? __lux_v : 1)(parseInt(e.target.value))); }})]), lux_el("div", {style: "border-top: 1px solid #eee; padding-top: 1.5rem;"}, [lux_el("h2", {style: "margin: 0 0 0.75rem; font-size: 1.1rem; color: #333;"}, [() => `Notes (${total_notes()})`, () => ((high_count() > 0)) ? lux_el("span", {style: "color: #e74c3c; font-size: 0.8rem; margin-left: 0.5rem;"}, [() => `${high_count()} high priority`]) : null]), lux_el("div", {style: "display: flex; gap: 0.5rem; margin-bottom: 1rem;"}, [lux_el("input", {id: "note-input", type: "text", placeholder: "Add a note...", value: () => note_input(), style: "flex: 1; padding: 0.6rem 0.75rem; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9rem; outline: none;", onInput: (e) => { setNote_input(e.target.value); }, onKeydown: (e) => {
    if ((e.key == "Enter")) {
      add_note();
    }
  }}), lux_el("select", {id: "priority-select", value: () => selected_priority(), style: "padding: 0.5rem; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.85rem;", onChange: (e) => { setSelected_priority(e.target.value); }}, [lux_el("option", {value: "Low"}, ["Low"]), lux_el("option", {value: "Medium"}, ["Medium"]), lux_el("option", {value: "High"}, ["High"])]), lux_el("button", {id: "btn-add-note", style: "padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem; white-space: nowrap;", onClick: add_note}, ["Add"])]), lux_el("div", {id: "notes-list"}, [() => notes().map((note) => NoteItem({note: note}))]), () => ((total_notes() == 0)) ? lux_el("div", {style: "text-align: center; color: #ccc; padding: 1.5rem; font-size: 0.9rem;"}, ["No notes yet. Add one above!"]) : null])])]);
}

// ── Mount ──
document.addEventListener("DOMContentLoaded", () => {
  mount(App, document.getElementById("app") || document.body);
});
  </script>
</body>
</html>