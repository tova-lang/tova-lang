<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tova Playground</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
/* ─── Reset & Base ─────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #1e1e2e; --bg-surface: #181825; --bg-overlay: #11111b;
  --bg-hover: #1e1e2e;
  --text: #cdd6f4; --text-dim: #6c7086; --text-bright: #f5f5f5;
  --accent: #cba6f7; --accent-dim: #9370db; --accent-bg: rgba(203,166,247,0.1);
  --green: #a6e3a1; --red: #f38ba8; --yellow: #f9e2af; --blue: #89b4fa;
  --teal: #94e2d5; --peach: #fab387;
  --border: #313244; --border-active: #45475a;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --header-h: 48px; --status-h: 28px;
  --tab-h: 36px; --sidebar-w: 340px;
  --editor-font-size: 14px;
}
html, body { height: 100%; overflow: hidden; }
body {
  font-family: var(--font-sans); background: var(--bg); color: var(--text);
  display: flex; flex-direction: column;
}

/* ─── Header ───────────────────────────────────────── */
.header {
  height: var(--header-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.header .logo {
  font-weight: 700; font-size: 15px; color: var(--accent);
  display: flex; align-items: center; gap: 6px; white-space: nowrap;
}
.header .logo span { color: var(--text-dim); font-weight: 400; font-size: 12px; }
.header .sep { width: 1px; height: 24px; background: var(--border); }
.header .spacer { flex: 1; }

.btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; transition: all 0.15s; font-family: var(--font-sans);
  white-space: nowrap;
}
.btn:hover { border-color: var(--border-active); background: var(--bg-surface); }
.btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
.btn-primary { background: var(--accent); color: var(--bg-overlay); border-color: var(--accent); font-weight: 600; }
.btn-primary:hover { background: var(--accent-dim); border-color: var(--accent-dim); }
.btn-icon { padding: 5px 8px; font-size: 14px; }
.btn .kbd { font-size: 10px; opacity: 0.6; font-family: var(--font-mono); }

select.examples-select {
  padding: 5px 24px 5px 8px; border-radius: 6px; border: 1px solid var(--border);
  background: var(--bg); color: var(--text); font-size: 12px;
  cursor: pointer; font-family: var(--font-sans); max-width: 200px;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236c7086' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 6px center;
}
select.examples-select:hover { border-color: var(--border-active); }
select.examples-select optgroup { background: var(--bg-surface); color: var(--accent); font-style: normal; }
select.examples-select option { background: var(--bg); color: var(--text); }

/* ─── Main Layout ──────────────────────────────────── */
.main {
  flex: 1; display: flex; overflow: hidden;
  height: calc(100% - var(--header-h) - var(--status-h));
}
.pane { display: flex; flex-direction: column; overflow: hidden; min-width: 200px; }
.pane-editor { flex: 1; position: relative; }
.pane-output { flex: 1; }

/* ─── Drag Handle ──────────────────────────────────── */
.drag-handle {
  width: 4px; cursor: col-resize; background: var(--border);
  transition: background 0.15s; flex-shrink: 0;
}
.drag-handle:hover, .drag-handle.active { background: var(--accent); }

/* ─── Output Tabs ──────────────────────────────────── */
.tabs {
  display: flex; height: var(--tab-h); background: var(--bg-surface);
  border-bottom: 1px solid var(--border); flex-shrink: 0; align-items: flex-end;
}
.tab {
  padding: 0 14px; height: 100%; font-size: 12px; cursor: pointer; display: flex; align-items: center;
  color: var(--text-dim); border-bottom: 2px solid transparent;
  transition: all 0.15s; user-select: none; gap: 6px;
}
.tab:hover { color: var(--text); background: rgba(255,255,255,0.02); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab .badge {
  font-size: 10px; padding: 1px 6px; border-radius: 8px;
  background: var(--red); color: var(--bg); font-weight: 600; min-width: 18px; text-align: center;
}

/* ─── Output Panels ────────────────────────────────── */
.output-content { flex: 1; overflow: auto; position: relative; }
.output-panel { display: none; height: 100%; overflow: auto; }
.output-panel.active { display: block; }
#panel-console.active { display: flex; flex-direction: column; }
#panel-js { position: relative; }

#js-output, #console-output, #ast-output {
  padding: 12px 16px; font-family: var(--font-mono); font-size: 13px;
  line-height: 1.6; white-space: pre-wrap; word-break: break-word;
}
#js-output { color: var(--text); }
#console-output .log-line { color: var(--text); padding: 1px 0; }
#console-output .log-error { color: var(--red); padding: 1px 0; }
#console-output .log-warn { color: var(--yellow); padding: 1px 0; }
#console-output .log-info { color: var(--blue); padding: 1px 0; }
#console-output .log-return { color: var(--text-dim); font-style: italic; padding: 1px 0; }

#preview-frame {
  width: 100%; height: 100%; border: none; background: #fff;
}

/* ─── AST Tree ─────────────────────────────────────── */
.ast-node { margin-left: 16px; font-family: var(--font-mono); font-size: 12px; line-height: 1.5; }
.ast-toggle { cursor: pointer; user-select: none; display: inline-flex; align-items: center; gap: 4px; }
.ast-toggle:hover { color: var(--accent); }
.ast-toggle::before { content: '\25B6'; font-size: 8px; display: inline-block; transition: transform 0.15s; }
.ast-toggle.open::before { transform: rotate(90deg); }
.ast-key { color: var(--blue); }
.ast-string { color: var(--green); }
.ast-number { color: var(--yellow); }
.ast-bool { color: var(--accent); }
.ast-null { color: var(--text-dim); }
.ast-type { color: var(--accent); font-weight: 600; }
.ast-children { display: none; }
.ast-children.open { display: block; }

/* ─── Status Bar ───────────────────────────────────── */
.status-bar {
  height: var(--status-h); display: flex; align-items: center;
  padding: 0 12px; background: var(--bg-surface);
  border-top: 1px solid var(--border); font-size: 11px;
  color: var(--text-dim); gap: 16px; flex-shrink: 0;
}
.status-bar .success { color: var(--green); }
.status-bar .error { color: var(--red); }
.status-bar .spacer { flex: 1; }

/* ─── Error Display ────────────────────────────────── */
.error-banner {
  padding: 8px 16px; background: rgba(243,139,168,0.08);
  border-bottom: 1px solid rgba(243,139,168,0.3); color: var(--red);
  font-family: var(--font-mono); font-size: 12px; display: none;
  cursor: pointer; position: relative;
}
.error-banner:hover { background: rgba(243,139,168,0.12); }
.error-banner.visible { display: flex; align-items: center; gap: 8px; }
.error-banner .error-icon { font-weight: bold; flex-shrink: 0; }
.error-banner .error-text { flex: 1; }

/* ─── Sidebar / Reference Panel ───────────────────── */
.sidebar {
  width: 0; overflow: hidden; background: var(--bg-surface);
  border-left: 1px solid var(--border); transition: width 0.2s ease;
  flex-shrink: 0; display: flex; flex-direction: column;
}
.sidebar.open { width: var(--sidebar-w); }
.sidebar-header {
  display: flex; align-items: center; padding: 10px 14px;
  border-bottom: 1px solid var(--border); gap: 8px; flex-shrink: 0;
}
.sidebar-header h3 { font-size: 14px; font-weight: 600; color: var(--text-bright); flex: 1; }
.sidebar-close {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 18px; padding: 2px 6px; border-radius: 4px;
}
.sidebar-close:hover { color: var(--text); background: var(--bg); }
.sidebar-body { flex: 1; overflow-y: auto; padding: 8px 0; }

/* Reference styles */
.ref-section { margin-bottom: 4px; }
.ref-title {
  padding: 6px 14px; font-size: 12px; font-weight: 600;
  color: var(--accent); cursor: pointer; display: flex; align-items: center; gap: 6px;
  user-select: none;
}
.ref-title:hover { background: var(--bg); }
.ref-title::before { content: '\25B6'; font-size: 8px; transition: transform 0.15s; }
.ref-title.open::before { transform: rotate(90deg); }
.ref-items { display: none; padding: 0 14px 8px; }
.ref-items.open { display: block; }
.ref-item { margin: 3px 0; }
.ref-item code {
  font-family: var(--font-mono); font-size: 11px; color: var(--green);
  background: rgba(166,227,161,0.08); padding: 1px 4px; border-radius: 3px;
}
.ref-item .ref-desc { font-size: 11px; color: var(--text-dim); margin-left: 4px; }

/* Tutorial styles */
.tutorial-nav { display: flex; gap: 4px; padding: 8px 14px; flex-shrink: 0; border-top: 1px solid var(--border); }
.tutorial-nav .btn { flex: 1; justify-content: center; font-size: 12px; }
.tutorial-step { padding: 14px; }
.tutorial-step h4 { color: var(--accent); font-size: 14px; margin-bottom: 8px; }
.tutorial-step p { font-size: 13px; color: var(--text); line-height: 1.5; margin-bottom: 10px; }
.tutorial-step .try-btn {
  display: inline-flex; align-items: center; gap: 4px;
  padding: 6px 14px; border-radius: 6px; border: 1px solid var(--accent);
  background: var(--accent-bg); color: var(--accent); font-size: 12px;
  cursor: pointer; font-weight: 500;
}
.tutorial-step .try-btn:hover { background: rgba(203,166,247,0.2); }
.tutorial-progress {
  display: flex; gap: 4px; padding: 0 14px 8px; flex-shrink: 0;
}
.tutorial-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--border); cursor: pointer;
}
.tutorial-dot.active { background: var(--accent); }
.tutorial-dot.completed { background: var(--green); }

/* ─── Keyboard Shortcuts Modal ────────────────────── */
.modal-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: none; align-items: center; justify-content: center; z-index: 100;
}
.modal-backdrop.visible { display: flex; }
.modal {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 24px; max-width: 480px; width: 90%;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.modal h3 { color: var(--accent); margin-bottom: 16px; font-size: 16px; }
.modal-close {
  float: right; background: none; border: none; color: var(--text-dim);
  cursor: pointer; font-size: 20px; padding: 0 4px;
}
.modal-close:hover { color: var(--text); }
.shortcut-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 0; border-bottom: 1px solid rgba(49,50,68,0.5);
}
.shortcut-row:last-child { border-bottom: none; }
.shortcut-keys {
  display: flex; gap: 4px;
}
.shortcut-key {
  background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  padding: 2px 8px; font-family: var(--font-mono); font-size: 11px; color: var(--text-bright);
}
.shortcut-desc { font-size: 13px; color: var(--text-dim); }

/* ─── Settings Dropdown ──────────────────────────── */
.settings-dropdown {
  position: absolute; top: calc(var(--header-h) + 4px); right: 12px;
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 12px; min-width: 220px; z-index: 50;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
}
.settings-dropdown.visible { display: block; }
.settings-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 0; font-size: 13px;
}
.settings-row label { color: var(--text); }
.settings-row select, .settings-row input[type="range"] {
  background: var(--bg); border: 1px solid var(--border); color: var(--text);
  border-radius: 4px; padding: 3px 6px; font-size: 12px;
}
.toggle {
  width: 36px; height: 20px; border-radius: 10px; background: var(--border);
  position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle.on { background: var(--accent); }
.toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 16px; height: 16px; border-radius: 50%; background: white;
  transition: transform 0.2s;
}
.toggle.on::after { transform: translateX(16px); }

/* ─── Welcome Overlay ─────────────────────────────── */
.welcome-toast {
  position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 16px; font-size: 12px;
  color: var(--text-dim); z-index: 10; display: flex; align-items: center; gap: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3); white-space: nowrap;
  animation: fadeIn 0.3s ease;
}
.welcome-toast .kbd-hint {
  font-family: var(--font-mono); font-size: 10px;
  background: var(--bg); border: 1px solid var(--border); padding: 2px 6px;
  border-radius: 3px; color: var(--text);
}
.welcome-toast .close-toast {
  background: none; border: none; color: var(--text-dim); cursor: pointer;
  font-size: 14px; padding: 0 2px;
}
@keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(8px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

/* ─── Console Enhancements ────────────────────────── */
.console-toolbar {
  display: flex; align-items: center; gap: 8px;
  padding: 4px 12px; background: var(--bg-surface);
  border-bottom: 1px solid var(--border); font-size: 11px; flex-shrink: 0;
}
.console-toolbar .spacer { flex: 1; }
.console-toolbar .console-timing { color: var(--text-dim); font-family: var(--font-mono); }
.log-icon { margin-right: 6px; opacity: 0.7; font-size: 11px; }
.log-content { white-space: pre-wrap; word-break: break-word; }
#console-output .log-line, #console-output .log-error,
#console-output .log-warn, #console-output .log-info {
  display: flex; align-items: flex-start; padding: 3px 16px; border-bottom: 1px solid rgba(49,50,68,0.3);
}
#console-output .log-line:hover, #console-output .log-error:hover,
#console-output .log-warn:hover, #console-output .log-info:hover {
  background: rgba(255,255,255,0.02);
}

/* ─── Error Banner Enhanced ───────────────────────── */
.error-banner .error-hint {
  color: var(--yellow); font-size: 11px; margin-left: 12px; opacity: 0.8;
}

/* ─── Command Palette ─────────────────────────────── */
.cmd-palette-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: flex-start; justify-content: center;
  padding-top: 20vh; z-index: 200;
}
.cmd-palette-backdrop.visible { display: flex; }
.cmd-palette {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 12px; width: 520px; max-width: 90vw;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5); overflow: hidden;
}
.cmd-palette input {
  width: 100%; padding: 14px 16px; background: transparent;
  border: none; border-bottom: 1px solid var(--border);
  color: var(--text); font-size: 15px; font-family: var(--font-sans);
  outline: none;
}
.cmd-palette input::placeholder { color: var(--text-dim); }
.cmd-palette-results {
  max-height: 320px; overflow-y: auto; padding: 4px 0;
}
.cmd-palette-item {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 16px; cursor: pointer; font-size: 13px;
  color: var(--text); transition: background 0.1s;
}
.cmd-palette-item:hover, .cmd-palette-item.selected {
  background: var(--accent-bg); color: var(--accent);
}
.cmd-palette-item .cmd-icon { width: 20px; text-align: center; opacity: 0.6; font-size: 14px; }
.cmd-palette-item .cmd-label { flex: 1; }
.cmd-palette-item .cmd-category { font-size: 11px; color: var(--text-dim); }
.cmd-palette-item .cmd-shortcut {
  font-family: var(--font-mono); font-size: 10px; color: var(--text-dim);
  background: var(--bg); border: 1px solid var(--border); border-radius: 3px;
  padding: 1px 5px;
}
.cmd-palette-empty {
  padding: 24px 16px; text-align: center; color: var(--text-dim); font-size: 13px;
}

/* ─── Layout Toggle ───────────────────────────────── */
.main.vertical { flex-direction: column; }
.main.vertical .drag-handle { width: auto; height: 4px; cursor: row-resize; }
.main.vertical .pane { min-width: unset; min-height: 150px; }

/* ─── Light Theme ─────────────────────────────────── */
.light-theme {
  --bg: #f8f9fa; --bg-surface: #ffffff; --bg-overlay: #e9ecef;
  --bg-hover: #f1f3f5;
  --text: #212529; --text-dim: #868e96; --text-bright: #000000;
  --accent: #7c3aed; --accent-dim: #6d28d9; --accent-bg: rgba(124,58,237,0.08);
  --green: #2b8a3e; --red: #e03131; --yellow: #e67700; --blue: #1971c2;
  --teal: #0ca678; --peach: #e8590c;
  --border: #dee2e6; --border-active: #ced4da;
}
.light-theme .cm-editor .cm-gutters { background: #f1f3f5; }
.light-theme #preview-frame { background: #fff; }

/* ─── Embed Mode ──────────────────────────────────── */
.embed-mode .header { display: none; }
.embed-mode .status-bar { display: none; }
.embed-mode .sidebar { display: none; }

/* ─── JS Output Editor ────────────────────────────── */
#js-output-editor { height: 100%; }
#panel-js .cm-editor { height: 100%; }
#panel-js .cm-editor .cm-gutters { background: var(--bg-surface); }

/* ─── CodeMirror Overrides ─────────────────────────── */
.cm-editor { height: 100%; font-size: var(--editor-font-size); }
.cm-editor .cm-scroller { font-family: var(--font-mono) !important; }
.cm-editor .cm-content { padding: 8px 0; }
.cm-editor .cm-gutters {
  background: var(--bg-surface); border-right: 1px solid var(--border);
  color: var(--text-dim);
}
.cm-editor .cm-activeLineGutter { background: rgba(203,166,247,0.08); }
.cm-editor .cm-activeLine { background: rgba(203,166,247,0.04); }
.cm-editor .cm-selectionBackground { background: rgba(203,166,247,0.2) !important; }
.cm-editor.cm-focused .cm-selectionBackground { background: rgba(203,166,247,0.25) !important; }
.cm-editor .cm-cursor { border-left-color: var(--accent); }
.cm-error-line { background: rgba(243,139,168,0.1) !important; }
.cm-error-gutter .cm-gutterElement { padding: 0 2px; }

/* ─── Autocomplete Styling ────────────────────────── */
.cm-tooltip-autocomplete { background: var(--bg-surface) !important; border: 1px solid var(--border) !important; border-radius: 8px !important; }
.cm-tooltip-autocomplete ul li { padding: 4px 8px !important; }
.cm-tooltip-autocomplete ul li[aria-selected] { background: var(--accent-bg) !important; color: var(--accent) !important; }
.cm-completionLabel { font-family: var(--font-mono); }
.cm-completionDetail { font-size: 11px; opacity: 0.7; margin-left: 8px; }
.cm-completionInfo { padding: 8px; font-size: 12px; }

/* ─── Scrollbar ───────────────────────────────────── */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--border-active); }

/* ─── Responsive ───────────────────────────────────── */
@media (max-width: 768px) {
  .main { flex-direction: column; }
  .drag-handle { width: auto; height: 4px; cursor: row-resize; }
  .pane { min-width: unset; min-height: 150px; }
  .sidebar { position: fixed; right: 0; top: var(--header-h); bottom: var(--status-h); z-index: 50; }
  .header .hide-mobile { display: none; }
  .header .sep { display: none; }
}
</style>
</head>
<body>

<!-- ─── Header ────────────────────────────────────── -->
<div class="header">
  <div class="logo">&#9670; Tova <span>Playground</span></div>
  <div class="sep"></div>
  <select class="examples-select" id="examples-select">
    <option value="" disabled selected>Load Example...</option>
  </select>
  <div class="spacer"></div>
  <button class="btn hide-mobile" id="btn-tutorial" title="Interactive tutorial">Learn</button>
  <button class="btn hide-mobile" id="btn-reference" title="Language reference">Reference</button>
  <div class="sep hide-mobile"></div>
  <button class="btn btn-icon hide-mobile" id="btn-layout" title="Toggle layout (Cmd+J)">&#9707;</button>
  <button class="btn btn-icon hide-mobile" id="btn-shortcuts" title="Keyboard shortcuts">&#9000;</button>
  <button class="btn btn-icon hide-mobile" id="btn-settings" title="Settings">&#9881;</button>
  <button class="btn" id="btn-export" title="Export as standalone HTML">Export</button>
  <button class="btn" id="btn-download" title="Download .tova file">&#8615;</button>
  <button class="btn" id="btn-share" title="Copy shareable URL">Share</button>
  <button class="btn btn-primary" id="btn-run" title="Cmd/Ctrl+Enter">Run &#9654;</button>
</div>

<!-- ─── Settings Dropdown ─────────────────────────── -->
<div class="settings-dropdown" id="settings-dropdown">
  <div class="settings-row">
    <label>Font Size</label>
    <select id="setting-fontsize">
      <option value="12">12px</option>
      <option value="13">13px</option>
      <option value="14" selected>14px</option>
      <option value="15">15px</option>
      <option value="16">16px</option>
      <option value="18">18px</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Auto-Compile</label>
    <div class="toggle on" id="setting-autocompile"></div>
  </div>
  <div class="settings-row">
    <label>Auto-Run</label>
    <div class="toggle on" id="setting-autorun"></div>
  </div>
  <div class="settings-row">
    <label>Light Theme</label>
    <div class="toggle" id="setting-theme"></div>
  </div>
</div>

<!-- ─── Main ──────────────────────────────────────── -->
<div class="main">
  <div class="pane pane-editor">
    <div id="editor"></div>
  </div>
  <div class="drag-handle" id="drag-handle"></div>
  <div class="pane pane-output">
    <div class="tabs" id="output-tabs">
      <div class="tab active" data-tab="js">JS Output</div>
      <div class="tab" data-tab="console">Console <span class="badge" id="console-badge" style="display:none">0</span></div>
      <div class="tab" data-tab="preview">Preview</div>
      <div class="tab" data-tab="ast">AST</div>
    </div>
    <div class="error-banner" id="error-banner">
      <span class="error-icon">&#10006;</span>
      <span class="error-text" id="error-text"></span>
      <span class="error-hint" id="error-hint"></span>
    </div>
    <div class="output-content">
      <div class="output-panel active" id="panel-js"><div id="js-output-editor"></div><pre id="js-output" style="display:none"></pre></div>
      <div class="output-panel" id="panel-console">
        <div class="console-toolbar">
          <span class="console-timing" id="console-timing"></span>
          <div class="spacer"></div>
          <button class="btn" id="btn-copy-console" style="padding:2px 8px;font-size:11px;">Copy</button>
          <button class="btn" id="btn-clear-console" style="padding:2px 8px;font-size:11px;">Clear</button>
        </div>
        <div id="console-output" style="padding:12px 0;font-family:var(--font-mono);font-size:13px;line-height:1.6;overflow:auto;flex:1;"></div>
      </div>
      <div class="output-panel" id="panel-preview"><iframe id="preview-frame" sandbox="allow-scripts"></iframe></div>
      <div class="output-panel" id="panel-ast"><div id="ast-output"></div></div>
    </div>
  </div>

  <!-- ─── Sidebar ─────────────────────────────────── -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h3 id="sidebar-title">Reference</h3>
      <button class="sidebar-close" id="sidebar-close">&#10005;</button>
    </div>
    <div class="sidebar-body" id="sidebar-body"></div>
    <div class="tutorial-nav" id="tutorial-nav" style="display:none;">
      <button class="btn" id="tut-prev">&#8592; Prev</button>
      <button class="btn btn-primary" id="tut-next">Next &#8594;</button>
    </div>
  </div>
</div>

<!-- ─── Status Bar ────────────────────────────────── -->
<div class="status-bar">
  <span id="status-compile"></span>
  <span id="status-size" style="color:var(--text-dim)"></span>
  <div class="spacer"></div>
  <span id="status-cursor">Ln 1, Col 1</span>
</div>

<!-- ─── Keyboard Shortcuts Modal ──────────────────── -->
<div class="modal-backdrop" id="shortcuts-modal">
  <div class="modal">
    <button class="modal-close" id="shortcuts-close">&#10005;</button>
    <h3>Keyboard Shortcuts</h3>
    <div class="shortcut-row"><span class="shortcut-desc">Run code</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Enter</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Command palette</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">K</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Save to browser</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">S</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle reference</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">R</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Toggle layout</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">J</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Show shortcuts</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">?</span></div></div>
    <div class="shortcut-row"><span class="shortcut-desc">Download .tova file</span><div class="shortcut-keys"><span class="shortcut-key">Cmd</span><span class="shortcut-key">Shift</span><span class="shortcut-key">S</span></div></div>
    <p style="margin-top:12px;font-size:11px;color:var(--text-dim)">On Windows/Linux, use Ctrl instead of Cmd</p>
  </div>
</div>

<!-- ─── Command Palette ──────────────────────────── -->
<div class="cmd-palette-backdrop" id="cmd-palette">
  <div class="cmd-palette">
    <input type="text" id="cmd-input" placeholder="Search examples, actions, reference..." autocomplete="off" />
    <div class="cmd-palette-results" id="cmd-results"></div>
  </div>
</div>

<!-- ─── LZString for sharing ─────────────────────── -->
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

<!-- ─── Inlined Tova Compiler & Runtime ───────────── -->
<script>
var RUNTIME_CODE = "// Fine-grained reactivity system for Tova (signals-based)\n\nlet currentEffect = null;\nconst effectStack = [];\n\n// ─── Ownership System ─────────────────────────────────────\nlet currentOwner = null;\nconst ownerStack = [];\n\n// ─── Batching ────────────────────────────────────────────\n// Default: synchronous flush after each setter (backward compatible).\n// Inside batch(): effects are deferred and flushed once when batch ends.\n// This means setA(1); setB(2) causes 2 runs by default, but\n// batch(() => { setA(1); setB(2); }) causes only 1 run.\n\nlet pendingEffects = new Set();\nlet batchDepth = 0;\nlet flushing = false;\n\nfunction flush() {\n  if (flushing) return; // prevent re-entrant flush\n  flushing = true;\n  let iterations = 0;\n  try {\n    while (pendingEffects.size > 0) {\n      if (++iterations > 100) {\n        console.error('Tova: Possible infinite loop in reactive updates (>100 flush iterations). Aborting.');\n        pendingEffects.clear();\n        break;\n      }\n      const toRun = [...pendingEffects];\n      pendingEffects.clear();\n      for (const effect of toRun) {\n        if (!effect._disposed) {\n          effect();\n        }\n      }\n    }\n  } finally {\n    flushing = false;\n  }\n}\nfunction batch(fn) {\n  batchDepth++;\n  try {\n    fn();\n  } finally {\n    batchDepth--;\n    if (batchDepth === 0) {\n      flush();\n    }\n  }\n}\n\n// ─── Ownership Root ──────────────────────────────────────\nfunction createRoot(fn) {\n  const root = {\n    _children: [],\n    _disposed: false,\n    _cleanups: [],\n    _contexts: null,\n    _owner: currentOwner,\n    dispose() {\n      if (root._disposed) return;\n      root._disposed = true;\n      // Dispose children in reverse order\n      for (let i = root._children.length - 1; i >= 0; i--) {\n        const child = root._children[i];\n        if (typeof child.dispose === 'function') child.dispose();\n      }\n      root._children.length = 0;\n      // Run cleanups in reverse order\n      for (let i = root._cleanups.length - 1; i >= 0; i--) {\n        try { root._cleanups[i](); } catch (e) { console.error('Tova: root cleanup error:', e); }\n      }\n      root._cleanups.length = 0;\n    }\n  };\n  ownerStack.push(currentOwner);\n  currentOwner = root;\n  try {\n    return fn(root.dispose.bind(root));\n  } finally {\n    currentOwner = ownerStack.pop();\n  }\n}\n\n// ─── Dependency Cleanup ──────────────────────────────────\n\nfunction cleanupDeps(subscriber) {\n  if (subscriber._deps) {\n    for (const depSet of subscriber._deps) {\n      depSet.delete(subscriber);\n    }\n    subscriber._deps.clear();\n  }\n}\n\nfunction trackDep(subscriber, subscriberSet) {\n  subscriberSet.add(subscriber);\n  if (!subscriber._deps) subscriber._deps = new Set();\n  subscriber._deps.add(subscriberSet);\n}\n\n// ─── Signals ─────────────────────────────────────────────\nfunction createSignal(initialValue) {\n  let value = initialValue;\n  const subscribers = new Set();\n\n  function getter() {\n    if (currentEffect) {\n      trackDep(currentEffect, subscribers);\n    }\n    return value;\n  }\n\n  function setter(newValue) {\n    if (typeof newValue === 'function') {\n      newValue = newValue(value);\n    }\n    if (value !== newValue) {\n      value = newValue;\n      for (const sub of [...subscribers]) {\n        if (sub._isComputed) {\n          sub(); // propagate dirty flags synchronously through computed graph\n        } else {\n          pendingEffects.add(sub);\n        }\n      }\n      if (batchDepth === 0) {\n        flush();\n      }\n    }\n  }\n\n  return [getter, setter];\n}\n\n// ─── Effects ─────────────────────────────────────────────\n\nfunction runCleanups(effect) {\n  if (effect._cleanup) {\n    try { effect._cleanup(); } catch (e) { console.error('Tova: cleanup error:', e); }\n    effect._cleanup = null;\n  }\n  if (effect._cleanups && effect._cleanups.length > 0) {\n    for (const cb of effect._cleanups) {\n      try { cb(); } catch (e) { console.error('Tova: cleanup error:', e); }\n    }\n    effect._cleanups = [];\n  }\n}\nfunction createEffect(fn) {\n  function effect() {\n    if (effect._running) return;\n    if (effect._disposed) return;\n    effect._running = true;\n\n    // Run cleanups from previous execution\n    runCleanups(effect);\n\n    // Remove from all previous dependency subscriber sets\n    cleanupDeps(effect);\n\n    effectStack.push(effect);\n    currentEffect = effect;\n    try {\n      const result = fn();\n      // If effect returns a function, use as cleanup\n      if (typeof result === 'function') {\n        effect._cleanup = result;\n      }\n    } catch (e) {\n      console.error('Tova: Error in effect:', e);\n      if (currentErrorHandler) {\n        currentErrorHandler(e);\n      }\n    } finally {\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n      effect._running = false;\n    }\n  }\n\n  effect._deps = new Set();\n  effect._running = false;\n  effect._disposed = false;\n  effect._cleanup = null;\n  effect._cleanups = [];\n  effect._owner = currentOwner;\n\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._children.push(effect);\n  }\n\n  effect.dispose = function () {\n    effect._disposed = true;\n    runCleanups(effect);\n    cleanupDeps(effect);\n    pendingEffects.delete(effect);\n    // Remove from owner's children\n    if (effect._owner) {\n      const idx = effect._owner._children.indexOf(effect);\n      if (idx >= 0) effect._owner._children.splice(idx, 1);\n    }\n  };\n\n  // Run immediately (synchronous first run)\n  effect();\n  return effect;\n}\n\n// ─── Computed (lazy/pull-based for glitch-free reads) ────\nfunction createComputed(fn) {\n  let value;\n  let dirty = true;\n  const subscribers = new Set();\n\n  // notify is called synchronously when a source signal changes.\n  // It marks the computed dirty and propagates to downstream subscribers.\n  function notify() {\n    if (!dirty) {\n      dirty = true;\n      for (const sub of [...subscribers]) {\n        if (sub._isComputed) {\n          sub(); // cascade dirty flags synchronously\n        } else {\n          pendingEffects.add(sub);\n        }\n      }\n    }\n  }\n\n  notify._deps = new Set();\n  notify._disposed = false;\n  notify._isComputed = true;\n  notify._owner = currentOwner;\n\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._children.push(notify);\n  }\n\n  notify.dispose = function () {\n    notify._disposed = true;\n    cleanupDeps(notify);\n    if (notify._owner) {\n      const idx = notify._owner._children.indexOf(notify);\n      if (idx >= 0) notify._owner._children.splice(idx, 1);\n    }\n  };\n\n  function recompute() {\n    cleanupDeps(notify);\n\n    effectStack.push(notify);\n    currentEffect = notify;\n    try {\n      value = fn();\n      dirty = false;\n    } finally {\n      effectStack.pop();\n      currentEffect = effectStack[effectStack.length - 1] || null;\n    }\n  }\n\n  // Initial computation\n  recompute();\n\n  function getter() {\n    if (currentEffect) {\n      trackDep(currentEffect, subscribers);\n    }\n    if (dirty) {\n      recompute();\n    }\n    return value;\n  }\n\n  return getter;\n}\n\n// ─── Lifecycle Hooks ─────────────────────────────────────\nfunction onMount(fn) {\n  const owner = currentOwner;\n  queueMicrotask(() => {\n    const result = fn();\n    if (typeof result === 'function' && owner && !owner._disposed) {\n      owner._cleanups.push(result);\n    }\n  });\n}\nfunction onUnmount(fn) {\n  if (currentOwner && !currentOwner._disposed) {\n    currentOwner._cleanups.push(fn);\n  }\n}\nfunction onCleanup(fn) {\n  if (currentEffect) {\n    if (!currentEffect._cleanups) currentEffect._cleanups = [];\n    currentEffect._cleanups.push(fn);\n  }\n}\n\n// ─── Untrack ─────────────────────────────────────────────\n// Run a function without tracking any signal reads (opt out of reactivity)\nfunction untrack(fn) {\n  const prev = currentEffect;\n  currentEffect = null;\n  try {\n    return fn();\n  } finally {\n    currentEffect = prev;\n  }\n}\n\n// ─── Watch ───────────────────────────────────────────────\n// Watch a reactive expression, calling callback with (newValue, oldValue)\n// Returns a dispose function to stop watching.\nfunction watch(getter, callback, options = {}) {\n  let oldValue = undefined;\n  let initialized = false;\n\n  const effect = createEffect(() => {\n    const newValue = getter();\n    if (initialized) {\n      callback(newValue, oldValue);\n    } else if (options.immediate) {\n      callback(newValue, undefined);\n    }\n    oldValue = newValue;\n    initialized = true;\n  });\n\n  return effect.dispose ? effect.dispose.bind(effect) : () => {\n    effect._disposed = true;\n    runCleanups(effect);\n    cleanupDeps(effect);\n    pendingEffects.delete(effect);\n  };\n}\n\n// ─── Refs ────────────────────────────────────────────────\nfunction createRef(initialValue) {\n  return { current: initialValue !== undefined ? initialValue : null };\n}\n\n// ─── Error Boundaries ────────────────────────────────────\n\nlet currentErrorHandler = null;\nfunction createErrorBoundary() {\n  const [error, setError] = createSignal(null);\n\n  function run(fn) {\n    const prev = currentErrorHandler;\n    currentErrorHandler = (e) => setError(e);\n    try {\n      return fn();\n    } catch (e) {\n      setError(e);\n      return null;\n    } finally {\n      currentErrorHandler = prev;\n    }\n  }\n\n  function reset() {\n    setError(null);\n  }\n\n  return { error, run, reset };\n}\nfunction ErrorBoundary({ fallback, children }) {\n  const [error, setError] = createSignal(null);\n\n  const prev = currentErrorHandler;\n  currentErrorHandler = (e) => setError(e);\n\n  // Return a reactive wrapper that switches between children and fallback\n  // The __tova_dynamic marker tells the renderer to create an effect for this node\n  const childContent = children && children.length === 1 ? children[0] : tova_fragment(children || []);\n\n  currentErrorHandler = prev;\n\n  return {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    compute: () => {\n      const err = error();\n      if (err) {\n        return typeof fallback === 'function'\n          ? fallback({ error: err, reset: () => setError(null) })\n          : fallback;\n      }\n      return childContent;\n    },\n  };\n}\n\n// ─── Dynamic Component ──────────────────────────────────\n// Renders a component dynamically based on a reactive signal.\n// Usage: Dynamic({ component: mySignal, ...props })\nfunction Dynamic({ component, ...rest }) {\n  return {\n    __tova: true,\n    tag: '__dynamic',\n    props: {},\n    children: [],\n    compute: () => {\n      const comp = typeof component === 'function' && !component.__tova ? component() : component;\n      if (!comp) return null;\n      if (typeof comp === 'function') {\n        return comp(rest);\n      }\n      return comp;\n    },\n  };\n}\n\n// ─── Portal ─────────────────────────────────────────────\n// Renders children into a different DOM target.\n// Usage: Portal({ target: \"#modal-root\", children })\nfunction Portal({ target, children }) {\n  return {\n    __tova: true,\n    tag: '__portal',\n    props: { target },\n    children: children || [],\n  };\n}\n\n// ─── Lazy ───────────────────────────────────────────────\n// Async component loading with optional fallback.\n// Usage: const LazyComp = lazy(() => import('./HeavyComponent.js'))\nfunction lazy(loader) {\n  let resolved = null;\n  let promise = null;\n\n  return function LazyWrapper(props) {\n    if (resolved) {\n      return resolved(props);\n    }\n\n    const [comp, setComp] = createSignal(null);\n    const [err, setErr] = createSignal(null);\n\n    if (!promise) {\n      promise = loader()\n        .then(mod => {\n          resolved = mod.default || mod;\n          setComp(() => resolved);\n        })\n        .catch(e => setErr(e));\n    }\n\n    return {\n      __tova: true,\n      tag: '__dynamic',\n      props: {},\n      children: [],\n      compute: () => {\n        const e = err();\n        if (e) return tova_el('span', { className: 'tova-error' }, [String(e)]);\n        const c = comp();\n        if (c) return c(props);\n        // Fallback while loading\n        return props && props.fallback ? props.fallback : null;\n      },\n    };\n  };\n}\n\n// ─── Context (Provide/Inject) ────────────────────────────\n// Tree-based: values are stored on the ownership tree, inject walks up.\nfunction createContext(defaultValue) {\n  const id = Symbol('context');\n  return { _id: id, _default: defaultValue };\n}\nfunction provide(context, value) {\n  const owner = currentOwner;\n  if (owner) {\n    if (!owner._contexts) owner._contexts = new Map();\n    owner._contexts.set(context._id, value);\n  }\n}\nfunction inject(context) {\n  let owner = currentOwner;\n  while (owner) {\n    if (owner._contexts && owner._contexts.has(context._id)) {\n      return owner._contexts.get(context._id);\n    }\n    owner = owner._owner;\n  }\n  return context._default;\n}\n\n// ─── DOM Rendering ────────────────────────────────────────\n\n// Inject scoped CSS into the page (idempotent — only injects once per id)\nconst __tovaInjectedStyles = new Set();\nfunction tova_inject_css(id, css) {\n  if (__tovaInjectedStyles.has(id)) return;\n  __tovaInjectedStyles.add(id);\n  const style = document.createElement('style');\n  style.setAttribute('data-tova-style', id);\n  style.textContent = css;\n  document.head.appendChild(style);\n}\nfunction tova_el(tag, props = {}, children = []) {\n  return { __tova: true, tag, props, children };\n}\nfunction tova_fragment(children) {\n  return { __tova: true, tag: '__fragment', props: {}, children };\n}\n\n// Inject a key prop into a vnode for keyed reconciliation\nfunction tova_keyed(key, vnode) {\n  if (vnode && vnode.__tova) {\n    vnode.props = { ...vnode.props, key };\n  }\n  return vnode;\n}\n\n// Flatten nested arrays and vnodes into a flat list of vnodes\nfunction flattenVNodes(children) {\n  const result = [];\n  for (const child of children) {\n    if (child === null || child === undefined) {\n      continue;\n    } else if (Array.isArray(child)) {\n      result.push(...flattenVNodes(child));\n    } else {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\n// ─── Marker-based DOM helpers ─────────────────────────────\n// Instead of wrapping dynamic blocks/fragments in <span style=\"display:contents\">,\n// we use comment node markers. A marker's __tovaNodes tracks its content nodes.\n// Content nodes have __tovaOwner pointing to their owning marker.\n\n// Recursively dispose ownership roots attached to a DOM subtree\nfunction disposeNode(node) {\n  if (!node) return;\n  if (node.__tovaRoot) {\n    node.__tovaRoot();\n    node.__tovaRoot = null;\n  }\n  // If this is a marker, dispose and remove its content nodes\n  if (node.__tovaNodes) {\n    for (const cn of node.__tovaNodes) {\n      disposeNode(cn);\n      if (cn.parentNode) cn.parentNode.removeChild(cn);\n    }\n    node.__tovaNodes = [];\n  }\n  if (node.childNodes) {\n    for (const child of Array.from(node.childNodes)) {\n      disposeNode(child);\n    }\n  }\n}\n\n// Check if a node is transitively owned by a marker (walks __tovaOwner chain)\nfunction isOwnedBy(node, marker) {\n  let owner = node.__tovaOwner;\n  while (owner) {\n    if (owner === marker) return true;\n    owner = owner.__tovaOwner;\n  }\n  return false;\n}\n\n// Get logical children of a parent element (skips marker content nodes)\nfunction getLogicalChildren(parent) {\n  const logical = [];\n  for (let i = 0; i < parent.childNodes.length; i++) {\n    const node = parent.childNodes[i];\n    if (!node.__tovaOwner) {\n      logical.push(node);\n    }\n  }\n  return logical;\n}\n\n// Find the first DOM sibling after all of a marker's content\nfunction nextSiblingAfterMarker(marker) {\n  if (!marker.__tovaNodes || marker.__tovaNodes.length === 0) {\n    return marker.nextSibling;\n  }\n  let last = marker.__tovaNodes[marker.__tovaNodes.length - 1];\n  // If last content is itself a marker, recurse to find physical end\n  while (last && last.__tovaNodes && last.__tovaNodes.length > 0) {\n    last = last.__tovaNodes[last.__tovaNodes.length - 1];\n  }\n  return last ? last.nextSibling : marker.nextSibling;\n}\n\n// Remove a logical node (marker + its content, or a regular node) from the DOM\nfunction removeLogicalNode(parent, node) {\n  disposeNode(node);\n  if (node.parentNode === parent) parent.removeChild(node);\n}\n\n// Insert rendered result (could be single node or DocumentFragment) before ref,\n// setting __tovaOwner on top-level inserted nodes. Returns array of inserted nodes.\nfunction insertRendered(parent, rendered, ref, owner) {\n  if (rendered.nodeType === 11) {\n    const nodes = Array.from(rendered.childNodes);\n    for (const n of nodes) {\n      if (!n.__tovaOwner) n.__tovaOwner = owner;\n    }\n    parent.insertBefore(rendered, ref);\n    return nodes;\n  }\n  if (!rendered.__tovaOwner) rendered.__tovaOwner = owner;\n  parent.insertBefore(rendered, ref);\n  return [rendered];\n}\n\n// Clear a marker's content from the DOM and reset __tovaNodes\nfunction clearMarkerContent(marker) {\n  for (const node of marker.__tovaNodes) {\n    disposeNode(node);\n    if (node.parentNode) node.parentNode.removeChild(node);\n  }\n  marker.__tovaNodes = [];\n}\n\n// ─── Render ───────────────────────────────────────────────\n\n// Create real DOM nodes from a vnode (with fine-grained reactive bindings).\n// Returns a single DOM node for elements/text, or a DocumentFragment for\n// markers (dynamic blocks, fragments) containing [marker, ...content].\nfunction render(vnode) {\n  if (vnode === null || vnode === undefined) {\n    return document.createTextNode('');\n  }\n\n  // Reactive dynamic block (JSXIf, JSXFor, reactive text, etc.)\n  if (typeof vnode === 'function') {\n    const marker = document.createComment('');\n    marker.__tovaDynamic = true;\n    marker.__tovaNodes = [];\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    createEffect(() => {\n      const val = vnode();\n      const parent = marker.parentNode;\n      const ref = nextSiblingAfterMarker(marker);\n\n      // Array: keyed or positional reconciliation within marker range\n      if (Array.isArray(val)) {\n        const flat = flattenVNodes(val);\n        const hasKeys = flat.some(c => getKey(c) != null);\n        if (hasKeys) {\n          patchKeyedInMarker(marker, flat);\n        } else {\n          patchPositionalInMarker(marker, flat);\n        }\n        return;\n      }\n\n      // Text: optimize single text node update in place\n      if (val == null || typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {\n        const text = val == null ? '' : String(val);\n        if (marker.__tovaNodes.length === 1 && marker.__tovaNodes[0].nodeType === 3) {\n          if (marker.__tovaNodes[0].textContent !== text) {\n            marker.__tovaNodes[0].textContent = text;\n          }\n          return;\n        }\n        clearMarkerContent(marker);\n        const textNode = document.createTextNode(text);\n        textNode.__tovaOwner = marker;\n        parent.insertBefore(textNode, ref);\n        marker.__tovaNodes = [textNode];\n        return;\n      }\n\n      // Vnode or other: clear and re-render\n      clearMarkerContent(marker);\n      if (val && val.__tova) {\n        const rendered = render(val);\n        marker.__tovaNodes = insertRendered(parent, rendered, ref, marker);\n      } else {\n        const textNode = document.createTextNode(String(val));\n        textNode.__tovaOwner = marker;\n        parent.insertBefore(textNode, ref);\n        marker.__tovaNodes = [textNode];\n      }\n    });\n\n    return frag;\n  }\n\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    return document.createTextNode(String(vnode));\n  }\n\n  if (Array.isArray(vnode)) {\n    const fragment = document.createDocumentFragment();\n    for (const child of vnode) {\n      fragment.appendChild(render(child));\n    }\n    return fragment;\n  }\n\n  if (!vnode.__tova) {\n    return document.createTextNode(String(vnode));\n  }\n\n  // Fragment — marker + children (no wrapper element)\n  if (vnode.tag === '__fragment') {\n    const marker = document.createComment('');\n    marker.__tovaFragment = true;\n    marker.__tovaNodes = [];\n    marker.__vnode = vnode;\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    for (const child of flattenVNodes(vnode.children)) {\n      const rendered = render(child);\n      const inserted = insertRendered(frag, rendered, null, marker);\n      marker.__tovaNodes.push(...inserted);\n    }\n\n    return frag;\n  }\n\n  // Dynamic reactive node (ErrorBoundary, Dynamic component, etc.)\n  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {\n    const marker = document.createComment('');\n    marker.__tovaDynamic = true;\n    marker.__tovaNodes = [];\n\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n\n    let prevDispose = null;\n    createEffect(() => {\n      const inner = vnode.compute();\n      const parent = marker.parentNode;\n      const ref = nextSiblingAfterMarker(marker);\n\n      if (prevDispose) {\n        prevDispose();\n        prevDispose = null;\n      }\n      clearMarkerContent(marker);\n\n      createRoot((dispose) => {\n        prevDispose = dispose;\n        const rendered = render(inner);\n        marker.__tovaNodes = insertRendered(parent, rendered, ref, marker);\n      });\n    });\n\n    return frag;\n  }\n\n  // Portal — render children into a different DOM target\n  if (vnode.tag === '__portal') {\n    const placeholder = document.createComment('portal');\n    const targetSelector = vnode.props.target;\n    queueMicrotask(() => {\n      const targetEl = typeof targetSelector === 'string'\n        ? document.querySelector(targetSelector)\n        : targetSelector;\n      if (targetEl) {\n        for (const child of flattenVNodes(vnode.children)) {\n          targetEl.appendChild(render(child));\n        }\n      }\n    });\n    return placeholder;\n  }\n\n  // Element\n  const el = document.createElement(vnode.tag);\n  applyReactiveProps(el, vnode.props);\n\n  // Render children\n  for (const child of flattenVNodes(vnode.children)) {\n    el.appendChild(render(child));\n  }\n\n  // Store vnode reference for patching\n  el.__vnode = vnode;\n\n  return el;\n}\n\n// Apply reactive props — function-valued props get their own effect\nfunction applyReactiveProps(el, props) {\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      el.addEventListener(eventName, value);\n      if (!el.__handlers) el.__handlers = {};\n      el.__handlers[eventName] = value;\n    } else if (key === 'key') {\n      // Skip\n    } else if (typeof value === 'function' && !key.startsWith('on')) {\n      // Reactive prop — create effect for fine-grained updates\n      createEffect(() => {\n        const val = value();\n        applyPropValue(el, key, val);\n      });\n    } else {\n      applyPropValue(el, key, value);\n    }\n  }\n}\n\nfunction applyPropValue(el, key, val) {\n  if (key === 'className') {\n    if (el.className !== val) el.className = val || '';\n  } else if (key === 'innerHTML' || key === 'dangerouslySetInnerHTML') {\n    const html = typeof val === 'object' && val !== null ? val.__html || '' : val || '';\n    if (el.innerHTML !== html) el.innerHTML = html;\n  } else if (key === 'value') {\n    if (el !== document.activeElement && el.value !== val) {\n      el.value = val;\n    }\n  } else if (key === 'checked') {\n    el.checked = !!val;\n  } else if (key === 'disabled' || key === 'readOnly' || key === 'hidden') {\n    el[key] = !!val;\n  } else if (key === 'style' && typeof val === 'object') {\n    Object.assign(el.style, val);\n  } else {\n    const s = val == null ? '' : String(val);\n    if (el.getAttribute(key) !== s) {\n      el.setAttribute(key, s);\n    }\n  }\n}\n\n// Apply/update props on a DOM element (used by patcher for full-tree mode)\nfunction applyProps(el, newProps, oldProps) {\n  // Remove old props that are no longer present\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in newProps)) {\n      if (key.startsWith('on')) {\n        const eventName = key.slice(2).toLowerCase();\n        if (el.__handlers && el.__handlers[eventName]) {\n          el.removeEventListener(eventName, el.__handlers[eventName]);\n          delete el.__handlers[eventName];\n        }\n      } else if (key === 'className') {\n        el.className = '';\n      } else if (key === 'style') {\n        el.removeAttribute('style');\n      } else {\n        el.removeAttribute(key);\n      }\n    }\n  }\n\n  // Apply new props\n  for (const [key, value] of Object.entries(newProps)) {\n    if (key === 'className') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.className !== val) el.className = val;\n    } else if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      const oldHandler = el.__handlers && el.__handlers[eventName];\n      if (oldHandler !== value) {\n        if (oldHandler) el.removeEventListener(eventName, oldHandler);\n        el.addEventListener(eventName, value);\n        if (!el.__handlers) el.__handlers = {};\n        el.__handlers[eventName] = value;\n      }\n    } else if (key === 'style' && typeof value === 'object') {\n      Object.assign(el.style, value);\n    } else if (key === 'key') {\n      // Skip\n    } else if (key === 'value') {\n      const val = typeof value === 'function' ? value() : value;\n      if (el !== document.activeElement && el.value !== val) {\n        el.value = val;\n      }\n    } else if (key === 'checked') {\n      el.checked = !!value;\n    } else {\n      const val = typeof value === 'function' ? value() : value;\n      if (el.getAttribute(key) !== String(val)) {\n        el.setAttribute(key, val);\n      }\n    }\n  }\n}\n\n// ─── Keyed Reconciliation ────────────────────────────────\n\nfunction getKey(vnode) {\n  if (vnode && vnode.__tova && vnode.props) return vnode.props.key;\n  return undefined;\n}\n\nfunction getNodeKey(node) {\n  if (node && node.__vnode && node.__vnode.props) return node.__vnode.props.key;\n  return undefined;\n}\n\n// Keyed reconciliation within a marker's content range\nfunction patchKeyedInMarker(marker, newVNodes) {\n  const parent = marker.parentNode;\n  const oldNodes = [...marker.__tovaNodes];\n  const oldKeyMap = new Map();\n\n  for (const node of oldNodes) {\n    const key = getNodeKey(node);\n    if (key != null) oldKeyMap.set(key, node);\n  }\n\n  const newNodes = [];\n  const usedOld = new Set();\n\n  for (const newChild of newVNodes) {\n    const key = getKey(newChild);\n\n    if (key != null && oldKeyMap.has(key)) {\n      const oldNode = oldKeyMap.get(key);\n      usedOld.add(oldNode);\n\n      if (oldNode.nodeType === 1 && newChild.__tova &&\n          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {\n        const oldVNode = oldNode.__vnode || { props: {}, children: [] };\n        applyProps(oldNode, newChild.props, oldVNode.props);\n        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));\n        oldNode.__vnode = newChild;\n        newNodes.push(oldNode);\n      } else {\n        const node = render(newChild);\n        // render may return Fragment — collect nodes\n        if (node.nodeType === 11) {\n          const nodes = Array.from(node.childNodes);\n          for (const n of nodes) { if (!n.__tovaOwner) n.__tovaOwner = marker; }\n          parent.insertBefore(node, nextSiblingAfterMarker(marker));\n          newNodes.push(...nodes);\n        } else {\n          if (!node.__tovaOwner) node.__tovaOwner = marker;\n          newNodes.push(node);\n        }\n      }\n    } else {\n      const node = render(newChild);\n      if (node.nodeType === 11) {\n        const nodes = Array.from(node.childNodes);\n        for (const n of nodes) { if (!n.__tovaOwner) n.__tovaOwner = marker; }\n        parent.insertBefore(node, nextSiblingAfterMarker(marker));\n        newNodes.push(...nodes);\n      } else {\n        if (!node.__tovaOwner) node.__tovaOwner = marker;\n        newNodes.push(node);\n      }\n    }\n  }\n\n  // Remove unused old nodes\n  for (const node of oldNodes) {\n    if (!usedOld.has(node)) {\n      disposeNode(node);\n      if (node.parentNode === parent) parent.removeChild(node);\n    }\n  }\n\n  // Arrange in correct order after marker using cursor approach\n  let cursor = marker.nextSibling;\n  for (const node of newNodes) {\n    if (node === cursor) {\n      cursor = node.nextSibling;\n    } else {\n      parent.insertBefore(node, cursor);\n    }\n  }\n\n  marker.__tovaNodes = newNodes;\n}\n\n// Positional reconciliation within a marker's content range\nfunction patchPositionalInMarker(marker, newChildren) {\n  const parent = marker.parentNode;\n  const oldNodes = [...marker.__tovaNodes];\n  const oldCount = oldNodes.length;\n  const newCount = newChildren.length;\n\n  // Patch in place\n  const patchCount = Math.min(oldCount, newCount);\n  for (let i = 0; i < patchCount; i++) {\n    patchSingle(parent, oldNodes[i], newChildren[i]);\n  }\n\n  // Append new children\n  const ref = nextSiblingAfterMarker(marker);\n  for (let i = oldCount; i < newCount; i++) {\n    const rendered = render(newChildren[i]);\n    const inserted = insertRendered(parent, rendered, ref, marker);\n    oldNodes.push(...inserted);\n  }\n\n  // Remove excess children\n  for (let i = newCount; i < oldCount; i++) {\n    disposeNode(oldNodes[i]);\n    if (oldNodes[i].parentNode === parent) parent.removeChild(oldNodes[i]);\n  }\n\n  marker.__tovaNodes = oldNodes.slice(0, Math.max(newCount, oldCount > newCount ? newCount : oldNodes.length));\n  // Simplify: rebuild __tovaNodes from what should remain\n  if (newCount <= oldCount) {\n    marker.__tovaNodes = oldNodes.slice(0, newCount);\n  }\n}\n\n// Keyed reconciliation for children of an element (not marker-based)\nfunction patchKeyedChildren(parent, newVNodes) {\n  const logical = getLogicalChildren(parent);\n  const oldKeyMap = new Map();\n\n  for (const node of logical) {\n    const key = getNodeKey(node);\n    if (key != null) oldKeyMap.set(key, node);\n  }\n\n  const newNodes = [];\n  const usedOld = new Set();\n\n  for (const newChild of newVNodes) {\n    const key = getKey(newChild);\n\n    if (key != null && oldKeyMap.has(key)) {\n      const oldNode = oldKeyMap.get(key);\n      usedOld.add(oldNode);\n\n      if (oldNode.nodeType === 1 && newChild.__tova &&\n          oldNode.tagName.toLowerCase() === newChild.tag.toLowerCase()) {\n        const oldVNode = oldNode.__vnode || { props: {}, children: [] };\n        applyProps(oldNode, newChild.props, oldVNode.props);\n        patchChildrenOfElement(oldNode, flattenVNodes(newChild.children));\n        oldNode.__vnode = newChild;\n        newNodes.push(oldNode);\n      } else {\n        newNodes.push(render(newChild));\n      }\n    } else {\n      newNodes.push(render(newChild));\n    }\n  }\n\n  // Remove unused old logical nodes\n  for (const node of logical) {\n    if (!usedOld.has(node) && node.parentNode === parent) {\n      removeLogicalNode(parent, node);\n    }\n  }\n\n  // Arrange in correct order\n  for (let i = 0; i < newNodes.length; i++) {\n    const expected = newNodes[i];\n    const logicalNow = getLogicalChildren(parent);\n    const current = logicalNow[i];\n    if (current !== expected) {\n      parent.insertBefore(expected, current || null);\n    }\n  }\n}\n\n// Positional reconciliation for children of an element\nfunction patchPositionalChildren(parent, newChildren) {\n  const logical = getLogicalChildren(parent);\n  const oldCount = logical.length;\n  const newCount = newChildren.length;\n\n  for (let i = 0; i < Math.min(oldCount, newCount); i++) {\n    patchSingle(parent, logical[i], newChildren[i]);\n  }\n\n  for (let i = oldCount; i < newCount; i++) {\n    parent.appendChild(render(newChildren[i]));\n  }\n\n  // Remove excess logical children\n  const currentLogical = getLogicalChildren(parent);\n  while (currentLogical.length > newCount) {\n    const node = currentLogical.pop();\n    removeLogicalNode(parent, node);\n  }\n}\n\n// Patch children of a regular element\nfunction patchChildrenOfElement(el, newChildren) {\n  const hasKeys = newChildren.some(c => getKey(c) != null);\n  if (hasKeys) {\n    patchKeyedChildren(el, newChildren);\n  } else {\n    patchPositionalChildren(el, newChildren);\n  }\n}\n\n// Patch a single logical node in place\nfunction patchSingle(parent, existing, newVNode) {\n  if (!existing) {\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  if (newVNode === null || newVNode === undefined) {\n    removeLogicalNode(parent, existing);\n    return;\n  }\n\n  // Function vnode — replace with new dynamic block\n  if (typeof newVNode === 'function') {\n    const rendered = render(newVNode);\n    if (existing.__tovaNodes) {\n      // Existing is a marker — clear its content and replace\n      clearMarkerContent(existing);\n      parent.replaceChild(rendered, existing);\n    } else {\n      disposeNode(existing);\n      parent.replaceChild(rendered, existing);\n    }\n    return;\n  }\n\n  // Text\n  if (typeof newVNode === 'string' || typeof newVNode === 'number' || typeof newVNode === 'boolean') {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      removeLogicalNode(parent, existing);\n      parent.insertBefore(document.createTextNode(text), null);\n    }\n    return;\n  }\n\n  if (!newVNode.__tova) {\n    const text = String(newVNode);\n    if (existing.nodeType === 3) {\n      if (existing.textContent !== text) existing.textContent = text;\n    } else {\n      removeLogicalNode(parent, existing);\n      parent.insertBefore(document.createTextNode(text), null);\n    }\n    return;\n  }\n\n  // Fragment — patch marker content\n  if (newVNode.tag === '__fragment') {\n    if (existing.__tovaFragment) {\n      // Patch children within the marker range\n      const oldNodes = [...existing.__tovaNodes];\n      const newChildren = flattenVNodes(newVNode.children);\n      // Simple approach: clear and re-render fragment content\n      clearMarkerContent(existing);\n      const ref = nextSiblingAfterMarker(existing);\n      for (const child of newChildren) {\n        const rendered = render(child);\n        const inserted = insertRendered(parent, rendered, ref, existing);\n        existing.__tovaNodes.push(...inserted);\n      }\n      existing.__vnode = newVNode;\n      return;\n    }\n    removeLogicalNode(parent, existing);\n    parent.appendChild(render(newVNode));\n    return;\n  }\n\n  // Element — patch in place\n  if (existing.nodeType === 1 && newVNode.tag &&\n      existing.tagName.toLowerCase() === newVNode.tag.toLowerCase()) {\n    const oldVNode = existing.__vnode || { props: {}, children: [] };\n    applyProps(existing, newVNode.props, oldVNode.props);\n    patchChildrenOfElement(existing, flattenVNodes(newVNode.children));\n    existing.__vnode = newVNode;\n    return;\n  }\n\n  // Different type — full replace\n  removeLogicalNode(parent, existing);\n  parent.appendChild(render(newVNode));\n}\n\n// ─── Hydration (SSR) ─────────────────────────────────────\n// SSR renders flat HTML without markers. Hydration attaches reactivity\n// to existing DOM nodes and inserts markers for dynamic blocks.\n\nfunction hydrateVNode(domNode, vnode) {\n  if (!domNode) return null;\n  if (vnode === null || vnode === undefined) return domNode;\n\n  // Function vnode (reactive text, JSXIf, JSXFor)\n  if (typeof vnode === 'function') {\n    if (domNode.nodeType === 3) {\n      // Reactive text: attach effect to existing text node\n      domNode.__tovaReactive = true;\n      createEffect(() => {\n        const val = vnode();\n        const text = val == null ? '' : String(val);\n        if (domNode.textContent !== text) domNode.textContent = text;\n      });\n      return domNode.nextSibling;\n    }\n    // Complex dynamic block: insert marker-based render, replace SSR node\n    const parent = domNode.parentNode;\n    const next = domNode.nextSibling;\n    const rendered = render(vnode);\n    parent.replaceChild(rendered, domNode);\n    // rendered is a DocumentFragment — its children are now in parent\n    // Find the next unprocessed node\n    return next;\n  }\n\n  // Primitive text — already correct from SSR\n  if (typeof vnode === 'string' || typeof vnode === 'number' || typeof vnode === 'boolean') {\n    return domNode.nextSibling;\n  }\n\n  // Array\n  if (Array.isArray(vnode)) {\n    let cursor = domNode;\n    for (const child of flattenVNodes(vnode)) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return cursor;\n  }\n\n  if (!vnode.__tova) return domNode.nextSibling;\n\n  // Fragment — children rendered inline in SSR (no wrapper)\n  if (vnode.tag === '__fragment') {\n    const children = flattenVNodes(vnode.children);\n    let cursor = domNode;\n    for (const child of children) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return cursor;\n  }\n\n  // Dynamic node — replace SSR content with reactive marker\n  if (vnode.tag === '__dynamic' && typeof vnode.compute === 'function') {\n    const parent = domNode.parentNode;\n    const next = domNode.nextSibling;\n    const rendered = render(vnode);\n    parent.replaceChild(rendered, domNode);\n    return next;\n  }\n\n  // Element — attach event handlers, reactive props, refs\n  if (domNode.nodeType === 1 && domNode.tagName.toLowerCase() === vnode.tag.toLowerCase()) {\n    hydrateProps(domNode, vnode.props);\n    domNode.__vnode = vnode;\n\n    const children = flattenVNodes(vnode.children || []);\n    let cursor = domNode.firstChild;\n    for (const child of children) {\n      if (!cursor) break;\n      cursor = hydrateVNode(cursor, child);\n    }\n    return domNode.nextSibling;\n  }\n\n  // Tag mismatch — fall back to full render\n  const parent = domNode.parentNode;\n  const next = domNode.nextSibling;\n  const rendered = render(vnode);\n  parent.replaceChild(rendered, domNode);\n  return next;\n}\n\nfunction hydrateProps(el, props) {\n  for (const [key, value] of Object.entries(props)) {\n    if (key === 'ref') {\n      if (typeof value === 'object' && value !== null && 'current' in value) {\n        value.current = el;\n      } else if (typeof value === 'function') {\n        value(el);\n      }\n    } else if (key.startsWith('on')) {\n      const eventName = key.slice(2).toLowerCase();\n      el.addEventListener(eventName, value);\n      if (!el.__handlers) el.__handlers = {};\n      el.__handlers[eventName] = value;\n    } else if (key === 'key') {\n      // Skip\n    } else if (typeof value === 'function' && !key.startsWith('on')) {\n      createEffect(() => {\n        const val = value();\n        applyPropValue(el, key, val);\n      });\n    }\n  }\n}\nfunction hydrate(component, container) {\n  if (!container) {\n    console.error('Tova: Hydration target not found');\n    return;\n  }\n\n  return createRoot(() => {\n    const vnode = typeof component === 'function' ? component() : component;\n    if (container.firstChild) {\n      hydrateVNode(container.firstChild, vnode);\n    }\n  });\n}\nfunction mount(component, container) {\n  if (!container) {\n    console.error('Tova: Mount target not found');\n    return;\n  }\n\n  return createRoot((dispose) => {\n    const vnode = typeof component === 'function' ? component() : component;\n    container.innerHTML = '';\n    container.appendChild(render(vnode));\n    return dispose;\n  });\n}";
var STRING_PROTO_CODE = "// Tova string method extensions — bridges Tova method syntax to JavaScript\n// Allows: \"hello\".upper() instead of requiring upper(\"hello\")\n\nconst methods = {\n  upper()       { return this.toUpperCase(); },\n  lower()       { return this.toLowerCase(); },\n  contains(s)   { return this.includes(s); },\n  starts_with(s){ return this.startsWith(s); },\n  ends_with(s)  { return this.endsWith(s); },\n  chars()       { return [...this]; },\n  words()       { return this.split(/\\s+/).filter(Boolean); },\n  lines()       { return this.split('\\n'); },\n  capitalize()  { return this.length ? this.charAt(0).toUpperCase() + this.slice(1) : this; },\n  title_case()  { return this.replace(/\\b\\w/g, c => c.toUpperCase()); },\n  snake_case()  { return this.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); },\n  camel_case()  { return this.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); },\n};\n\nfor (const [name, fn] of Object.entries(methods)) {\n  if (!String.prototype[name]) {\n    Object.defineProperty(String.prototype, name, {\n      value: fn,\n      writable: true,\n      configurable: true,\n    });\n  }\n}";
var STDLIB_CODE = "function print(...args) { console.log(...args); }\nfunction len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }\nfunction range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }\nfunction enumerate(a) { return a.map((v, i) => [i, v]); }\nfunction sum(a) { return a.reduce((x, y) => x + y, 0); }\nfunction sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }\nfunction reversed(a) { return [...a].reverse(); }\nfunction zip(...as) { const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }\nfunction min(a) { return Math.min(...a); }\nfunction max(a) { return Math.max(...a); }\nfunction type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }\nfunction filter(arr, fn) { return arr.filter(fn); }\nfunction map(arr, fn) { return arr.map(fn); }\nfunction flat_map(arr, fn) { return arr.flatMap(fn); }\nfunction any(arr, fn) { return arr.some(fn); }\nfunction all(arr, fn) { return arr.every(fn); }";

// ─── Tova Compiler Bundle ────────────────────────────
(function() {

// ─── src/lexer/tokens.js ───────────────────────────────

// Token type definitions for the Tova language
const TokenType = {
  // Literals
  NUMBER: 'NUMBER',
  STRING: 'STRING',
  STRING_TEMPLATE: 'STRING_TEMPLATE',
  BOOLEAN: 'BOOLEAN',
  NIL: 'NIL',
  IDENTIFIER: 'IDENTIFIER',

  // Keywords
  VAR: 'VAR',
  LET: 'LET',
  FN: 'FN',
  RETURN: 'RETURN',
  IF: 'IF',
  ELIF: 'ELIF',
  ELSE: 'ELSE',
  FOR: 'FOR',
  WHILE: 'WHILE',
  MATCH: 'MATCH',
  TYPE: 'TYPE',
  IMPORT: 'IMPORT',
  FROM: 'FROM',
  EXPORT: 'EXPORT',
  AS: 'AS',

  // Boolean / logic keywords
  AND: 'AND',
  OR: 'OR',
  NOT: 'NOT',
  IN: 'IN',
  TRUE: 'TRUE',
  FALSE: 'FALSE',

  // Control flow
  BREAK: 'BREAK',
  CONTINUE: 'CONTINUE',

  // Error handling
  TRY: 'TRY',
  CATCH: 'CATCH',
  FINALLY: 'FINALLY',

  // Async
  ASYNC: 'ASYNC',
  AWAIT: 'AWAIT',

  // Guard
  GUARD: 'GUARD',

  // Interface
  INTERFACE: 'INTERFACE',
  DERIVE: 'DERIVE',

  // Visibility
  PUB: 'PUB',

  // Impl blocks / traits
  IMPL: 'IMPL',
  TRAIT: 'TRAIT',

  // Defer
  DEFER: 'DEFER',

  // Generators
  YIELD: 'YIELD',

  // Extern
  EXTERN: 'EXTERN',

  // Full-stack keywords
  SERVER: 'SERVER',
  CLIENT: 'CLIENT',
  SHARED: 'SHARED',
  ROUTE: 'ROUTE',
  STATE: 'STATE',
  COMPUTED: 'COMPUTED',
  EFFECT: 'EFFECT',
  COMPONENT: 'COMPONENT',
  STORE: 'STORE',
  STYLE_BLOCK: 'STYLE_BLOCK',

  // HTTP methods (used in route declarations)
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',

  // Operators
  PLUS: 'PLUS',               // +
  MINUS: 'MINUS',             // -
  STAR: 'STAR',               // *
  SLASH: 'SLASH',             // /
  PERCENT: 'PERCENT',         // %
  POWER: 'POWER',             // **
  ASSIGN: 'ASSIGN',           // =
  EQUAL: 'EQUAL',             // ==
  NOT_EQUAL: 'NOT_EQUAL',     // !=
  LESS: 'LESS',               // <
  LESS_EQUAL: 'LESS_EQUAL',   // <=
  GREATER: 'GREATER',         // >
  GREATER_EQUAL: 'GREATER_EQUAL', // >=
  AND_AND: 'AND_AND',         // &&
  OR_OR: 'OR_OR',             // ||
  BANG: 'BANG',                // !
  PIPE: 'PIPE',               // |>
  ARROW: 'ARROW',             // =>
  THIN_ARROW: 'THIN_ARROW',   // ->
  DOT: 'DOT',                 // .
  DOT_DOT: 'DOT_DOT',        // ..
  DOT_DOT_EQUAL: 'DOT_DOT_EQUAL', // ..=
  SPREAD: 'SPREAD',           // ...
  COLON: 'COLON',             // :
  DOUBLE_COLON: 'DOUBLE_COLON', // ::
  QUESTION: 'QUESTION',       // ?
  QUESTION_DOT: 'QUESTION_DOT', // ?.
  QUESTION_QUESTION: 'QUESTION_QUESTION', // ??
  PLUS_ASSIGN: 'PLUS_ASSIGN', // +=
  MINUS_ASSIGN: 'MINUS_ASSIGN', // -=
  STAR_ASSIGN: 'STAR_ASSIGN', // *=
  SLASH_ASSIGN: 'SLASH_ASSIGN', // /=

  // Delimiters
  LPAREN: 'LPAREN',           // (
  RPAREN: 'RPAREN',           // )
  LBRACE: 'LBRACE',           // {
  RBRACE: 'RBRACE',           // }
  LBRACKET: 'LBRACKET',       // [
  RBRACKET: 'RBRACKET',       // ]
  COMMA: 'COMMA',             // ,
  SEMICOLON: 'SEMICOLON',     // ;
  NEWLINE: 'NEWLINE',         // \n (significant in some contexts)

  // JSX
  JSX_OPEN: 'JSX_OPEN',       // <tag
  JSX_CLOSE: 'JSX_CLOSE',     // </tag>
  JSX_SELF_CLOSE: 'JSX_SELF_CLOSE', // />
  JSX_TEXT: 'JSX_TEXT',

  // Regex
  REGEX: 'REGEX',             // /pattern/flags

  // Special
  EOF: 'EOF',
  DOCSTRING: 'DOCSTRING',     // /// comment
};

// Keywords map for quick lookup during lexing
const Keywords = {
  'var': TokenType.VAR,
  'let': TokenType.LET,
  'fn': TokenType.FN,
  'return': TokenType.RETURN,
  'if': TokenType.IF,
  'elif': TokenType.ELIF,
  'else': TokenType.ELSE,
  'for': TokenType.FOR,
  'while': TokenType.WHILE,
  'match': TokenType.MATCH,
  'type': TokenType.TYPE,
  'import': TokenType.IMPORT,
  'from': TokenType.FROM,
  'export': TokenType.EXPORT,
  'as': TokenType.AS,
  'and': TokenType.AND,
  'or': TokenType.OR,
  'not': TokenType.NOT,
  'in': TokenType.IN,
  'true': TokenType.TRUE,
  'false': TokenType.FALSE,
  'nil': TokenType.NIL,
  'break': TokenType.BREAK,
  'continue': TokenType.CONTINUE,
  'try': TokenType.TRY,
  'catch': TokenType.CATCH,
  'finally': TokenType.FINALLY,
  'async': TokenType.ASYNC,
  'await': TokenType.AWAIT,
  'guard': TokenType.GUARD,
  'interface': TokenType.INTERFACE,
  'derive': TokenType.DERIVE,
  'pub': TokenType.PUB,
  'impl': TokenType.IMPL,
  'trait': TokenType.TRAIT,
  'defer': TokenType.DEFER,
  'yield': TokenType.YIELD,
  'extern': TokenType.EXTERN,
  'server': TokenType.SERVER,
  'client': TokenType.CLIENT,
  'shared': TokenType.SHARED,
  'route': TokenType.ROUTE,
  'state': TokenType.STATE,
  'computed': TokenType.COMPUTED,
  'effect': TokenType.EFFECT,
  'component': TokenType.COMPONENT,
  'store': TokenType.STORE,
};

// Token class
class Token {
  constructor(type, value, line, column) {
    this.type = type;
    this.value = value;
    this.line = line;
    this.column = column;
  }

  toString() {
    return `Token(${this.type}, ${JSON.stringify(this.value)}, ${this.line}:${this.column})`;
  }
}

// ─── src/lexer/lexer.js ────────────────────────────────

class Lexer {
  static MAX_INTERPOLATION_DEPTH = 64;

  constructor(source, filename = '<stdin>', lineOffset = 0, columnOffset = 0, _depth = 0) {
    this.source = source;
    this.filename = filename;
    this.tokens = [];
    this.pos = 0;
    this.line = 1 + lineOffset;
    this.column = 1 + columnOffset;
    this.length = source.length;
    this._depth = _depth;

    // JSX context tracking for unquoted text support
    this._jsxStack = [];          // stack of 'tag' or 'cfblock' entries
    this._jsxTagOpening = false;  // true when < starts a JSX opening tag
    this._jsxSelfClosing = false; // true when / seen inside JSX tag (before >)
    this._jsxClosingTag = false;  // true when </ detected
    this._jsxExprDepth = 0;       // brace depth for {expr} inside JSX
    this._jsxControlFlowPending = false; // true after if/for/elif/else keyword in JSX
    this._cfParenDepth = 0;       // () and [] nesting in control flow condition
    this._cfBraceDepth = 0;       // {} nesting for expression braces (key={...})
  }

  error(message) {
    throw new Error(`${this.filename}:${this.line}:${this.column} — ${message}`);
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.length ? this.source[idx] : '\0';
  }

  advance() {
    const ch = this.source[this.pos];
    this.pos++;
    if (ch === '\n') {
      this.line++;
      this.column = 1;
    } else {
      this.column++;
    }
    return ch;
  }

  match(expected) {
    if (this.pos < this.length && this.source[this.pos] === expected) {
      this.advance();
      return true;
    }
    return false;
  }

  addToken(type, value) {
    this.tokens.push(new Token(type, value, this.line, this.column));
  }

  isDigit(ch) {
    return ch >= '0' && ch <= '9';
  }

  isAlpha(ch) {
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_') return true;
    // Unicode letter support
    if (ch > '\x7f') return /\p{Letter}/u.test(ch);
    return false;
  }

  isAlphaNumeric(ch) {
    if (this.isAlpha(ch) || this.isDigit(ch)) return true;
    // Unicode continue characters (combining marks, etc.)
    if (ch > '\x7f') return /[\p{Letter}\p{Number}\p{Mark}]/u.test(ch);
    return false;
  }

  isWhitespace(ch) {
    return ch === ' ' || ch === '\t' || ch === '\r';
  }

  _isJSXStart() {
    const nextCh = this.peek();
    if (!this.isAlpha(nextCh)) return false;
    // Check the token BEFORE < (LESS was already pushed, so it's at length-2)
    const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
    if (!prev) return true;
    const valueTypes = [TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.STRING,
      TokenType.STRING_TEMPLATE, TokenType.RPAREN, TokenType.RBRACKET,
      TokenType.TRUE, TokenType.FALSE, TokenType.NIL];
    return !valueTypes.includes(prev.type);
  }

  tokenize() {
    while (this.pos < this.length) {
      this.scanToken();
    }
    this.tokens.push(new Token(TokenType.EOF, null, this.line, this.column));
    return this.tokens;
  }

  scanToken() {
    // In JSX children mode, scan raw text instead of normal tokens
    if (this._jsxStack.length > 0 && this._jsxExprDepth === 0 &&
        !this._jsxTagOpening && !this._jsxClosingTag &&
        !this._jsxControlFlowPending) {
      return this._scanInJSXChildren();
    }

    const ch = this.peek();

    // Skip whitespace (not newlines)
    if (this.isWhitespace(ch)) {
      this.advance();
      return;
    }

    // Newlines
    if (ch === '\n') {
      this.tokens.push(new Token(TokenType.NEWLINE, '\n', this.line, this.column));
      this.advance();
      return;
    }

    // Comments
    if (ch === '/' && this.peek(1) === '/') {
      this.scanComment();
      return;
    }
    if (ch === '/' && this.peek(1) === '*') {
      this.scanBlockComment();
      return;
    }

    // Regex literals: /pattern/flags
    // Must not be /=, //, /*, and must be in a context where regex makes sense
    if (ch === '/' && this.peek(1) !== '/' && this.peek(1) !== '*' && this.peek(1) !== '='
        && this._jsxStack.length === 0) {
      let prev = null;
      for (let i = this.tokens.length - 1; i >= 0; i--) {
        if (this.tokens[i].type !== TokenType.NEWLINE) {
          prev = this.tokens[i];
          break;
        }
      }
      // Only treat as regex after tokens that clearly start an expression context
      const regexPreceders = [
        TokenType.ASSIGN, TokenType.LPAREN, TokenType.LBRACKET, TokenType.LBRACE,
        TokenType.COMMA, TokenType.COLON, TokenType.SEMICOLON,
        TokenType.RETURN, TokenType.ARROW, TokenType.PIPE,
        TokenType.EQUAL, TokenType.NOT_EQUAL,
        TokenType.AND, TokenType.OR, TokenType.AND_AND, TokenType.OR_OR,
        TokenType.NOT, TokenType.BANG,
        TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN,
      ];
      if (prev && regexPreceders.includes(prev.type)) {
        this.scanRegex();
        return;
      }
      // At start of file (no prev token), treat / as regex if followed by a non-space, non-special char
      if (!prev && this.pos + 1 < this.length && !/[\s\/*=]/.test(this.peek(1))) {
        this.scanRegex();
        return;
      }
    }

    // Numbers
    if (this.isDigit(ch)) {
      this.scanNumber();
      return;
    }

    // Strings
    if (ch === '"') {
      this.scanString();
      return;
    }
    if (ch === "'") {
      this.scanSimpleString();
      return;
    }

    // Identifiers and keywords
    if (this.isAlpha(ch)) {
      this.scanIdentifier();
      return;
    }

    // Operators and delimiters
    this.scanOperator();
  }

  _scanInJSXChildren() {
    const ch = this.peek();

    // Close control flow block: } when top of stack is 'cfblock'
    if (ch === '}' && this._jsxStack.length > 0 && this._jsxStack[this._jsxStack.length - 1] === 'cfblock') {
      this._jsxStack.pop();
      this.scanOperator(); // emits RBRACE
      return;
    }

    // Skip whitespace/newlines silently when followed by structural chars
    if (this.isWhitespace(ch) || ch === '\n') {
      let pp = this.pos;
      while (pp < this.length && (this.source[pp] === ' ' || this.source[pp] === '\t' || this.source[pp] === '\r' || this.source[pp] === '\n')) {
        pp++;
      }
      const nextNonWs = pp < this.length ? this.source[pp] : '\0';
      // Skip whitespace if next meaningful char is structural
      if (nextNonWs === '<' || nextNonWs === '{' || nextNonWs === '}' || nextNonWs === '"' || nextNonWs === "'" || pp >= this.length) {
        while (this.pos < pp) this.advance();
        return;
      }
      // Check if next non-ws starts a keyword (if/for/elif/else)
      if (this.isAlpha(nextNonWs)) {
        let word = '', wp = pp;
        while (wp < this.length && this.isAlphaNumeric(this.source[wp])) {
          word += this.source[wp]; wp++;
        }
        if (['if', 'for', 'elif', 'else'].includes(word)) {
          while (this.pos < pp) this.advance();
          return;
        }
      }
      // Otherwise, fall through to collect as JSX text
    }

    if (ch === '{') {
      this.scanOperator();
      this._jsxExprDepth = 1;
      return;
    }
    if (ch === '<') {
      // In JSX children, set flags directly (heuristic may fail after STRING tokens)
      const nextCh = this.peek(1);
      if (nextCh === '/') {
        this._jsxClosingTag = true;
      } else if (this.isAlpha(nextCh)) {
        this._jsxTagOpening = true;
      }
      this.scanOperator();
      return;
    }
    if (ch === '"') { this.scanString(); return; }
    if (ch === "'") { this.scanSimpleString(); return; }

    // Check for JSX control flow keywords: if, for, elif, else
    if (this.isAlpha(ch)) {
      let word = '', peekPos = this.pos;
      while (peekPos < this.length && this.isAlphaNumeric(this.source[peekPos])) {
        word += this.source[peekPos]; peekPos++;
      }
      if (['if', 'for', 'elif', 'else'].includes(word)) {
        this.scanIdentifier();
        // After keyword, enter control flow pending mode for normal scanning
        this._jsxControlFlowPending = true;
        this._cfParenDepth = 0;
        this._cfBraceDepth = 0;
        return;
      }
    }

    // Everything else: scan as raw JSX text
    this._scanJSXText();
  }

  _scanJSXText() {
    const startLine = this.line, startCol = this.column;
    let text = '';
    while (this.pos < this.length) {
      const ch = this.peek();
      if (ch === '<' || ch === '{' || ch === '"' || ch === "'") break;
      // Stop at keywords if, for, elif, else preceded by whitespace
      if (this.isAlpha(ch) && text.length > 0 && /\s$/.test(text)) {
        let word = '', pp = this.pos;
        while (pp < this.length && this.isAlphaNumeric(this.source[pp])) {
          word += this.source[pp]; pp++;
        }
        if (['if', 'for', 'elif', 'else'].includes(word)) break;
      }
      text += this.advance();
    }
    if (text.length > 0) {
      this.tokens.push(new Token(TokenType.JSX_TEXT, text, startLine, startCol));
    }
  }

  scanComment() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // /
    this.advance(); // /

    // Check for docstring ///
    const isDocstring = this.peek() === '/';
    if (isDocstring) this.advance();

    let value = '';
    while (this.pos < this.length && this.peek() !== '\n') {
      value += this.advance();
    }

    if (isDocstring) {
      this.tokens.push(new Token(TokenType.DOCSTRING, value.trim(), startLine, startCol));
    }
    // Regular comments are discarded
  }

  scanBlockComment() {
    this.advance(); // /
    this.advance(); // *
    let depth = 1;

    while (this.pos < this.length && depth > 0) {
      if (this.peek() === '/' && this.peek(1) === '*') {
        depth++;
        this.advance();
        this.advance();
      } else if (this.peek() === '*' && this.peek(1) === '/') {
        depth--;
        this.advance();
        this.advance();
      } else {
        this.advance();
      }
    }

    if (depth !== 0) {
      this.error('Unterminated block comment');
    }
  }

  scanNumber() {
    const startLine = this.line;
    const startCol = this.column;
    let value = '';

    // Handle hex, octal, binary
    if (this.peek() === '0') {
      const next = this.peek(1);
      if (next === 'x' || next === 'X') {
        this.advance(); // 0
        this.advance(); // x
        while (this.pos < this.length && /[0-9a-fA-F_]/.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected hex digits after 0x');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 16), startLine, startCol));
        return;
      }
      if (next === 'b' || next === 'B') {
        this.advance(); // 0
        this.advance(); // b
        while (this.pos < this.length && /[01_]/.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected binary digits after 0b');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 2), startLine, startCol));
        return;
      }
      if (next === 'o' || next === 'O') {
        this.advance(); // 0
        this.advance(); // o
        while (this.pos < this.length && /[0-7_]/.test(this.peek())) {
          const ch = this.advance();
          if (ch !== '_') value += ch;
        }
        if (!value) this.error('Expected octal digits after 0o');
        this.tokens.push(new Token(TokenType.NUMBER, parseInt(value, 8), startLine, startCol));
        return;
      }
    }

    // Decimal
    while (this.pos < this.length && (this.isDigit(this.peek()) || this.peek() === '_')) {
      const ch = this.advance();
      if (ch !== '_') value += ch;
    }

    // Decimal point
    if (this.peek() === '.' && this.peek(1) !== '.') {
      value += this.advance(); // .
      while (this.pos < this.length && (this.isDigit(this.peek()) || this.peek() === '_')) {
        const ch = this.advance();
        if (ch !== '_') value += ch;
      }
    }

    // Exponent
    if (this.peek() === 'e' || this.peek() === 'E') {
      const savedPos = this.pos;
      const savedCol = this.column;
      let expPart = this.advance(); // consume 'e'/'E'
      if (this.peek() === '+' || this.peek() === '-') {
        expPart += this.advance();
      }
      if (this.pos < this.length && this.isDigit(this.peek())) {
        value += expPart;
        while (this.pos < this.length && this.isDigit(this.peek())) {
          value += this.advance();
        }
      } else {
        // No digits after exponent — backtrack, treat 'e' as separate token
        this.pos = savedPos;
        this.column = savedCol;
      }
    }

    this.tokens.push(new Token(TokenType.NUMBER, parseFloat(value), startLine, startCol));
  }

  scanString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening "

    const parts = [];
    let current = '';

    while (this.pos < this.length && this.peek() !== '"') {
      // Escape sequences
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated string');
        }
        const esc = this.advance();
        switch (esc) {
          case 'n': current += '\n'; break;
          case 't': current += '\t'; break;
          case 'r': current += '\r'; break;
          case '\\': current += '\\'; break;
          case '"': current += '"'; break;
          case '{': current += '{'; break;
          default: current += '\\' + esc;
        }
        continue;
      }

      // String interpolation: {expr}
      if (this.peek() === '{') {
        this.advance(); // {
        if (current.length > 0) {
          parts.push({ type: 'text', value: current });
          current = '';
        }

        // Lex the interpolation expression, respecting nested strings
        const exprStartLine = this.line - 1; // 0-based offset for sub-lexer
        const exprStartCol = this.column - 1;
        let depth = 1;
        let exprSource = '';
        while (this.pos < this.length && depth > 0) {
          const ch = this.peek();
          // Skip over string literals so braces inside them don't affect depth
          if (ch === '"' || ch === "'" || ch === '`') {
            const quote = ch;
            exprSource += this.advance(); // opening quote
            let strDepth = 0; // track interpolation depth inside nested strings
            while (this.pos < this.length) {
              if (this.peek() === '\\') {
                exprSource += this.advance(); // backslash
                if (this.pos < this.length) exprSource += this.advance(); // escaped char
              } else if (quote === '"' && this.peek() === '{') {
                strDepth++;
                exprSource += this.advance();
              } else if (quote === '"' && this.peek() === '}' && strDepth > 0) {
                strDepth--;
                exprSource += this.advance();
              } else if (this.peek() === quote && strDepth === 0) {
                break;
              } else {
                exprSource += this.advance();
              }
            }
            if (this.pos < this.length) exprSource += this.advance(); // closing quote
            continue;
          }
          if (ch === '{') depth++;
          if (ch === '}') {
            depth--;
            if (depth === 0) break;
          }
          exprSource += this.advance();
        }

        if (this.peek() !== '}') {
          this.error('Unterminated string interpolation');
        }
        this.advance(); // }

        // Sub-lex the expression with correct file position offsets
        if (this._depth + 1 > Lexer.MAX_INTERPOLATION_DEPTH) {
          this.error('String interpolation nested too deeply (max ' + Lexer.MAX_INTERPOLATION_DEPTH + ' levels)');
        }
        const subLexer = new Lexer(exprSource, this.filename, exprStartLine, exprStartCol, this._depth + 1);
        const exprTokens = subLexer.tokenize();
        // Remove the EOF token
        exprTokens.pop();

        parts.push({ type: 'expr', tokens: exprTokens, source: exprSource });
        continue;
      }

      current += this.advance();
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing "

    // If there are no interpolation parts, emit a simple string
    if (parts.length === 0) {
      this.tokens.push(new Token(TokenType.STRING, current, startLine, startCol));
    } else {
      if (current.length > 0) {
        parts.push({ type: 'text', value: current });
      }
      this.tokens.push(new Token(TokenType.STRING_TEMPLATE, parts, startLine, startCol));
    }
  }

  scanSimpleString() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening '

    let value = '';
    while (this.pos < this.length && this.peek() !== "'") {
      if (this.peek() === '\\') {
        this.advance();
        if (this.pos >= this.length) {
          this.error('Unterminated string');
        }
        const esc = this.advance();
        switch (esc) {
          case 'n': value += '\n'; break;
          case 't': value += '\t'; break;
          case 'r': value += '\r'; break;
          case '\\': value += '\\'; break;
          case "'": value += "'"; break;
          default: value += '\\' + esc;
        }
      } else {
        value += this.advance();
      }
    }

    if (this.pos >= this.length) {
      this.error('Unterminated string');
    }
    this.advance(); // closing '

    this.tokens.push(new Token(TokenType.STRING, value, startLine, startCol));
  }

  scanRegex() {
    const startLine = this.line;
    const startCol = this.column;
    this.advance(); // opening /

    let pattern = '';
    let escaped = false;
    let inCharClass = false;

    while (this.pos < this.length) {
      const ch = this.peek();
      if (ch === '\n') {
        this.error('Unterminated regex literal');
      }
      if (escaped) {
        pattern += ch;
        this.advance();
        escaped = false;
        continue;
      }
      if (ch === '\\') {
        pattern += ch;
        this.advance();
        escaped = true;
        continue;
      }
      if (ch === '[') inCharClass = true;
      if (ch === ']') inCharClass = false;
      if (ch === '/' && !inCharClass) break;
      pattern += this.advance();
    }

    if (this.pos >= this.length || this.peek() !== '/') {
      this.error('Unterminated regex literal');
    }
    this.advance(); // closing /

    // Read flags
    let flags = '';
    while (this.pos < this.length && /[gimsuydv]/.test(this.peek())) {
      flags += this.advance();
    }

    this.tokens.push(new Token(TokenType.REGEX, { pattern, flags }, startLine, startCol));
  }

  scanIdentifier() {
    const startLine = this.line;
    const startCol = this.column;
    let value = '';

    while (this.pos < this.length && this.isAlphaNumeric(this.peek())) {
      value += this.advance();
    }

    // Raw string: r"no\escapes"
    if (value === 'r' && this.pos < this.length && this.peek() === '"') {
      this.advance(); // opening "
      let raw = '';
      while (this.pos < this.length && this.peek() !== '"') {
        raw += this.advance();
      }
      if (this.pos >= this.length) {
        this.error('Unterminated raw string');
      }
      this.advance(); // closing "
      this.tokens.push(new Token(TokenType.STRING, raw, startLine, startCol));
      return;
    }

    // Special case: "style {" → read raw CSS block
    if (value === 'style') {
      const savedPos = this.pos;
      const savedLine = this.line;
      const savedCol = this.column;
      // Skip whitespace (including newlines) to check for {
      while (this.pos < this.length && (this.isWhitespace(this.peek()) || this.peek() === '\n')) {
        this.advance();
      }
      if (this.peek() === '{') {
        this.advance(); // skip {
        let depth = 1;
        let css = '';
        while (depth > 0 && this.pos < this.length) {
          const ch = this.peek();
          if (ch === '{') depth++;
          else if (ch === '}') {
            depth--;
            if (depth === 0) { this.advance(); break; }
          }
          css += this.advance();
        }
        if (depth > 0) {
          this.error('Unterminated style block');
        }
        this.tokens.push(new Token(TokenType.STYLE_BLOCK, css.trim(), startLine, startCol));
        return;
      }
      // Not a style block — restore position
      this.pos = savedPos;
      this.line = savedLine;
      this.column = savedCol;
    }

    // Check if it's a keyword
    const type = Keywords[value] || TokenType.IDENTIFIER;
    this.tokens.push(new Token(type, value, startLine, startCol));
  }

  scanOperator() {
    const startLine = this.line;
    const startCol = this.column;
    const ch = this.advance();

    switch (ch) {
      case '(':
        this.tokens.push(new Token(TokenType.LPAREN, '(', startLine, startCol));
        if (this._jsxControlFlowPending) this._cfParenDepth++;
        break;
      case ')':
        this.tokens.push(new Token(TokenType.RPAREN, ')', startLine, startCol));
        if (this._jsxControlFlowPending && this._cfParenDepth > 0) this._cfParenDepth--;
        break;
      case '{':
        this.tokens.push(new Token(TokenType.LBRACE, '{', startLine, startCol));
        if (this._jsxControlFlowPending) {
          if (this._cfBraceDepth > 0) {
            // Nested brace inside expression (e.g., key={obj.field})
            this._cfBraceDepth++;
          } else if (this._cfParenDepth > 0) {
            // Inside parens, this is an expression brace
            this._cfBraceDepth++;
          } else {
            // Check if prev token is ASSIGN (key={...}) or FOR (destructuring: for {a,b} in ...)
            const prev = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
            if (prev && (prev.type === TokenType.ASSIGN || prev.type === TokenType.FOR)) {
              this._cfBraceDepth++;
            } else {
              // This is the block opener for the control flow body
              this._jsxControlFlowPending = false;
              this._jsxStack.push('cfblock');
            }
          }
        } else if (this._jsxExprDepth > 0) {
          this._jsxExprDepth++;
        }
        break;
      case '}':
        this.tokens.push(new Token(TokenType.RBRACE, '}', startLine, startCol));
        if (this._jsxControlFlowPending && this._cfBraceDepth > 0) {
          this._cfBraceDepth--;
        } else if (this._jsxExprDepth > 0) {
          this._jsxExprDepth--;
        }
        break;
      case '[':
        this.tokens.push(new Token(TokenType.LBRACKET, '[', startLine, startCol));
        if (this._jsxControlFlowPending) this._cfParenDepth++;
        break;
      case ']':
        this.tokens.push(new Token(TokenType.RBRACKET, ']', startLine, startCol));
        if (this._jsxControlFlowPending && this._cfParenDepth > 0) this._cfParenDepth--;
        break;
      case ',':
        this.tokens.push(new Token(TokenType.COMMA, ',', startLine, startCol));
        break;
      case ';':
        this.tokens.push(new Token(TokenType.SEMICOLON, ';', startLine, startCol));
        break;

      case '+':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.PLUS_ASSIGN, '+=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.PLUS, '+', startLine, startCol));
        }
        break;

      case '-':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.THIN_ARROW, '->', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.MINUS_ASSIGN, '-=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.MINUS, '-', startLine, startCol));
        }
        break;

      case '*':
        if (this.match('*')) {
          this.tokens.push(new Token(TokenType.POWER, '**', startLine, startCol));
        } else if (this.match('=')) {
          this.tokens.push(new Token(TokenType.STAR_ASSIGN, '*=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.STAR, '*', startLine, startCol));
        }
        break;

      case '/':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.SLASH_ASSIGN, '/=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.SLASH, '/', startLine, startCol));
          if (this._jsxTagOpening) this._jsxSelfClosing = true;
        }
        break;

      case '%':
        this.tokens.push(new Token(TokenType.PERCENT, '%', startLine, startCol));
        break;

      case '=':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.EQUAL, '==', startLine, startCol));
        } else if (this.match('>')) {
          this.tokens.push(new Token(TokenType.ARROW, '=>', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.ASSIGN, '=', startLine, startCol));
        }
        break;

      case '!':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.NOT_EQUAL, '!=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.BANG, '!', startLine, startCol));
        }
        break;

      case '<':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.LESS_EQUAL, '<=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.LESS, '<', startLine, startCol));
          // Don't override flags already set by _scanInJSXChildren
          if (!this._jsxClosingTag && !this._jsxTagOpening) {
            if (this.peek() === '/') {
              this._jsxClosingTag = true;
            } else if (this._isJSXStart()) {
              this._jsxTagOpening = true;
            }
          }
        }
        break;

      case '>':
        if (this.match('=')) {
          this.tokens.push(new Token(TokenType.GREATER_EQUAL, '>=', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.GREATER, '>', startLine, startCol));
          // JSX state transitions on >
          if (this._jsxSelfClosing) {
            // Self-closing tag: <br/> — don't push to stack
            this._jsxTagOpening = false;
            this._jsxSelfClosing = false;
          } else if (this._jsxClosingTag) {
            // Closing tag: </div> — pop 'tag' from stack
            this._jsxClosingTag = false;
            if (this._jsxStack.length > 0) this._jsxStack.pop();
          } else if (this._jsxTagOpening) {
            // Opening tag: <div> — push 'tag' to stack (entering children mode)
            this._jsxTagOpening = false;
            this._jsxStack.push('tag');
          }
        }
        break;

      case '&':
        if (this.match('&')) {
          this.tokens.push(new Token(TokenType.AND_AND, '&&', startLine, startCol));
        } else if (this._jsxStack.length > 0) {
          // Inside JSX, & is valid text - should not reach here normally
          // but handle gracefully by treating as text
          this.tokens.push(new Token(TokenType.JSX_TEXT, '&', startLine, startCol));
        } else {
          this.error(`Unexpected character: '&'. Did you mean '&&'?`);
        }
        break;

      case '|':
        if (this.match('>')) {
          this.tokens.push(new Token(TokenType.PIPE, '|>', startLine, startCol));
        } else if (this.match('|')) {
          this.tokens.push(new Token(TokenType.OR_OR, '||', startLine, startCol));
        } else {
          this.error(`Unexpected character: '|'. Did you mean '|>' or '||'?`);
        }
        break;

      case '.':
        if (this.match('.')) {
          if (this.match('=')) {
            this.tokens.push(new Token(TokenType.DOT_DOT_EQUAL, '..=', startLine, startCol));
          } else if (this.match('.')) {
            this.tokens.push(new Token(TokenType.SPREAD, '...', startLine, startCol));
          } else {
            this.tokens.push(new Token(TokenType.DOT_DOT, '..', startLine, startCol));
          }
        } else {
          this.tokens.push(new Token(TokenType.DOT, '.', startLine, startCol));
        }
        break;

      case ':':
        if (this.match(':')) {
          this.tokens.push(new Token(TokenType.DOUBLE_COLON, '::', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.COLON, ':', startLine, startCol));
        }
        break;

      case '?':
        if (this.match('.')) {
          this.tokens.push(new Token(TokenType.QUESTION_DOT, '?.', startLine, startCol));
        } else if (this.match('?')) {
          this.tokens.push(new Token(TokenType.QUESTION_QUESTION, '??', startLine, startCol));
        } else {
          this.tokens.push(new Token(TokenType.QUESTION, '?', startLine, startCol));
        }
        break;

      default:
        this.error(`Unexpected character: '${ch}'`);
    }
  }
}

// ─── src/parser/ast.js ─────────────────────────────────

// AST Node definitions for the Tova language

// Sentinel value for pipe target placeholder (used in method pipe |> .method())
const PIPE_TARGET = '__pipe_target__';

// ============================================================
// Program (root node)
// ============================================================
class Program {
  constructor(body) {
    this.type = 'Program';
    this.body = body; // Array of top-level statements/blocks
  }
}

// ============================================================
// Full-stack blocks
// ============================================================
class ServerBlock {
  constructor(body, loc, name = null) {
    this.type = 'ServerBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class ClientBlock {
  constructor(body, loc, name = null) {
    this.type = 'ClientBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}
class SharedBlock {
  constructor(body, loc, name = null) {
    this.type = 'SharedBlock';
    this.name = name;
    this.body = body;
    this.loc = loc;
  }
}

// ============================================================
// Declarations
// ============================================================
class Assignment {
  constructor(targets, values, loc) {
    this.type = 'Assignment';
    this.targets = targets;   // Array of identifiers (supports multiple: a, b = 1, 2)
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class VarDeclaration {
  constructor(targets, values, loc) {
    this.type = 'VarDeclaration';
    this.targets = targets;   // Array of identifiers
    this.values = values;     // Array of expressions
    this.loc = loc;
  }
}
class LetDestructure {
  constructor(pattern, value, loc) {
    this.type = 'LetDestructure';
    this.pattern = pattern;   // ObjectPattern or ArrayPattern
    this.value = value;       // Expression
    this.loc = loc;
  }
}
class FunctionDeclaration {
  constructor(name, params, body, returnType, loc, isAsync = false) {
    this.type = 'FunctionDeclaration';
    this.name = name;
    this.params = params;     // Array of Parameter nodes
    this.body = body;         // BlockStatement or Expression (implicit return)
    this.returnType = returnType; // optional type annotation
    this.isAsync = isAsync;
    this.loc = loc;
  }
}
class Parameter {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'Parameter';
    this.name = name;
    this.typeAnnotation = typeAnnotation; // optional
    this.defaultValue = defaultValue;     // optional
    this.loc = loc;
  }
}
class TypeDeclaration {
  constructor(name, typeParams, variants, loc) {
    this.type = 'TypeDeclaration';
    this.name = name;
    this.typeParams = typeParams; // Array of type parameter names (generics)
    this.variants = variants;     // Array of TypeVariant or TypeField
    this.loc = loc;
  }
}
class TypeVariant {
  constructor(name, fields, loc) {
    this.type = 'TypeVariant';
    this.name = name;
    this.fields = fields; // Array of { name, typeAnnotation }
    this.loc = loc;
  }
}
class TypeField {
  constructor(name, typeAnnotation, loc) {
    this.type = 'TypeField';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.loc = loc;
  }
}

// ============================================================
// Import / Export
// ============================================================
class ImportDeclaration {
  constructor(specifiers, source, loc) {
    this.type = 'ImportDeclaration';
    this.specifiers = specifiers; // Array of { imported, local }
    this.source = source;         // string literal
    this.loc = loc;
  }
}
class ImportSpecifier {
  constructor(imported, local, loc) {
    this.type = 'ImportSpecifier';
    this.imported = imported;
    this.local = local || imported;
    this.loc = loc;
  }
}
class ImportDefault {
  constructor(local, source, loc) {
    this.type = 'ImportDefault';
    this.local = local;
    this.source = source;
    this.loc = loc;
  }
}
class ImportWildcard {
  constructor(local, source, loc) {
    this.type = 'ImportWildcard';
    this.local = local;    // namespace binding name
    this.source = source;
    this.loc = loc;
  }
}

// ============================================================
// Statements
// ============================================================
class BlockStatement {
  constructor(body, loc) {
    this.type = 'BlockStatement';
    this.body = body;
    this.loc = loc;
  }
}
class ReturnStatement {
  constructor(value, loc) {
    this.type = 'ReturnStatement';
    this.value = value;
    this.loc = loc;
  }
}
class IfStatement {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfStatement';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement or null
    this.loc = loc;
  }
}
class ForStatement {
  constructor(variable, iterable, body, elseBody, loc) {
    this.type = 'ForStatement';
    this.variable = variable;   // Identifier or destructure pattern
    this.iterable = iterable;   // Expression
    this.body = body;           // BlockStatement
    this.elseBody = elseBody;   // BlockStatement or null (for-else)
    this.loc = loc;
  }
}
class WhileStatement {
  constructor(condition, body, loc) {
    this.type = 'WhileStatement';
    this.condition = condition;
    this.body = body;
    this.loc = loc;
  }
}
class IfExpression {
  constructor(condition, consequent, alternates, elseBody, loc) {
    this.type = 'IfExpression';
    this.condition = condition;
    this.consequent = consequent;     // BlockStatement
    this.alternates = alternates;     // Array of { condition, body } for elif
    this.elseBody = elseBody;         // BlockStatement (required)
    this.loc = loc;
  }
}
class TryCatchStatement {
  constructor(tryBody, catchParam, catchBody, loc, finallyBody = null) {
    this.type = 'TryCatchStatement';
    this.tryBody = tryBody;         // Array of statements
    this.catchParam = catchParam;   // string (error variable name) or null
    this.catchBody = catchBody;     // Array of statements (or null if try/finally only)
    this.finallyBody = finallyBody; // Array of statements or null
    this.loc = loc;
  }
}
class BreakStatement {
  constructor(loc) {
    this.type = 'BreakStatement';
    this.loc = loc;
  }
}
class ContinueStatement {
  constructor(loc) {
    this.type = 'ContinueStatement';
    this.loc = loc;
  }
}
class GuardStatement {
  constructor(condition, elseBody, loc) {
    this.type = 'GuardStatement';
    this.condition = condition;
    this.elseBody = elseBody; // BlockStatement
    this.loc = loc;
  }
}
class ExpressionStatement {
  constructor(expression, loc) {
    this.type = 'ExpressionStatement';
    this.expression = expression;
    this.loc = loc;
  }
}

// ============================================================
// Expressions
// ============================================================
class Identifier {
  constructor(name, loc) {
    this.type = 'Identifier';
    this.name = name;
    this.loc = loc;
  }
}
class NumberLiteral {
  constructor(value, loc) {
    this.type = 'NumberLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class StringLiteral {
  constructor(value, loc) {
    this.type = 'StringLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class TemplateLiteral {
  constructor(parts, loc) {
    this.type = 'TemplateLiteral';
    this.parts = parts; // Array of { type: 'text'|'expr', value }
    this.loc = loc;
  }
}
class BooleanLiteral {
  constructor(value, loc) {
    this.type = 'BooleanLiteral';
    this.value = value;
    this.loc = loc;
  }
}
class NilLiteral {
  constructor(loc) {
    this.type = 'NilLiteral';
    this.loc = loc;
  }
}
class RegexLiteral {
  constructor(pattern, flags, loc) {
    this.type = 'RegexLiteral';
    this.pattern = pattern;
    this.flags = flags;
    this.loc = loc;
  }
}
class ArrayLiteral {
  constructor(elements, loc) {
    this.type = 'ArrayLiteral';
    this.elements = elements;
    this.loc = loc;
  }
}
class ObjectLiteral {
  constructor(properties, loc) {
    this.type = 'ObjectLiteral';
    this.properties = properties; // Array of { key, value, shorthand }
    this.loc = loc;
  }
}
class BinaryExpression {
  constructor(operator, left, right, loc) {
    this.type = 'BinaryExpression';
    this.operator = operator;
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class UnaryExpression {
  constructor(operator, operand, prefix, loc) {
    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
    this.prefix = prefix;
    this.loc = loc;
  }
}
class ChainedComparison {
  constructor(operands, operators, loc) {
    this.type = 'ChainedComparison';
    this.operands = operands;   // [a, b, c] for a < b < c
    this.operators = operators; // ['<', '<']
    this.loc = loc;
  }
}
class LogicalExpression {
  constructor(operator, left, right, loc) {
    this.type = 'LogicalExpression';
    this.operator = operator; // 'and', 'or', '&&', '||'
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class CallExpression {
  constructor(callee, args, loc) {
    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = args;
    this.loc = loc;
  }
}
class NamedArgument {
  constructor(name, value, loc) {
    this.type = 'NamedArgument';
    this.name = name;
    this.value = value;
    this.loc = loc;
  }
}
class MemberExpression {
  constructor(object, property, computed, loc) {
    this.type = 'MemberExpression';
    this.object = object;
    this.property = property;
    this.computed = computed; // true for obj[expr], false for obj.prop
    this.loc = loc;
  }
}
class OptionalChain {
  constructor(object, property, computed, loc) {
    this.type = 'OptionalChain';
    this.object = object;
    this.property = property;
    this.computed = computed;
    this.loc = loc;
  }
}
class PipeExpression {
  constructor(left, right, loc) {
    this.type = 'PipeExpression';
    this.left = left;
    this.right = right;
    this.loc = loc;
  }
}
class LambdaExpression {
  constructor(params, body, loc, isAsync = false) {
    this.type = 'LambdaExpression';
    this.params = params;
    this.body = body;
    this.isAsync = isAsync;
    this.loc = loc;
  }
}
class MatchExpression {
  constructor(subject, arms, loc) {
    this.type = 'MatchExpression';
    this.subject = subject;
    this.arms = arms; // Array of MatchArm
    this.loc = loc;
  }
}
class MatchArm {
  constructor(pattern, guard, body, loc) {
    this.type = 'MatchArm';
    this.pattern = pattern;
    this.guard = guard;   // optional guard expression (if condition)
    this.body = body;
    this.loc = loc;
  }
}
class RangeExpression {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangeExpression';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive; // true for ..=, false for ..
    this.loc = loc;
  }
}
class SliceExpression {
  constructor(object, start, end, step, loc) {
    this.type = 'SliceExpression';
    this.object = object;
    this.start = start;
    this.end = end;
    this.step = step;
    this.loc = loc;
  }
}
class SpreadExpression {
  constructor(argument, loc) {
    this.type = 'SpreadExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class PropagateExpression {
  constructor(expression, loc) {
    this.type = 'PropagateExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class ListComprehension {
  constructor(expression, variable, iterable, condition, loc) {
    this.type = 'ListComprehension';
    this.expression = expression;
    this.variable = variable;
    this.iterable = iterable;
    this.condition = condition; // optional filter
    this.loc = loc;
  }
}
class DictComprehension {
  constructor(key, value, variables, iterable, condition, loc) {
    this.type = 'DictComprehension';
    this.key = key;
    this.value = value;
    this.variables = variables;
    this.iterable = iterable;
    this.condition = condition;
    this.loc = loc;
  }
}
class MembershipExpression {
  constructor(value, collection, negated, loc) {
    this.type = 'MembershipExpression';
    this.value = value;
    this.collection = collection;
    this.negated = negated; // true for "not in"
    this.loc = loc;
  }
}
class CompoundAssignment {
  constructor(target, operator, value, loc) {
    this.type = 'CompoundAssignment';
    this.target = target;
    this.operator = operator; // +=, -=, *=, /=
    this.value = value;
    this.loc = loc;
  }
}
class AwaitExpression {
  constructor(argument, loc) {
    this.type = 'AwaitExpression';
    this.argument = argument;
    this.loc = loc;
  }
}
class InterfaceDeclaration {
  constructor(name, methods, loc) {
    this.type = 'InterfaceDeclaration';
    this.name = name;
    this.methods = methods; // Array of { name, params, returnType }
    this.loc = loc;
  }
}
class StringConcatPattern {
  constructor(prefix, rest, loc) {
    this.type = 'StringConcatPattern';
    this.prefix = prefix; // StringLiteral value
    this.rest = rest;     // BindingPattern or WildcardPattern
    this.loc = loc;
  }
}

// ============================================================
// Patterns (for destructuring and match)
// ============================================================
class ObjectPattern {
  constructor(properties, loc) {
    this.type = 'ObjectPattern';
    this.properties = properties; // Array of { key, value (alias), defaultValue }
    this.loc = loc;
  }
}
class ArrayPattern {
  constructor(elements, loc) {
    this.type = 'ArrayPattern';
    this.elements = elements;
    this.loc = loc;
  }
}
class WildcardPattern {
  constructor(loc) {
    this.type = 'WildcardPattern';
    this.loc = loc;
  }
}
class LiteralPattern {
  constructor(value, loc) {
    this.type = 'LiteralPattern';
    this.value = value;
    this.loc = loc;
  }
}
class VariantPattern {
  constructor(name, fields, loc) {
    this.type = 'VariantPattern';
    this.name = name;
    this.fields = fields;
    this.loc = loc;
  }
}
class BindingPattern {
  constructor(name, loc) {
    this.type = 'BindingPattern';
    this.name = name;
    this.loc = loc;
  }
}
class RangePattern {
  constructor(start, end, inclusive, loc) {
    this.type = 'RangePattern';
    this.start = start;
    this.end = end;
    this.inclusive = inclusive;
    this.loc = loc;
  }
}

// ============================================================
// Client-specific nodes
// ============================================================
class StateDeclaration {
  constructor(name, typeAnnotation, initialValue, loc) {
    this.type = 'StateDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.initialValue = initialValue;
    this.loc = loc;
  }
}
class ComputedDeclaration {
  constructor(name, expression, loc) {
    this.type = 'ComputedDeclaration';
    this.name = name;
    this.expression = expression;
    this.loc = loc;
  }
}
class EffectDeclaration {
  constructor(body, loc) {
    this.type = 'EffectDeclaration';
    this.body = body;
    this.loc = loc;
  }
}
class ComponentDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'ComponentDeclaration';
    this.name = name;
    this.params = params;
    this.body = body; // Array of JSX elements and statements
    this.loc = loc;
  }
}
class ComponentStyleBlock {
  constructor(css, loc) {
    this.type = 'ComponentStyleBlock';
    this.css = css; // raw CSS string
    this.loc = loc;
  }
}
class StoreDeclaration {
  constructor(name, body, loc) {
    this.type = 'StoreDeclaration';
    this.name = name;   // e.g. "TodoStore"
    this.body = body;   // Array of StateDeclaration, ComputedDeclaration, FunctionDeclaration
    this.loc = loc;
  }
}

// ============================================================
// JSX-like nodes
// ============================================================
class JSXElement {
  constructor(tag, attributes, children, selfClosing, loc) {
    this.type = 'JSXElement';
    this.tag = tag;
    this.attributes = attributes; // Array of JSXAttribute
    this.children = children;     // Array of JSXElement, JSXText, JSXExpression
    this.selfClosing = selfClosing;
    this.loc = loc;
  }
}
class JSXAttribute {
  constructor(name, value, loc) {
    this.type = 'JSXAttribute';
    this.name = name;   // string (e.g., "class", "on:click")
    this.value = value;  // Expression or string
    this.loc = loc;
  }
}
class JSXSpreadAttribute {
  constructor(expression, loc) {
    this.type = 'JSXSpreadAttribute';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXText {
  constructor(value, loc) {
    this.type = 'JSXText';
    this.value = value;
    this.loc = loc;
  }
}
class JSXExpression {
  constructor(expression, loc) {
    this.type = 'JSXExpression';
    this.expression = expression;
    this.loc = loc;
  }
}
class JSXFor {
  constructor(variable, iterable, body, loc, keyExpr = null) {
    this.type = 'JSXFor';
    this.variable = variable;
    this.iterable = iterable;
    this.body = body;
    this.keyExpr = keyExpr; // optional key expression for keyed reconciliation
    this.loc = loc;
  }
}
class JSXIf {
  constructor(condition, consequent, alternate, loc, alternates = []) {
    this.type = 'JSXIf';
    this.condition = condition;
    this.consequent = consequent;
    this.alternates = alternates; // Array of { condition, body } for elif chains
    this.alternate = alternate;   // else body (or null)
    this.loc = loc;
  }
}

// ============================================================
// Server-specific nodes
// ============================================================
class RouteDeclaration {
  constructor(method, path, handler, loc, decorators = []) {
    this.type = 'RouteDeclaration';
    this.method = method;   // GET, POST, PUT, DELETE, PATCH
    this.path = path;       // string literal
    this.handler = handler; // Identifier or FunctionDeclaration
    this.decorators = decorators; // Array of { name, args } for "with auth, role("admin")"
    this.loc = loc;
  }
}
class MiddlewareDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'MiddlewareDeclaration';
    this.name = name;
    this.params = params;   // Array of Parameter nodes (req, next)
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class HealthCheckDeclaration {
  constructor(path, loc) {
    this.type = 'HealthCheckDeclaration';
    this.path = path;       // string literal, e.g. "/health"
    this.loc = loc;
  }
}
class CorsDeclaration {
  constructor(config, loc) {
    this.type = 'CorsDeclaration';
    this.config = config;   // { origins: ArrayLiteral, methods: ArrayLiteral, headers: ArrayLiteral }
    this.loc = loc;
  }
}
class ErrorHandlerDeclaration {
  constructor(params, body, loc) {
    this.type = 'ErrorHandlerDeclaration';
    this.params = params;   // Array of Parameter nodes (err, req)
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class WebSocketDeclaration {
  constructor(handlers, loc, config = null) {
    this.type = 'WebSocketDeclaration';
    this.handlers = handlers; // { on_open, on_message, on_close, on_error } — each is { params, body } or null
    this.config = config;     // { auth: expression } or null
    this.loc = loc;
  }
}
class StaticDeclaration {
  constructor(path, dir, loc, fallback = null) {
    this.type = 'StaticDeclaration';
    this.path = path;       // URL prefix, e.g. "/public"
    this.dir = dir;         // directory path, e.g. "./public"
    this.fallback = fallback; // fallback file, e.g. "index.html"
    this.loc = loc;
  }
}
class DiscoverDeclaration {
  constructor(peerName, urlExpression, loc, config = null) {
    this.type = 'DiscoverDeclaration';
    this.peerName = peerName;         // string — the peer server name
    this.urlExpression = urlExpression; // Expression — the URL
    this.config = config;             // { threshold, timeout } or null
    this.loc = loc;
  }
}
class AuthDeclaration {
  constructor(config, loc) {
    this.type = 'AuthDeclaration';
    this.config = config; // { type, secret, ... } object config
    this.loc = loc;
  }
}
class MaxBodyDeclaration {
  constructor(limit, loc) {
    this.type = 'MaxBodyDeclaration';
    this.limit = limit; // Expression — max body size in bytes
    this.loc = loc;
  }
}
class RouteGroupDeclaration {
  constructor(prefix, body, loc) {
    this.type = 'RouteGroupDeclaration';
    this.prefix = prefix; // string — URL prefix, e.g. "/api/v1"
    this.body = body;     // Array of server statements
    this.loc = loc;
  }
}
class RateLimitDeclaration {
  constructor(config, loc) {
    this.type = 'RateLimitDeclaration';
    this.config = config;
    this.loc = loc;
  }
}
class LifecycleHookDeclaration {
  constructor(hook, params, body, loc) {
    this.type = 'LifecycleHookDeclaration';
    this.hook = hook;       // "start" or "stop"
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class SubscribeDeclaration {
  constructor(event, params, body, loc) {
    this.type = 'SubscribeDeclaration';
    this.event = event;     // string — event name
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class EnvDeclaration {
  constructor(name, typeAnnotation, defaultValue, loc) {
    this.type = 'EnvDeclaration';
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.defaultValue = defaultValue;
    this.loc = loc;
  }
}
class ScheduleDeclaration {
  constructor(pattern, name, params, body, loc) {
    this.type = 'ScheduleDeclaration';
    this.pattern = pattern;   // string — interval or cron pattern
    this.name = name;         // optional function name
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class UploadDeclaration {
  constructor(config, loc) {
    this.type = 'UploadDeclaration';
    this.config = config;   // { max_size, allowed_types, ... }
    this.loc = loc;
  }
}
class SessionDeclaration {
  constructor(config, loc) {
    this.type = 'SessionDeclaration';
    this.config = config;   // { secret, max_age, cookie_name, ... }
    this.loc = loc;
  }
}
class DbDeclaration {
  constructor(config, loc) {
    this.type = 'DbDeclaration';
    this.config = config;   // { path, wal, ... }
    this.loc = loc;
  }
}
class TlsDeclaration {
  constructor(config, loc) {
    this.type = 'TlsDeclaration';
    this.config = config;   // { cert, key, ... }
    this.loc = loc;
  }
}
class CompressionDeclaration {
  constructor(config, loc) {
    this.type = 'CompressionDeclaration';
    this.config = config;   // { enabled, min_size, ... }
    this.loc = loc;
  }
}
class BackgroundJobDeclaration {
  constructor(name, params, body, loc) {
    this.type = 'BackgroundJobDeclaration';
    this.name = name;
    this.params = params;
    this.body = body;
    this.loc = loc;
  }
}
class CacheDeclaration {
  constructor(config, loc) {
    this.type = 'CacheDeclaration';
    this.config = config;   // { max_age, stale_while_revalidate, ... }
    this.loc = loc;
  }
}
class SseDeclaration {
  constructor(path, params, body, loc) {
    this.type = 'SseDeclaration';
    this.path = path;       // string — SSE endpoint path
    this.params = params;   // Array of Parameter nodes
    this.body = body;       // BlockStatement
    this.loc = loc;
  }
}
class ModelDeclaration {
  constructor(name, config, loc) {
    this.type = 'ModelDeclaration';
    this.name = name;       // string — type name to generate CRUD for
    this.config = config;   // { table, timestamps, ... } or null
    this.loc = loc;
  }
}
class TestBlock {
  constructor(name, body, loc) {
    this.type = 'TestBlock';
    this.name = name;       // optional string name
    this.body = body;       // Array of statements
    this.loc = loc;
  }
}

// ============================================================
// Extern declarations
// ============================================================
class ExternDeclaration {
  constructor(name, params, returnType, loc, isAsync = false) {
    this.type = 'ExternDeclaration';
    this.name = name;
    this.params = params;     // Array of Parameter nodes (types only, names optional)
    this.returnType = returnType; // TypeAnnotation or null
    this.isAsync = isAsync;
    this.loc = loc;
  }
}

// ============================================================
// Type annotations
// ============================================================
class TypeAnnotation {
  constructor(name, typeParams, loc) {
    this.type = 'TypeAnnotation';
    this.name = name;         // "Int", "String", "Bool", "Float", etc.
    this.typeParams = typeParams; // Array of TypeAnnotation (for generics)
    this.loc = loc;
  }
}
class ArrayTypeAnnotation {
  constructor(elementType, loc) {
    this.type = 'ArrayTypeAnnotation';
    this.elementType = elementType;
    this.loc = loc;
  }
}
class FunctionTypeAnnotation {
  constructor(paramTypes, returnType, loc) {
    this.type = 'FunctionTypeAnnotation';
    this.paramTypes = paramTypes;
    this.returnType = returnType;
    this.loc = loc;
  }
}

// ============================================================
// Impl blocks
// ============================================================
class ImplDeclaration {
  constructor(typeName, methods, loc, traitName = null) {
    this.type = 'ImplDeclaration';
    this.typeName = typeName;
    this.traitName = traitName; // null for plain impl, string for `impl Trait for Type`
    this.methods = methods;     // Array of FunctionDeclaration (first param is self)
    this.loc = loc;
  }
}

// ============================================================
// Trait declarations
// ============================================================
class TraitDeclaration {
  constructor(name, methods, loc) {
    this.type = 'TraitDeclaration';
    this.name = name;
    this.methods = methods; // Array of { name, params, returnType, body (optional for defaults) }
    this.loc = loc;
  }
}

// ============================================================
// Type aliases
// ============================================================
class TypeAlias {
  constructor(name, typeExpr, loc) {
    this.type = 'TypeAlias';
    this.name = name;
    this.typeExpr = typeExpr; // TypeAnnotation
    this.loc = loc;
  }
}

// ============================================================
// Defer statement
// ============================================================
class DeferStatement {
  constructor(body, loc) {
    this.type = 'DeferStatement';
    this.body = body; // Expression or BlockStatement
    this.loc = loc;
  }
}

// ============================================================
// Yield expression (generators)
// ============================================================
class YieldExpression {
  constructor(argument, delegate, loc) {
    this.type = 'YieldExpression';
    this.argument = argument; // expression to yield
    this.delegate = delegate; // true for `yield from`
    this.loc = loc;
  }
}

// ============================================================
// Tuple expression/pattern/type
// ============================================================
class TupleExpression {
  constructor(elements, loc) {
    this.type = 'TupleExpression';
    this.elements = elements; // Array of expressions
    this.loc = loc;
  }
}
class TuplePattern {
  constructor(elements, loc) {
    this.type = 'TuplePattern';
    this.elements = elements; // Array of patterns
    this.loc = loc;
  }
}
class TupleTypeAnnotation {
  constructor(elementTypes, loc) {
    this.type = 'TupleTypeAnnotation';
    this.elementTypes = elementTypes;
    this.loc = loc;
  }
}

// AST namespace shim for parser.js compatibility

const AST = { Program, ServerBlock, ClientBlock, SharedBlock, Assignment, VarDeclaration, LetDestructure, FunctionDeclaration, Parameter, TypeDeclaration, TypeVariant, TypeField, ImportDeclaration, ImportSpecifier, ImportDefault, ImportWildcard, BlockStatement, ReturnStatement, IfStatement, ForStatement, WhileStatement, IfExpression, TryCatchStatement, BreakStatement, ContinueStatement, GuardStatement, ExpressionStatement, Identifier, NumberLiteral, StringLiteral, TemplateLiteral, BooleanLiteral, NilLiteral, RegexLiteral, ArrayLiteral, ObjectLiteral, BinaryExpression, UnaryExpression, ChainedComparison, LogicalExpression, CallExpression, NamedArgument, MemberExpression, OptionalChain, PipeExpression, LambdaExpression, MatchExpression, MatchArm, RangeExpression, SliceExpression, SpreadExpression, PropagateExpression, ListComprehension, DictComprehension, MembershipExpression, CompoundAssignment, AwaitExpression, InterfaceDeclaration, StringConcatPattern, ObjectPattern, ArrayPattern, WildcardPattern, LiteralPattern, VariantPattern, BindingPattern, RangePattern, StateDeclaration, ComputedDeclaration, EffectDeclaration, ComponentDeclaration, ComponentStyleBlock, StoreDeclaration, JSXElement, JSXAttribute, JSXSpreadAttribute, JSXText, JSXExpression, JSXFor, JSXIf, RouteDeclaration, MiddlewareDeclaration, HealthCheckDeclaration, CorsDeclaration, ErrorHandlerDeclaration, WebSocketDeclaration, StaticDeclaration, DiscoverDeclaration, AuthDeclaration, MaxBodyDeclaration, RouteGroupDeclaration, RateLimitDeclaration, LifecycleHookDeclaration, SubscribeDeclaration, EnvDeclaration, ScheduleDeclaration, UploadDeclaration, SessionDeclaration, DbDeclaration, TlsDeclaration, CompressionDeclaration, BackgroundJobDeclaration, CacheDeclaration, SseDeclaration, ModelDeclaration, TestBlock, ExternDeclaration, TypeAnnotation, ArrayTypeAnnotation, FunctionTypeAnnotation, ImplDeclaration, TraitDeclaration, TypeAlias, DeferStatement, YieldExpression, TupleExpression, TuplePattern, TupleTypeAnnotation };

// ─── src/parser/parser.js ──────────────────────────────

class Parser {
  static MAX_EXPRESSION_DEPTH = 200;

  constructor(tokens, filename = '<stdin>') {
    this.tokens = tokens.filter(t => t.type !== TokenType.NEWLINE && t.type !== TokenType.DOCSTRING);
    this.rawTokens = tokens;
    this.filename = filename;
    this.pos = 0;
    this.errors = [];
    this._expressionDepth = 0;
    this.docstrings = this.extractDocstrings(tokens);
  }

  extractDocstrings(tokens) {
    const docs = [];
    for (const t of tokens) {
      if (t.type === TokenType.DOCSTRING) {
        docs.push(t);
      }
    }
    return docs;
  }

  // ─── Helpers ───────────────────────────────────────────────

  error(message) {
    const tok = this.current();
    const err = new Error(
      `${this.filename}:${tok.line}:${tok.column} — Parse error: ${message}\n  Got: ${tok.type} (${JSON.stringify(tok.value)})`
    );
    err.loc = { line: tok.line, column: tok.column, file: this.filename };
    throw err;
  }

  current() {
    return this.tokens[this.pos] || this.tokens[this.tokens.length - 1];
  }

  peek(offset = 0) {
    const idx = this.pos + offset;
    return idx < this.tokens.length ? this.tokens[idx] : this.tokens[this.tokens.length - 1];
  }

  advance() {
    const tok = this.current();
    this.pos++;
    return tok;
  }

  check(type) {
    return this.current().type === type;
  }

  checkValue(type, value) {
    const tok = this.current();
    return tok.type === type && tok.value === value;
  }

  match(...types) {
    for (const type of types) {
      if (this.check(type)) {
        return this.advance();
      }
    }
    return null;
  }

  expect(type, message) {
    if (this.check(type)) {
      return this.advance();
    }
    this.error(message || `Expected ${type}, got ${this.current().type}`);
  }

  loc() {
    const tok = this.current();
    return { line: tok.line, column: tok.column, file: this.filename };
  }

  isAtEnd() {
    return this.check(TokenType.EOF);
  }

  _synchronize() {
    this.advance(); // skip the problematic token
    while (!this.isAtEnd()) {
      const tok = this.current();
      // Statement-starting keywords — safe to resume parsing here
      if (tok.type === TokenType.FN || tok.type === TokenType.TYPE ||
          tok.type === TokenType.IF || tok.type === TokenType.FOR ||
          tok.type === TokenType.WHILE || tok.type === TokenType.RETURN ||
          tok.type === TokenType.IMPORT || tok.type === TokenType.MATCH ||
          tok.type === TokenType.TRY || tok.type === TokenType.SERVER ||
          tok.type === TokenType.CLIENT || tok.type === TokenType.SHARED ||
          tok.type === TokenType.GUARD || tok.type === TokenType.INTERFACE ||
          tok.type === TokenType.IMPL || tok.type === TokenType.TRAIT ||
          tok.type === TokenType.PUB || tok.type === TokenType.DEFER ||
          tok.type === TokenType.EXTERN) {
        return;
      }
      if (tok.type === TokenType.RBRACE) {
        this.advance();
        return;
      }
      this.advance();
    }
  }

  _synchronizeBlock() {
    // Don't advance if already at } — that's the block closer we need
    if (!this.isAtEnd() && this.current().type !== TokenType.RBRACE) {
      this.advance(); // skip the problematic token
    }
    while (!this.isAtEnd()) {
      const tok = this.current();
      // Stop at } WITHOUT consuming — let the block close properly
      if (tok.type === TokenType.RBRACE) return;
      // Statement-starting keywords — safe to resume parsing here
      if (tok.type === TokenType.FN || tok.type === TokenType.TYPE ||
          tok.type === TokenType.IF || tok.type === TokenType.FOR ||
          tok.type === TokenType.WHILE || tok.type === TokenType.RETURN ||
          tok.type === TokenType.IMPORT || tok.type === TokenType.MATCH ||
          tok.type === TokenType.TRY || tok.type === TokenType.SERVER ||
          tok.type === TokenType.CLIENT || tok.type === TokenType.SHARED ||
          tok.type === TokenType.GUARD || tok.type === TokenType.INTERFACE ||
          tok.type === TokenType.IMPL || tok.type === TokenType.TRAIT ||
          tok.type === TokenType.PUB || tok.type === TokenType.DEFER ||
          tok.type === TokenType.EXTERN || tok.type === TokenType.VAR ||
          tok.type === TokenType.STATE || tok.type === TokenType.ROUTE ||
          tok.type === TokenType.IDENTIFIER) {
        return;
      }
      this.advance();
    }
  }

  // Detect if current < starts a JSX tag (vs comparison operator)
  _looksLikeJSX() {
    if (!this.check(TokenType.LESS)) return false;
    const next = this.peek(1);
    if (next.type !== TokenType.IDENTIFIER) return false;
    // Uppercase tag is always a component reference, never a comparison variable
    if (/^[A-Z]/.test(next.value)) return true;
    const afterIdent = this.peek(2);
    // JSX patterns: <div>, <div/>, <div attr=...>, <div on:click=...>
    // After the tag name, we can see >, /, an attribute name (identifier or keyword), or :
    return afterIdent.type === TokenType.GREATER ||
           afterIdent.type === TokenType.SLASH ||
           afterIdent.type === TokenType.IDENTIFIER ||
           afterIdent.type === TokenType.COLON ||
           afterIdent.type === TokenType.STATE ||
           afterIdent.type === TokenType.TYPE ||
           afterIdent.type === TokenType.FOR ||
           afterIdent.type === TokenType.IN ||
           afterIdent.type === TokenType.IF ||
           afterIdent.type === TokenType.ELSE ||
           afterIdent.type === TokenType.MATCH ||
           afterIdent.type === TokenType.RETURN ||
           afterIdent.type === TokenType.NUMBER;
  }

  // ─── Program ───────────────────────────────────────────────

  parse() {
    const body = [];
    while (!this.isAtEnd()) {
      try {
        const stmt = this.parseTopLevel();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronize();
      }
    }
    if (this.errors.length > 0) {
      const combined = new Error(this.errors.map(e => e.message).join('\n'));
      combined.errors = this.errors;
      combined.partialAST = new AST.Program(body);
      throw combined;
    }
    return new AST.Program(body);
  }

  parseTopLevel() {
    if (this.check(TokenType.SERVER)) return this.parseServerBlock();
    if (this.check(TokenType.CLIENT)) return this.parseClientBlock();
    if (this.check(TokenType.SHARED)) return this.parseSharedBlock();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    // test block: test "name" { ... } or test { ... }
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'test') {
      const next = this.peek(1);
      if (next.type === TokenType.LBRACE || next.type === TokenType.STRING) {
        return this.parseTestBlock();
      }
    }
    return this.parseStatement();
  }

  parseTestBlock() {
    const l = this.loc();
    this.advance(); // consume 'test'
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after test block name");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close test block");
    return new AST.TestBlock(name, body, l);
  }

  // ─── Full-stack blocks ────────────────────────────────────

  parseServerBlock() {
    const l = this.loc();
    this.expect(TokenType.SERVER);
    // Optional block name: server "api" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'server'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseServerStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close server block");
    return new AST.ServerBlock(body, l, name);
  }

  parseClientBlock() {
    const l = this.loc();
    this.expect(TokenType.CLIENT);
    // Optional block name: client "admin" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'client'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseClientStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close client block");
    return new AST.ClientBlock(body, l, name);
  }

  parseSharedBlock() {
    const l = this.loc();
    this.expect(TokenType.SHARED);
    // Optional block name: shared "models" { }
    let name = null;
    if (this.check(TokenType.STRING)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LBRACE, "Expected '{' after 'shared'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close shared block");
    return new AST.SharedBlock(body, l, name);
  }

  // ─── Server-specific statements ───────────────────────────

  parseServerStatement() {
    if (this.check(TokenType.ROUTE)) return this.parseRoute();

    // Contextual keywords in server blocks
    if (this.check(TokenType.IDENTIFIER)) {
      const val = this.current().value;
      if (val === 'middleware' && this.peek(1).type === TokenType.FN) {
        return this.parseMiddleware();
      }
      if (val === 'health') {
        return this.parseHealthCheck();
      }
      if (val === 'cors' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCorsConfig();
      }
      if (val === 'on_error' && this.peek(1).type === TokenType.FN) {
        return this.parseErrorHandler();
      }
      if (val === 'ws' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseWebSocket();
      }
      if (val === 'static' && this.peek(1).type === TokenType.STRING) {
        return this.parseStaticDeclaration();
      }
      if (val === 'discover' && this.peek(1).type === TokenType.STRING) {
        return this.parseDiscover();
      }
      if (val === 'auth' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseAuthConfig();
      }
      if (val === 'max_body') {
        return this.parseMaxBody();
      }
      if (val === 'routes' && this.peek(1).type === TokenType.STRING) {
        return this.parseRouteGroup();
      }
      if (val === 'rate_limit' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseRateLimitConfig();
      }
      if (val === 'on_start' && this.peek(1).type === TokenType.FN) {
        return this.parseLifecycleHook('start');
      }
      if (val === 'on_stop' && this.peek(1).type === TokenType.FN) {
        return this.parseLifecycleHook('stop');
      }
      if (val === 'subscribe' && this.peek(1).type === TokenType.STRING) {
        return this.parseSubscribe();
      }
      if (val === 'env' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseEnvDeclaration();
      }
      if (val === 'schedule' && this.peek(1).type === TokenType.STRING) {
        return this.parseSchedule();
      }
      if (val === 'upload' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseUploadConfig();
      }
      if (val === 'session' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseSessionConfig();
      }
      if (val === 'db' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseDbConfig();
      }
      if (val === 'tls' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseTlsConfig();
      }
      if (val === 'compression' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCompressionConfig();
      }
      if (val === 'background' && this.peek(1).type === TokenType.FN) {
        return this.parseBackgroundJob();
      }
      if (val === 'cache' && this.peek(1).type === TokenType.LBRACE) {
        return this.parseCacheConfig();
      }
      if (val === 'sse' && this.peek(1).type === TokenType.STRING) {
        return this.parseSseDeclaration();
      }
      if (val === 'model' && this.peek(1).type === TokenType.IDENTIFIER) {
        return this.parseModelDeclaration();
      }
    }

    return this.parseStatement();
  }

  parseMiddleware() {
    const l = this.loc();
    this.advance(); // consume 'middleware'
    this.expect(TokenType.FN);
    const name = this.expect(TokenType.IDENTIFIER, "Expected middleware name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after middleware name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after middleware parameters");
    const body = this.parseBlock();
    return new AST.MiddlewareDeclaration(name, params, body, l);
  }

  parseHealthCheck() {
    const l = this.loc();
    this.advance(); // consume 'health'
    const path = this.expect(TokenType.STRING, "Expected health check path string");
    return new AST.HealthCheckDeclaration(path.value, l);
  }

  parseCorsConfig() {
    const l = this.loc();
    this.advance(); // consume 'cors'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cors'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected cors config key").value;
      this.expect(TokenType.COLON, "Expected ':' after cors key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cors config");
    return new AST.CorsDeclaration(config, l);
  }

  parseErrorHandler() {
    const l = this.loc();
    this.advance(); // consume 'on_error'
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after error handler parameters");
    const body = this.parseBlock();
    return new AST.ErrorHandlerDeclaration(params, body, l);
  }

  parseWebSocket() {
    const l = this.loc();
    this.advance(); // consume 'ws'
    this.expect(TokenType.LBRACE, "Expected '{' after 'ws'");

    const handlers = {};
    const config = {};
    const validEvents = ['on_open', 'on_message', 'on_close', 'on_error'];
    const validConfigKeys = ['auth'];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const name = this.expect(TokenType.IDENTIFIER, "Expected WebSocket event handler name or config key").value;
      if (validConfigKeys.includes(name)) {
        // Config key: auth: <expr>
        this.expect(TokenType.COLON, `Expected ':' after '${name}'`);
        config[name] = this.parseExpression();
        this.match(TokenType.COMMA);
      } else if (validEvents.includes(name)) {
        this.expect(TokenType.FN, "Expected 'fn' after event name");
        this.expect(TokenType.LPAREN);
        const params = this.parseParameterList();
        this.expect(TokenType.RPAREN);
        const body = this.parseBlock();
        handlers[name] = { params, body };
      } else {
        this.error(`Invalid WebSocket key '${name}'. Expected one of: ${[...validConfigKeys, ...validEvents].join(', ')}`);
      }
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close ws block");
    const wsConfig = Object.keys(config).length > 0 ? config : null;
    return new AST.WebSocketDeclaration(handlers, l, wsConfig);
  }

  parseStaticDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'static'
    const urlPath = this.expect(TokenType.STRING, "Expected URL path for static files").value;
    this.expect(TokenType.ARROW, "Expected '=>' after static path");
    const dir = this.expect(TokenType.STRING, "Expected directory path for static files").value;
    let fallback = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'fallback') {
      this.advance(); // consume 'fallback'
      fallback = this.expect(TokenType.STRING, "Expected fallback file path").value;
    }
    return new AST.StaticDeclaration(urlPath, dir, l, fallback);
  }

  parseDiscover() {
    const l = this.loc();
    this.advance(); // consume 'discover'
    const peerName = this.expect(TokenType.STRING, "Expected peer name string after 'discover'").value;
    // Expect 'at' as contextual keyword
    const atTok = this.expect(TokenType.IDENTIFIER, "Expected 'at' after peer name");
    if (atTok.value !== 'at') {
      this.error("Expected 'at' after peer name in discover declaration");
    }
    const urlExpression = this.parseExpression();
    let config = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'with') {
      this.advance(); // consume 'with'
      this.expect(TokenType.LBRACE, "Expected '{' after 'with'");
      config = {};
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const key = this.expect(TokenType.IDENTIFIER, "Expected config key").value;
        this.expect(TokenType.COLON, "Expected ':' after config key");
        const value = this.parseExpression();
        config[key] = value;
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close discover config");
    }
    return new AST.DiscoverDeclaration(peerName, urlExpression, l, config);
  }

  parseAuthConfig() {
    const l = this.loc();
    this.advance(); // consume 'auth'
    this.expect(TokenType.LBRACE, "Expected '{' after 'auth'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      // Accept keywords (like 'type') and identifiers as config keys
      let key;
      if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.TYPE)) {
        key = this.advance().value;
      } else {
        this.error("Expected auth config key");
      }
      this.expect(TokenType.COLON, "Expected ':' after auth key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close auth config");
    return new AST.AuthDeclaration(config, l);
  }

  parseMaxBody() {
    const l = this.loc();
    this.advance(); // consume 'max_body'
    const limit = this.parseExpression();
    return new AST.MaxBodyDeclaration(limit, l);
  }

  parseRouteGroup() {
    const l = this.loc();
    this.advance(); // consume 'routes'
    const prefix = this.expect(TokenType.STRING, "Expected route group prefix string").value;
    this.expect(TokenType.LBRACE, "Expected '{' after route group prefix");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseServerStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close route group");
    return new AST.RouteGroupDeclaration(prefix, body, l);
  }

  parseRateLimitConfig() {
    const l = this.loc();
    this.advance(); // consume 'rate_limit'
    this.expect(TokenType.LBRACE, "Expected '{' after 'rate_limit'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected rate_limit config key").value;
      this.expect(TokenType.COLON, "Expected ':' after rate_limit key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close rate_limit config");
    return new AST.RateLimitDeclaration(config, l);
  }

  parseLifecycleHook(hookName) {
    const l = this.loc();
    this.advance(); // consume 'on_start' or 'on_stop'
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after lifecycle hook parameters");
    const body = this.parseBlock();
    return new AST.LifecycleHookDeclaration(hookName, params, body, l);
  }

  parseSubscribe() {
    const l = this.loc();
    this.advance(); // consume 'subscribe'
    const event = this.expect(TokenType.STRING, "Expected event name string").value;
    this.expect(TokenType.FN, "Expected 'fn' after event name");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after subscribe parameters");
    const body = this.parseBlock();
    return new AST.SubscribeDeclaration(event, params, body, l);
  }

  parseEnvDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'env'
    const name = this.expect(TokenType.IDENTIFIER, "Expected env variable name").value;
    this.expect(TokenType.COLON, "Expected ':' after env variable name");
    const typeAnnotation = this.parseTypeAnnotation();
    let defaultValue = null;
    if (this.match(TokenType.ASSIGN)) {
      defaultValue = this.parseExpression();
    }
    return new AST.EnvDeclaration(name, typeAnnotation, defaultValue, l);
  }

  parseSchedule() {
    const l = this.loc();
    this.advance(); // consume 'schedule'
    const pattern = this.expect(TokenType.STRING, "Expected schedule pattern string").value;
    this.expect(TokenType.FN, "Expected 'fn' after schedule pattern");
    let name = null;
    if (this.check(TokenType.IDENTIFIER)) {
      name = this.advance().value;
    }
    this.expect(TokenType.LPAREN, "Expected '(' after schedule fn");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after schedule parameters");
    const body = this.parseBlock();
    return new AST.ScheduleDeclaration(pattern, name, params, body, l);
  }

  parseUploadConfig() {
    const l = this.loc();
    this.advance(); // consume 'upload'
    this.expect(TokenType.LBRACE, "Expected '{' after 'upload'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected upload config key").value;
      this.expect(TokenType.COLON, "Expected ':' after upload key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close upload config");
    return new AST.UploadDeclaration(config, l);
  }

  parseSessionConfig() {
    const l = this.loc();
    this.advance(); // consume 'session'
    this.expect(TokenType.LBRACE, "Expected '{' after 'session'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected session config key").value;
      this.expect(TokenType.COLON, "Expected ':' after session key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close session config");
    return new AST.SessionDeclaration(config, l);
  }

  parseDbConfig() {
    const l = this.loc();
    this.advance(); // consume 'db'
    this.expect(TokenType.LBRACE, "Expected '{' after 'db'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected db config key").value;
      this.expect(TokenType.COLON, "Expected ':' after db key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close db config");
    return new AST.DbDeclaration(config, l);
  }

  parseTlsConfig() {
    const l = this.loc();
    this.advance(); // consume 'tls'
    this.expect(TokenType.LBRACE, "Expected '{' after 'tls'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected tls config key").value;
      this.expect(TokenType.COLON, "Expected ':' after tls key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close tls config");
    return new AST.TlsDeclaration(config, l);
  }

  parseCompressionConfig() {
    const l = this.loc();
    this.advance(); // consume 'compression'
    this.expect(TokenType.LBRACE, "Expected '{' after 'compression'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected compression config key").value;
      this.expect(TokenType.COLON, "Expected ':' after compression key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close compression config");
    return new AST.CompressionDeclaration(config, l);
  }

  parseBackgroundJob() {
    const l = this.loc();
    this.advance(); // consume 'background'
    this.expect(TokenType.FN, "Expected 'fn' after 'background'");
    const name = this.expect(TokenType.IDENTIFIER, "Expected background job name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after background job name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after background job parameters");
    const body = this.parseBlock();
    return new AST.BackgroundJobDeclaration(name, params, body, l);
  }

  parseCacheConfig() {
    const l = this.loc();
    this.advance(); // consume 'cache'
    this.expect(TokenType.LBRACE, "Expected '{' after 'cache'");
    const config = {};
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected cache config key").value;
      this.expect(TokenType.COLON, "Expected ':' after cache key");
      const value = this.parseExpression();
      config[key] = value;
      this.match(TokenType.COMMA);
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close cache config");
    return new AST.CacheDeclaration(config, l);
  }

  parseSseDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'sse'
    const path = this.expect(TokenType.STRING, "Expected SSE endpoint path").value;
    this.expect(TokenType.FN, "Expected 'fn' after SSE path");
    this.expect(TokenType.LPAREN, "Expected '(' after 'fn'");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after SSE parameters");
    const body = this.parseBlock();
    return new AST.SseDeclaration(path, params, body, l);
  }

  parseModelDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'model'
    const name = this.expect(TokenType.IDENTIFIER, "Expected model/type name after 'model'").value;
    let config = null;
    if (this.check(TokenType.LBRACE)) {
      this.advance(); // consume '{'
      config = {};
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const key = this.expect(TokenType.IDENTIFIER, "Expected model config key").value;
        this.expect(TokenType.COLON, "Expected ':' after model config key");
        const value = this.parseExpression();
        config[key] = value;
        this.match(TokenType.COMMA);
      }
      this.expect(TokenType.RBRACE, "Expected '}' to close model config");
    }
    return new AST.ModelDeclaration(name, config, l);
  }

  parseRoute() {
    const l = this.loc();
    this.expect(TokenType.ROUTE);

    // HTTP method: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS (as identifiers)
    const methodTok = this.expect(TokenType.IDENTIFIER, "Expected HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)");
    const method = methodTok.value.toUpperCase();
    if (!['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'].includes(method)) {
      this.error(`Invalid HTTP method: ${method}`);
    }

    const path = this.expect(TokenType.STRING, "Expected route path string");

    // Optional decorators: route GET "/path" with auth, role("admin") => handler
    let decorators = [];
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'with') {
      this.advance(); // consume 'with'
      // Parse comma-separated decorator list
      do {
        const decName = this.expect(TokenType.IDENTIFIER, "Expected decorator name").value;
        let decArgs = [];
        if (this.check(TokenType.LPAREN)) {
          this.advance(); // (
          while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
            decArgs.push(this.parseExpression());
            if (!this.match(TokenType.COMMA)) break;
          }
          this.expect(TokenType.RPAREN, "Expected ')' after decorator arguments");
        }
        decorators.push({ name: decName, args: decArgs });
      } while (this.match(TokenType.COMMA));
    }

    this.expect(TokenType.ARROW, "Expected '=>' after route path");
    const handler = this.parseExpression();

    return new AST.RouteDeclaration(method, path.value, handler, l, decorators);
  }

  // ─── Client-specific statements ───────────────────────────

  parseClientStatement() {
    if (this.check(TokenType.STATE)) return this.parseState();
    if (this.check(TokenType.COMPUTED)) return this.parseComputed();
    if (this.check(TokenType.EFFECT)) return this.parseEffect();
    if (this.check(TokenType.COMPONENT)) return this.parseComponent();
    if (this.check(TokenType.STORE)) return this.parseStore();
    return this.parseStatement();
  }

  parseStore() {
    const l = this.loc();
    this.expect(TokenType.STORE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected store name").value;
    this.expect(TokenType.LBRACE, "Expected '{' after store name");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.STATE)) {
        body.push(this.parseState());
      } else if (this.check(TokenType.COMPUTED)) {
        body.push(this.parseComputed());
      } else if (this.check(TokenType.FN) && this.peek(1).type === TokenType.IDENTIFIER) {
        body.push(this.parseFunctionDeclaration());
      } else {
        this.error("Expected 'state', 'computed', or 'fn' inside store block");
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close store block");

    return new AST.StoreDeclaration(name, body, l);
  }

  parseState() {
    const l = this.loc();
    this.expect(TokenType.STATE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected state variable name").value;

    let typeAnnotation = null;
    if (this.match(TokenType.COLON)) {
      typeAnnotation = this.parseTypeAnnotation();
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in state declaration");
    const value = this.parseExpression();

    return new AST.StateDeclaration(name, typeAnnotation, value, l);
  }

  parseComputed() {
    const l = this.loc();
    this.expect(TokenType.COMPUTED);
    const name = this.expect(TokenType.IDENTIFIER, "Expected computed variable name").value;
    this.expect(TokenType.ASSIGN, "Expected '=' in computed declaration");
    const expr = this.parseExpression();

    return new AST.ComputedDeclaration(name, expr, l);
  }

  parseEffect() {
    const l = this.loc();
    this.expect(TokenType.EFFECT);
    const body = this.parseBlock();
    return new AST.EffectDeclaration(body, l);
  }

  parseComponent() {
    const l = this.loc();
    this.expect(TokenType.COMPONENT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected component name").value;

    let params = [];
    if (this.match(TokenType.LPAREN)) {
      params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after component parameters");
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open component body");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.STYLE_BLOCK)) {
        const sl = this.loc();
        const css = this.current().value;
        this.advance();
        body.push(new AST.ComponentStyleBlock(css, sl));
      } else if (this.check(TokenType.LESS) && this._looksLikeJSX()) {
        body.push(this.parseJSXElement());
      } else if (this.check(TokenType.STATE)) {
        body.push(this.parseState());
      } else if (this.check(TokenType.COMPUTED)) {
        body.push(this.parseComputed());
      } else if (this.check(TokenType.EFFECT)) {
        body.push(this.parseEffect());
      } else if (this.check(TokenType.COMPONENT)) {
        body.push(this.parseComponent());
      } else {
        body.push(this.parseStatement());
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close component body");

    return new AST.ComponentDeclaration(name, params, body, l);
  }

  // ─── JSX-like parsing ─────────────────────────────────────

  _collapseJSXWhitespace(text) {
    let result = text.replace(/\s+/g, ' ');
    if (result.trim() === '') return '';
    return result.trim();
  }

  parseJSXElement() {
    const l = this.loc();
    this.expect(TokenType.LESS, "Expected '<'");

    const tag = this.expect(TokenType.IDENTIFIER, "Expected tag name").value;

    // Parse attributes (including spread: {...expr})
    const attributes = [];
    while (!this.check(TokenType.GREATER) && !this.check(TokenType.SLASH) && !this.isAtEnd()) {
      // Check for spread attribute: {...expr}
      if (this.check(TokenType.LBRACE) && this.peek(1).type === TokenType.SPREAD) {
        const sl = this.loc();
        this.advance(); // {
        this.advance(); // ...
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after spread expression");
        attributes.push(new AST.JSXSpreadAttribute(expr, sl));
      } else {
        attributes.push(this.parseJSXAttribute());
      }
    }

    // Self-closing tag: />
    if (this.match(TokenType.SLASH)) {
      this.expect(TokenType.GREATER, "Expected '>' in self-closing tag");
      return new AST.JSXElement(tag, attributes, [], true, l);
    }

    this.expect(TokenType.GREATER, "Expected '>'");

    // Parse children
    const children = this.parseJSXChildren(tag);

    return new AST.JSXElement(tag, attributes, children, false, l);
  }

  parseJSXAttribute() {
    const l = this.loc();
    // Accept keywords as attribute names (type, class, for, etc. are valid HTML attributes)
    let name;
    if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.TYPE) || this.check(TokenType.FOR) ||
        this.check(TokenType.IN) || this.check(TokenType.AS) || this.check(TokenType.EXPORT) ||
        this.check(TokenType.STATE) || this.check(TokenType.COMPUTED) || this.check(TokenType.ROUTE)) {
      name = this.advance().value;
    } else {
      this.error("Expected attribute name");
    }

    // Handle namespaced attributes: on:click, bind:value, class:active
    if (this.match(TokenType.COLON)) {
      let suffix;
      if (this.check(TokenType.IDENTIFIER) || this.check(TokenType.IN)) {
        suffix = this.advance().value;
      } else {
        suffix = this.expect(TokenType.IDENTIFIER, "Expected name after ':'").value;
      }
      name = `${name}:${suffix}`;
    }

    if (!this.match(TokenType.ASSIGN)) {
      // Boolean attribute: <input disabled />
      return new AST.JSXAttribute(name, new AST.BooleanLiteral(true, l), l);
    }

    // Value can be {expression} or "string"
    if (this.match(TokenType.LBRACE)) {
      const expr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after attribute expression");
      return new AST.JSXAttribute(name, expr, l);
    }

    if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
      const val = this.parseStringLiteral();
      return new AST.JSXAttribute(name, val, l);
    }

    this.error("Expected attribute value");
  }

  parseJSXChildren(parentTag) {
    const children = [];

    while (!this.isAtEnd()) {
      // Closing tag: </tag>
      if (this.check(TokenType.LESS) && this.peek(1).type === TokenType.SLASH) {
        this.advance(); // <
        this.advance(); // /
        const closeTag = this.expect(TokenType.IDENTIFIER, "Expected closing tag name").value;
        if (closeTag !== parentTag) {
          this.error(`Mismatched closing tag: expected </${parentTag}>, got </${closeTag}>`);
        }
        this.expect(TokenType.GREATER, "Expected '>' in closing tag");
        break;
      }

      // Nested element
      if (this.check(TokenType.LESS)) {
        children.push(this.parseJSXElement());
        continue;
      }

      // String literal as text
      if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        const str = this.parseStringLiteral();
        children.push(new AST.JSXText(str, this.loc()));
        continue;
      }

      // Unquoted JSX text
      if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          children.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
        continue;
      }

      // Expression in braces: {expr}
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const expr = this.parseExpression();
        this.expect(TokenType.RBRACE, "Expected '}' after JSX expression");
        children.push(new AST.JSXExpression(expr, this.loc()));
        continue;
      }

      // for loop inside JSX
      if (this.check(TokenType.FOR)) {
        children.push(this.parseJSXFor());
        continue;
      }

      // if inside JSX
      if (this.check(TokenType.IF)) {
        children.push(this.parseJSXIf());
        continue;
      }

      break;
    }

    return children;
  }

  parseJSXFor() {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // Support destructuring: for [i, item] in ..., for {name, age} in ...
    let variable;
    if (this.check(TokenType.LBRACKET)) {
      // Array destructuring: [a, b]
      this.advance(); // consume [
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' in destructuring pattern");
      variable = `[${elements.join(', ')}]`;
    } else if (this.check(TokenType.LBRACE)) {
      // Object destructuring: {name, age}
      this.advance(); // consume {
      const props = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        props.push(this.expect(TokenType.IDENTIFIER, "Expected property name in object pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in destructuring pattern");
      variable = `{${props.join(', ')}}`;
    } else {
      variable = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
    }

    this.expect(TokenType.IN, "Expected 'in' in for loop");
    const iterable = this.parseExpression();

    // Optional key expression: for item in items key={item.id} { ... }
    let keyExpr = null;
    if (this.check(TokenType.IDENTIFIER) && this.current().value === 'key') {
      this.advance(); // consume 'key'
      this.expect(TokenType.ASSIGN, "Expected '=' after 'key'");
      this.expect(TokenType.LBRACE, "Expected '{' after 'key='");
      keyExpr = this.parseExpression();
      this.expect(TokenType.RBRACE, "Expected '}' after key expression");
    }

    this.expect(TokenType.LBRACE, "Expected '{' in JSX for body");

    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElement());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else {
        break;
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX for body");

    return new AST.JSXFor(variable, iterable, body, l, keyExpr);
  }

  _parseJSXIfBody() {
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      if (this.check(TokenType.LESS)) {
        body.push(this.parseJSXElement());
      } else if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
        body.push(new AST.JSXText(this.parseStringLiteral(), this.loc()));
      } else if (this.check(TokenType.JSX_TEXT)) {
        const tok = this.advance();
        const text = this._collapseJSXWhitespace(tok.value);
        if (text.length > 0) {
          body.push(new AST.JSXText(new AST.StringLiteral(text, this.loc()), this.loc()));
        }
      } else if (this.check(TokenType.LBRACE)) {
        this.advance();
        body.push(new AST.JSXExpression(this.parseExpression(), this.loc()));
        this.expect(TokenType.RBRACE);
      } else {
        break;
      }
    }
    return body;
  }

  parseJSXIf() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' in JSX if body");
    const consequent = this._parseJSXIfBody();
    this.expect(TokenType.RBRACE, "Expected '}' to close JSX if body");

    // Parse elif chains
    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance(); // consume 'elif'
      const elifCond = this.parseExpression();
      this.expect(TokenType.LBRACE, "Expected '{' in JSX elif body");
      const elifBody = this._parseJSXIfBody();
      this.expect(TokenType.RBRACE, "Expected '}' to close JSX elif body");
      alternates.push({ condition: elifCond, body: elifBody });
    }

    // Parse optional else
    let alternate = null;
    if (this.check(TokenType.ELSE)) {
      this.advance();
      this.expect(TokenType.LBRACE);
      alternate = this._parseJSXIfBody();
      this.expect(TokenType.RBRACE);
    }

    return new AST.JSXIf(condition, consequent, alternate, l, alternates);
  }

  // ─── Statements ───────────────────────────────────────────

  parseStatement() {
    // pub modifier: pub fn, pub type, pub x = ...
    if (this.check(TokenType.PUB)) return this.parsePubDeclaration();
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN) return this.parseAsyncFunctionDeclaration();
    if (this.check(TokenType.FN) && this.peek(1).type === TokenType.IDENTIFIER) return this.parseFunctionDeclaration();
    if (this.check(TokenType.TYPE)) return this.parseTypeDeclaration();
    if (this.check(TokenType.VAR)) return this.parseVarDeclaration();
    if (this.check(TokenType.LET)) return this.parseLetDestructure();
    if (this.check(TokenType.IF)) return this.parseIfStatement();
    if (this.check(TokenType.FOR)) return this.parseForStatement();
    if (this.check(TokenType.WHILE)) return this.parseWhileStatement();
    if (this.check(TokenType.RETURN)) return this.parseReturnStatement();
    if (this.check(TokenType.IMPORT)) return this.parseImport();
    if (this.check(TokenType.MATCH)) return this.parseMatchAsStatement();
    if (this.check(TokenType.TRY)) return this.parseTryCatch();
    if (this.check(TokenType.BREAK)) return this.parseBreakStatement();
    if (this.check(TokenType.CONTINUE)) return this.parseContinueStatement();
    if (this.check(TokenType.GUARD)) return this.parseGuardStatement();
    if (this.check(TokenType.INTERFACE)) return this.parseInterfaceDeclaration();
    if (this.check(TokenType.IMPL)) return this.parseImplDeclaration();
    if (this.check(TokenType.TRAIT)) return this.parseTraitDeclaration();
    if (this.check(TokenType.DEFER)) return this.parseDeferStatement();
    if (this.check(TokenType.EXTERN)) return this.parseExternDeclaration();

    return this.parseExpressionOrAssignment();
  }

  parsePubDeclaration() {
    const l = this.loc();
    this.advance(); // consume 'pub'
    if (this.check(TokenType.PUB)) {
      this.error("Duplicate 'pub' modifier");
    }
    const stmt = this.parseStatement();
    if (stmt) stmt.isPublic = true;
    return stmt;
  }

  parseImplDeclaration() {
    const l = this.loc();
    this.expect(TokenType.IMPL);
    const firstName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'impl'").value;

    // Check for `impl Trait for Type`
    let typeName, traitName = null;
    if (this.check(TokenType.FOR)) {
      this.advance();
      traitName = firstName;
      typeName = this.expect(TokenType.IDENTIFIER, "Expected type name after 'for'").value;
    } else {
      typeName = firstName;
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open impl block");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const isAsync = this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN;
      if (isAsync) {
        methods.push(this.parseAsyncFunctionDeclaration());
      } else {
        this.expect(TokenType.FN, "Expected 'fn' in impl block");
        const methodLoc = this.loc();
        const name = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
        this.expect(TokenType.LPAREN, "Expected '(' after method name");
        const params = this.parseParameterList();
        this.expect(TokenType.RPAREN, "Expected ')' after parameters");
        let returnType = null;
        if (this.match(TokenType.THIN_ARROW)) {
          returnType = this.parseTypeAnnotation();
        }
        const body = this.parseBlock();
        methods.push(new AST.FunctionDeclaration(name, params, body, returnType, methodLoc));
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close impl block");
    return new AST.ImplDeclaration(typeName, methods, l, traitName);
  }

  parseTraitDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TRAIT);
    const name = this.expect(TokenType.IDENTIFIER, "Expected trait name").value;
    this.expect(TokenType.LBRACE, "Expected '{' to open trait body");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      this.expect(TokenType.FN, "Expected 'fn' in trait body");
      const methodName = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
      this.expect(TokenType.LPAREN, "Expected '(' after method name");
      const params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after parameters");
      let returnType = null;
      if (this.match(TokenType.THIN_ARROW)) {
        returnType = this.parseTypeAnnotation();
      }
      // Optional default implementation
      let body = null;
      if (this.check(TokenType.LBRACE)) {
        body = this.parseBlock();
      }
      methods.push({ name: methodName, params, returnType, body });
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close trait body");
    return new AST.TraitDeclaration(name, methods, l);
  }

  parseDeferStatement() {
    const l = this.loc();
    this.expect(TokenType.DEFER);
    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }
    return new AST.DeferStatement(body, l);
  }

  parseExternDeclaration() {
    const l = this.loc();
    this.expect(TokenType.EXTERN);

    const isAsync = !!this.match(TokenType.ASYNC);
    this.expect(TokenType.FN, "Expected 'fn' after 'extern'");
    const name = this.expect(TokenType.IDENTIFIER, "Expected function name in extern declaration").value;
    this.expect(TokenType.LPAREN, "Expected '(' after extern function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after extern parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    return new AST.ExternDeclaration(name, params, returnType, l, isAsync);
  }

  parseFunctionDeclaration() {
    const l = this.loc();
    this.expect(TokenType.FN);
    const name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l);
  }

  parseAsyncFunctionDeclaration() {
    const l = this.loc();
    this.expect(TokenType.ASYNC);
    this.expect(TokenType.FN);
    const name = this.expect(TokenType.IDENTIFIER, "Expected function name").value;
    this.expect(TokenType.LPAREN, "Expected '(' after function name");
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN, "Expected ')' after parameters");

    let returnType = null;
    if (this.match(TokenType.THIN_ARROW)) {
      returnType = this.parseTypeAnnotation();
    }

    const body = this.parseBlock();
    return new AST.FunctionDeclaration(name, params, body, returnType, l, true);
  }

  parseBreakStatement() {
    const l = this.loc();
    this.expect(TokenType.BREAK);
    return new AST.BreakStatement(l);
  }

  parseContinueStatement() {
    const l = this.loc();
    this.expect(TokenType.CONTINUE);
    return new AST.ContinueStatement(l);
  }

  parseGuardStatement() {
    const l = this.loc();
    this.expect(TokenType.GUARD);
    const condition = this.parseExpression();
    this.expect(TokenType.ELSE, "Expected 'else' after guard condition");
    const elseBody = this.parseBlock();
    return new AST.GuardStatement(condition, elseBody, l);
  }

  parseInterfaceDeclaration() {
    const l = this.loc();
    this.expect(TokenType.INTERFACE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected interface name").value;
    this.expect(TokenType.LBRACE, "Expected '{' to open interface body");

    const methods = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      this.expect(TokenType.FN, "Expected 'fn' in interface body");
      const methodName = this.expect(TokenType.IDENTIFIER, "Expected method name").value;
      this.expect(TokenType.LPAREN, "Expected '(' after method name");
      const params = this.parseParameterList();
      this.expect(TokenType.RPAREN, "Expected ')' after parameters");
      let returnType = null;
      if (this.match(TokenType.THIN_ARROW)) {
        returnType = this.parseTypeAnnotation();
      }
      methods.push({ name: methodName, params, returnType });
    }
    this.expect(TokenType.RBRACE, "Expected '}' to close interface body");
    return new AST.InterfaceDeclaration(name, methods, l);
  }

  parseParameterList() {
    const params = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      const l = this.loc();

      // Destructuring pattern parameter: {name, email} or [a, b]
      if (this.check(TokenType.LBRACE)) {
        this.advance();
        const properties = [];
        while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
          const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
          let value = key;
          let defaultValue = null;
          if (this.match(TokenType.COLON)) {
            value = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
          }
          if (this.match(TokenType.ASSIGN)) {
            defaultValue = this.parseExpression();
          }
          properties.push({ key, value, defaultValue });
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RBRACE, "Expected '}'");
        const pattern = new AST.ObjectPattern(properties, l);
        const param = new AST.Parameter(null, null, null, l);
        param.destructure = pattern;
        params.push(param);
      } else if (this.check(TokenType.LBRACKET)) {
        this.advance();
        const elements = [];
        while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
          elements.push(this.expect(TokenType.IDENTIFIER, "Expected element name").value);
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RBRACKET, "Expected ']'");
        const pattern = new AST.ArrayPattern(elements, l);
        const param = new AST.Parameter(null, null, null, l);
        param.destructure = pattern;
        params.push(param);
      } else {
        const name = this.expect(TokenType.IDENTIFIER, "Expected parameter name").value;

        let typeAnnotation = null;
        if (this.match(TokenType.COLON)) {
          typeAnnotation = this.parseTypeAnnotation();
        }

        let defaultValue = null;
        if (this.match(TokenType.ASSIGN)) {
          defaultValue = this.parseExpression();
        }

        params.push(new AST.Parameter(name, typeAnnotation, defaultValue, l));
      }

      if (!this.match(TokenType.COMMA)) break;
    }
    return params;
  }

  parseTypeAnnotation() {
    const l = this.loc();

    // [Type] — array type shorthand
    if (this.match(TokenType.LBRACKET)) {
      const elementType = this.parseTypeAnnotation();
      this.expect(TokenType.RBRACKET, "Expected ']' in array type");
      return new AST.ArrayTypeAnnotation(elementType, l);
    }

    // (Type, Type) — tuple type or (Type, Type) -> ReturnType — function type
    if (this.check(TokenType.LPAREN)) {
      this.advance();
      const types = [];
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        types.push(this.parseTypeAnnotation());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RPAREN, "Expected ')' in type annotation");
      // Check for -> to distinguish function type from tuple type
      if (this.match(TokenType.THIN_ARROW)) {
        const returnType = this.parseTypeAnnotation();
        return new AST.FunctionTypeAnnotation(types, returnType, l);
      }
      return new AST.TupleTypeAnnotation(types, l);
    }

    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    // Generics: Type<A, B>
    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.parseTypeAnnotation());
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    return new AST.TypeAnnotation(name, typeParams, l);
  }

  parseTypeDeclaration() {
    const l = this.loc();
    this.expect(TokenType.TYPE);
    const name = this.expect(TokenType.IDENTIFIER, "Expected type name").value;

    // Optional type parameters: Type<T, E>
    let typeParams = [];
    if (this.match(TokenType.LESS)) {
      do {
        typeParams.push(this.expect(TokenType.IDENTIFIER, "Expected type parameter name").value);
      } while (this.match(TokenType.COMMA));
      this.expect(TokenType.GREATER, "Expected '>' to close type parameters");
    }

    // Type alias: type Name = TypeExpr
    if (this.match(TokenType.ASSIGN)) {
      const typeExpr = this.parseTypeAnnotation();
      return new AST.TypeAlias(name, typeExpr, l);
    }

    this.expect(TokenType.LBRACE, "Expected '{' to open type body");

    const variants = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const vl = this.loc();
      const vname = this.expect(TokenType.IDENTIFIER, "Expected variant or field name").value;

      if (this.match(TokenType.LPAREN)) {
        // Variant with fields: Circle(radius: Float)
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          const fl = this.loc();
          const fname = this.expect(TokenType.IDENTIFIER, "Expected field name").value;
          let ftype = null;
          if (this.match(TokenType.COLON)) {
            ftype = this.parseTypeAnnotation();
          }
          fields.push(new AST.TypeField(fname, ftype, fl));
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN, "Expected ')' after variant fields");
        variants.push(new AST.TypeVariant(vname, fields, vl));
      } else if (this.match(TokenType.COLON)) {
        // Simple field: name: String
        const ftype = this.parseTypeAnnotation();
        variants.push(new AST.TypeField(vname, ftype, vl));
      } else {
        // Bare variant: None
        variants.push(new AST.TypeVariant(vname, [], vl));
      }

      this.match(TokenType.COMMA);
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close type body");

    // Optional derive clause: type Foo { ... } derive [Eq, Show, JSON]
    const node = new AST.TypeDeclaration(name, typeParams, variants, l);
    if (this.match(TokenType.DERIVE)) {
      this.expect(TokenType.LBRACKET, "Expected '[' after derive");
      node.derive = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        node.derive.push(this.expect(TokenType.IDENTIFIER, "Expected derive trait name").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' after derive traits");
    }
    return node;
  }

  parseVarDeclaration() {
    const l = this.loc();
    this.expect(TokenType.VAR);

    const targets = [];
    do {
      targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
    } while (this.match(TokenType.COMMA));

    this.expect(TokenType.ASSIGN, "Expected '=' in var declaration");

    const values = [this.parseExpression()];
    while (this.match(TokenType.COMMA)) {
      values.push(this.parseExpression());
    }

    return new AST.VarDeclaration(targets, values, l);
  }

  parseLetDestructure() {
    const l = this.loc();
    this.expect(TokenType.LET);

    let pattern;
    if (this.check(TokenType.LBRACE)) {
      pattern = this.parseObjectPattern();
    } else if (this.check(TokenType.LBRACKET)) {
      pattern = this.parseArrayPattern();
    } else if (this.check(TokenType.LPAREN)) {
      // Tuple destructuring: let (a, b) = expr
      pattern = this.parseTuplePattern();
    } else {
      this.error("Expected '{', '[', or '(' after 'let' for destructuring");
    }

    this.expect(TokenType.ASSIGN, "Expected '=' in destructuring");
    const value = this.parseExpression();

    return new AST.LetDestructure(pattern, value, l);
  }

  parseObjectPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);
    const properties = [];

    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      const key = this.expect(TokenType.IDENTIFIER, "Expected property name").value;
      let valueName = key;
      let defaultValue = null;

      if (this.match(TokenType.COLON)) {
        valueName = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
      }
      if (this.match(TokenType.ASSIGN)) {
        defaultValue = this.parseExpression();
      }

      properties.push({ key, value: valueName, defaultValue });
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACE, "Expected '}' in object pattern");
    return new AST.ObjectPattern(properties, l);
  }

  parseArrayPattern() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);
    const elements = [];

    while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
      if (this.check(TokenType.IDENTIFIER) && this.current().value === '_') {
        elements.push(null); // skip placeholder
        this.advance();
      } else {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RBRACKET, "Expected ']' in array pattern");
    return new AST.ArrayPattern(elements, l);
  }

  parseTuplePattern() {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const elements = [];
    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in tuple pattern").value);
      if (!this.match(TokenType.COMMA)) break;
    }
    this.expect(TokenType.RPAREN, "Expected ')' in tuple pattern");
    return new AST.TuplePattern(elements, l);
  }

  parseIfStatement() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance();
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.IfStatement(condition, consequent, alternates, elseBody, l);
  }

  parseForStatement() {
    const l = this.loc();
    this.expect(TokenType.FOR);

    // For variable(s) — supports simple, pair, array destructuring, and object destructuring
    let variable;
    if (this.check(TokenType.LBRACKET)) {
      // Array destructuring: for [a, b] in ...
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.expect(TokenType.IDENTIFIER, "Expected variable name in array pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET, "Expected ']' in destructuring pattern");
      variable = `[${elements.join(', ')}]`;
    } else if (this.check(TokenType.LBRACE)) {
      // Object destructuring: for {name, age} in ...
      this.advance();
      const props = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        props.push(this.expect(TokenType.IDENTIFIER, "Expected property name in object pattern").value);
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in destructuring pattern");
      variable = `{${props.join(', ')}}`;
    } else {
      const firstName = this.expect(TokenType.IDENTIFIER, "Expected loop variable").value;
      if (this.match(TokenType.COMMA)) {
        const secondName = this.expect(TokenType.IDENTIFIER, "Expected second loop variable").value;
        variable = [firstName, secondName];
      } else {
        variable = firstName;
      }
    }

    this.expect(TokenType.IN, "Expected 'in' after for variable");
    const iterable = this.parseExpression();
    const body = this.parseBlock();

    let elseBody = null;
    if (this.match(TokenType.ELSE)) {
      elseBody = this.parseBlock();
    }

    return new AST.ForStatement(variable, iterable, body, elseBody, l);
  }

  parseWhileStatement() {
    const l = this.loc();
    this.expect(TokenType.WHILE);
    const condition = this.parseExpression();
    const body = this.parseBlock();
    return new AST.WhileStatement(condition, body, l);
  }

  parseTryCatch() {
    const l = this.loc();
    this.expect(TokenType.TRY);
    const tryBlock = this.parseBlock();

    let catchParam = null;
    let catchBody = null;
    let finallyBody = null;

    // Parse optional catch block
    if (this.match(TokenType.CATCH)) {
      if (this.check(TokenType.IDENTIFIER)) {
        catchParam = this.advance().value;
      }
      const catchBlock = this.parseBlock();
      catchBody = catchBlock.body;
    }

    // Parse optional finally block
    if (this.match(TokenType.FINALLY)) {
      const finallyBlock = this.parseBlock();
      finallyBody = finallyBlock.body;
    }

    // Must have at least catch or finally
    if (!catchBody && !finallyBody) {
      this.error("Expected 'catch' or 'finally' after try block");
    }

    return new AST.TryCatchStatement(tryBlock.body, catchParam, catchBody, l, finallyBody);
  }

  parseReturnStatement() {
    const l = this.loc();
    const returnToken = this.expect(TokenType.RETURN);

    let value = null;
    // Only parse return value if the next token is on the same line as `return`
    // This prevents `return\nx = 5` from being parsed as `return x` then `= 5`
    if (!this.check(TokenType.RBRACE) && !this.isAtEnd() && this.current().line === returnToken.line) {
      value = this.parseExpression();
    }

    return new AST.ReturnStatement(value, l);
  }

  parseImport() {
    const l = this.loc();
    this.expect(TokenType.IMPORT);

    // import * as name from "module"
    if (this.check(TokenType.STAR)) {
      this.advance(); // consume *
      this.expect(TokenType.AS, "Expected 'as' after '*' in wildcard import");
      const name = this.expect(TokenType.IDENTIFIER, "Expected namespace name after 'as'").value;
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportWildcard(name, source, l);
    }

    // import { a, b } from "module"
    if (this.match(TokenType.LBRACE)) {
      const specifiers = [];
      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
        const imported = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
        let local = imported;
        if (this.match(TokenType.AS)) {
          local = this.expect(TokenType.IDENTIFIER, "Expected alias name").value;
        }
        specifiers.push(new AST.ImportSpecifier(imported, local, this.loc()));
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACE, "Expected '}' in import");
      this.expect(TokenType.FROM, "Expected 'from' in import");
      const source = this.expect(TokenType.STRING, "Expected module path").value;
      return new AST.ImportDeclaration(specifiers, source, l);
    }

    // import Name from "module"
    const name = this.expect(TokenType.IDENTIFIER, "Expected import name").value;
    this.expect(TokenType.FROM, "Expected 'from' in import");
    const source = this.expect(TokenType.STRING, "Expected module path").value;
    return new AST.ImportDefault(name, source, l);
  }

  parseBlock() {
    const l = this.loc();
    this.expect(TokenType.LBRACE, "Expected '{'");
    const body = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      try {
        const stmt = this.parseStatement();
        if (stmt) body.push(stmt);
      } catch (e) {
        this.errors.push(e);
        this._synchronizeBlock();
      }
    }
    this.expect(TokenType.RBRACE, "Expected '}'");
    return new AST.BlockStatement(body, l);
  }

  // ─── Expression or Assignment ─────────────────────────────

  parseExpressionOrAssignment() {
    const l = this.loc();
    const expr = this.parseExpression();

    // Multiple assignment: a, b = 1, 2
    if (this.check(TokenType.COMMA) && expr.type === 'Identifier') {
      const targets = [expr.name];
      while (this.match(TokenType.COMMA)) {
        targets.push(this.expect(TokenType.IDENTIFIER, "Expected variable name").value);
      }
      this.expect(TokenType.ASSIGN, "Expected '=' in multiple assignment");
      const values = [this.parseExpression()];
      while (this.match(TokenType.COMMA)) {
        values.push(this.parseExpression());
      }
      return new AST.Assignment(targets, values, l);
    }

    // Simple assignment: x = expr (creates immutable binding), obj.x = expr, arr[i] = expr
    if (this.match(TokenType.ASSIGN)) {
      if (expr.type === 'Identifier') {
        const value = this.parseExpression();
        return new AST.Assignment([expr.name], [value], l);
      }
      if (expr.type === 'MemberExpression') {
        const value = this.parseExpression();
        return new AST.Assignment([expr], [value], l);
      }
      this.error("Invalid assignment target");
    }

    // Compound assignment: x += expr
    const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
    if (compoundOp) {
      if (expr.type !== 'Identifier' && expr.type !== 'MemberExpression') {
        this.error("Invalid compound assignment target");
      }
      const value = this.parseExpression();
      return new AST.CompoundAssignment(expr, compoundOp.value, value, l);
    }

    return new AST.ExpressionStatement(expr, l);
  }

  parseMatchAsStatement() {
    const expr = this.parseMatchExpression();
    return new AST.ExpressionStatement(expr, this.loc());
  }

  parseIfExpression() {
    const l = this.loc();
    this.expect(TokenType.IF);
    const condition = this.parseExpression();
    const consequent = this.parseBlock();

    const alternates = [];
    while (this.check(TokenType.ELIF)) {
      this.advance();
      const elifCond = this.parseExpression();
      const elifBody = this.parseBlock();
      alternates.push({ condition: elifCond, body: elifBody });
    }

    if (!this.check(TokenType.ELSE)) {
      this.error("if expression requires an else branch");
    }
    this.advance();
    const elseBody = this.parseBlock();

    return new AST.IfExpression(condition, consequent, alternates, elseBody, l);
  }

  // ─── Expressions (precedence climbing) ────────────────────

  parseExpression() {
    if (++this._expressionDepth > Parser.MAX_EXPRESSION_DEPTH) {
      this._expressionDepth--;
      this.error('Expression nested too deeply (max ' + Parser.MAX_EXPRESSION_DEPTH + ' levels)');
    }
    try {
      return this.parsePipe();
    } finally {
      this._expressionDepth--;
    }
  }

  parsePipe() {
    let left = this.parseNullCoalesce();
    while (this.match(TokenType.PIPE)) {
      const l = this.loc();
      // Method pipe: |> .method(args) — parse as MemberExpression with empty Identifier
      if (this.check(TokenType.DOT)) {
        this.advance(); // consume .
        const method = this.expect(TokenType.IDENTIFIER, "Expected method name after '.'").value;
        const placeholder = new AST.Identifier(AST.PIPE_TARGET, l);
        const memberExpr = new AST.MemberExpression(placeholder, method, false, l);
        if (this.check(TokenType.LPAREN)) {
          const call = this.parseCallExpression(memberExpr);
          left = new AST.PipeExpression(left, call, l);
        } else {
          left = new AST.PipeExpression(left, memberExpr, l);
        }
      } else {
        const right = this.parseNullCoalesce();
        left = new AST.PipeExpression(left, right, l);
      }
    }
    return left;
  }

  parseNullCoalesce() {
    let left = this.parseOr();
    while (this.match(TokenType.QUESTION_QUESTION)) {
      const l = this.loc();
      const right = this.parseOr();
      left = new AST.BinaryExpression('??', left, right, l);
    }
    return left;
  }

  parseOr() {
    let left = this.parseAnd();
    while (this.match(TokenType.OR_OR) || this.match(TokenType.OR)) {
      const l = this.loc();
      const right = this.parseAnd();
      left = new AST.LogicalExpression('or', left, right, l);
    }
    return left;
  }

  parseAnd() {
    let left = this.parseNot();
    while (this.match(TokenType.AND_AND) || this.match(TokenType.AND)) {
      const l = this.loc();
      const right = this.parseNot();
      left = new AST.LogicalExpression('and', left, right, l);
    }
    return left;
  }

  parseNot() {
    if (this.match(TokenType.NOT) || this.match(TokenType.BANG)) {
      const l = this.loc();
      const operand = this.parseNot();
      return new AST.UnaryExpression('not', operand, true, l);
    }
    return this.parseComparison();
  }

  parseComparison() {
    let left = this.parseMembership();

    // Check for chained comparisons: a < b < c
    const compOps = [TokenType.LESS, TokenType.LESS_EQUAL, TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.EQUAL, TokenType.NOT_EQUAL];

    if (compOps.some(op => this.check(op))) {
      // Don't parse < as comparison if it looks like JSX
      if (this.check(TokenType.LESS) && this._looksLikeJSX()) {
        return left;
      }
      const l = this.loc(); // capture loc at the operator
      const operands = [left];
      const operators = [];

      while (true) {
        const op = this.match(...compOps);
        if (!op) break;
        operators.push(op.value);
        operands.push(this.parseMembership());
      }

      if (operators.length === 1) {
        return new AST.BinaryExpression(operators[0], operands[0], operands[1], l);
      }
      return new AST.ChainedComparison(operands, operators, l);
    }

    return left;
  }

  parseMembership() {
    let left = this.parseRange();

    // "in" / "not in"
    if (this.check(TokenType.NOT) && this.peek(1).type === TokenType.IN) {
      const l = this.loc();
      this.advance(); // not
      this.advance(); // in
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, true, l);
    }

    if (this.check(TokenType.IN)) {
      const l = this.loc();
      this.advance();
      const right = this.parseRange();
      return new AST.MembershipExpression(left, right, false, l);
    }

    return left;
  }

  parseRange() {
    let left = this.parseAddition();

    if (this.check(TokenType.DOT_DOT_EQUAL)) {
      const l = this.loc();
      this.advance();
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, true, l);
    }
    if (this.check(TokenType.DOT_DOT)) {
      const l = this.loc();
      this.advance();
      const right = this.parseAddition();
      return new AST.RangeExpression(left, right, false, l);
    }

    return left;
  }

  parseAddition() {
    let left = this.parseMultiplication();
    while (true) {
      const l = this.loc();
      const op = this.match(TokenType.PLUS, TokenType.MINUS);
      if (!op) break;
      const right = this.parseMultiplication();
      left = new AST.BinaryExpression(op.value, left, right, l);
    }
    return left;
  }

  parseMultiplication() {
    let left = this.parsePower();
    while (true) {
      const l = this.loc();
      const op = this.match(TokenType.STAR, TokenType.SLASH, TokenType.PERCENT);
      if (!op) break;
      const right = this.parsePower();
      left = new AST.BinaryExpression(op.value, left, right, l);
    }
    return left;
  }

  parsePower() {
    let base = this.parseUnary();
    if (this.check(TokenType.POWER)) {
      const l = this.loc();
      this.advance();
      const exp = this.parsePower(); // Right-associative
      return new AST.BinaryExpression('**', base, exp, l);
    }
    return base;
  }

  parseUnary() {
    if (this.check(TokenType.AWAIT)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.AwaitExpression(operand, l);
    }
    if (this.check(TokenType.YIELD)) {
      const l = this.loc();
      this.advance();
      // yield from expr
      let delegate = false;
      if (this.check(TokenType.FROM)) {
        this.advance();
        delegate = true;
      }
      const operand = this.parseUnary();
      return new AST.YieldExpression(operand, delegate, l);
    }
    if (this.check(TokenType.MINUS)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.UnaryExpression('-', operand, true, l);
    }
    if (this.check(TokenType.SPREAD)) {
      const l = this.loc();
      this.advance();
      const operand = this.parseUnary();
      return new AST.SpreadExpression(operand, l);
    }
    return this.parsePostfix();
  }

  parsePostfix() {
    let expr = this.parsePrimary();

    while (true) {
      if (this.check(TokenType.DOT)) {
        const l = this.loc();
        this.advance();
        const prop = this.expect(TokenType.IDENTIFIER, "Expected property name after '.'").value;
        expr = new AST.MemberExpression(expr, prop, false, l);
        continue;
      }

      if (this.check(TokenType.QUESTION_DOT)) {
        const l = this.loc();
        this.advance();
        const prop = this.expect(TokenType.IDENTIFIER, "Expected property name after '?.'").value;
        expr = new AST.OptionalChain(expr, prop, false, l);
        continue;
      }

      if (this.check(TokenType.LBRACKET)) {
        // Don't treat [ as subscript if it's on a new line (avoids ambiguity with array patterns in match)
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine > prevLine) break;
        expr = this.parseSubscript(expr);
        continue;
      }

      if (this.check(TokenType.LPAREN)) {
        expr = this.parseCallExpression(expr);
        continue;
      }

      if (this.check(TokenType.QUESTION)) {
        const prevLine = this.pos > 0 ? this.tokens[this.pos - 1].line : 0;
        const curLine = this.current().line;
        if (curLine === prevLine) {
          const l = this.loc();
          this.advance();
          expr = new AST.PropagateExpression(expr, l);
          continue;
        }
      }

      break;
    }

    return expr;
  }

  parseSubscript(object) {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    // Handle [::step] — DOUBLE_COLON is lexed as one token
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, null, step, l);
    }

    // Check for slice: obj[start:end:step]
    if (this.check(TokenType.COLON)) {
      // [:end] or [:end:step]
      this.advance();
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, null, end, step, l);
    }

    const start = this.parseExpression();

    // Handle [start::step] — DOUBLE_COLON after start expression
    if (this.check(TokenType.DOUBLE_COLON)) {
      this.advance();
      let step = null;
      if (!this.check(TokenType.RBRACKET)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, null, step, l);
    }

    if (this.match(TokenType.COLON)) {
      // [start:end] or [start:end:step]
      let end = null;
      let step = null;
      if (!this.check(TokenType.COLON) && !this.check(TokenType.DOUBLE_COLON) && !this.check(TokenType.RBRACKET)) {
        end = this.parseExpression();
      }
      if (this.match(TokenType.COLON)) {
        step = this.parseExpression();
      }
      this.expect(TokenType.RBRACKET, "Expected ']'");
      return new AST.SliceExpression(object, start, end, step, l);
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.MemberExpression(object, start, true, l);
  }

  parseCallExpression(callee) {
    const l = this.loc();
    this.expect(TokenType.LPAREN);
    const args = [];

    while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
      // Check for named argument: name: value
      if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COLON) {
        const name = this.advance().value;
        this.advance(); // :
        const value = this.parseExpression();
        args.push(new AST.NamedArgument(name, value, this.loc()));
      } else {
        args.push(this.parseExpression());
      }
      if (!this.match(TokenType.COMMA)) break;
    }

    this.expect(TokenType.RPAREN, "Expected ')' after arguments");
    return new AST.CallExpression(callee, args, l);
  }

  // ─── Primary expressions ──────────────────────────────────

  parsePrimary() {
    const l = this.loc();

    // Number
    if (this.check(TokenType.NUMBER)) {
      return new AST.NumberLiteral(this.advance().value, l);
    }

    // String
    if (this.check(TokenType.STRING) || this.check(TokenType.STRING_TEMPLATE)) {
      return this.parseStringLiteral();
    }

    // Regex literal
    if (this.check(TokenType.REGEX)) {
      const token = this.advance();
      return new AST.RegexLiteral(token.value.pattern, token.value.flags, l);
    }

    // Boolean
    if (this.check(TokenType.TRUE)) {
      this.advance();
      return new AST.BooleanLiteral(true, l);
    }
    if (this.check(TokenType.FALSE)) {
      this.advance();
      return new AST.BooleanLiteral(false, l);
    }

    // Nil
    if (this.check(TokenType.NIL)) {
      this.advance();
      return new AST.NilLiteral(l);
    }

    // Match expression
    if (this.check(TokenType.MATCH)) {
      return this.parseMatchExpression();
    }

    // If expression (in expression position): if cond { a } else { b }
    if (this.check(TokenType.IF)) {
      return this.parseIfExpression();
    }

    // Async lambda: async fn(params) body
    if (this.check(TokenType.ASYNC) && this.peek(1).type === TokenType.FN) {
      return this.parseAsyncLambda();
    }

    // Lambda: fn(params) body  or  params => body
    if (this.check(TokenType.FN) && this.peek(1).type === TokenType.LPAREN) {
      return this.parseLambda();
    }

    // Arrow lambda: x => expr  or  (x, y) => expr
    // We'll handle this in the identifier/paren case

    // Array literal or list comprehension
    if (this.check(TokenType.LBRACKET)) {
      return this.parseArrayOrComprehension();
    }

    // Object literal or dict comprehension
    if (this.check(TokenType.LBRACE)) {
      return this.parseObjectOrDictComprehension();
    }

    // Parenthesized expression or arrow lambda
    if (this.check(TokenType.LPAREN)) {
      return this.parseParenOrArrowLambda();
    }

    // server/client/shared as identifiers in expression position (for RPC: server.get_users())
    if (this.check(TokenType.SERVER) || this.check(TokenType.CLIENT) || this.check(TokenType.SHARED)) {
      const name = this.advance().value;
      return new AST.Identifier(name, l);
    }

    // Identifier (or arrow lambda: x => expr)
    if (this.check(TokenType.IDENTIFIER)) {
      const name = this.advance().value;
      // Check for arrow lambda: x => expr
      if (this.check(TokenType.ARROW)) {
        this.advance();
        const body = this.parseExpression();
        return new AST.LambdaExpression(
          [new AST.Parameter(name, null, null, l)],
          body,
          l
        );
      }
      return new AST.Identifier(name, l);
    }

    this.error(`Unexpected token: ${this.current().type}`);
  }

  parseStringLiteral() {
    const l = this.loc();
    const tok = this.advance();

    if (tok.type === TokenType.STRING) {
      return new AST.StringLiteral(tok.value, l);
    }

    // String template with interpolation
    const parts = tok.value.map(part => {
      if (part.type === 'text') {
        return { type: 'text', value: part.value };
      }
      // Re-parse the expression tokens
      const subParser = new Parser(
        [...part.tokens, { type: TokenType.EOF, value: null, line: 0, column: 0 }],
        this.filename
      );
      const expr = subParser.parseExpression();
      return { type: 'expr', value: expr };
    });

    return new AST.TemplateLiteral(parts, l);
  }

  parseLambda() {
    const l = this.loc();
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      // Parse expression, then check for compound/simple assignment
      const expr = this.parseExpression();
      const compoundOp = this.match(TokenType.PLUS_ASSIGN, TokenType.MINUS_ASSIGN, TokenType.STAR_ASSIGN, TokenType.SLASH_ASSIGN);
      if (compoundOp) {
        const value = this.parseExpression();
        body = new AST.CompoundAssignment(expr, compoundOp.value, value, l);
      } else if (this.match(TokenType.ASSIGN)) {
        if (expr.type === 'Identifier') {
          const value = this.parseExpression();
          body = new AST.Assignment([expr.name], [value], l);
        } else {
          body = expr;
        }
      } else {
        body = expr;
      }
    }

    return new AST.LambdaExpression(params, body, l);
  }

  parseAsyncLambda() {
    const l = this.loc();
    this.expect(TokenType.ASYNC);
    this.expect(TokenType.FN);
    this.expect(TokenType.LPAREN);
    const params = this.parseParameterList();
    this.expect(TokenType.RPAREN);

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.LambdaExpression(params, body, l, true);
  }

  parseMatchExpression() {
    const l = this.loc();
    this.expect(TokenType.MATCH);
    const subject = this.parseExpression();
    this.expect(TokenType.LBRACE, "Expected '{' to open match body");

    const arms = [];
    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {
      arms.push(this.parseMatchArm());
      this.match(TokenType.COMMA); // Optional comma between arms
    }

    this.expect(TokenType.RBRACE, "Expected '}' to close match body");
    return new AST.MatchExpression(subject, arms, l);
  }

  parseMatchArm() {
    const l = this.loc();
    const pattern = this.parsePattern();

    let guard = null;
    if (this.match(TokenType.IF)) {
      guard = this.parseExpression();
    }

    this.expect(TokenType.ARROW, "Expected '=>' in match arm");

    let body;
    if (this.check(TokenType.LBRACE)) {
      body = this.parseBlock();
    } else {
      body = this.parseExpression();
    }

    return new AST.MatchArm(pattern, guard, body, l);
  }

  parsePattern() {
    const l = this.loc();

    // Wildcard _
    if (this.checkValue(TokenType.IDENTIFIER, '_')) {
      this.advance();
      return new AST.WildcardPattern(l);
    }

    // Negative number literal pattern: -1, -3.14
    if (this.check(TokenType.MINUS) && this.peek(1).type === TokenType.NUMBER) {
      this.advance(); // consume -
      const val = -this.advance().value;
      // Check for range pattern: -5..0
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const endNeg = this.match(TokenType.MINUS);
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, endNeg ? -end : end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const endNeg = this.match(TokenType.MINUS);
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, endNeg ? -end : end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // Number literal pattern
    if (this.check(TokenType.NUMBER)) {
      const val = this.advance().value;
      // Check for range pattern: 1..10
      if (this.match(TokenType.DOT_DOT_EQUAL)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, true, l);
      }
      if (this.match(TokenType.DOT_DOT)) {
        const end = this.expect(TokenType.NUMBER, "Expected number in range pattern").value;
        return new AST.RangePattern(val, end, false, l);
      }
      return new AST.LiteralPattern(val, l);
    }

    // String literal pattern, possibly with ++ concat pattern
    if (this.check(TokenType.STRING)) {
      const strVal = this.advance().value;
      // Check for string concat pattern: "prefix" ++ rest
      // Verify the two + tokens are adjacent (no space between them) to distinguish from arithmetic
      if (this.check(TokenType.PLUS) && this.peek(1).type === TokenType.PLUS &&
          this.current().column + 1 === this.peek(1).column && this.current().line === this.peek(1).line) {
        this.advance(); // first +
        this.advance(); // second +
        const rest = this.parsePattern();
        return new AST.StringConcatPattern(strVal, rest, l);
      }
      return new AST.LiteralPattern(strVal, l);
    }

    // Boolean literal pattern
    if (this.check(TokenType.TRUE)) {
      this.advance();
      return new AST.LiteralPattern(true, l);
    }
    if (this.check(TokenType.FALSE)) {
      this.advance();
      return new AST.LiteralPattern(false, l);
    }

    // Nil pattern
    if (this.check(TokenType.NIL)) {
      this.advance();
      return new AST.LiteralPattern(null, l);
    }

    // Array pattern: [a, b, c] or [0, _]
    if (this.check(TokenType.LBRACKET)) {
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RBRACKET) && !this.isAtEnd()) {
        elements.push(this.parsePattern());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RBRACKET);
      return new AST.ArrayPattern(elements, l);
    }

    // Tuple pattern: (a, b)
    if (this.check(TokenType.LPAREN)) {
      this.advance();
      const elements = [];
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        elements.push(this.parsePattern());
        if (!this.match(TokenType.COMMA)) break;
      }
      this.expect(TokenType.RPAREN, "Expected ')' in tuple pattern");
      return new AST.TuplePattern(elements, l);
    }

    // Identifier: could be variant pattern or binding pattern
    if (this.check(TokenType.IDENTIFIER)) {
      const name = this.advance().value;

      // Variant pattern: Circle(r), Some(Ok(value))
      if (this.match(TokenType.LPAREN)) {
        const fields = [];
        while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
          fields.push(this.parsePattern());
          if (!this.match(TokenType.COMMA)) break;
        }
        this.expect(TokenType.RPAREN);
        return new AST.VariantPattern(name, fields, l);
      }

      // Binding pattern (lowercase = binding, uppercase = variant without args)
      if (name[0] === name[0].toUpperCase() && name[0] !== '_') {
        return new AST.VariantPattern(name, [], l);
      }
      return new AST.BindingPattern(name, l);
    }

    this.error("Expected pattern");
  }

  parseArrayOrComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACKET);

    if (this.check(TokenType.RBRACKET)) {
      this.advance();
      return new AST.ArrayLiteral([], l);
    }

    // Parse first expression
    const first = this.parseExpression();

    // Check if this is a list comprehension: [expr for x in items]
    if (this.check(TokenType.FOR)) {
      this.advance();
      const variable = this.expect(TokenType.IDENTIFIER, "Expected variable in comprehension").value;
      this.expect(TokenType.IN, "Expected 'in' in comprehension");
      const iterable = this.parseExpression();

      let condition = null;
      if (this.match(TokenType.IF)) {
        condition = this.parseExpression();
      }

      this.expect(TokenType.RBRACKET, "Expected ']' to close comprehension");
      return new AST.ListComprehension(first, variable, iterable, condition, l);
    }

    // Regular array literal
    const elements = [first];
    while (this.match(TokenType.COMMA)) {
      if (this.check(TokenType.RBRACKET)) break; // trailing comma
      elements.push(this.parseExpression());
    }

    this.expect(TokenType.RBRACKET, "Expected ']'");
    return new AST.ArrayLiteral(elements, l);
  }

  parseObjectOrDictComprehension() {
    const l = this.loc();
    this.expect(TokenType.LBRACE);

    if (this.check(TokenType.RBRACE)) {
      this.advance();
      return new AST.ObjectLiteral([], l);
    }

    // Try to parse first key: value pair
    const firstKey = this.parseExpression();

    if (this.match(TokenType.COLON)) {
      const firstValue = this.parseExpression();

      // Dict comprehension: {k: v for k, v in pairs}
      if (this.check(TokenType.FOR)) {
        this.advance();
        const vars = [];
        vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        if (this.match(TokenType.COMMA)) {
          vars.push(this.expect(TokenType.IDENTIFIER, "Expected variable").value);
        }
        this.expect(TokenType.IN, "Expected 'in' in comprehension");
        const iterable = this.parseExpression();
        let condition = null;
        if (this.match(TokenType.IF)) {
          condition = this.parseExpression();
        }
        this.expect(TokenType.RBRACE, "Expected '}' to close dict comprehension");
        return new AST.DictComprehension(firstKey, firstValue, vars, iterable, condition, l);
      }

      // Regular object literal
      const properties = [{ key: firstKey, value: firstValue, shorthand: false }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        const key = this.parseExpression();
        this.expect(TokenType.COLON, "Expected ':' in object literal");
        const value = this.parseExpression();
        properties.push({ key, value, shorthand: false });
      }

      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    // Shorthand object: { x, y } or mixed { x, y: 10 }
    if (firstKey.type === 'Identifier') {
      const properties = [{ key: firstKey, value: firstKey, shorthand: true }];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RBRACE)) break;
        const key = this.parseExpression();
        if (this.match(TokenType.COLON)) {
          // Colon property: y: 10
          const value = this.parseExpression();
          properties.push({ key, value, shorthand: false });
        } else {
          // Shorthand property: y
          properties.push({ key, value: key, shorthand: true });
        }
      }
      this.expect(TokenType.RBRACE, "Expected '}'");
      return new AST.ObjectLiteral(properties, l);
    }

    this.error("Invalid object literal");
  }

  parseParenOrArrowLambda() {
    const l = this.loc();

    // Save position to backtrack if needed
    const savedPos = this.pos;

    this.expect(TokenType.LPAREN);

    // Empty parens: () => expr
    if (this.check(TokenType.RPAREN)) {
      this.advance();
      if (this.check(TokenType.ARROW)) {
        this.advance();
        const body = this.parseExpression();
        return new AST.LambdaExpression([], body, l);
      }
      // Empty parens but not arrow — error or unit value
      this.error("Unexpected '()'");
    }

    // Try to parse as arrow lambda params
    // Look ahead: if we see ) => then it's a lambda
    const params = [];
    let isLambda = true;

    const savedErrors = this.errors.length;
    try {
      const innerSaved = this.pos;
      while (!this.check(TokenType.RPAREN) && !this.isAtEnd()) {
        if (!this.check(TokenType.IDENTIFIER)) {
          isLambda = false;
          break;
        }
        const pname = this.advance().value;
        let ptype = null;
        let pdefault = null;
        if (this.match(TokenType.COLON)) {
          // Could be a type annotation or named argument
          if (this.check(TokenType.IDENTIFIER)) {
            ptype = this.parseTypeAnnotation();
          } else {
            isLambda = false;
            break;
          }
        }
        if (this.match(TokenType.ASSIGN)) {
          pdefault = this.parseExpression();
        }
        params.push(new AST.Parameter(pname, ptype, pdefault, l));
        if (!this.match(TokenType.COMMA)) break;
      }

      if (isLambda && this.check(TokenType.RPAREN)) {
        this.advance(); // )
        if (this.check(TokenType.ARROW)) {
          this.advance(); // =>
          const body = this.check(TokenType.LBRACE) ? this.parseBlock() : this.parseExpression();
          return new AST.LambdaExpression(params, body, l);
        }
      }
    } catch (e) {
      // Not a lambda, backtrack
    }

    // Backtrack and parse as parenthesized expression or tuple
    // Also restore errors to discard any ghost errors from speculative parsing
    this.errors.length = savedErrors;
    this.pos = savedPos;
    this.expect(TokenType.LPAREN);
    const expr = this.parseExpression();

    // Tuple: (a, b, c) — requires at least one comma
    if (this.check(TokenType.COMMA)) {
      const elements = [expr];
      while (this.match(TokenType.COMMA)) {
        if (this.check(TokenType.RPAREN)) break; // trailing comma
        elements.push(this.parseExpression());
      }
      this.expect(TokenType.RPAREN, "Expected ')'");
      return new AST.TupleExpression(elements, l);
    }

    this.expect(TokenType.RPAREN, "Expected ')'");
    return expr;
  }
}

// ─── src/analyzer/scope.js ─────────────────────────────

// Scope and symbol management for the Tova analyzer
class Symbol {
  constructor(name, kind, type, mutable, loc) {
    this.name = name;
    this.kind = kind;       // 'variable', 'function', 'type', 'parameter', 'state', 'computed', 'component'
    this.type = type;       // type annotation (optional)
    this.mutable = mutable; // true for 'var' declarations
    this.loc = loc;
    this.used = false;
  }
}
class Scope {
  constructor(parent = null, context = 'module') {
    this.parent = parent;
    this.context = context; // 'module', 'server', 'client', 'shared', 'function', 'block'
    this.symbols = new Map();
    this.children = [];
  }

  define(name, symbol) {
    if (this.symbols.has(name)) {
      throw new Error(
        `${symbol.loc.file}:${symbol.loc.line}:${symbol.loc.column} — '${name}' is already defined in this scope`
      );
    }
    this.symbols.set(name, symbol);
  }

  lookup(name) {
    if (this.symbols.has(name)) {
      return this.symbols.get(name);
    }
    if (this.parent) {
      return this.parent.lookup(name);
    }
    return null;
  }

  lookupLocal(name) {
    return this.symbols.get(name) || null;
  }

  getContext() {
    if (this.context === 'server' || this.context === 'client' || this.context === 'shared') {
      return this.context;
    }
    if (this.parent) {
      return this.parent.getContext();
    }
    return 'module';
  }

  child(context) {
    const c = new Scope(this, context || this.context);
    this.children.push(c);
    return c;
  }
}

// ─── src/analyzer/analyzer.js ──────────────────────────

class Analyzer {
  constructor(ast, filename = '<stdin>', options = {}) {
    this.ast = ast;
    this.filename = filename;
    this.errors = [];
    this.warnings = [];
    this.tolerant = options.tolerant || false;
    this.globalScope = new Scope(null, 'module');
    this.currentScope = this.globalScope;
    this._allScopes = []; // Track all scopes for unused variable checking
    this._functionReturnTypeStack = []; // Stack of expected return types for type checking
    this._asyncDepth = 0; // Track nesting inside async functions for await validation

    // Register built-in types
    this.registerBuiltins();
  }

  registerBuiltins() {
    const builtins = [
      'Int', 'Float', 'String', 'Bool', 'Nil', 'Any',
      'print', 'range', 'len', 'type_of', 'enumerate', 'zip',
      'map', 'filter', 'reduce', 'sum', 'sorted', 'reversed',
      'fetch', 'db',
      'Ok', 'Err', 'Some', 'None', 'Result', 'Option',
      // Collections
      'find', 'any', 'all', 'flat_map', 'unique', 'group_by',
      'chunk', 'flatten', 'take', 'drop', 'first', 'last',
      'count', 'partition',
      // Math
      'abs', 'floor', 'ceil', 'round', 'clamp', 'sqrt', 'pow', 'random',
      // Strings
      'trim', 'split', 'join', 'replace', 'repeat',
      // Utility
      'keys', 'values', 'entries', 'merge', 'freeze', 'clone',
      // Async
      'sleep',
      // String functions
      'upper', 'lower', 'contains', 'starts_with', 'ends_with',
      'chars', 'words', 'lines', 'capitalize', 'title_case',
      'snake_case', 'camel_case',
      // Math extras
      'min', 'max',
    ];
    for (const name of builtins) {
      this.globalScope.define(name, new Symbol(name, 'builtin', null, false, { line: 0, column: 0, file: '<builtin>' }));
    }
  }

  error(message, loc) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    this.errors.push({
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    });
  }

  warn(message, loc) {
    const l = loc || { line: 0, column: 0, file: this.filename };
    this.warnings.push({
      message,
      file: l.file || this.filename,
      line: l.line,
      column: l.column,
    });
  }

  analyze() {
    // Pre-pass: collect named server block functions for inter-server RPC validation
    this.serverBlockFunctions = new Map(); // blockName -> [functionName, ...]
    const collectFns = (stmts) => {
      const fns = [];
      for (const stmt of stmts) {
        if (stmt.type === 'FunctionDeclaration') {
          fns.push(stmt.name);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          fns.push(...collectFns(stmt.body));
        }
      }
      return fns;
    };
    for (const node of this.ast.body) {
      if (node.type === 'ServerBlock' && node.name) {
        const fns = collectFns(node.body);
        if (this.serverBlockFunctions.has(node.name)) {
          this.serverBlockFunctions.get(node.name).push(...fns);
        } else {
          this.serverBlockFunctions.set(node.name, fns);
        }
      }
    }

    this.visitProgram(this.ast);

    // Check for unused variables/imports (#9)
    this._collectAllScopes(this.globalScope);
    this._checkUnusedSymbols();

    if (this.errors.length > 0) {
      if (this.tolerant) {
        return { warnings: this.warnings, errors: this.errors, scope: this.globalScope };
      }
      const msgs = this.errors.map(e => `  ${e.file}:${e.line}:${e.column} — ${e.message}`);
      const err = new Error(`Analysis errors:\n${msgs.join('\n')}`);
      err.errors = this.errors;
      err.warnings = this.warnings;
      throw err;
    }

    return { warnings: this.warnings, scope: this.globalScope };
  }

  _checkUnusedSymbols() {
    for (const scope of this._allScopes) {
      // Only check inside functions, not module/server/client level
      if (!this._isScopeInsideFunction(scope)) continue;

      for (const [name, sym] of scope.symbols) {
        if (sym.kind === 'builtin') continue;
        if (name.startsWith('_')) continue;
        if (sym.kind === 'type') continue;
        if (sym.kind === 'parameter') continue;

        if (!sym.used && sym.loc && sym.loc.line > 0) {
          this.warn(`'${name}' is declared but never used`, sym.loc);
        }
      }
    }
  }

  _collectAllScopes(scope) {
    this._allScopes.push(scope);
    for (const child of scope.children) {
      this._collectAllScopes(child);
    }
  }

  _isScopeInsideFunction(scope) {
    let s = scope;
    while (s) {
      if (s.context === 'function') return true;
      if (s.context === 'module' || s.context === 'server' || s.context === 'client' || s.context === 'shared') return false;
      s = s.parent;
    }
    return false;
  }

  // ─── Type Inference ──────────────────────────────────────

  _inferType(expr) {
    if (!expr) return null;
    switch (expr.type) {
      case 'NumberLiteral':
        return Number.isInteger(expr.value) ? 'Int' : 'Float';
      case 'StringLiteral':
      case 'TemplateLiteral':
        return 'String';
      case 'BooleanLiteral':
        return 'Bool';
      case 'NilLiteral':
        return 'Nil';
      case 'ArrayLiteral':
        if (expr.elements.length > 0) {
          const elType = this._inferType(expr.elements[0]);
          return elType ? `[${elType}]` : '[Any]';
        }
        return '[Any]';
      case 'CallExpression':
        if (expr.callee.type === 'Identifier') {
          const name = expr.callee.name;
          if (name === 'Ok') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Result<${innerType}, _>` : 'Result';
          }
          if (name === 'Err') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Result<_, ${innerType}>` : 'Result';
          }
          if (name === 'Some') {
            const innerType = expr.arguments.length > 0 ? this._inferType(expr.arguments[0]) : null;
            return innerType ? `Option<${innerType}>` : 'Option';
          }
          if (name === 'len' || name === 'count') return 'Int';
          if (name === 'type_of') return 'String';
          if (name === 'random') return 'Float';
          // Look up declared return type from function symbol
          const fnSym = this.currentScope.lookup(name);
          if (fnSym && fnSym.kind === 'function') {
            if (fnSym._variantOf) return fnSym._variantOf;
            if (fnSym.type) return this._typeAnnotationToString(fnSym.type);
          }
        }
        return null;
      case 'Identifier':
        if (expr.name === 'None') return 'Option<_>';
        if (expr.name === 'true' || expr.name === 'false') return 'Bool';
        // Look up stored type
        const sym = this.currentScope.lookup(expr.name);
        return sym ? sym.inferredType : null;
      case 'TupleExpression':
        return `(${expr.elements.map(e => this._inferType(e) || 'Any').join(', ')})`;
      case 'BinaryExpression':
        if (expr.operator === '++') return 'String';
        if (['+', '-', '*', '/', '%', '**'].includes(expr.operator)) {
          const lt = this._inferType(expr.left);
          const rt = this._inferType(expr.right);
          if (lt === 'Float' || rt === 'Float') return 'Float';
          return 'Int';
        }
        if (['==', '!=', '<', '>', '<=', '>='].includes(expr.operator)) return 'Bool';
        return null;
      case 'UnaryExpression':
        if (expr.operator === 'not' || expr.operator === '!') return 'Bool';
        if (expr.operator === '-') return this._inferType(expr.operand);
        return null;
      case 'LogicalExpression':
        return 'Bool';
      default:
        return null;
    }
  }

  _typeAnnotationToString(ann) {
    if (!ann) return null;
    if (typeof ann === 'string') return ann;
    switch (ann.type) {
      case 'TypeAnnotation':
        if (ann.typeParams && ann.typeParams.length > 0) {
          const params = ann.typeParams.map(p => this._typeAnnotationToString(p)).join(', ');
          return `${ann.name}<${params}>`;
        }
        return ann.name;
      case 'ArrayTypeAnnotation':
        return `[${this._typeAnnotationToString(ann.elementType) || 'Any'}]`;
      case 'TupleTypeAnnotation':
        return `(${ann.elementTypes.map(t => this._typeAnnotationToString(t) || 'Any').join(', ')})`;
      case 'FunctionTypeAnnotation':
        return 'Function';
      default:
        return null;
    }
  }

  _parseGenericType(typeStr) {
    if (!typeStr) return { base: typeStr, params: [] };
    const ltIdx = typeStr.indexOf('<');
    if (ltIdx === -1) return { base: typeStr, params: [] };
    const base = typeStr.slice(0, ltIdx);
    const inner = typeStr.slice(ltIdx + 1, typeStr.lastIndexOf('>'));
    // Split on top-level commas (respecting nested <>)
    const params = [];
    let depth = 0;
    let start = 0;
    for (let i = 0; i < inner.length; i++) {
      if (inner[i] === '<') depth++;
      else if (inner[i] === '>') depth--;
      else if (inner[i] === ',' && depth === 0) {
        params.push(inner.slice(start, i).trim());
        start = i + 1;
      }
    }
    params.push(inner.slice(start).trim());
    return { base, params };
  }

  _typesCompatible(expected, actual) {
    // Unknown types are always compatible (gradual typing)
    if (!expected || !actual) return true;
    if (expected === 'Any' || actual === 'Any') return true;
    if (expected === '_' || actual === '_') return true;
    // Exact match
    if (expected === actual) return true;
    // Numeric compatibility: Int and Float are interchangeable
    const numerics = new Set(['Int', 'Float']);
    if (numerics.has(expected) && numerics.has(actual)) return true;
    // Nil is compatible with Option
    if (actual === 'Nil' && (expected === 'Option' || expected.startsWith('Option'))) return true;
    if ((expected === 'Nil') && (actual === 'Option' || actual.startsWith('Option'))) return true;
    // Array compatibility: check element types
    if (expected.startsWith('[') && actual.startsWith('[')) {
      const expEl = expected.slice(1, -1);
      const actEl = actual.slice(1, -1);
      return this._typesCompatible(expEl, actEl);
    }
    // Tuple compatibility: check element types pairwise
    if (expected.startsWith('(') && actual.startsWith('(')) {
      const expEls = expected.slice(1, -1).split(', ');
      const actEls = actual.slice(1, -1).split(', ');
      if (expEls.length !== actEls.length) return false;
      return expEls.every((e, i) => this._typesCompatible(e, actEls[i]));
    }
    // Generic type compatibility: Result<Int, String> vs Result<String, Int>
    const expG = this._parseGenericType(expected);
    const actG = this._parseGenericType(actual);
    if (expG.params.length > 0 || actG.params.length > 0) {
      // Base types must match
      if (expG.base !== actG.base) return false;
      // If one has no params (plain `Result`), compatible with any parameterized version (gradual typing)
      if (expG.params.length === 0 || actG.params.length === 0) return true;
      // Compare params pairwise
      if (expG.params.length !== actG.params.length) return false;
      return expG.params.every((ep, i) => this._typesCompatible(ep, actG.params[i]));
    }
    return false;
  }

  // ─── Visitors ─────────────────────────────────────────────

  visitProgram(node) {
    for (const stmt of node.body) {
      if (this.tolerant) {
        try { this.visitNode(stmt); } catch (e) { /* skip nodes that crash in tolerant mode */ }
      } else {
        this.visitNode(stmt);
      }
    }
  }

  visitNode(node) {
    if (!node) return;

    switch (node.type) {
      case 'ServerBlock': return this.visitServerBlock(node);
      case 'ClientBlock': return this.visitClientBlock(node);
      case 'SharedBlock': return this.visitSharedBlock(node);
      case 'Assignment': return this.visitAssignment(node);
      case 'VarDeclaration': return this.visitVarDeclaration(node);
      case 'LetDestructure': return this.visitLetDestructure(node);
      case 'FunctionDeclaration': return this.visitFunctionDeclaration(node);
      case 'TypeDeclaration': return this.visitTypeDeclaration(node);
      case 'ImportDeclaration': return this.visitImportDeclaration(node);
      case 'ImportDefault': return this.visitImportDefault(node);
      case 'ImportWildcard': return this.visitImportWildcard(node);
      case 'IfStatement': return this.visitIfStatement(node);
      case 'ForStatement': return this.visitForStatement(node);
      case 'WhileStatement': return this.visitWhileStatement(node);
      case 'TryCatchStatement': return this.visitTryCatchStatement(node);
      case 'ReturnStatement': return this.visitReturnStatement(node);
      case 'ExpressionStatement': return this.visitExpression(node.expression);
      case 'BlockStatement': return this.visitBlock(node);
      case 'CompoundAssignment': return this.visitCompoundAssignment(node);
      case 'BreakStatement': return this.visitBreakStatement(node);
      case 'ContinueStatement': return this.visitContinueStatement(node);
      case 'GuardStatement': return this.visitGuardStatement(node);
      case 'InterfaceDeclaration': return this.visitInterfaceDeclaration(node);
      case 'StateDeclaration': return this.visitStateDeclaration(node);
      case 'ComputedDeclaration': return this.visitComputedDeclaration(node);
      case 'EffectDeclaration': return this.visitEffectDeclaration(node);
      case 'ComponentDeclaration': return this.visitComponentDeclaration(node);
      case 'StoreDeclaration': return this.visitStoreDeclaration(node);
      case 'RouteDeclaration': return this.visitRouteDeclaration(node);
      case 'MiddlewareDeclaration': return this.visitMiddlewareDeclaration(node);
      case 'HealthCheckDeclaration': return this.visitHealthCheckDeclaration(node);
      case 'CorsDeclaration': return this.visitCorsDeclaration(node);
      case 'ErrorHandlerDeclaration': return this.visitErrorHandlerDeclaration(node);
      case 'WebSocketDeclaration': return this.visitWebSocketDeclaration(node);
      case 'StaticDeclaration': return this.visitStaticDeclaration(node);
      case 'DiscoverDeclaration': return this.visitDiscoverDeclaration(node);
      case 'AuthDeclaration': return this.visitAuthDeclaration(node);
      case 'MaxBodyDeclaration': return this.visitMaxBodyDeclaration(node);
      case 'RouteGroupDeclaration': return this.visitRouteGroupDeclaration(node);
      case 'RateLimitDeclaration': return this.visitRateLimitDeclaration(node);
      case 'LifecycleHookDeclaration': return this.visitLifecycleHookDeclaration(node);
      case 'SubscribeDeclaration': return this.visitSubscribeDeclaration(node);
      case 'EnvDeclaration': return this.visitEnvDeclaration(node);
      case 'ScheduleDeclaration': return this.visitScheduleDeclaration(node);
      case 'UploadDeclaration': return this.visitUploadDeclaration(node);
      case 'SessionDeclaration': return this.visitSessionDeclaration(node);
      case 'DbDeclaration': return this.visitDbDeclaration(node);
      case 'TlsDeclaration': return this.visitTlsDeclaration(node);
      case 'CompressionDeclaration': return this.visitCompressionDeclaration(node);
      case 'BackgroundJobDeclaration': return this.visitBackgroundJobDeclaration(node);
      case 'CacheDeclaration': return this.visitCacheDeclaration(node);
      case 'SseDeclaration': return this.visitSseDeclaration(node);
      case 'ModelDeclaration': return this.visitModelDeclaration(node);
      case 'TestBlock': return this.visitTestBlock(node);
      case 'ComponentStyleBlock': return; // raw CSS — no analysis needed
      case 'ImplDeclaration': return this.visitImplDeclaration(node);
      case 'TraitDeclaration': return this.visitTraitDeclaration(node);
      case 'TypeAlias': return this.visitTypeAlias(node);
      case 'DeferStatement': return this.visitDeferStatement(node);
      case 'ExternDeclaration': return this.visitExternDeclaration(node);
      default:
        // Expression nodes
        this.visitExpression(node);
    }
  }

  visitExpression(node) {
    if (!node) return;

    switch (node.type) {
      case 'Identifier':
        return this.visitIdentifier(node);
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NilLiteral':
        return;
      case 'TemplateLiteral':
        for (const part of node.parts) {
          if (part.type === 'expr') this.visitExpression(part.value);
        }
        return;
      case 'BinaryExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        this._checkBinaryExprTypes(node);
        return;
      case 'UnaryExpression':
        this.visitExpression(node.operand);
        return;
      case 'LogicalExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'ChainedComparison':
        for (const op of node.operands) this.visitExpression(op);
        return;
      case 'MembershipExpression':
        this.visitExpression(node.value);
        this.visitExpression(node.collection);
        return;
      case 'CallExpression':
        // Validate inter-server RPC calls: peerName.functionName()
        if (this._currentServerBlockName && node.callee.type === 'MemberExpression' &&
            node.callee.object.type === 'Identifier' && !node.callee.computed) {
          const targetName = node.callee.object.name;
          const fnName = node.callee.property;
          if (targetName === this._currentServerBlockName) {
            this.warn(`Server block "${targetName}" is calling itself via RPC — consider calling the function directly`, node.loc);
          } else if (this.serverBlockFunctions.has(targetName)) {
            const peerFns = this.serverBlockFunctions.get(targetName);
            if (!peerFns.includes(fnName)) {
              this.error(`No function '${fnName}' in server block "${targetName}"`, node.loc);
            }
          }
        }
        // Argument count and type validation for known functions
        this._checkCallArgCount(node);
        this._checkCallArgTypes(node);
        this.visitExpression(node.callee);
        for (const arg of node.arguments) {
          if (arg.type === 'NamedArgument') {
            this.visitExpression(arg.value);
          } else {
            this.visitExpression(arg);
          }
        }
        return;
      case 'MemberExpression':
      case 'OptionalChain':
        this.visitExpression(node.object);
        if (node.computed) this.visitExpression(node.property);
        return;
      case 'PipeExpression':
        this.visitExpression(node.left);
        this.visitExpression(node.right);
        return;
      case 'LambdaExpression':
        return this.visitLambda(node);
      case 'MatchExpression':
        return this.visitMatchExpression(node);
      case 'ArrayLiteral':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'ObjectLiteral':
        for (const prop of node.properties) {
          this.visitExpression(prop.key);
          this.visitExpression(prop.value);
        }
        return;
      case 'ListComprehension':
        return this.visitListComprehension(node);
      case 'DictComprehension':
        return this.visitDictComprehension(node);
      case 'RangeExpression':
        this.visitExpression(node.start);
        this.visitExpression(node.end);
        return;
      case 'SliceExpression':
        this.visitExpression(node.object);
        if (node.start) this.visitExpression(node.start);
        if (node.end) this.visitExpression(node.end);
        if (node.step) this.visitExpression(node.step);
        return;
      case 'SpreadExpression':
        this.visitExpression(node.argument);
        return;
      case 'PropagateExpression':
        this.visitExpression(node.expression);
        return;
      case 'AwaitExpression':
        if (this._asyncDepth === 0) {
          this.error("'await' can only be used inside an async function", node.loc);
        }
        this.visitExpression(node.argument);
        return;
      case 'YieldExpression':
        if (node.argument) this.visitExpression(node.argument);
        return;
      case 'TupleExpression':
        for (const el of node.elements) this.visitExpression(el);
        return;
      case 'IfExpression':
        this.visitExpression(node.condition);
        this.visitNode(node.consequent);
        for (const alt of node.alternates) {
          this.visitExpression(alt.condition);
          this.visitNode(alt.body);
        }
        this.visitNode(node.elseBody);
        return;
      case 'JSXElement':
        return this.visitJSXElement(node);
    }
  }

  // ─── Block visitors ───────────────────────────────────────

  visitServerBlock(node) {
    const prevScope = this.currentScope;
    const prevServerBlockName = this._currentServerBlockName;
    this._currentServerBlockName = node.name || null;
    this.currentScope = this.currentScope.child('server');

    try {
      // Register peer server block names as valid identifiers in this scope
      if (node.name && this.serverBlockFunctions.size > 0) {
        for (const [peerName] of this.serverBlockFunctions) {
          if (peerName !== node.name) {
            try {
              this.currentScope.define(peerName,
                new Symbol(peerName, 'builtin', null, false, { line: 0, column: 0, file: '<peer-server>' }));
            } catch (e) {
              // Ignore if already defined
            }
          }
        }
      }

      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
      this._currentServerBlockName = prevServerBlockName;
    }
  }

  visitClientBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('client');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitSharedBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('shared');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  }

  // ─── Declaration visitors ─────────────────────────────────

  visitAssignment(node) {
    // Visit values first (for type inference)
    for (const val of node.values) {
      this.visitExpression(val);
    }

    // Check if any target is already defined (immutable reassignment check)
    for (let i = 0; i < node.targets.length; i++) {
      const target = node.targets[i];
      const existing = this._lookupAssignTarget(target);
      if (existing) {
        if (!existing.mutable) {
          this.error(`Cannot reassign immutable variable '${target}'. Use 'var' for mutable variables.`, node.loc);
        }
        // Type check reassignment
        if (existing.inferredType && i < node.values.length) {
          const newType = this._inferType(node.values[i]);
          if (!this._typesCompatible(existing.inferredType, newType)) {
            this.warn(`Type mismatch: '${target}' is ${existing.inferredType}, but assigned ${newType}`, node.loc);
          }
        }
        existing.used = true;
      } else {
        // New binding — define in current scope with inferred type
        const inferredType = i < node.values.length ? this._inferType(node.values[i]) : null;
        // Warn if this shadows a variable from an outer function scope
        if (this._existsInOuterScope(target)) {
          this.warn(`Variable '${target}' shadows a binding in an outer scope`, node.loc);
        }
        try {
          const sym = new Symbol(target, 'variable', null, false, node.loc);
          sym.inferredType = inferredType;
          this.currentScope.define(target, sym);
        } catch (e) {
          this.error(e.message);
        }
      }
    }
  }

  visitVarDeclaration(node) {
    // Visit values first so type inference can work
    for (const val of node.values) {
      this.visitExpression(val);
    }
    for (let i = 0; i < node.targets.length; i++) {
      const target = node.targets[i];
      const inferredType = i < node.values.length ? this._inferType(node.values[i]) : null;
      try {
        const sym = new Symbol(target, 'variable', null, true, node.loc);
        sym.inferredType = inferredType;
        this.currentScope.define(target, sym);
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  visitLetDestructure(node) {
    this.visitExpression(node.value);

    if (node.pattern.type === 'ObjectPattern') {
      for (const prop of node.pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (node.pattern.type === 'ArrayPattern' || node.pattern.type === 'TuplePattern') {
      for (const el of node.pattern.elements) {
        if (el) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'variable', null, false, node.loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitFunctionDeclaration(node) {
    try {
      const sym = new Symbol(node.name, 'function', node.returnType, false, node.loc);
      sym._params = node.params.map(p => p.name);
      sym._totalParamCount = node.params.length;
      sym._requiredParamCount = node.params.filter(p => !p.defaultValue).length;
      sym._paramTypes = node.params.map(p => p.typeAnnotation || null);
      this.currentScope.define(node.name, sym);
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');

    // Push expected return type for return-statement checking
    const expectedReturn = node.returnType ? this._typeAnnotationToString(node.returnType) : null;
    this._functionReturnTypeStack.push(expectedReturn);
    if (node.isAsync) this._asyncDepth++;

    try {
      for (const param of node.params) {
        if (param.destructure) {
          this._defineDestructureParams(param.destructure, param.loc);
        } else {
          try {
            const paramSym = new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc);
            paramSym.inferredType = param.typeAnnotation ? this._typeAnnotationToString(param.typeAnnotation) : null;
            this.currentScope.define(param.name, paramSym);
          } catch (e) {
            this.error(e.message);
          }
        }
        if (param.defaultValue) {
          this.visitExpression(param.defaultValue);
        }
      }

      this.visitNode(node.body);

      // Return path analysis: check that all paths return a value
      if (expectedReturn && node.body.type === 'BlockStatement') {
        if (!this._definitelyReturns(node.body)) {
          this.warn(`Function '${node.name}' declares return type ${expectedReturn} but not all code paths return a value`, node.loc);
        }
      }
    } finally {
      if (node.isAsync) this._asyncDepth--;
      this._functionReturnTypeStack.pop();
      this.currentScope = prevScope;
    }
  }

  visitExternDeclaration(node) {
    const sym = new Symbol(node.name, 'function', node.returnType, false, node.loc);
    sym._params = node.params.map(p => p.name || `arg${node.params.indexOf(p)}`);
    sym._totalParamCount = node.params.length;
    sym._requiredParamCount = node.params.filter(p => !p.defaultValue).length;
    sym._paramTypes = node.params.map(p => p.typeAnnotation || null);
    sym.extern = true;
    sym.isAsync = node.isAsync;
    // Extern declarations can override builtins (they provide more precise type info)
    const existing = this.currentScope.lookupLocal(node.name);
    if (existing && existing.kind === 'builtin') {
      this.currentScope.symbols.set(node.name, sym);
    } else {
      try {
        this.currentScope.define(node.name, sym);
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  _defineDestructureParams(pattern, loc) {
    if (pattern.type === 'ObjectPattern') {
      for (const prop of pattern.properties) {
        try {
          this.currentScope.define(prop.value,
            new Symbol(prop.value, 'parameter', null, false, loc));
        } catch (e) {
          this.error(e.message);
        }
      }
    } else if (pattern.type === 'ArrayPattern' || pattern.type === 'TuplePattern') {
      for (const el of pattern.elements) {
        if (el) {
          try {
            this.currentScope.define(el,
              new Symbol(el, 'parameter', null, false, loc));
          } catch (e) {
            this.error(e.message);
          }
        }
      }
    }
  }

  visitTypeDeclaration(node) {
    try {
      const typeSym = new Symbol(node.name, 'type', null, false, node.loc);
      typeSym._typeParams = node.typeParams || [];
      this.currentScope.define(node.name, typeSym);
    } catch (e) {
      this.error(e.message);
    }

    // Define variant constructors as functions
    for (const variant of node.variants) {
      if (variant.type === 'TypeVariant') {
        try {
          const varSym = new Symbol(variant.name, 'function', null, false, variant.loc);
          varSym._params = variant.fields.map(f => f.name);
          varSym._totalParamCount = variant.fields.length;
          varSym._requiredParamCount = variant.fields.length;
          varSym._variantOf = node.name;
          varSym._paramTypes = variant.fields.map(f => f.typeAnnotation || null);
          this.currentScope.define(variant.name, varSym);
        } catch (e) {
          this.error(e.message);
        }
      }
    }
  }

  visitImportDeclaration(node) {
    for (const spec of node.specifiers) {
      try {
        this.currentScope.define(spec.local,
          new Symbol(spec.local, 'variable', null, false, spec.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
  }

  visitImportDefault(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  visitImportWildcard(node) {
    try {
      this.currentScope.define(node.local,
        new Symbol(node.local, 'module', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  // ─── Statement visitors ───────────────────────────────────

  visitBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      for (const stmt of node.body) {
        this.visitNode(stmt);
      }
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitIfStatement(node) {
    this.visitExpression(node.condition);
    this.visitNode(node.consequent);
    for (const alt of node.alternates) {
      this.visitExpression(alt.condition);
      this.visitNode(alt.body);
    }
    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
  }

  visitForStatement(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;

    try {
      this.visitExpression(node.iterable);

      // Define loop variable(s)
      const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
      for (const v of vars) {
        try {
          this.currentScope.define(v,
            new Symbol(v, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }

      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }

    if (node.elseBody) {
      this.visitNode(node.elseBody);
    }
  }

  visitWhileStatement(node) {
    this.visitExpression(node.condition);
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    this.currentScope._isLoop = true;
    try {
      this.visitNode(node.body);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitTryCatchStatement(node) {
    const prevScope = this.currentScope;

    this.currentScope = prevScope.child('block');
    try {
      for (const stmt of node.tryBody) this.visitNode(stmt);
    } finally {
      this.currentScope = prevScope;
    }

    if (node.catchBody) {
      this.currentScope = prevScope.child('block');
      try {
        if (node.catchParam) {
          this.currentScope.define(node.catchParam, new Symbol(node.catchParam, 'variable', null, false, node.loc));
        }
        for (const stmt of node.catchBody) this.visitNode(stmt);
      } finally {
        this.currentScope = prevScope;
      }
    }

    if (node.finallyBody) {
      this.currentScope = prevScope.child('block');
      try {
        for (const stmt of node.finallyBody) this.visitNode(stmt);
      } finally {
        this.currentScope = prevScope;
      }
    }
  }

  visitReturnStatement(node) {
    if (node.value) {
      this.visitExpression(node.value);
    }
    // Return must be inside a function
    if (this._functionReturnTypeStack.length === 0) {
      this.error("'return' can only be used inside a function", node.loc);
      return;
    }
    // Check return type against declared function return type
    if (this._functionReturnTypeStack.length > 0) {
      const expectedReturn = this._functionReturnTypeStack[this._functionReturnTypeStack.length - 1];
      if (expectedReturn) {
        const actualType = node.value ? this._inferType(node.value) : 'Nil';
        if (!this._typesCompatible(expectedReturn, actualType)) {
          this.error(`Type mismatch: function expects return type ${expectedReturn}, but got ${actualType}`, node.loc);
        }
      }
    }
  }

  visitCompoundAssignment(node) {
    // Target must be mutable
    if (node.target.type === 'Identifier') {
      const sym = this.currentScope.lookup(node.target.name);
      if (sym && !sym.mutable && sym.kind !== 'builtin') {
        this.error(`Cannot use '${node.operator}' on immutable variable '${node.target.name}'`, node.loc);
      }
      // Type check compound assignment
      if (sym && sym.inferredType) {
        const op = node.operator;
        const numerics = new Set(['Int', 'Float']);
        if (['-=', '*=', '/='].includes(op)) {
          if (!numerics.has(sym.inferredType) && sym.inferredType !== 'Any') {
            this.warn(`Type mismatch: '${op}' requires numeric type, but '${node.target.name}' is ${sym.inferredType}`, node.loc);
          }
          const valType = this._inferType(node.value);
          if (valType && !numerics.has(valType) && valType !== 'Any') {
            this.warn(`Type mismatch: '${op}' requires numeric value, but got ${valType}`, node.loc);
          }
        } else if (op === '+=') {
          // += on numerics requires numeric value, on strings requires string
          if (numerics.has(sym.inferredType)) {
            const valType = this._inferType(node.value);
            if (valType && !numerics.has(valType) && valType !== 'Any') {
              this.warn(`Type mismatch: '${op}' on numeric variable requires numeric value, but got ${valType}`, node.loc);
            }
          } else if (sym.inferredType === 'String') {
            const valType = this._inferType(node.value);
            if (valType && valType !== 'String' && valType !== 'Any') {
              this.warn(`Type mismatch: '${op}' on String variable requires String value, but got ${valType}`, node.loc);
            }
          }
        }
      }
    }
    this.visitExpression(node.target);
    this.visitExpression(node.value);
  }

  // ─── Client-specific visitors ─────────────────────────────

  visitStateDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'state' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'state', node.typeAnnotation, true, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.initialValue);
  }

  visitComputedDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'computed' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'computed', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    this.visitExpression(node.expression);
  }

  visitEffectDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'effect' can only be used inside a client block`, node.loc);
    }
    this.visitNode(node.body);
  }

  visitComponentDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'component' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'component', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    for (const child of node.body) {
      this.visitNode(child);
    }
    this.currentScope = prevScope;
  }

  visitStoreDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'client') {
      this.error(`'store' can only be used inside a client block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'variable', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }

    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    for (const child of node.body) {
      this.visitNode(child);
    }
    this.currentScope = prevScope;
  }

  visitRouteDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'route' can only be used inside a server block`, node.loc);
    }
    this.visitExpression(node.handler);

    // Route param ↔ handler signature type safety
    if (node.handler.type === 'Identifier') {
      const handlerName = node.handler.name;
      // Find the function declaration in the current server block scope
      const fnSym = this.currentScope.lookup(handlerName);
      if (fnSym && fnSym.kind === 'function' && fnSym._params) {
        const pathParams = new Set();
        const pathStr = node.path || '';
        const paramMatches = pathStr.match(/:([a-zA-Z_][a-zA-Z0-9_]*)/g);
        if (paramMatches) {
          for (const m of paramMatches) pathParams.add(m.slice(1));
        }
        const handlerParams = fnSym._params.filter(p => p !== 'req');
        for (const hp of handlerParams) {
          if (pathParams.size > 0 && !pathParams.has(hp) && node.method.toUpperCase() === 'GET') {
            // For GET routes, params not in path come from query — this is fine, just a warning
            this.warn(`Handler '${handlerName}' param '${hp}' not in route path '${pathStr}' — will be extracted from query string`, node.loc);
          }
        }
      }
    }
  }

  visitMiddlewareDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'middleware' can only be used inside a server block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitHealthCheckDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'health' can only be used inside a server block`, node.loc);
    }
  }

  visitCorsDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'cors' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitErrorHandlerDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'on_error' can only be used inside a server block`, node.loc);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitWebSocketDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'ws' can only be used inside a server block`, node.loc);
    }
    for (const [, handler] of Object.entries(node.handlers)) {
      if (!handler) continue;
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('function');
      for (const param of handler.params) {
        try {
          this.currentScope.define(param.name,
            new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
      this.visitNode(handler.body);
      this.currentScope = prevScope;
    }
  }

  visitStaticDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'static' can only be used inside a server block`, node.loc);
    }
  }

  visitDiscoverDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'discover' can only be used inside a server block`, node.loc);
    }
    this.visitExpression(node.urlExpression);
  }

  visitAuthDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'auth' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitMaxBodyDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'max_body' can only be used inside a server block`, node.loc);
    }
    this.visitExpression(node.limit);
  }

  visitRouteGroupDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'routes' can only be used inside a server block`, node.loc);
    }
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
  }

  visitRateLimitDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'rate_limit' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitLifecycleHookDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'on_${node.hook}' can only be used inside a server block`, node.loc);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitSubscribeDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'subscribe' can only be used inside a server block`, node.loc);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitEnvDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'env' can only be used inside a server block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'variable', node.typeAnnotation, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    if (node.defaultValue) {
      this.visitExpression(node.defaultValue);
    }
  }

  visitScheduleDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'schedule' can only be used inside a server block`, node.loc);
    }
    if (node.name) {
      try {
        this.currentScope.define(node.name,
          new Symbol(node.name, 'function', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitUploadDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'upload' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitSessionDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'session' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitDbDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'db' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitTlsDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'tls' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitCompressionDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'compression' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitBackgroundJobDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'background' can only be used inside a server block`, node.loc);
    }
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'function', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');
    for (const param of node.params) {
      try {
        this.currentScope.define(param.name,
          new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc));
      } catch (e) {
        this.error(e.message);
      }
    }
    this.visitNode(node.body);
    this.currentScope = prevScope;
  }

  visitCacheDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'cache' can only be used inside a server block`, node.loc);
    }
    for (const value of Object.values(node.config)) {
      this.visitExpression(value);
    }
  }

  visitSseDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'sse' can only be used inside a server block`, node.loc);
    }
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    for (const p of node.params) {
      this.currentScope.define(p.name, { kind: 'param' });
    }
    for (const stmt of node.body.body || []) {
      this.visitNode(stmt);
    }
    this.currentScope = prevScope;
  }

  visitModelDeclaration(node) {
    const ctx = this.currentScope.getContext();
    if (ctx !== 'server') {
      this.error(`'model' can only be used inside a server block`, node.loc);
    }
    if (node.config) {
      for (const value of Object.values(node.config)) {
        this.visitExpression(value);
      }
    }
  }

  visitTestBlock(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    for (const stmt of node.body) {
      this.visitNode(stmt);
    }
    this.currentScope = prevScope;
  }

  // ─── Expression visitors ──────────────────────────────────

  visitIdentifier(node) {
    if (node.name === '_') return; // wildcard is always valid
    if (node.name === PIPE_TARGET) return; // pipe target placeholder from method pipe

    const sym = this.currentScope.lookup(node.name);
    if (!sym) {
      if (!this._isKnownGlobal(node.name)) {
        this.warn(`'${node.name}' is not defined`, node.loc);
      }
    } else {
      sym.used = true;
    }
  }

  _isKnownGlobal(name) {
    const jsGlobals = new Set([
      // JS built-ins
      'console', 'document', 'window', 'globalThis', 'self',
      'JSON', 'Math', 'Date', 'RegExp', 'Error', 'TypeError', 'RangeError',
      'Promise', 'Set', 'Map', 'WeakSet', 'WeakMap', 'Symbol',
      'Array', 'Object', 'String', 'Number', 'Boolean', 'Function',
      'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'NaN', 'Infinity',
      'undefined', 'null', 'true', 'false',
      'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
      'queueMicrotask', 'structuredClone',
      'URL', 'URLSearchParams', 'Headers', 'Request', 'Response',
      'FormData', 'Blob', 'File', 'FileReader',
      'AbortController', 'AbortSignal',
      'TextEncoder', 'TextDecoder',
      'crypto', 'performance', 'navigator', 'location', 'history',
      'localStorage', 'sessionStorage',
      'fetch', 'alert', 'confirm', 'prompt',
      'Bun', 'Deno', 'process', 'require', 'module', 'exports', '__dirname', '__filename',
      'Buffer', 'atob', 'btoa',
      // Tova runtime
      'print', 'range', 'len', 'type_of', 'enumerate', 'zip',
      'map', 'filter', 'reduce', 'sum', 'sorted', 'reversed',
      'Ok', 'Err', 'Some', 'None', 'Result', 'Option',
      'db', 'server', 'client', 'shared',
      // Tova stdlib — collections
      'find', 'any', 'all', 'flat_map', 'unique', 'group_by',
      'chunk', 'flatten', 'take', 'drop', 'first', 'last',
      'count', 'partition',
      // Tova stdlib — math
      'abs', 'floor', 'ceil', 'round', 'clamp', 'sqrt', 'pow', 'random',
      // Tova stdlib — strings
      'trim', 'split', 'join', 'replace', 'repeat',
      // Tova stdlib — utility
      'keys', 'values', 'entries', 'merge', 'freeze', 'clone',
      // Tova stdlib — async
      'sleep',
    ]);
    return jsGlobals.has(name);
  }

  visitLambda(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('function');

    const expectedReturn = node.returnType ? this._typeAnnotationToString(node.returnType) : null;
    this._functionReturnTypeStack.push(expectedReturn);
    if (node.isAsync) this._asyncDepth++;

    try {
      for (const param of node.params) {
        try {
          const paramSym = new Symbol(param.name, 'parameter', param.typeAnnotation, false, param.loc);
          paramSym.inferredType = param.typeAnnotation ? this._typeAnnotationToString(param.typeAnnotation) : null;
          this.currentScope.define(param.name, paramSym);
        } catch (e) {
          this.error(e.message);
        }
      }
      if (node.body.type === 'BlockStatement') {
        this.visitNode(node.body);
        // Return path analysis for lambdas with block bodies and declared return types
        if (expectedReturn && !this._definitelyReturns(node.body)) {
          this.warn(`Lambda declares return type ${expectedReturn} but not all code paths return a value`, node.loc);
        }
      } else {
        // Single-expression body — always returns implicitly
        this.visitExpression(node.body);
      }
    } finally {
      if (node.isAsync) this._asyncDepth--;
      this._functionReturnTypeStack.pop();
      this.currentScope = prevScope;
    }
  }

  visitMatchExpression(node) {
    this.visitExpression(node.subject);
    for (const arm of node.arms) {
      const prevScope = this.currentScope;
      this.currentScope = this.currentScope.child('block');

      try {
        this.visitPattern(arm.pattern);
        if (arm.guard) this.visitExpression(arm.guard);

        if (arm.body.type === 'BlockStatement') {
          this.visitNode(arm.body);
        } else {
          this.visitExpression(arm.body);
        }
      } finally {
        this.currentScope = prevScope;
      }
    }

    // Exhaustive match checking (#12)
    this._checkMatchExhaustiveness(node);
  }

  _checkMatchExhaustiveness(node) {
    // Check if the match has a wildcard/binding catch-all
    const hasWildcard = node.arms.some(arm =>
      arm.pattern.type === 'WildcardPattern' ||
      (arm.pattern.type === 'BindingPattern' && !arm.guard)
    );
    if (hasWildcard) return; // Catch-all exists, always exhaustive

    // If subject is an identifier, try to find its type for variant checking
    const variantNames = new Set();
    const coveredVariants = new Set();

    // Collect all variant patterns used in the match
    for (const arm of node.arms) {
      if (arm.pattern.type === 'VariantPattern') {
        coveredVariants.add(arm.pattern.name);
      }
    }

    // If we have variant patterns, check if all known variants are covered
    if (coveredVariants.size > 0) {
      // Check built-in Result/Option types
      if (coveredVariants.has('Ok') || coveredVariants.has('Err')) {
        if (!coveredVariants.has('Ok')) {
          this.warn(`Non-exhaustive match: missing 'Ok' variant`, node.loc);
        }
        if (!coveredVariants.has('Err')) {
          this.warn(`Non-exhaustive match: missing 'Err' variant`, node.loc);
        }
      }
      if (coveredVariants.has('Some') || coveredVariants.has('None')) {
        if (!coveredVariants.has('Some')) {
          this.warn(`Non-exhaustive match: missing 'Some' variant`, node.loc);
        }
        if (!coveredVariants.has('None')) {
          this.warn(`Non-exhaustive match: missing 'None' variant`, node.loc);
        }
      }

      // Check user-defined types — look up in _variantFields from the global scope
      // Collect all known type variants by iterating type declarations
      for (const topNode of this.ast.body) {
        this._collectTypeVariants(topNode, variantNames, coveredVariants, node.loc);
      }
    }
  }

  _collectTypeVariants(node, allVariants, coveredVariants, matchLoc) {
    if (node.type === 'TypeDeclaration') {
      const typeVariants = node.variants.filter(v => v.type === 'TypeVariant').map(v => v.name);
      // If any of the match arms reference a variant from this type, check all
      const relevantVariants = typeVariants.filter(v => coveredVariants.has(v));
      if (relevantVariants.length > 0) {
        for (const v of typeVariants) {
          if (!coveredVariants.has(v)) {
            this.warn(`Non-exhaustive match: missing '${v}' variant from type '${node.name}'`, matchLoc);
          }
        }
      }
    }
    // Recurse into blocks
    if (node.type === 'SharedBlock' || node.type === 'ServerBlock' || node.type === 'ClientBlock') {
      for (const child of node.body) {
        this._collectTypeVariants(child, allVariants, coveredVariants, matchLoc);
      }
    }
  }

  visitPattern(pattern) {
    if (!pattern) return;

    switch (pattern.type) {
      case 'WildcardPattern':
      case 'LiteralPattern':
      case 'RangePattern':
        break;
      case 'BindingPattern':
        try {
          this.currentScope.define(pattern.name,
            new Symbol(pattern.name, 'variable', null, false, pattern.loc));
        } catch (e) {
          this.error(e.message);
        }
        break;
      case 'VariantPattern':
        for (const field of pattern.fields) {
          if (typeof field === 'string') {
            // Legacy: plain string field names
            try {
              this.currentScope.define(field,
                new Symbol(field, 'variable', null, false, pattern.loc));
            } catch (e) {
              this.error(e.message);
            }
          } else {
            // Nested pattern (e.g., Some(Ok(value)))
            this.visitPattern(field);
          }
        }
        break;
      case 'ArrayPattern':
      case 'TuplePattern':
        if (pattern.elements) {
          for (const el of pattern.elements) {
            this.visitPattern(el);
          }
        }
        break;
      case 'StringConcatPattern':
        if (pattern.rest) {
          this.visitPattern(pattern.rest);
        }
        break;
    }
  }

  visitListComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    try {
      this.visitExpression(node.iterable);
      try {
        this.currentScope.define(node.variable,
          new Symbol(node.variable, 'variable', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
      if (node.condition) this.visitExpression(node.condition);
      this.visitExpression(node.expression);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitDictComprehension(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');

    try {
      this.visitExpression(node.iterable);
      for (const v of node.variables) {
        try {
          this.currentScope.define(v,
            new Symbol(v, 'variable', null, false, node.loc));
        } catch (e) {
          this.error(e.message);
        }
      }
      if (node.condition) this.visitExpression(node.condition);
      this.visitExpression(node.key);
      this.visitExpression(node.value);
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitJSXElement(node) {
    for (const attr of node.attributes) {
      if (attr.type === 'JSXSpreadAttribute') {
        this.visitExpression(attr.expression);
      } else {
        this.visitExpression(attr.value);
      }
    }
    for (const child of node.children) {
      if (child.type === 'JSXElement') {
        this.visitJSXElement(child);
      } else if (child.type === 'JSXExpression') {
        this.visitExpression(child.expression);
      } else if (child.type === 'JSXFor') {
        this.visitJSXFor(child);
      } else if (child.type === 'JSXIf') {
        this.visitJSXIf(child);
      }
    }
  }

  visitJSXFor(node) {
    const prevScope = this.currentScope;
    this.currentScope = this.currentScope.child('block');
    try {
      this.visitExpression(node.iterable);
      try {
        this.currentScope.define(node.variable,
          new Symbol(node.variable, 'variable', null, false, node.loc));
      } catch (e) {
        this.error(e.message);
      }
      for (const child of node.body) {
        this.visitNode(child);
      }
    } finally {
      this.currentScope = prevScope;
    }
  }

  visitJSXIf(node) {
    this.visitExpression(node.condition);
    for (const child of node.consequent) {
      this.visitNode(child);
    }
    if (node.alternates) {
      for (const alt of node.alternates) {
        this.visitExpression(alt.condition);
        for (const child of alt.body) {
          this.visitNode(child);
        }
      }
    }
    if (node.alternate) {
      for (const child of node.alternate) {
        this.visitNode(child);
      }
    }
  }

  // ─── New feature visitors ─────────────────────────────────

  visitBreakStatement(node) {
    if (!this._isInsideLoop()) {
      this.error("'break' can only be used inside a loop", node.loc);
    }
  }

  visitContinueStatement(node) {
    if (!this._isInsideLoop()) {
      this.error("'continue' can only be used inside a loop", node.loc);
    }
  }

  _definitelyReturns(node) {
    if (!node) return false;
    switch (node.type) {
      case 'ReturnStatement':
        return true;
      case 'BlockStatement':
        if (node.body.length === 0) return false;
        return this._definitelyReturns(node.body[node.body.length - 1]);
      case 'IfStatement':
        if (!node.elseBody) return false;
        const consequentReturns = this._definitelyReturns(node.consequent);
        const elseReturns = this._definitelyReturns(node.elseBody);
        const allAlternatesReturn = (node.alternates || []).every(alt => this._definitelyReturns(alt.body));
        return consequentReturns && elseReturns && allAlternatesReturn;
      case 'GuardStatement':
        // Guard's else block always runs if condition fails — if it returns, the guard is a definite return path
        return this._definitelyReturns(node.elseBody);
      case 'MatchExpression': {
        const hasWildcard = node.arms.some(arm =>
          arm.pattern.type === 'WildcardPattern' ||
          (arm.pattern.type === 'BindingPattern' && !arm.guard)
        );
        if (!hasWildcard) return false;
        return node.arms.every(arm => this._definitelyReturns(arm.body));
      }
      case 'TryCatchStatement': {
        const tryReturns = node.tryBody.length > 0 &&
          this._definitelyReturns(node.tryBody[node.tryBody.length - 1]);
        const catchReturns = !node.catchBody || (node.catchBody.length > 0 &&
          this._definitelyReturns(node.catchBody[node.catchBody.length - 1]));
        return tryReturns && catchReturns;
      }
      case 'ExpressionStatement':
        return this._definitelyReturns(node.expression);
      default:
        return false;
    }
  }

  _checkCallArgCount(node) {
    if (node.callee.type !== 'Identifier') return;
    const fnSym = this.currentScope.lookup(node.callee.name);
    if (!fnSym || fnSym.kind === 'builtin' || fnSym._totalParamCount === undefined) return;

    // Skip check if any argument uses spread (unknown count)
    const hasSpread = node.arguments.some(a => a.type === 'SpreadExpression');
    if (hasSpread) return;

    const actualCount = node.arguments.length;
    const name = node.callee.name;

    if (actualCount > fnSym._totalParamCount) {
      this.warn(`'${name}' expects ${fnSym._totalParamCount} argument${fnSym._totalParamCount !== 1 ? 's' : ''}, but got ${actualCount}`, node.loc);
    } else if (actualCount < fnSym._requiredParamCount) {
      this.warn(`'${name}' expects at least ${fnSym._requiredParamCount} argument${fnSym._requiredParamCount !== 1 ? 's' : ''}, but got ${actualCount}`, node.loc);
    }
  }

  _checkCallArgTypes(node) {
    if (node.callee.type !== 'Identifier') return;
    const fnSym = this.currentScope.lookup(node.callee.name);
    if (!fnSym || fnSym.kind === 'builtin' || !fnSym._paramTypes) return;

    const hasSpread = node.arguments.some(a => a.type === 'SpreadExpression');
    if (hasSpread) return;

    for (let i = 0; i < node.arguments.length && i < fnSym._paramTypes.length; i++) {
      const arg = node.arguments[i];
      if (arg.type === 'NamedArgument' || arg.type === 'SpreadExpression') continue;
      const paramTypeAnn = fnSym._paramTypes[i];
      if (!paramTypeAnn) continue;
      const expectedType = this._typeAnnotationToString(paramTypeAnn);
      const actualType = this._inferType(arg);
      if (!this._typesCompatible(expectedType, actualType)) {
        const paramName = fnSym._params ? fnSym._params[i] : `argument ${i + 1}`;
        this.error(`Type mismatch: '${paramName}' expects ${expectedType}, but got ${actualType}`, arg.loc || node.loc);
      }
    }
  }

  _checkBinaryExprTypes(node) {
    const op = node.operator;
    const leftType = this._inferType(node.left);
    const rightType = this._inferType(node.right);

    if (op === '++') {
      // String concatenation: both sides should be String
      if (leftType && leftType !== 'String' && leftType !== 'Any') {
        this.warn(`Type mismatch: '++' expects String on left side, but got ${leftType}`, node.loc);
      }
      if (rightType && rightType !== 'String' && rightType !== 'Any') {
        this.warn(`Type mismatch: '++' expects String on right side, but got ${rightType}`, node.loc);
      }
    } else if (['-', '*', '/', '%', '**'].includes(op)) {
      // Arithmetic: both sides must be numeric
      const numerics = new Set(['Int', 'Float']);
      if (leftType && !numerics.has(leftType) && leftType !== 'Any') {
        this.warn(`Type mismatch: '${op}' expects numeric type, but got ${leftType}`, node.loc);
      }
      if (rightType && !numerics.has(rightType) && rightType !== 'Any') {
        this.warn(`Type mismatch: '${op}' expects numeric type, but got ${rightType}`, node.loc);
      }
    } else if (op === '+') {
      // Addition: both sides must be numeric (Tova uses ++ for strings)
      const numerics = new Set(['Int', 'Float']);
      if (leftType && !numerics.has(leftType) && leftType !== 'Any') {
        this.warn(`Type mismatch: '+' expects numeric type, but got ${leftType}`, node.loc);
      }
      if (rightType && !numerics.has(rightType) && rightType !== 'Any') {
        this.warn(`Type mismatch: '+' expects numeric type, but got ${rightType}`, node.loc);
      }
    }
  }

  // Search for a variable from current scope up to the nearest function/module boundary.
  // This ensures `x = 20` inside an if/for block finds `x = 10` from the enclosing function,
  // preventing silent shadowing of immutable bindings within the same function.
  _lookupAssignTarget(name) {
    let scope = this.currentScope;
    while (scope) {
      const sym = scope.symbols.get(name);
      if (sym) return sym;
      // Stop after checking a function or top-level scope (don't cross function boundaries)
      if (scope.context === 'function' || scope.context === 'module' ||
          scope.context === 'server' || scope.context === 'client' || scope.context === 'shared') {
        break;
      }
      scope = scope.parent;
    }
    return null;
  }

  // Check if a name exists in any outer scope beyond the current function boundary.
  // Used to warn about shadowing of outer variables.
  _existsInOuterScope(name) {
    let scope = this.currentScope;
    let crossedBoundary = false;
    while (scope) {
      if (!crossedBoundary && (scope.context === 'function' || scope.context === 'module' ||
          scope.context === 'server' || scope.context === 'client' || scope.context === 'shared')) {
        crossedBoundary = true;
        scope = scope.parent;
        continue;
      }
      if (crossedBoundary) {
        const sym = scope.symbols.get(name);
        if (sym) return true;
      }
      scope = scope.parent;
    }
    return false;
  }

  pushScope(context) {
    this.currentScope = this.currentScope.child(context);
  }

  popScope() {
    this.currentScope = this.currentScope.parent;
  }

  _isInsideLoop() {
    // Walk up the AST context — check if any parent is a for/while loop scope
    // Stop at function boundaries so break/continue inside lambdas is rejected
    let scope = this.currentScope;
    while (scope) {
      if (scope._isLoop) return true;
      if (scope.context === 'function') return false;
      scope = scope.parent;
    }
    return false;
  }

  visitGuardStatement(node) {
    this.visitExpression(node.condition);
    this.visitNode(node.elseBody);
  }

  visitInterfaceDeclaration(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'type', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  visitImplDeclaration(node) {
    // Validate that methods reference the type
    for (const method of node.methods) {
      this.pushScope('function');
      try {
        // self is implicitly available
        try {
          this.currentScope.define('self',
            new Symbol('self', 'variable', null, true, method.loc));
        } catch (e) { /* ignore */ }
        for (const p of method.params) {
          if (p.name && p.name !== 'self') {
            try {
              this.currentScope.define(p.name,
                new Symbol(p.name, 'variable', null, false, p.loc));
            } catch (e) { /* ignore */ }
          }
        }
        if (method.body) {
          this.visitBlock(method.body);
        }
      } finally {
        this.popScope();
      }
    }
  }

  visitTraitDeclaration(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'type', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
    // Visit default implementations
    for (const method of node.methods) {
      if (method.body) {
        this.pushScope('function');
        try {
          for (const p of method.params) {
            if (p.name) {
              try {
                this.currentScope.define(p.name,
                  new Symbol(p.name, 'variable', null, false, p.loc || node.loc));
              } catch (e) { /* ignore */ }
            }
          }
          this.visitBlock(method.body);
        } finally {
          this.popScope();
        }
      }
    }
  }

  visitTypeAlias(node) {
    try {
      this.currentScope.define(node.name,
        new Symbol(node.name, 'type', null, false, node.loc));
    } catch (e) {
      this.error(e.message);
    }
  }

  visitDeferStatement(node) {
    // Validate defer is inside a function
    let scope = this.currentScope;
    let insideFunction = false;
    while (scope) {
      if (scope.context === 'function') {
        insideFunction = true;
        break;
      }
      scope = scope.parent;
    }
    if (!insideFunction) {
      this.warn("'defer' used outside of a function", node.loc);
    }
    if (node.body) {
      if (node.body.type === 'BlockStatement') {
        this.visitBlock(node.body);
      } else {
        this.visitExpression(node.body);
      }
    }
  }
}

// ─── src/stdlib/inline.js ──────────────────────────────

// Tova standard library — inline string versions for codegen
// Single source of truth for all inline stdlib code used in code generation.
// Used by: base-codegen.js, client-codegen.js, bin/tova.js
const RESULT_OPTION = `function Ok(value) { return Object.freeze({ __tag: "Ok", value, map(fn) { return Ok(fn(value)); }, flatMap(fn) { const r = fn(value); if (r && r.__tag) return r; throw new Error("flatMap callback must return Ok/Err"); }, unwrap() { return value; }, unwrapOr(_) { return value; }, expect(_) { return value; }, isOk() { return true; }, isErr() { return false; }, mapErr(_) { return this; }, unwrapErr() { throw new Error("Called unwrapErr on Ok"); }, or(_) { return this; }, and(other) { return other; } }); }
function Err(error) { return Object.freeze({ __tag: "Err", error, map(_) { return this; }, flatMap(_) { return this; }, unwrap() { throw new Error("Called unwrap on Err: " + (typeof error === "object" ? JSON.stringify(error) : error)); }, unwrapOr(def) { return def; }, expect(msg) { throw new Error(msg); }, isOk() { return false; }, isErr() { return true; }, mapErr(fn) { return Err(fn(error)); }, unwrapErr() { return error; }, or(other) { return other; }, and(_) { return this; } }); }
function Some(value) { return Object.freeze({ __tag: "Some", value, map(fn) { return Some(fn(value)); }, flatMap(fn) { const r = fn(value); if (r && r.__tag) return r; throw new Error("flatMap callback must return Some/None"); }, unwrap() { return value; }, unwrapOr(_) { return value; }, expect(_) { return value; }, isSome() { return true; }, isNone() { return false; }, or(_) { return this; }, and(other) { return other; }, filter(pred) { return pred(value) ? this : None; } }); }
const None = Object.freeze({ __tag: "None", map(_) { return None; }, flatMap(_) { return None; }, unwrap() { throw new Error("Called unwrap on None"); }, unwrapOr(def) { return def; }, expect(msg) { throw new Error(msg); }, isSome() { return false; }, isNone() { return true; }, or(other) { return other; }, and(_) { return None; }, filter(_) { return None; } });`;
const PROPAGATE = `function __propagate(val) {
  if (val && val.__tag === "Err") throw { __tova_propagate: true, value: val };
  if (val && val.__tag === "None") throw { __tova_propagate: true, value: val };
  if (val && val.__tag === "Ok") return val.value;
  if (val && val.__tag === "Some") return val.value;
  return val;
}`;
const BUILTINS = `function print(...args) { console.log(...args); }
function len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }
function range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; if (st === 0) return []; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }
function enumerate(a) { return a.map((v, i) => [i, v]); }
function sum(a) { return a.reduce((x, y) => x + y, 0); }
function sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }
function reversed(a) { return [...a].reverse(); }
function zip(...as) { if (as.length === 0) return []; const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }
function min(a) { return a.length === 0 ? null : Math.min(...a); }
function max(a) { return a.length === 0 ? null : Math.max(...a); }
function type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }
function filter(arr, fn) { return arr.filter(fn); }
function map(arr, fn) { return arr.map(fn); }
function find(arr, fn) { return arr.find(fn) ?? null; }
function any(arr, fn) { return arr.some(fn); }
function all(arr, fn) { return arr.every(fn); }
function flat_map(arr, fn) { return arr.flatMap(fn); }
function reduce(arr, fn, init) { return init === undefined ? arr.reduce(fn) : arr.reduce(fn, init); }
function unique(arr) { return [...new Set(arr)]; }
function group_by(arr, fn) { const r = {}; for (const v of arr) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; }
function chunk(arr, n) { const r = []; for (let i = 0; i < arr.length; i += n) r.push(arr.slice(i, i + n)); return r; }
function flatten(arr) { return arr.flat(); }
function take(arr, n) { return arr.slice(0, n); }
function drop(arr, n) { return arr.slice(n); }
function first(arr) { return arr.length > 0 ? arr[0] : null; }
function last(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }
function count(arr, fn) { return arr.filter(fn).length; }
function partition(arr, fn) { const y = [], n = []; for (const v of arr) { (fn(v) ? y : n).push(v); } return [y, n]; }
function abs(n) { return Math.abs(n); }
function floor(n) { return Math.floor(n); }
function ceil(n) { return Math.ceil(n); }
function round(n) { return Math.round(n); }
function clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); }
function sqrt(n) { return Math.sqrt(n); }
function pow(b, e) { return Math.pow(b, e); }
function random() { return Math.random(); }
function trim(s) { return s.trim(); }
function split(s, sep) { return s.split(sep); }
function join(arr, sep) { return arr.join(sep); }
function replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); }
function repeat(s, n) { return s.repeat(n); }
function keys(obj) { return Object.keys(obj); }
function values(obj) { return Object.values(obj); }
function entries(obj) { return Object.entries(obj); }
function merge(...objs) { return Object.assign({}, ...objs); }
function freeze(obj) { return Object.freeze(obj); }
function clone(obj) { return structuredClone(obj); }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function upper(s) { return s.toUpperCase(); }
function lower(s) { return s.toLowerCase(); }
function contains(s, sub) { return s.includes(sub); }
function starts_with(s, prefix) { return s.startsWith(prefix); }
function ends_with(s, suffix) { return s.endsWith(suffix); }
function chars(s) { return [...s]; }
function words(s) { return s.split(/\\s+/).filter(Boolean); }
function lines(s) { return s.split('\\n'); }
function capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; }
function title_case(s) { return s.replace(/\\b\\w/g, c => c.toUpperCase()); }
function snake_case(s) { return s.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); }
function camel_case(s) { return s.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); }
function assert_eq(a, b, msg) { if (a !== b) throw new Error(msg || \`Assertion failed: \${JSON.stringify(a)} !== \${JSON.stringify(b)}\`); }
function assert_ne(a, b, msg) { if (a === b) throw new Error(msg || \`Assertion failed: values should not be equal: \${JSON.stringify(a)}\`); }
function assert(cond, msg) { if (!cond) throw new Error(msg || "Assertion failed"); }`;


// Individual builtin functions for tree-shaking
const BUILTIN_FUNCTIONS = {
  print: `function print(...args) { console.log(...args); }`,
  len: `function len(v) { if (v == null) return 0; if (typeof v === 'string' || Array.isArray(v)) return v.length; if (typeof v === 'object') return Object.keys(v).length; return 0; }`,
  range: `function range(s, e, st) { if (e === undefined) { e = s; s = 0; } if (st === undefined) st = s < e ? 1 : -1; if (st === 0) return []; const r = []; if (st > 0) { for (let i = s; i < e; i += st) r.push(i); } else { for (let i = s; i > e; i += st) r.push(i); } return r; }`,
  enumerate: `function enumerate(a) { return a.map((v, i) => [i, v]); }`,
  sum: `function sum(a) { return a.reduce((x, y) => x + y, 0); }`,
  sorted: `function sorted(a, k) { const c = [...a]; if (k) c.sort((x, y) => { const kx = k(x), ky = k(y); return kx < ky ? -1 : kx > ky ? 1 : 0; }); else c.sort((x, y) => x < y ? -1 : x > y ? 1 : 0); return c; }`,
  reversed: `function reversed(a) { return [...a].reverse(); }`,
  zip: `function zip(...as) { if (as.length === 0) return []; const m = Math.min(...as.map(a => a.length)); const r = []; for (let i = 0; i < m; i++) r.push(as.map(a => a[i])); return r; }`,
  min: `function min(a) { return a.length === 0 ? null : Math.min(...a); }`,
  max: `function max(a) { return a.length === 0 ? null : Math.max(...a); }`,
  type_of: `function type_of(v) { if (v === null) return 'Nil'; if (Array.isArray(v)) return 'List'; if (v?.__tag) return v.__tag; const t = typeof v; switch(t) { case 'number': return Number.isInteger(v) ? 'Int' : 'Float'; case 'string': return 'String'; case 'boolean': return 'Bool'; case 'function': return 'Function'; case 'object': return 'Object'; default: return 'Unknown'; } }`,
  filter: `function filter(arr, fn) { return arr.filter(fn); }`,
  map: `function map(arr, fn) { return arr.map(fn); }`,
  find: `function find(arr, fn) { return arr.find(fn) ?? null; }`,
  any: `function any(arr, fn) { return arr.some(fn); }`,
  all: `function all(arr, fn) { return arr.every(fn); }`,
  flat_map: `function flat_map(arr, fn) { return arr.flatMap(fn); }`,
  reduce: `function reduce(arr, fn, init) { return init === undefined ? arr.reduce(fn) : arr.reduce(fn, init); }`,
  unique: `function unique(arr) { return [...new Set(arr)]; }`,
  group_by: `function group_by(arr, fn) { const r = {}; for (const v of arr) { const k = fn(v); if (!r[k]) r[k] = []; r[k].push(v); } return r; }`,
  chunk: `function chunk(arr, n) { const r = []; for (let i = 0; i < arr.length; i += n) r.push(arr.slice(i, i + n)); return r; }`,
  flatten: `function flatten(arr) { return arr.flat(); }`,
  take: `function take(arr, n) { return arr.slice(0, n); }`,
  drop: `function drop(arr, n) { return arr.slice(n); }`,
  first: `function first(arr) { return arr.length > 0 ? arr[0] : null; }`,
  last: `function last(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }`,
  count: `function count(arr, fn) { return arr.filter(fn).length; }`,
  partition: `function partition(arr, fn) { const y = [], n = []; for (const v of arr) { (fn(v) ? y : n).push(v); } return [y, n]; }`,
  abs: `function abs(n) { return Math.abs(n); }`,
  floor: `function floor(n) { return Math.floor(n); }`,
  ceil: `function ceil(n) { return Math.ceil(n); }`,
  round: `function round(n) { return Math.round(n); }`,
  clamp: `function clamp(n, lo, hi) { return Math.min(Math.max(n, lo), hi); }`,
  sqrt: `function sqrt(n) { return Math.sqrt(n); }`,
  pow: `function pow(b, e) { return Math.pow(b, e); }`,
  random: `function random() { return Math.random(); }`,
  trim: `function trim(s) { return s.trim(); }`,
  split: `function split(s, sep) { return s.split(sep); }`,
  join: `function join(arr, sep) { return arr.join(sep); }`,
  replace: `function replace(s, from, to) { return typeof from === 'string' ? s.replaceAll(from, to) : s.replace(from, to); }`,
  repeat: `function repeat(s, n) { return s.repeat(n); }`,
  keys: `function keys(obj) { return Object.keys(obj); }`,
  values: `function values(obj) { return Object.values(obj); }`,
  entries: `function entries(obj) { return Object.entries(obj); }`,
  merge: `function merge(...objs) { return Object.assign({}, ...objs); }`,
  freeze: `function freeze(obj) { return Object.freeze(obj); }`,
  clone: `function clone(obj) { return structuredClone(obj); }`,
  sleep: `function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }`,
  upper: `function upper(s) { return s.toUpperCase(); }`,
  lower: `function lower(s) { return s.toLowerCase(); }`,
  contains: `function contains(s, sub) { return s.includes(sub); }`,
  starts_with: `function starts_with(s, prefix) { return s.startsWith(prefix); }`,
  ends_with: `function ends_with(s, suffix) { return s.endsWith(suffix); }`,
  chars: `function chars(s) { return [...s]; }`,
  words: `function words(s) { return s.split(/\\s+/).filter(Boolean); }`,
  lines: `function lines(s) { return s.split('\\n'); }`,
  capitalize: `function capitalize(s) { return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s; }`,
  title_case: `function title_case(s) { return s.replace(/\\b\\w/g, c => c.toUpperCase()); }`,
  snake_case: `function snake_case(s) { return s.replace(/[-\\s]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase().replace(/^_/, ''); }`,
  camel_case: `function camel_case(s) { return s.replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[A-Z]/, c => c.toLowerCase()); }`,
  assert_eq: `function assert_eq(a, b, msg) { if (a !== b) throw new Error(msg || \`Assertion failed: \${JSON.stringify(a)} !== \${JSON.stringify(b)}\`); }`,
  assert_ne: `function assert_ne(a, b, msg) { if (a === b) throw new Error(msg || \`Assertion failed: values should not be equal: \${JSON.stringify(a)}\`); }`,
  assert: `function assert(cond, msg) { if (!cond) throw new Error(msg || "Assertion failed"); }`,
};

// All known builtin names for matching
const BUILTIN_NAMES = new Set(Object.keys(BUILTIN_FUNCTIONS));

// Build stdlib containing only the functions that are actually used
function buildSelectiveStdlib(usedNames) {
  const parts = [];
  for (const name of usedNames) {
    if (BUILTIN_FUNCTIONS[name]) {
      parts.push(BUILTIN_FUNCTIONS[name]);
    }
  }
  return parts.join('\n');
}

// Full stdlib for runtime (REPL, run command)
function getFullStdlib() {
  return `${BUILTINS}\n${RESULT_OPTION}\n${PROPAGATE}`;
}

// Stdlib for client codegen (includes builtins + result/option + propagate)
function getClientStdlib() {
  return `${BUILTINS}\n${RESULT_OPTION}\n${PROPAGATE}`;
}

// ─── src/codegen/base-codegen.js ───────────────────────

// Base code generation utilities shared across all codegen targets
class BaseCodegen {
  constructor() {
    this.indent = 0;
    this._counter = 0;
    this._scopes = [new Set()]; // scope stack for tracking declared variables
    this._needsContainsHelper = false; // track if __contains helper is needed
    this._needsPropagateHelper = false; // track if __propagate helper is needed
    this._usedBuiltins = new Set(); // track which stdlib builtins are actually used
    this._needsResultOption = false; // track if Ok/Err/Some/None are used
    this._variantFields = { 'Ok': ['value'], 'Err': ['error'], 'Some': ['value'] }; // map variant name -> [field names] for pattern destructuring
    // Source map tracking
    this._sourceMappings = []; // {sourceLine, sourceCol, outputLine, outputCol}
    this._outputLineCount = 0;
  }

  _uid() {
    return this._counter++;
  }

  // Known void/side-effect-only calls that shouldn't be implicitly returned
  _isVoidCall(expr) {
    if (expr.type !== 'CallExpression') return false;
    if (expr.callee.type === 'Identifier') {
      const voidFns = new Set(['print', 'assert', 'assert_eq', 'assert_ne']);
      return voidFns.has(expr.callee.name);
    }
    return false;
  }

  // ─── Scope tracking ─────────────────────────────────────────

  pushScope() {
    this._scopes.push(new Set());
  }

  popScope() {
    this._scopes.pop();
  }

  declareVar(name) {
    this._scopes[this._scopes.length - 1].add(name);
  }

  isDeclared(name) {
    for (let i = this._scopes.length - 1; i >= 0; i--) {
      if (this._scopes[i].has(name)) return true;
    }
    return false;
  }

  // ─── Helpers ────────────────────────────────────────────────

  i() {
    return '  '.repeat(this.indent);
  }

  // Source map: record a mapping from source location to output line
  _addMapping(node, outputLine) {
    if (node && node.loc && node.loc.line) {
      this._sourceMappings.push({
        sourceLine: node.loc.line - 1, // 0-based
        sourceCol: (node.loc.column || 1) - 1, // 0-based
        outputLine,
        outputCol: this.indent * 2, // approximate column from indent
      });
    }
  }

  // Get collected source mappings
  getSourceMappings() {
    return this._sourceMappings;
  }

  getUsedBuiltins() {
    return this._usedBuiltins;
  }

  getContainsHelper() {
    return 'function __contains(col, val) {\n' +
      '  if (Array.isArray(col) || typeof col === \'string\') return col.includes(val);\n' +
      '  if (col instanceof Set || col instanceof Map) return col.has(val);\n' +
      '  if (typeof col === \'object\' && col !== null) return val in col;\n' +
      '  return false;\n' +
      '}';
  }

  genPropagateExpression(node) {
    this._needsPropagateHelper = true;
    return `__propagate(${this.genExpression(node.expression)})`;
  }

  _containsPropagate(node) {
    if (!node) return false;
    if (node.type === 'PropagateExpression') return true;
    // Stop at nested function/lambda boundaries — they get their own wrapper
    if (node.type === 'FunctionDeclaration' || node.type === 'LambdaExpression') return false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsPropagate(item)) return true;
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsPropagate(val)) return true;
      }
    }
    return false;
  }

  getPropagateHelper() {
    return PROPAGATE;
  }

  getResultOptionHelper() {
    return RESULT_OPTION;
  }

  getStringProtoHelper() {
    return '// String methods are now standalone stdlib functions';
  }

  generateStatement(node) {
    if (!node) return '';

    // Record source mapping before generating
    this._addMapping(node, this._outputLineCount);

    let result;
    switch (node.type) {
      case 'Assignment': result = this.genAssignment(node); break;
      case 'VarDeclaration': result = this.genVarDeclaration(node); break;
      case 'LetDestructure': result = this.genLetDestructure(node); break;
      case 'FunctionDeclaration': result = this.genFunctionDeclaration(node); break;
      case 'TypeDeclaration': result = this.genTypeDeclaration(node); break;
      case 'ImportDeclaration': result = this.genImport(node); break;
      case 'ImportDefault': result = this.genImportDefault(node); break;
      case 'ImportWildcard': result = this.genImportWildcard(node); break;
      case 'IfStatement': result = this.genIfStatement(node); break;
      case 'ForStatement': result = this.genForStatement(node); break;
      case 'WhileStatement': result = this.genWhileStatement(node); break;
      case 'TryCatchStatement': result = this.genTryCatchStatement(node); break;
      case 'ReturnStatement': result = this.genReturnStatement(node); break;
      case 'ExpressionStatement': result = `${this.i()}${this.genExpression(node.expression)};`; break;
      case 'BlockStatement': result = this.genBlock(node); break;
      case 'CompoundAssignment': result = this.genCompoundAssignment(node); break;
      case 'BreakStatement': result = `${this.i()}break;`; break;
      case 'ContinueStatement': result = `${this.i()}continue;`; break;
      case 'GuardStatement': result = this.genGuardStatement(node); break;
      case 'InterfaceDeclaration': result = this.genInterfaceDeclaration(node); break;
      case 'ImplDeclaration': result = this.genImplDeclaration(node); break;
      case 'TraitDeclaration': result = this.genTraitDeclaration(node); break;
      case 'TypeAlias': result = this.genTypeAlias(node); break;
      case 'DeferStatement': result = this.genDeferStatement(node); break;
      case 'ExternDeclaration': result = `${this.i()}// extern: ${node.name}`; break;
      default:
        result = `${this.i()}${this.genExpression(node)};`;
    }

    // Track output line count
    if (result) {
      const newlines = result.split('\n').length - 1;
      this._outputLineCount += newlines + 1; // +1 for the line itself (join with \n)
    }

    return result;
  }

  genExpression(node) {
    if (!node) return 'undefined';

    switch (node.type) {
      case 'Identifier':
        // Track builtin identifier usage (e.g., None used without call)
        if (BUILTIN_NAMES.has(node.name)) {
          this._usedBuiltins.add(node.name);
        }
        if (node.name === 'Ok' || node.name === 'Err' || node.name === 'Some' || node.name === 'None') {
          this._needsResultOption = true;
        }
        return node.name === '_' ? '_' : node.name;
      case 'NumberLiteral': return String(node.value);
      case 'StringLiteral': return JSON.stringify(node.value);
      case 'BooleanLiteral': return String(node.value);
      case 'NilLiteral': return 'null';
      case 'RegexLiteral': return `/${node.pattern}/${node.flags}`;
      case 'TemplateLiteral': return this.genTemplateLiteral(node);
      case 'BinaryExpression': return this.genBinaryExpression(node);
      case 'UnaryExpression': return this.genUnaryExpression(node);
      case 'LogicalExpression': return this.genLogicalExpression(node);
      case 'ChainedComparison': return this.genChainedComparison(node);
      case 'MembershipExpression': return this.genMembershipExpression(node);
      case 'CallExpression': return this.genCallExpression(node);
      case 'MemberExpression': return this.genMemberExpression(node);
      case 'OptionalChain': return this.genOptionalChain(node);
      case 'PipeExpression': return this.genPipeExpression(node);
      case 'LambdaExpression': return this.genLambdaExpression(node);
      case 'MatchExpression': return this.genMatchExpression(node);
      case 'IfExpression': return this.genIfExpression(node);
      case 'ArrayLiteral': return this.genArrayLiteral(node);
      case 'ObjectLiteral': return this.genObjectLiteral(node);
      case 'ListComprehension': return this.genListComprehension(node);
      case 'DictComprehension': return this.genDictComprehension(node);
      case 'RangeExpression': return this.genRangeExpression(node);
      case 'SliceExpression': return this.genSliceExpression(node);
      case 'SpreadExpression': return `...${this.genExpression(node.argument)}`;
      case 'PropagateExpression': return this.genPropagateExpression(node);
      case 'NamedArgument': return this.genExpression(node.value);
      case 'AwaitExpression': return `(await ${this.genExpression(node.argument)})`;
      case 'YieldExpression': return node.delegate ? `(yield* ${this.genExpression(node.argument)})` : `(yield ${this.genExpression(node.argument)})`;
      case 'TupleExpression': return `[${node.elements.map(e => this.genExpression(e)).join(', ')}]`;
      default:
        throw new Error(`Codegen: unknown expression type '${node.type}'`);
    }
  }

  // ─── Statements ───────────────────────────────────────────

  genAssignment(node) {
    const exportPrefix = node.isPublic ? 'export ' : '';
    if (node.targets.length === 1 && node.values.length === 1) {
      const target = node.targets[0];
      // Member expression target: obj.x = expr, arr[i] = expr
      if (typeof target === 'object' && target.type === 'MemberExpression') {
        return `${this.i()}${this.genExpression(target)} = ${this.genExpression(node.values[0])};`;
      }
      if (target === '_') {
        return `${this.i()}${this.genExpression(node.values[0])};`;
      }
      if (this.isDeclared(target)) {
        // Reassignment to an already-declared variable (must be mutable)
        return `${this.i()}${target} = ${this.genExpression(node.values[0])};`;
      }
      this.declareVar(target);
      return `${this.i()}${exportPrefix}const ${target} = ${this.genExpression(node.values[0])};`;
    }

    // Multiple assignment: a, b = 1, 2 (uses destructuring for atomicity)
    const vals = node.values.map(v => this.genExpression(v));
    const allDeclared = node.targets.every(t => this.isDeclared(t));
    const noneDeclared = node.targets.every(t => !this.isDeclared(t));

    if (allDeclared) {
      // Reassignment (e.g., swap): [a, b] = [v1, v2]
      return `${this.i()}[${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    if (noneDeclared) {
      // New declarations: const [a, b] = [v1, v2]
      for (const t of node.targets) this.declareVar(t);
      return `${this.i()}${exportPrefix}const [${node.targets.join(', ')}] = [${vals.join(', ')}];`;
    }

    // Mixed: some declared, some new — generate individual assignments
    const lines = [];
    const tempArr = `__tmp_${this._uid()}`;
    lines.push(`${this.i()}const ${tempArr} = [${vals.join(', ')}];`);
    for (let idx = 0; idx < node.targets.length; idx++) {
      const t = node.targets[idx];
      if (this.isDeclared(t)) {
        lines.push(`${this.i()}${t} = ${tempArr}[${idx}];`);
      } else {
        this.declareVar(t);
        lines.push(`${this.i()}const ${t} = ${tempArr}[${idx}];`);
      }
    }
    return lines.join('\n');
  }

  genVarDeclaration(node) {
    const exportPrefix = node.isPublic ? 'export ' : '';
    if (node.targets.length === 1 && node.values.length === 1) {
      this.declareVar(node.targets[0]);
      return `${this.i()}${exportPrefix}let ${node.targets[0]} = ${this.genExpression(node.values[0])};`;
    }
    const lines = [];
    for (let idx = 0; idx < node.targets.length; idx++) {
      this.declareVar(node.targets[idx]);
      const val = idx < node.values.length ? node.values[idx] : node.values[node.values.length - 1];
      lines.push(`${this.i()}${exportPrefix}let ${node.targets[idx]} = ${this.genExpression(val)};`);
    }
    return lines.join('\n');
  }

  genLetDestructure(node) {
    if (node.pattern.type === 'ObjectPattern') {
      for (const p of node.pattern.properties) this.declareVar(p.value);
      const props = node.pattern.properties.map(p => {
        let str = p.key;
        if (p.value !== p.key) str += `: ${p.value}`;
        if (p.defaultValue) str += ` = ${this.genExpression(p.defaultValue)}`;
        return str;
      }).join(', ');
      return `${this.i()}const { ${props} } = ${this.genExpression(node.value)};`;
    }
    if (node.pattern.type === 'ArrayPattern' || node.pattern.type === 'TuplePattern') {
      for (const e of node.pattern.elements) if (e) this.declareVar(e);
      const els = node.pattern.elements.map(e => e || '').join(', ');
      return `${this.i()}const [${els}] = ${this.genExpression(node.value)};`;
    }
    return '';
  }

  genFunctionDeclaration(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const isGenerator = this._containsYield(node.body);
    const exportPrefix = node.isPublic ? 'export ' : '';
    const asyncPrefix = node.isAsync ? 'async ' : '';
    const genStar = isGenerator ? '*' : '';
    this.pushScope();
    for (const p of node.params) {
      if (p.destructure) {
        this._declareDestructureVars(p.destructure);
      } else {
        this.declareVar(p.name);
      }
    }
    const body = this.genBlockBody(node.body);
    this.popScope();
    if (hasPropagate) {
      return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
    }
    return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${body}\n${this.i()}}`;
  }

  genParams(params) {
    return params.map(p => {
      if (p.destructure) {
        if (p.destructure.type === 'ObjectPattern') {
          const props = p.destructure.properties.map(prop => {
            let str = prop.key;
            if (prop.value !== prop.key) str += `: ${prop.value}`;
            if (prop.defaultValue) str += ` = ${this.genExpression(prop.defaultValue)}`;
            return str;
          }).join(', ');
          return `{ ${props} }`;
        }
        if (p.destructure.type === 'ArrayPattern' || p.destructure.type === 'TuplePattern') {
          return `[${p.destructure.elements.join(', ')}]`;
        }
      }
      if (p.defaultValue) {
        return `${p.name} = ${this.genExpression(p.defaultValue)}`;
      }
      return p.name;
    }).join(', ');
  }

  genImport(node) {
    for (const s of node.specifiers) this.declareVar(s.local);
    const specs = node.specifiers.map(s => {
      if (s.imported !== s.local) return `${s.imported} as ${s.local}`;
      return s.imported;
    }).join(', ');
    return `${this.i()}import { ${specs} } from ${JSON.stringify(node.source)};`;
  }

  genImportDefault(node) {
    this.declareVar(node.local);
    return `${this.i()}import ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genImportWildcard(node) {
    this.declareVar(node.local);
    return `${this.i()}import * as ${node.local} from ${JSON.stringify(node.source)};`;
  }

  genIfStatement(node) {
    let code = `${this.i()}if (${this.genExpression(node.condition)}) {\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node.consequent);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;

    for (const alt of node.alternates) {
      code += ` else if (${this.genExpression(alt.condition)}) {\n`;
      this.indent++;
      this.pushScope();
      code += this.genBlockStatements(alt.body);
      this.popScope();
      this.indent--;
      code += `\n${this.i()}}`;
    }

    if (node.elseBody) {
      code += ` else {\n`;
      this.indent++;
      this.pushScope();
      code += this.genBlockStatements(node.elseBody);
      this.popScope();
      this.indent--;
      code += `\n${this.i()}}`;
    }

    return code;
  }

  genForStatement(node) {
    const vars = Array.isArray(node.variable) ? node.variable : [node.variable];
    const iterExpr = this.genExpression(node.iterable);

    if (node.elseBody) {
      // for-else: run else if iterable was empty
      const tempVar = `__iter_${this._uid()}`;
      const enteredVar = `__entered_${this._uid()}`;
      let code = `${this.i()}{\n`;
      this.indent++;
      code += `${this.i()}const ${tempVar} = ${iterExpr};\n`;
      code += `${this.i()}let ${enteredVar} = false;\n`;
      this.pushScope();
      for (const v of vars) this.declareVar(v);
      if (vars.length === 2) {
        code += `${this.i()}for (const [${vars[0]}, ${vars[1]}] of ${tempVar}) {\n`;
      } else {
        code += `${this.i()}for (const ${vars[0]} of ${tempVar}) {\n`;
      }
      this.indent++;
      code += `${this.i()}${enteredVar} = true;\n`;
      code += this.genBlockStatements(node.body);
      this.indent--;
      code += `\n${this.i()}}\n`;
      this.popScope();
      this.pushScope();
      code += `${this.i()}if (!${enteredVar}) {\n`;
      this.indent++;
      code += this.genBlockStatements(node.elseBody);
      this.indent--;
      code += `\n${this.i()}}\n`;
      this.popScope();
      this.indent--;
      code += `${this.i()}}`;
      return code;
    }

    this.pushScope();
    for (const v of vars) this.declareVar(v);
    let code;
    if (vars.length === 2) {
      code = `${this.i()}for (const [${vars[0]}, ${vars[1]}] of ${iterExpr}) {\n`;
    } else {
      code = `${this.i()}for (const ${vars[0]} of ${iterExpr}) {\n`;
    }
    this.indent++;
    code += this.genBlockStatements(node.body);
    this.indent--;
    code += `\n${this.i()}}`;
    this.popScope();

    return code;
  }

  genWhileStatement(node) {
    let code = `${this.i()}while (${this.genExpression(node.condition)}) {\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node.body);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;
    return code;
  }

  genTryCatchStatement(node) {
    let code = `${this.i()}try {\n`;
    this.indent++;
    this.pushScope();
    for (const stmt of node.tryBody) {
      code += this.generateStatement(stmt) + '\n';
    }
    this.popScope();
    this.indent--;

    if (node.catchBody) {
      const catchVar = node.catchParam || '__err';
      code += `${this.i()}} catch (${catchVar}) {\n`;
      this.pushScope();
      this.declareVar(catchVar);
      this.indent++;
      // Re-throw propagation sentinels so ? operator works through user try/catch
      code += `${this.i()}if (${catchVar} && ${catchVar}.__tova_propagate) throw ${catchVar};\n`;
      for (const stmt of node.catchBody) {
        code += this.generateStatement(stmt) + '\n';
      }
      this.popScope();
      this.indent--;
      code += `${this.i()}}`;
    }

    if (node.finallyBody) {
      if (!node.catchBody) {
        // try/finally without catch
        code += `${this.i()}}`;
      }
      code += ` finally {\n`;
      this.indent++;
      this.pushScope();
      for (const stmt of node.finallyBody) {
        code += this.generateStatement(stmt) + '\n';
      }
      this.popScope();
      this.indent--;
      code += `${this.i()}}`;
    }

    return code;
  }

  genReturnStatement(node) {
    if (node.value) {
      return `${this.i()}return ${this.genExpression(node.value)};`;
    }
    return `${this.i()}return;`;
  }

  genCompoundAssignment(node) {
    return `${this.i()}${this.genExpression(node.target)} ${node.operator} ${this.genExpression(node.value)};`;
  }

  genBlock(node) {
    let code = `{\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;
    return code;
  }

  genBlockBody(block) {
    if (block.type !== 'BlockStatement') {
      this.indent++;
      const code = `${this.i()}return ${this.genExpression(block)};`;
      this.indent--;
      return code;
    }

    this.indent++;
    const stmts = block.body;

    // Collect defer statements and separate them from regular statements
    const regularStmts = [];
    const deferBodies = [];
    for (const stmt of stmts) {
      if (stmt.type === 'DeferStatement') {
        deferBodies.push(stmt.body);
      } else {
        regularStmts.push(stmt);
      }
    }

    const lines = [];

    // If there are defers, wrap in try/finally
    if (deferBodies.length > 0) {
      lines.push(`${this.i()}try {`);
      this.indent++;
    }

    for (let idx = 0; idx < regularStmts.length; idx++) {
      const stmt = regularStmts[idx];
      const isLast = idx === regularStmts.length - 1;
      // Implicit return: last expression in function body
      // Skip implicit return for known void/side-effect-only calls (print, assert, etc.)
      if (isLast && stmt.type === 'ExpressionStatement' && !this._isVoidCall(stmt.expression)) {
        lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithReturns(stmt));
      } else if (isLast && stmt.type === 'MatchExpression') {
        lines.push(`${this.i()}return ${this.genExpression(stmt)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }

    if (deferBodies.length > 0) {
      this.indent--;
      lines.push(`${this.i()}} finally {`);
      this.indent++;
      // Execute defers in LIFO order
      for (let i = deferBodies.length - 1; i >= 0; i--) {
        const body = deferBodies[i];
        if (body.type === 'BlockStatement') {
          lines.push(this.genBlockStatements(body));
        } else {
          lines.push(`${this.i()}${this.genExpression(body)};`);
        }
      }
      this.indent--;
      lines.push(`${this.i()}}`);
    }

    this.indent--;
    return lines.join('\n');
  }

  _genIfStatementWithReturns(node) {
    let code = `${this.i()}if (${this.genExpression(node.condition)}) {\n`;
    code += this._genBlockBodyReturns(node.consequent);
    code += `\n${this.i()}}`;

    for (const alt of node.alternates) {
      code += ` else if (${this.genExpression(alt.condition)}) {\n`;
      code += this._genBlockBodyReturns(alt.body);
      code += `\n${this.i()}}`;
    }

    if (node.elseBody) {
      code += ` else {\n`;
      code += this._genBlockBodyReturns(node.elseBody);
      code += `\n${this.i()}}`;
    }

    return code;
  }

  _genBlockBodyReturns(block) {
    // Like genBlockBody but always adds return to the last statement
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    this.indent++;
    const lines = [];
    for (let idx = 0; idx < stmts.length; idx++) {
      const stmt = stmts[idx];
      const isLast = idx === stmts.length - 1;
      if (isLast && stmt.type === 'ExpressionStatement') {
        lines.push(`${this.i()}return ${this.genExpression(stmt.expression)};`);
      } else if (isLast && stmt.type === 'IfStatement' && stmt.elseBody) {
        lines.push(this._genIfStatementWithReturns(stmt));
      } else if (isLast && stmt.type === 'MatchExpression') {
        lines.push(`${this.i()}return ${this.genExpression(stmt)};`);
      } else {
        lines.push(this.generateStatement(stmt));
      }
    }
    this.indent--;
    return lines.join('\n');
  }

  genBlockStatements(block) {
    if (!block) return '';
    const stmts = block.type === 'BlockStatement' ? block.body : [block];
    return stmts.map(s => this.generateStatement(s)).join('\n');
  }

  // ─── Expressions ──────────────────────────────────────────

  genTemplateLiteral(node) {
    const parts = node.parts.map(p => {
      if (p.type === 'text') {
        return p.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
      }
      return `\${${this.genExpression(p.value)}}`;
    }).join('');
    return `\`${parts}\``;
  }

  genBinaryExpression(node) {
    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);
    const op = node.operator;

    // String multiply: "ha" * 3 => "ha".repeat(3)
    if (op === '*' &&
      (node.left.type === 'StringLiteral' || node.left.type === 'TemplateLiteral')) {
      return `${left}.repeat(${right})`;
    }

    // Tova ?? is NaN-safe: catches null, undefined, AND NaN
    if (op === '??') {
      return `((__tova_v) => (__tova_v != null && __tova_v === __tova_v) ? __tova_v : ${right})(${left})`;
    }

    return `(${left} ${op} ${right})`;
  }

  genUnaryExpression(node) {
    const operand = this.genExpression(node.operand);
    if (node.operator === 'not') return `(!${operand})`;
    return `(${node.operator}${operand})`;
  }

  genLogicalExpression(node) {
    const left = this.genExpression(node.left);
    const right = this.genExpression(node.right);
    const op = node.operator === 'and' ? '&&' : node.operator === 'or' ? '||' : node.operator;
    return `(${left} ${op} ${right})`;
  }

  genChainedComparison(node) {
    // a < b < c => ((__t0 = a) < (__t1 = b) && __t1 < c)
    // Use temp vars for intermediate operands to avoid evaluating expressions multiple times
    if (node.operators.length === 1) {
      // Simple case: no duplication needed
      const left = this.genExpression(node.operands[0]);
      const right = this.genExpression(node.operands[1]);
      return `(${left} ${node.operators[0]} ${right})`;
    }
    const temps = [];
    const parts = [];
    for (let idx = 0; idx < node.operators.length; idx++) {
      let left, right;
      if (idx === 0) {
        left = this.genExpression(node.operands[idx]);
      } else {
        left = temps[idx - 1];
      }
      if (idx < node.operators.length - 1) {
        // Intermediate operand: assign to temp var so it's not evaluated twice
        const tmp = `__cmp_${this._uid()}`;
        temps.push(tmp);
        right = `(${tmp} = ${this.genExpression(node.operands[idx + 1])})`;
      } else {
        right = this.genExpression(node.operands[idx + 1]);
      }
      parts.push(`(${left} ${node.operators[idx]} ${right})`);
    }
    if (temps.length > 0) {
      return `(() => { let ${temps.join(', ')}; return (${parts.join(' && ')}); })()`;
    }
    return `(${parts.join(' && ')})`;
  }

  genMembershipExpression(node) {
    const val = this.genExpression(node.value);
    const col = this.genExpression(node.collection);
    this._needsContainsHelper = true;
    if (node.negated) {
      return `(!__contains(${col}, ${val}))`;
    }
    return `__contains(${col}, ${val})`;
  }

  genCallExpression(node) {
    // Transform Foo.new(...) → new Foo(...)
    if (node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property === 'new') {
      const obj = this.genExpression(node.callee.object);
      const args = node.arguments.map(a => this.genExpression(a)).join(', ');
      return `new ${obj}(${args})`;
    }

    // Track builtin usage for tree-shaking
    if (node.callee.type === 'Identifier') {
      if (BUILTIN_NAMES.has(node.callee.name)) {
        this._usedBuiltins.add(node.callee.name);
      }
      if (node.callee.name === 'Ok' || node.callee.name === 'Err' || node.callee.name === 'Some') {
        this._needsResultOption = true;
      }
    }

    const callee = this.genExpression(node.callee);
    const hasNamedArgs = node.arguments.some(a => a.type === 'NamedArgument');

    if (hasNamedArgs) {
      const allNamed = node.arguments.every(a => a.type === 'NamedArgument');
      if (allNamed) {
        // All named args → single object argument
        const parts = node.arguments.map(a => `${a.name}: ${this.genExpression(a.value)}`);
        return `${callee}({ ${parts.join(', ')} })`;
      }
      // Mixed: positional first, then named as trailing object
      const positional = [];
      const named = [];
      for (const a of node.arguments) {
        if (a.type === 'NamedArgument') {
          named.push(`${a.name}: ${this.genExpression(a.value)}`);
        } else {
          positional.push(this.genExpression(a));
        }
      }
      return `${callee}(${[...positional, `{ ${named.join(', ')} }`].join(', ')})`;
    }

    const args = node.arguments.map(a => this.genExpression(a)).join(', ');
    return `${callee}(${args})`;
  }

  genMemberExpression(node) {
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}[${this.genExpression(node.property)}]`;
    }
    return `${obj}.${node.property}`;
  }

  genOptionalChain(node) {
    const obj = this.genExpression(node.object);
    if (node.computed) {
      return `${obj}?.[${this.genExpression(node.property)}]`;
    }
    return `${obj}?.${node.property}`;
  }

  genPipeExpression(node) {
    const left = this.genExpression(node.left);
    const right = node.right;

    // Method pipe: x |> .method(args) => x.method(args)
    if (right.type === 'CallExpression' && right.callee.type === 'MemberExpression' &&
        right.callee.object.type === 'Identifier' && right.callee.object.name === PIPE_TARGET) {
      // This is the .method() case - handled through special MemberExpression with empty object
      const method = right.callee.property;
      const args = right.arguments.map(a => this.genExpression(a)).join(', ');
      return `${left}.${method}(${args})`;
    }

    // If right is a call expression, check for placeholder _ or insert as first arg
    if (right.type === 'CallExpression') {
      const placeholderCount = right.arguments.filter(a => a.type === 'Identifier' && a.name === '_').length;
      if (placeholderCount > 0) {
        const callee = this.genExpression(right.callee);
        if (placeholderCount > 1) {
          // Multiple placeholders: evaluate left once via IIFE temp var
          const tmp = `__pipe_${this._uid()}`;
          const args = right.arguments.map(a => {
            if (a.type === 'Identifier' && a.name === '_') return tmp;
            return this.genExpression(a);
          }).join(', ');
          return `((${tmp}) => ${callee}(${args}))(${left})`;
        }
        // Single placeholder: inline directly
        const args = right.arguments.map(a => {
          if (a.type === 'Identifier' && a.name === '_') return left;
          return this.genExpression(a);
        }).join(', ');
        return `${callee}(${args})`;
      }
      const callee = this.genExpression(right.callee);
      const args = [left, ...right.arguments.map(a => this.genExpression(a))].join(', ');
      return `${callee}(${args})`;
    }
    // If right is an identifier, call it with left as argument
    if (right.type === 'Identifier') {
      return `${right.name}(${left})`;
    }
    // Method pipe without call: x |> .method => x.method
    if (right.type === 'MemberExpression' && right.object.type === 'Identifier' && right.object.name === PIPE_TARGET) {
      return `${left}.${right.property}`;
    }
    // Fallback
    return `(${this.genExpression(right)})(${left})`;
  }

  genLambdaExpression(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const asyncPrefix = node.isAsync ? 'async ' : '';

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      const body = this.genBlockBody(node.body);
      this.popScope();
      if (hasPropagate) {
        return `${asyncPrefix}(${params}) => {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
      }
      return `${asyncPrefix}(${params}) => {\n${body}\n${this.i()}}`;
    }

    // Statement bodies (compound assignment, assignment in lambda)
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      this.indent++;
      const stmt = this.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `${asyncPrefix}(${params}) => { ${stmt.trim()} }`;
    }

    if (hasPropagate) {
      return `${asyncPrefix}(${params}) => { try { return ${this.genExpression(node.body)}; } catch (__e) { if (__e && __e.__tova_propagate) return __e.value; throw __e; } }`;
    }
    return `${asyncPrefix}(${params}) => ${this.genExpression(node.body)}`;
  }

  genMatchExpression(node) {
    // Generate as IIFE with if-else chain
    const subject = this.genExpression(node.subject);
    const tempVar = '__match';

    let code = `((${tempVar}) => {\n`;
    this.indent++;

    for (let idx = 0; idx < node.arms.length; idx++) {
      const arm = node.arms[idx];
      const condition = this.genPatternCondition(arm.pattern, tempVar, arm.guard);

      if (arm.pattern.type === 'WildcardPattern' || arm.pattern.type === 'BindingPattern') {
        if (idx === node.arms.length - 1 && !arm.guard) {
          // Default case
          if (arm.pattern.type === 'BindingPattern') {
            code += `${this.i()}const ${arm.pattern.name} = ${tempVar};\n`;
          }
          if (arm.body.type === 'BlockStatement') {
            code += this.genBlockBody(arm.body) + '\n';
          } else {
            code += `${this.i()}return ${this.genExpression(arm.body)};\n`;
          }
          break;
        }
      }

      const keyword = idx === 0 ? 'if' : 'else if';
      code += `${this.i()}${keyword} (${condition}) {\n`;
      this.indent++;

      // Bind variables from pattern
      code += this.genPatternBindings(arm.pattern, tempVar);

      if (arm.body.type === 'BlockStatement') {
        code += this.genBlockBody(arm.body) + '\n';
      } else {
        code += `${this.i()}return ${this.genExpression(arm.body)};\n`;
      }
      this.indent--;
      code += `${this.i()}}\n`;
    }

    this.indent--;
    code += `${this.i()}})(${subject})`;
    return code;
  }

  genIfExpression(node) {
    // Optimization: if all branches are single expressions, use ternary
    const isSingleExpr = (block) =>
      block.type === 'BlockStatement' && block.body.length === 1 && block.body[0].type === 'ExpressionStatement';

    if (node.alternates.length === 0 && isSingleExpr(node.consequent) && isSingleExpr(node.elseBody)) {
      const cond = this.genExpression(node.condition);
      const thenExpr = this.genExpression(node.consequent.body[0].expression);
      const elseExpr = this.genExpression(node.elseBody.body[0].expression);
      return `((${cond}) ? (${thenExpr}) : (${elseExpr}))`;
    }

    // Full IIFE for multi-statement branches
    let code = `(() => {\n`;
    this.indent++;

    code += `${this.i()}if (${this.genExpression(node.condition)}) {\n`;
    code += this.genBlockBody(node.consequent);
    code += `\n${this.i()}}`;

    for (const alt of node.alternates) {
      code += ` else if (${this.genExpression(alt.condition)}) {\n`;
      code += this.genBlockBody(alt.body);
      code += `\n${this.i()}}`;
    }

    code += ` else {\n`;
    code += this.genBlockBody(node.elseBody);
    code += `\n${this.i()}}`;

    this.indent--;
    code += `\n${this.i()}})()`;
    return code;
  }

  genPatternCondition(pattern, subject, guard) {
    let cond;

    switch (pattern.type) {
      case 'LiteralPattern':
        cond = `${subject} === ${JSON.stringify(pattern.value)}`;
        break;
      case 'RangePattern':
        if (pattern.inclusive) {
          cond = `${subject} >= ${pattern.start} && ${subject} <= ${pattern.end}`;
        } else {
          cond = `${subject} >= ${pattern.start} && ${subject} < ${pattern.end}`;
        }
        break;
      case 'VariantPattern': {
        const vchecks = [`${subject}?.__tag === "${pattern.name}"`];
        const declFields = this._variantFields[pattern.name] || [];
        for (let i = 0; i < pattern.fields.length; i++) {
          const f = pattern.fields[i];
          if (typeof f === 'object' && f.type && f.type !== 'WildcardPattern' && f.type !== 'BindingPattern') {
            const fieldName = f.type === 'BindingPattern' ? f.name : null;
            const propName = declFields[i] || fieldName || `value`;
            const fCond = this.genPatternCondition(f, `${subject}.${propName}`, null);
            if (fCond !== 'true') vchecks.push(fCond);
          }
        }
        cond = vchecks.join(' && ');
        break;
      }
      case 'ArrayPattern': {
        // Check it's an array with the right length, then check each element pattern
        const checks = [`Array.isArray(${subject})`, `${subject}.length === ${pattern.elements.length}`];
        for (let i = 0; i < pattern.elements.length; i++) {
          const elPat = pattern.elements[i];
          if (elPat.type !== 'WildcardPattern' && elPat.type !== 'BindingPattern') {
            const elCond = this.genPatternCondition(elPat, `${subject}[${i}]`, null);
            if (elCond !== 'true') checks.push(elCond);
          }
        }
        cond = checks.join(' && ');
        break;
      }
      case 'TuplePattern': {
        const checks = [`Array.isArray(${subject})`, `${subject}.length === ${pattern.elements.length}`];
        for (let i = 0; i < pattern.elements.length; i++) {
          const elPat = pattern.elements[i];
          if (elPat.type !== 'WildcardPattern' && elPat.type !== 'BindingPattern') {
            const elCond = this.genPatternCondition(elPat, `${subject}[${i}]`, null);
            if (elCond !== 'true') checks.push(elCond);
          }
        }
        cond = checks.join(' && ');
        break;
      }
      case 'StringConcatPattern':
        cond = `typeof ${subject} === 'string' && ${subject}.startsWith(${JSON.stringify(pattern.prefix)})`;
        break;
      case 'WildcardPattern':
        cond = 'true';
        break;
      case 'BindingPattern':
        cond = 'true';
        break;
      default:
        cond = 'true';
    }

    if (guard) {
      // For binding patterns, we need to bind first for the guard
      if (pattern.type === 'BindingPattern') {
        cond = `((${pattern.name}) => ${this.genExpression(guard)})(${subject})`;
      } else {
        cond = `(${cond}) && (${this.genExpression(guard)})`;
      }
    }

    return cond;
  }

  genPatternBindings(pattern, subject) {
    switch (pattern.type) {
      case 'BindingPattern':
        return `${this.i()}const ${pattern.name} = ${subject};\n`;
      case 'VariantPattern': {
        const declaredFields = this._variantFields[pattern.name] || [];
        return pattern.fields.map((f, idx) => {
          // Determine field name for property access
          const fieldName = typeof f === 'string' ? f : (f.type === 'BindingPattern' ? f.name : null);
          const propName = declaredFields[idx] || fieldName || `value`;
          const accessor = `${subject}.${propName}`;
          // String fields (legacy) — simple binding
          if (typeof f === 'string') {
            return `${this.i()}const ${f} = ${accessor};\n`;
          }
          // Nested pattern — recurse for bindings
          if (f.type === 'BindingPattern') {
            return `${this.i()}const ${f.name} = ${accessor};\n`;
          }
          if (f.type === 'WildcardPattern') return '';
          // Nested variant, array, tuple patterns
          return this.genPatternBindings(f, accessor);
        }).join('');
      }
      case 'ArrayPattern':
        return pattern.elements.map((el, idx) => {
          if (el.type === 'BindingPattern') {
            return `${this.i()}const ${el.name} = ${subject}[${idx}];\n`;
          }
          return this.genPatternBindings(el, `${subject}[${idx}]`);
        }).filter(s => s).join('');
      case 'TuplePattern':
        return pattern.elements.map((el, idx) => {
          if (el.type === 'BindingPattern') {
            return `${this.i()}const ${el.name} = ${subject}[${idx}];\n`;
          }
          return this.genPatternBindings(el, `${subject}[${idx}]`);
        }).filter(s => s).join('');
      case 'StringConcatPattern':
        if (pattern.rest && pattern.rest.type === 'BindingPattern') {
          return `${this.i()}const ${pattern.rest.name} = ${subject}.slice(${pattern.prefix.length});\n`;
        }
        return '';
      default:
        return '';
    }
  }

  genArrayLiteral(node) {
    const elements = node.elements.map(e => this.genExpression(e)).join(', ');
    return `[${elements}]`;
  }

  genObjectLiteral(node) {
    const props = node.properties.map(p => {
      if (p.shorthand) {
        return this.genExpression(p.key);
      }
      return `${this.genExpression(p.key)}: ${this.genExpression(p.value)}`;
    }).join(', ');
    return `{ ${props} }`;
  }

  genListComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const varName = node.variable;
    const expr = this.genExpression(node.expression);

    if (node.condition) {
      const cond = this.genExpression(node.condition);
      // Skip redundant .map() when expression is just the loop variable
      if (expr === varName) {
        return `${iter}.filter((${varName}) => ${cond})`;
      }
      return `${iter}.filter((${varName}) => ${cond}).map((${varName}) => ${expr})`;
    }
    return `${iter}.map((${varName}) => ${expr})`;
  }

  genDictComprehension(node) {
    const iter = this.genExpression(node.iterable);
    const vars = node.variables;
    const key = this.genExpression(node.key);
    const value = this.genExpression(node.value);

    const destructure = vars.length === 2 ? `[${vars[0]}, ${vars[1]}]` : vars[0];

    let code = `Object.fromEntries(${iter}`;
    if (node.condition) {
      code += `.filter((${destructure}) => ${this.genExpression(node.condition)})`;
    }
    code += `.map((${destructure}) => [${key}, ${value}]))`;
    return code;
  }

  genRangeExpression(node) {
    const start = this.genExpression(node.start);
    const end = this.genExpression(node.end);
    if (node.inclusive) {
      return `Array.from({length: (${end}) - (${start}) + 1}, (_, i) => (${start}) + i)`;
    }
    return `Array.from({length: (${end}) - (${start})}, (_, i) => (${start}) + i)`;
  }

  genSliceExpression(node) {
    const obj = this.genExpression(node.object);
    const start = node.start ? this.genExpression(node.start) : '';
    const end = node.end ? this.genExpression(node.end) : '';

    if (node.step) {
      const step = this.genExpression(node.step);
      const s = node.start ? this.genExpression(node.start) : 'null';
      const e = node.end ? this.genExpression(node.end) : 'null';
      // Handles both positive and negative step directions
      return `((a, s, e, st) => { const r = []; if (st > 0) { for (let i = s !== null ? s : 0; i < (e !== null ? e : a.length); i += st) r.push(a[i]); } else { for (let i = s !== null ? s : a.length - 1; i > (e !== null ? e : -1); i += st) r.push(a[i]); } return r; })(${obj}, ${s}, ${e}, ${step})`;
    }

    if (!start && !end) return `${obj}.slice()`;
    if (!start) return `${obj}.slice(0, ${end})`;
    if (!end) return `${obj}.slice(${start})`;
    return `${obj}.slice(${start}, ${end})`;
  }

  _declareDestructureVars(pattern) {
    if (pattern.type === 'ObjectPattern') {
      for (const p of pattern.properties) this.declareVar(p.value);
    } else if (pattern.type === 'ArrayPattern') {
      for (const e of pattern.elements) if (e) this.declareVar(e);
    }
  }

  genGuardStatement(node) {
    let code = `${this.i()}if (!(${this.genExpression(node.condition)})) {\n`;
    this.indent++;
    this.pushScope();
    code += this.genBlockStatements(node.elseBody);
    this.popScope();
    this.indent--;
    code += `\n${this.i()}}`;
    return code;
  }

  genInterfaceDeclaration(node) {
    // Interfaces are compile-time only — generate as a documentation comment
    const exportStr = node.isPublic ? 'export ' : '';
    const methods = node.methods.map(m => {
      const params = m.params.map(p => {
        let s = p.name;
        if (p.typeAnnotation) s += `: ${p.typeAnnotation.name || 'any'}`;
        return s;
      }).join(', ');
      const ret = m.returnType ? ` -> ${m.returnType.name || 'any'}` : '';
      return `${this.i()} *   fn ${m.name}(${params})${ret}`;
    }).join('\n');
    return `${this.i()}/* ${exportStr}interface ${node.name} {\n${methods}\n${this.i()} * } */`;
  }

  genTypeDeclaration(node) {
    const lines = [];
    const exportPrefix = node.isPublic ? 'export ' : '';

    const hasVariants = node.variants.some(v => v.type === 'TypeVariant');

    if (hasVariants) {
      for (const variant of node.variants) {
        if (variant.type === 'TypeVariant') {
          this.declareVar(variant.name);
          const fieldNames = variant.fields.map(f => f.name);
          this._variantFields[variant.name] = fieldNames;
          if (variant.fields.length === 0) {
            lines.push(`${this.i()}${exportPrefix}const ${variant.name} = Object.freeze({ __tag: "${variant.name}" });`);
          } else {
            const params = fieldNames.join(', ');
            const obj = fieldNames.map(f => `${f}`).join(', ');
            lines.push(`${this.i()}${exportPrefix}function ${variant.name}(${params}) { return Object.freeze({ __tag: "${variant.name}", ${obj} }); }`);
          }
        }
      }
    } else {
      this.declareVar(node.name);
      const fieldNames = node.variants.map(f => f.name);
      const params = fieldNames.join(', ');
      const obj = fieldNames.map(f => `${f}`).join(', ');
      lines.push(`${this.i()}${exportPrefix}function ${node.name}(${params}) { return { ${obj} }; }`);
    }

    // Derive clause: generate methods
    if (node.derive && node.derive.length > 0) {
      const targetName = hasVariants ? null : node.name;
      const fieldNames = hasVariants ? [] : node.variants.map(f => f.name);

      for (const trait of node.derive) {
        if (trait === 'Eq' && targetName) {
          // Deep equality: compare all fields
          const checks = fieldNames.map(f => `a.${f} === b.${f}`).join(' && ');
          lines.push(`${this.i()}${targetName}.__eq = function(a, b) { return ${checks || 'true'}; };`);
        }
        if (trait === 'Show' && targetName) {
          const fields = fieldNames.map(f => `${f}: \${JSON.stringify(obj.${f})}`).join(', ');
          lines.push(`${this.i()}${targetName}.__show = function(obj) { return \`${targetName}(${fields})\`; };`);
        }
        if (trait === 'JSON' && targetName) {
          lines.push(`${this.i()}${targetName}.toJSON = function(obj) { return JSON.stringify(obj); };`);
          lines.push(`${this.i()}${targetName}.fromJSON = function(str) { const d = JSON.parse(str); return ${targetName}(${fieldNames.map(f => `d.${f}`).join(', ')}); };`);
        }
      }

      // For variant types with derive
      if (hasVariants) {
        for (const trait of node.derive) {
          if (trait === 'Eq') {
            lines.push(`${this.i()}function __eq_${node.name}(a, b) { if (a === b) return true; if (!a || !b || a.__tag !== b.__tag) return false; for (const k of Object.keys(a)) { if (k === '__tag') continue; if (a[k] !== b[k]) { if (typeof a[k] === 'object' && typeof b[k] === 'object' && a[k]?.__tag && b[k]?.__tag) { if (!__eq_${node.name}(a[k], b[k])) return false; } else return false; } } return true; }`);
          }
          if (trait === 'Show') {
            lines.push(`${this.i()}function __show_${node.name}(obj) { return obj.__tag + "(" + Object.entries(obj).filter(([k]) => k !== "__tag").map(([k, v]) => k + ": " + JSON.stringify(v)).join(", ") + ")"; }`);
          }
          if (trait === 'JSON') {
            lines.push(`${this.i()}function __toJSON_${node.name}(obj) { return JSON.stringify(obj); }`);
          }
        }
      }
    }

    return lines.join('\n');
  }

  genImplDeclaration(node) {
    const lines = [];
    for (const method of node.methods) {
      const params = method.params.filter(p => p.name !== 'self');
      const paramStr = this.genParams(params);
      const hasPropagate = this._containsPropagate(method.body);
      const asyncPrefix = method.isAsync ? 'async ' : '';
      this.pushScope();
      for (const p of params) {
        if (p.destructure) this._declareDestructureVars(p.destructure);
        else this.declareVar(p.name);
      }
      const body = this.genBlockBody(method.body);
      this.popScope();
      if (hasPropagate) {
        lines.push(`${this.i()}${node.typeName}.prototype.${method.name} = ${asyncPrefix}function(${paramStr}) {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}};`);
      } else {
        lines.push(`${this.i()}${node.typeName}.prototype.${method.name} = ${asyncPrefix}function(${paramStr}) {\n${body}\n${this.i()}};`);
      }
    }
    return lines.join('\n');
  }

  genTraitDeclaration(node) {
    // Traits are mostly compile-time, but generate default implementations as functions
    const lines = [];
    const defaultMethods = node.methods.filter(m => m.body);
    if (defaultMethods.length > 0) {
      lines.push(`${this.i()}/* trait ${node.name} */`);
      for (const method of defaultMethods) {
        const params = this.genParams(method.params);
        this.pushScope();
        for (const p of method.params) {
          if (p.destructure) this._declareDestructureVars(p.destructure);
          else if (p.name) this.declareVar(p.name);
        }
        const body = this.genBlockBody(method.body);
        this.popScope();
        lines.push(`${this.i()}function __trait_${node.name}_${method.name}(${params}) {\n${body}\n${this.i()}}`);
      }
    } else {
      lines.push(`${this.i()}/* trait ${node.name} { ${node.methods.map(m => `fn ${m.name}()`).join(', ')} } */`);
    }
    return lines.join('\n');
  }

  genTypeAlias(node) {
    // Type aliases are compile-time only
    const exportStr = node.isPublic ? 'export ' : '';
    const typeStr = node.typeExpr.name || 'any';
    return `${this.i()}/* ${exportStr}type alias: ${node.name} = ${typeStr} */`;
  }

  genDeferStatement(node) {
    // Defer is handled by genBlockBody which collects defers and wraps in try/finally.
    // If called outside genBlockBody (e.g., via genBlockStatements), generate a no-op comment.
    // The actual defer logic is emitted correctly when genBlockBody processes the enclosing function.
    return `${this.i()}/* defer */`;
  }

  // Check if a function body contains yield expressions (for generator detection)
  _containsYield(node) {
    if (!node) return false;
    if (node.type === 'YieldExpression') return true;
    if (node.type === 'FunctionDeclaration' || node.type === 'LambdaExpression') return false;
    for (const key of Object.keys(node)) {
      if (key === 'loc' || key === 'type') continue;
      const val = node[key];
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'object' && this._containsYield(item)) return true;
        }
      } else if (val && typeof val === 'object' && val.type) {
        if (this._containsYield(val)) return true;
      }
    }
    return false;
  }
}

// ─── src/codegen/shared-codegen.js ─────────────────────

class SharedCodegen extends BaseCodegen {
  generate(block) {
    const code = block.body.map(stmt => this.generateStatement(stmt)).join('\n');
    return code;
  }

  // Generate any needed helpers (called after all code is generated)
  generateHelpers() {
    const helpers = [];
    helpers.push(this.getStringProtoHelper());
    // Only include Result/Option if Ok/Err/Some/None are used
    if (this._needsResultOption) {
      helpers.push(this.getResultOptionHelper());
    }
    if (this._needsContainsHelper) {
      helpers.push(this.getContainsHelper());
    }
    if (this._needsPropagateHelper) {
      helpers.push(this.getPropagateHelper());
    }
    // Include only used builtin functions
    const selectiveStdlib = buildSelectiveStdlib(this._usedBuiltins);
    if (selectiveStdlib) helpers.push(selectiveStdlib);
    return helpers.join('\n');
  }
}

// ─── src/codegen/server-codegen.js ─────────────────────

class ServerCodegen extends BaseCodegen {
  _astUsesIdentifier(blocks, name) {
    const search = (node) => {
      if (!node || typeof node !== 'object') return false;
      if (node.type === 'Identifier' && node.name === name) return true;
      if (node.type === 'MemberExpression' && node.object && node.object.type === 'Identifier' && node.object.name === name) return true;
      for (const key of Object.keys(node)) {
        if (key === 'loc' || key === 'type') continue;
        const val = node[key];
        if (Array.isArray(val)) {
          for (const item of val) {
            if (search(item)) return true;
          }
        } else if (val && typeof val === 'object' && val.type) {
          if (search(val)) return true;
        }
      }
      return false;
    };
    for (const block of blocks) {
      if (search(block)) return true;
    }
    return false;
  }

  _genValidationCode(params, indent = '  ') {
    const checks = [];
    for (const p of params) {
      const name = p.name;
      const ta = p.typeAnnotation;
      if (!ta) continue;
      const hasRequiredCheck = !p.defaultValue;
      if (hasRequiredCheck) {
        checks.push(`${indent}if (${name} === undefined || ${name} === null) __validationErrors.push("${name} is required");`);
      }
      const typeCheckPrefix = hasRequiredCheck ? 'else if' : 'if';
      if (ta.type === 'TypeAnnotation') {
        switch (ta.name) {
          case 'String':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "string") __validationErrors.push("${name} must be a string");`);
            break;
          case 'Int':
            checks.push(`${indent}${typeCheckPrefix} (!Number.isInteger(${name})) __validationErrors.push("${name} must be an integer");`);
            break;
          case 'Float':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "number") __validationErrors.push("${name} must be a number");`);
            break;
          case 'Bool':
            checks.push(`${indent}${typeCheckPrefix} (typeof ${name} !== "boolean") __validationErrors.push("${name} must be a boolean");`);
            break;
        }
      } else if (ta.type === 'ArrayTypeAnnotation') {
        checks.push(`${indent}${typeCheckPrefix} (!Array.isArray(${name})) __validationErrors.push("${name} must be an array");`);
      }
    }
    return checks;
  }

  _genAdvancedValidationCode(schemaExpr, indent = '  ') {
    const checks = [];
    if (schemaExpr.type !== 'ObjectLiteral') return checks;
    for (const prop of schemaExpr.properties) {
      const fieldName = prop.key.type === 'Identifier' ? prop.key.name : (prop.key.type === 'StringLiteral' ? prop.key.value : null);
      if (!fieldName) continue;
      const rules = prop.value;
      if (rules.type !== 'ObjectLiteral') continue;
      for (const rule of rules.properties) {
        const ruleKey = rule.key.type === 'Identifier' ? rule.key.name : (rule.key.type === 'StringLiteral' ? rule.key.value : null);
        if (!ruleKey) continue;
        const ruleVal = this.genExpression(rule.value);
        switch (ruleKey) {
          case 'required':
            checks.push(`${indent}if (${ruleVal} && (__body.${fieldName} === undefined || __body.${fieldName} === null || __body.${fieldName} === "")) __validationErrors.push("${fieldName} is required");`);
            break;
          case 'min_length':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && String(__body.${fieldName}).length < ${ruleVal}) __validationErrors.push("${fieldName} must be at least ${ruleVal} characters");`);
            break;
          case 'max_length':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && String(__body.${fieldName}).length > ${ruleVal}) __validationErrors.push("${fieldName} must be at most ${ruleVal} characters");`);
            break;
          case 'min':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && Number(__body.${fieldName}) < ${ruleVal}) __validationErrors.push("${fieldName} must be at least ${ruleVal}");`);
            break;
          case 'max':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && Number(__body.${fieldName}) > ${ruleVal}) __validationErrors.push("${fieldName} must be at most ${ruleVal}");`);
            break;
          case 'pattern':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && !new RegExp(${ruleVal}).test(String(__body.${fieldName}))) __validationErrors.push("${fieldName} does not match required pattern");`);
            break;
          case 'one_of':
            checks.push(`${indent}if (__body.${fieldName} !== undefined && __body.${fieldName} !== null && !${ruleVal}.includes(__body.${fieldName})) __validationErrors.push("${fieldName} must be one of: " + ${ruleVal}.join(", "));`);
            break;
        }
      }
    }
    return checks;
  }

  // Emit handler call, optionally wrapped in Promise.race for timeout
  _emitHandlerCall(lines, callExpr, timeoutMs) {
    if (timeoutMs) {
      lines.push(`  let __result;`);
      lines.push(`  try {`);
      lines.push(`    __result = await Promise.race([`);
      lines.push(`      ${callExpr},`);
      lines.push(`      new Promise((_, rej) => setTimeout(() => rej(new Error("__timeout__")), ${timeoutMs}))`);
      lines.push(`    ]);`);
      lines.push(`  } catch (__err) {`);
      lines.push(`    if (__err.message === "__timeout__") return Response.json({ error: "Gateway Timeout" }, { status: 504 });`);
      lines.push(`    throw __err;`);
      lines.push(`  }`);
    } else {
      lines.push(`  const __result = await ${callExpr};`);
    }
  }

  generate(serverBlocks, sharedCode, blockName = null, peerBlocks = null, sharedBlocks = []) {
    const lines = [];

    // Shared code
    if (sharedCode.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedCode);
      lines.push('');
    }

    // Collect all declarations from blocks (including route group flattening)
    const routes = [];
    const functions = [];
    const middlewares = [];
    const otherStatements = [];
    let healthPath = null;
    let corsConfig = null;
    let errorHandler = null;
    let wsDecl = null;
    let staticDecl = null;
    let authConfig = null;
    let maxBodyLimit = null;
    const discoverMap = new Map();
    let rateLimitConfig = null;
    const onStartHooks = [];
    const onStopHooks = [];
    const subscriptions = [];
    const envDecls = [];
    const schedules = [];
    let uploadConfig = null;
    let sessionConfig = null;
    let dbConfig = null;
    let tlsConfig = null;
    let compressionConfig = null;
    const backgroundJobs = [];
    let cacheConfig = null;
    const sseDecls = [];
    const modelDecls = [];

    const collectFromBody = (stmts, groupPrefix = null, groupMiddlewares = []) => {
      for (const stmt of stmts) {
        if (stmt.type === 'RouteDeclaration') {
          const route = stmt;
          if (groupPrefix) {
            const prefixedRoute = {
              ...route,
              path: groupPrefix + route.path,
              _groupMiddlewares: groupMiddlewares.length > 0 ? [...groupMiddlewares] : undefined,
            };
            routes.push(prefixedRoute);
          } else {
            routes.push(route);
          }
        } else if (stmt.type === 'FunctionDeclaration') {
          functions.push(stmt);
        } else if (stmt.type === 'MiddlewareDeclaration') {
          if (groupPrefix !== null) {
            groupMiddlewares.push(stmt.name);
          }
          middlewares.push(stmt);
        } else if (stmt.type === 'HealthCheckDeclaration') {
          healthPath = stmt.path;
        } else if (stmt.type === 'CorsDeclaration') {
          corsConfig = stmt.config;
        } else if (stmt.type === 'ErrorHandlerDeclaration') {
          errorHandler = stmt;
        } else if (stmt.type === 'WebSocketDeclaration') {
          wsDecl = stmt;
        } else if (stmt.type === 'StaticDeclaration') {
          staticDecl = stmt;
        } else if (stmt.type === 'AuthDeclaration') {
          authConfig = stmt.config;
        } else if (stmt.type === 'MaxBodyDeclaration') {
          maxBodyLimit = stmt.limit;
        } else if (stmt.type === 'DiscoverDeclaration') {
          discoverMap.set(stmt.peerName, stmt);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          const prefix = groupPrefix ? groupPrefix + stmt.prefix : stmt.prefix;
          const grpMw = [...groupMiddlewares]; // inherit parent group middlewares
          collectFromBody(stmt.body, prefix, grpMw);
        } else if (stmt.type === 'RateLimitDeclaration') {
          rateLimitConfig = stmt.config;
        } else if (stmt.type === 'LifecycleHookDeclaration') {
          if (stmt.hook === 'start') onStartHooks.push(stmt);
          else if (stmt.hook === 'stop') onStopHooks.push(stmt);
        } else if (stmt.type === 'SubscribeDeclaration') {
          subscriptions.push(stmt);
        } else if (stmt.type === 'EnvDeclaration') {
          envDecls.push(stmt);
        } else if (stmt.type === 'ScheduleDeclaration') {
          schedules.push(stmt);
        } else if (stmt.type === 'UploadDeclaration') {
          uploadConfig = stmt.config;
        } else if (stmt.type === 'SessionDeclaration') {
          sessionConfig = stmt.config;
        } else if (stmt.type === 'DbDeclaration') {
          dbConfig = stmt.config;
        } else if (stmt.type === 'TlsDeclaration') {
          tlsConfig = stmt.config;
        } else if (stmt.type === 'CompressionDeclaration') {
          compressionConfig = stmt.config;
        } else if (stmt.type === 'BackgroundJobDeclaration') {
          backgroundJobs.push(stmt);
        } else if (stmt.type === 'CacheDeclaration') {
          cacheConfig = stmt.config;
        } else if (stmt.type === 'SseDeclaration') {
          sseDecls.push(stmt);
        } else if (stmt.type === 'ModelDeclaration') {
          modelDecls.push(stmt);
        } else {
          otherStatements.push(stmt);
        }
      }
    };

    for (const block of serverBlocks) {
      collectFromBody(block.body);
    }

    // Collect type declarations from shared blocks for model/ORM generation
    const sharedTypes = new Map(); // typeName -> { fields: [{ name, type }] }
    for (const sb of sharedBlocks) {
      for (const stmt of sb.body) {
        if (stmt.type === 'TypeDeclaration' && stmt.variants) {
          const fields = [];
          for (const v of stmt.variants) {
            if (v.type === 'TypeField' && v.typeAnnotation) {
              fields.push({ name: v.name, type: v.typeAnnotation.name || (v.typeAnnotation.type === 'ArrayTypeAnnotation' ? 'Array' : 'Any') });
            }
          }
          if (fields.length > 0) {
            sharedTypes.set(stmt.name, { fields });
          }
        }
      }
    }

    // Separate group-only middlewares from global middlewares
    const globalMiddlewares = [];
    const allMiddlewareNames = new Set();
    for (const block of serverBlocks) {
      for (const stmt of block.body) {
        if (stmt.type === 'MiddlewareDeclaration') {
          globalMiddlewares.push(stmt);
        }
      }
    }
    for (const mw of middlewares) {
      allMiddlewareNames.add(mw.name);
    }

    // Build function param lookup map
    const fnParamMap = new Map();
    const fnDeclMap = new Map();
    for (const fn of functions) {
      fnParamMap.set(fn.name, fn.params.map(p => p.name));
      fnDeclMap.set(fn.name, fn);
    }

    // Check if 'db' is used
    const usesDb = this._astUsesIdentifier(serverBlocks, 'db');

    // Check if rate limiting is needed
    const needsRateLimitStore = !!rateLimitConfig || routes.some(r => (r.decorators || []).some(d => d.name === 'rate_limit'));

    // ════════════════════════════════════════════════════════════
    // 1. Distributed Tracing
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Distributed Tracing ──');
    lines.push('import { AsyncLocalStorage } from "node:async_hooks";');
    lines.push('const __requestContext = new AsyncLocalStorage();');
    lines.push('function __getRequestId() {');
    lines.push('  const store = __requestContext.getStore();');
    lines.push('  return store ? store.rid : null;');
    lines.push('}');
    lines.push('function __getLocals() {');
    lines.push('  const store = __requestContext.getStore();');
    lines.push('  return store ? store.locals : {};');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 2. Env Validation (F6) — fail fast
    // ════════════════════════════════════════════════════════════
    if (envDecls.length > 0) {
      lines.push('// ── Env Validation ──');
      for (const decl of envDecls) {
        const envName = decl.name;
        const ta = decl.typeAnnotation;
        const typeName = ta ? ta.name : 'String';
        lines.push(`const ${envName} = (() => {`);
        lines.push(`  const __raw = process.env.${envName};`);
        if (decl.defaultValue) {
          const defaultExpr = this.genExpression(decl.defaultValue);
          lines.push(`  if (__raw === undefined || __raw === "") return ${defaultExpr};`);
        } else {
          lines.push(`  if (__raw === undefined || __raw === "") { console.error("Required env var ${envName} is not set"); process.exit(1); }`);
        }
        switch (typeName) {
          case 'Int':
            lines.push(`  const __val = parseInt(__raw, 10);`);
            lines.push(`  if (isNaN(__val)) { console.error("env ${envName}: expected Int, got " + __raw); process.exit(1); }`);
            lines.push(`  return __val;`);
            break;
          case 'Float':
            lines.push(`  const __val = parseFloat(__raw);`);
            lines.push(`  if (isNaN(__val)) { console.error("env ${envName}: expected Float, got " + __raw); process.exit(1); }`);
            lines.push(`  return __val;`);
            break;
          case 'Bool':
            lines.push(`  return __raw === "true" || __raw === "1";`);
            break;
          default:
            lines.push(`  return __raw;`);
            break;
        }
        lines.push(`})();`);
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 3. Database (multi-driver: sqlite, postgres, mysql)
    // ════════════════════════════════════════════════════════════
    const dbDriver = dbConfig && dbConfig.driver ? (dbConfig.driver.value || 'sqlite') : 'sqlite';
    if (dbConfig || usesDb) {
      lines.push('// ── Database ──');
      if (dbDriver === 'postgres') {
        lines.push('import postgres from "postgres";');
        const urlExpr = dbConfig && dbConfig.url ? this.genExpression(dbConfig.url) : 'process.env.DATABASE_URL || "postgres://localhost:5432/app"';
        lines.push(`const __pg = postgres(${urlExpr});`);
        lines.push('const db = {');
        lines.push('  async query(sql, ...params) {');
        lines.push('    if (params.length > 0) { return __pg.unsafe(sql, params); }');
        lines.push('    return __pg.unsafe(sql);');
        lines.push('  },');
        lines.push('  async run(sql, ...params) {');
        lines.push('    if (params.length > 0) { return __pg.unsafe(sql, params); }');
        lines.push('    return __pg.unsafe(sql);');
        lines.push('  },');
        lines.push('  async get(sql, ...params) {');
        lines.push('    const rows = params.length > 0 ? await __pg.unsafe(sql, params) : await __pg.unsafe(sql);');
        lines.push('    return rows[0] || null;');
        lines.push('  },');
        lines.push('  async exec(sql) { return __pg.unsafe(sql); },');
        lines.push('  async transaction(fn) {');
        lines.push('    return __pg.begin(sql => fn({ query: (s, ...p) => sql.unsafe(s, p), run: (s, ...p) => sql.unsafe(s, p), get: async (s, ...p) => { const r = await sql.unsafe(s, p); return r[0] || null; }, exec: (s) => sql.unsafe(s) }));');
        lines.push('  },');
        lines.push('  async migrate(migrations) {');
        lines.push('    await __pg.unsafe(`CREATE TABLE IF NOT EXISTS __migrations (id SERIAL PRIMARY KEY, name TEXT NOT NULL UNIQUE, applied_at TIMESTAMPTZ DEFAULT NOW())`);');
        lines.push('    const applied = new Set((await __pg.unsafe("SELECT name FROM __migrations")).map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!applied.has(m.name)) {');
        lines.push('        await __pg.unsafe(m.up);');
        lines.push('        await __pg.unsafe("INSERT INTO __migrations (name) VALUES ($1)", [m.name]);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  async close() { await __pg.end(); },');
        lines.push('};');
      } else if (dbDriver === 'mysql') {
        lines.push('import mysql from "mysql2/promise";');
        const urlExpr = dbConfig && dbConfig.url ? this.genExpression(dbConfig.url) : 'process.env.DATABASE_URL || "mysql://localhost:3306/app"';
        lines.push(`const __mysqlPool = mysql.createPool(${urlExpr});`);
        lines.push('const db = {');
        lines.push('  async query(sql, ...params) {');
        lines.push('    const [rows] = await __mysqlPool.execute(sql, params);');
        lines.push('    return rows;');
        lines.push('  },');
        lines.push('  async run(sql, ...params) {');
        lines.push('    const [result] = await __mysqlPool.execute(sql, params);');
        lines.push('    return result;');
        lines.push('  },');
        lines.push('  async get(sql, ...params) {');
        lines.push('    const [rows] = await __mysqlPool.execute(sql, params);');
        lines.push('    return rows[0] || null;');
        lines.push('  },');
        lines.push('  async exec(sql) { const [r] = await __mysqlPool.query(sql); return r; },');
        lines.push('  async transaction(fn) {');
        lines.push('    const conn = await __mysqlPool.getConnection();');
        lines.push('    await conn.beginTransaction();');
        lines.push('    try {');
        lines.push('      const result = await fn({ query: async (s, ...p) => { const [r] = await conn.execute(s, p); return r; }, run: async (s, ...p) => { const [r] = await conn.execute(s, p); return r; }, get: async (s, ...p) => { const [r] = await conn.execute(s, p); return r[0] || null; }, exec: async (s) => { const [r] = await conn.query(s); return r; } });');
        lines.push('      await conn.commit();');
        lines.push('      return result;');
        lines.push('    } catch (e) { await conn.rollback(); throw e; }');
        lines.push('    finally { conn.release(); }');
        lines.push('  },');
        lines.push('  async migrate(migrations) {');
        lines.push('    await __mysqlPool.query(`CREATE TABLE IF NOT EXISTS __migrations (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL UNIQUE, applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);');
        lines.push('    const [applied] = await __mysqlPool.query("SELECT name FROM __migrations");');
        lines.push('    const appliedSet = new Set(applied.map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!appliedSet.has(m.name)) {');
        lines.push('        await __mysqlPool.query(m.up);');
        lines.push('        await __mysqlPool.execute("INSERT INTO __migrations (name) VALUES (?)", [m.name]);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  async close() { await __mysqlPool.end(); },');
        lines.push('};');
      } else {
        // Default: SQLite
        lines.push('import { Database } from "bun:sqlite";');
        const pathExpr = dbConfig && dbConfig.path ? this.genExpression(dbConfig.path) : '":memory:"';
        lines.push(`const __db = new Database(${pathExpr});`);
        const walEnabled = dbConfig && dbConfig.wal ? this.genExpression(dbConfig.wal) : 'true';
        lines.push(`if (${walEnabled}) __db.exec("PRAGMA journal_mode=WAL");`);
        lines.push('__db.exec("PRAGMA foreign_keys=ON");');
        lines.push('const db = {');
        lines.push('  query(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.all(...params);');
        lines.push('  },');
        lines.push('  run(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.run(...params);');
        lines.push('  },');
        lines.push('  get(sql, ...params) {');
        lines.push('    const stmt = __db.prepare(sql);');
        lines.push('    return stmt.get(...params);');
        lines.push('  },');
        lines.push('  exec(sql) { return __db.exec(sql); },');
        lines.push('  transaction(fn) {');
        lines.push('    return __db.transaction(fn)();');
        lines.push('  },');
        lines.push('  migrate(migrations) {');
        lines.push('    __db.exec(`CREATE TABLE IF NOT EXISTS __migrations (');
        lines.push('      id INTEGER PRIMARY KEY, name TEXT NOT NULL UNIQUE, applied_at TEXT DEFAULT (datetime(\'now\'))');
        lines.push('    )`);');
        lines.push('    const applied = new Set(__db.prepare("SELECT name FROM __migrations").all().map(r => r.name));');
        lines.push('    for (const m of migrations) {');
        lines.push('      if (!applied.has(m.name)) {');
        lines.push('        __db.exec(m.up);');
        lines.push('        __db.prepare("INSERT INTO __migrations (name) VALUES (?)").run(m.name);');
        lines.push('        console.log(`Migration applied: ${m.name}`);');
        lines.push('      }');
        lines.push('    }');
        lines.push('  },');
        lines.push('  close() { __db.close(); },');
        lines.push('};');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 4. Peer Server RPC Proxies (with circuit breaker + retry)
    // ════════════════════════════════════════════════════════════
    if (peerBlocks && peerBlocks.size > 0) {
      lines.push('// ── Circuit Breaker + Retry ──');
      lines.push('class __CircuitBreaker {');
      lines.push('  constructor(name, threshold = 5, resetTimeout = 30000) {');
      lines.push('    this.name = name;');
      lines.push('    this.state = "CLOSED";');
      lines.push('    this.failures = 0;');
      lines.push('    this.threshold = threshold;');
      lines.push('    this.resetTimeout = resetTimeout;');
      lines.push('    this.nextAttempt = 0;');
      lines.push('  }');
      lines.push('  async call(fn) {');
      lines.push('    if (this.state === "OPEN") {');
      lines.push('      if (Date.now() < this.nextAttempt) {');
      lines.push('        throw new Error(`Circuit breaker OPEN for ${this.name}`);');
      lines.push('      }');
      lines.push('      this.state = "HALF_OPEN";');
      lines.push('    }');
      lines.push('    try {');
      lines.push('      const result = await fn();');
      lines.push('      this.failures = 0;');
      lines.push('      this.state = "CLOSED";');
      lines.push('      return result;');
      lines.push('    } catch (err) {');
      lines.push('      this.failures++;');
      lines.push('      if (this.failures >= this.threshold) {');
      lines.push('        this.state = "OPEN";');
      lines.push('        this.nextAttempt = Date.now() + this.resetTimeout;');
      lines.push('      }');
      lines.push('      throw err;');
      lines.push('    }');
      lines.push('  }');
      lines.push('}');
      lines.push('');
      lines.push('async function __retryWithBackoff(fn, retries = 2, baseDelay = 100) {');
      lines.push('  for (let i = 0; i <= retries; i++) {');
      lines.push('    try { return await fn(); } catch (err) {');
      lines.push('      if (i === retries) throw err;');
      lines.push('      await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, i)));');
      lines.push('    }');
      lines.push('  }');
      lines.push('}');
      lines.push('');

      lines.push('// ── Peer Server RPC Proxies ──');
      for (const [peerName, peerFunctions] of peerBlocks) {
        const portVar = `PORT_${peerName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}`;
        const disc = discoverMap.get(peerName);
        const cbThreshold = disc && disc.config && disc.config.threshold ? this.genExpression(disc.config.threshold) : '5';
        const cbReset = disc && disc.config && disc.config.reset_timeout ? this.genExpression(disc.config.reset_timeout) : '30000';
        const rpcTimeout = disc && disc.config && disc.config.timeout ? this.genExpression(disc.config.timeout) : '10000';
        lines.push(`const __cb_${peerName} = new __CircuitBreaker("${peerName}", ${cbThreshold}, ${cbReset});`);

        let baseUrlExpr;
        if (disc) {
          baseUrlExpr = this.genExpression(disc.urlExpression);
        } else {
          baseUrlExpr = `(process.env.${portVar} ? \`http://localhost:\${process.env.${portVar}}\` : "http://localhost:3000")`;
        }

        lines.push(`const ${peerName} = {`);
        lines.push(`  __baseUrl: ${baseUrlExpr},`);
        for (const fnName of peerFunctions) {
          lines.push(`  async ${fnName}(...args) {`);
          lines.push(`    return __cb_${peerName}.call(() => __retryWithBackoff(async () => {`);
          lines.push(`      const __controller = new AbortController();`);
          lines.push(`      const __timeout = setTimeout(() => __controller.abort(), ${rpcTimeout});`);
          lines.push(`      try {`);
          lines.push(`        const __res = await fetch(\`\${${peerName}.__baseUrl}/rpc/${fnName}\`, {`);
          lines.push(`          method: 'POST',`);
          lines.push(`          headers: { 'Content-Type': 'application/json', 'X-Request-Id': __getRequestId() || '' },`);
          lines.push(`          body: JSON.stringify({ __args: args }),`);
          lines.push(`          signal: __controller.signal,`);
          lines.push(`        });`);
          lines.push(`        if (!__res.ok) throw new Error(\`RPC ${peerName}.${fnName} failed: \${__res.status}\`);`);
          lines.push(`        return (await __res.json()).result;`);
          lines.push(`      } catch (__err) {`);
          lines.push(`        if (__err.name === 'AbortError') throw new Error(\`RPC ${peerName}.${fnName} timed out\`);`);
          lines.push(`        throw __err;`);
          lines.push(`      } finally {`);
          lines.push(`        clearTimeout(__timeout);`);
          lines.push(`      }`);
          lines.push(`    }));`);
          lines.push(`  },`);
        }
        lines.push(`};`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 5. Runtime Helpers (respond, cookies)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Runtime Helpers ──');
    lines.push('function respond(status, body, headers = {}) {');
    lines.push('  const __hasContentType = Object.keys(headers).some(k => k.toLowerCase() === "content-type");');
    lines.push('  if (__hasContentType) {');
    lines.push('    const data = typeof body === "string" ? body : JSON.stringify(body);');
    lines.push('    return new Response(data, { status, headers });');
    lines.push('  }');
    lines.push('  return new Response(JSON.stringify(body), {');
    lines.push('    status,');
    lines.push('    headers: { "Content-Type": "application/json", ...headers },');
    lines.push('  });');
    lines.push('}');
    lines.push('');

    lines.push('function __parseQuery(searchParams) {');
    lines.push('  const q = {};');
    lines.push('  for (const [k, v] of searchParams) {');
    lines.push('    if (q[k] !== undefined) {');
    lines.push('      if (!Array.isArray(q[k])) q[k] = [q[k]];');
    lines.push('      q[k].push(v);');
    lines.push('    } else { q[k] = v; }');
    lines.push('  }');
    lines.push('  return q;');
    lines.push('}');
    lines.push('function __parseCookies(str) {');
    lines.push('  const c = {};');
    lines.push('  if (!str) return c;');
    lines.push('  for (const pair of str.split(";")) {');
    lines.push('    const [k, ...v] = pair.trim().split("=");');
    lines.push('    if (k) c[k.trim()] = v.join("=").trim();');
    lines.push('  }');
    lines.push('  return c;');
    lines.push('}');
    lines.push('');
    lines.push('async function __readBodyBytes(req) {');
    lines.push('  if (!req.body) return new Uint8Array(0);');
    lines.push('  const reader = req.body.getReader();');
    lines.push('  const chunks = [];');
    lines.push('  let totalBytes = 0;');
    lines.push('  while (true) {');
    lines.push('    const { done, value } = await reader.read();');
    lines.push('    if (done) break;');
    lines.push('    totalBytes += value.byteLength;');
    lines.push('    if (totalBytes > __maxBodySize) throw new Error("__BODY_TOO_LARGE__");');
    lines.push('    chunks.push(value);');
    lines.push('  }');
    lines.push('  const result = new Uint8Array(totalBytes);');
    lines.push('  let offset = 0;');
    lines.push('  for (const chunk of chunks) { result.set(chunk, offset); offset += chunk.byteLength; }');
    lines.push('  return result;');
    lines.push('}');
    lines.push('async function __parseBody(req) {');
    lines.push('  const ct = (req.headers.get("content-type") || "").toLowerCase();');
    lines.push('  if (ct.includes("multipart/form-data")) {');
    lines.push('    try {');
    lines.push('      const fd = await req.formData();');
    lines.push('      const obj = {};');
    lines.push('      for (const [k, v] of fd) {');
    lines.push('        if (obj[k] !== undefined) {');
    lines.push('          if (!Array.isArray(obj[k])) obj[k] = [obj[k]];');
    lines.push('          obj[k].push(v);');
    lines.push('        } else { obj[k] = v; }');
    lines.push('      }');
    lines.push('      return obj;');
    lines.push('    } catch { return null; }');
    lines.push('  }');
    lines.push('  const raw = await __readBodyBytes(req);');
    lines.push('  const text = new TextDecoder().decode(raw);');
    lines.push('  if (ct.includes("application/x-www-form-urlencoded")) {');
    lines.push('    try {');
    lines.push('      const sp = new URLSearchParams(text);');
    lines.push('      const obj = {};');
    lines.push('      for (const [k, v] of sp) {');
    lines.push('        if (obj[k] !== undefined) {');
    lines.push('          if (!Array.isArray(obj[k])) obj[k] = [obj[k]];');
    lines.push('          obj[k].push(v);');
    lines.push('        } else { obj[k] = v; }');
    lines.push('      }');
    lines.push('      return obj;');
    lines.push('    } catch { return null; }');
    lines.push('  }');
    lines.push('  try { return JSON.parse(text); } catch { return null; }');
    lines.push('}');

    // ════════════════════════════════════════════════════════════
    // 6. Response Helpers (F4) — redirect, set_cookie, stream
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Response Helpers ──');
    lines.push('function redirect(url, status = 302) {');
    lines.push('  return new Response(null, { status, headers: { Location: url } });');
    lines.push('}');
    lines.push('function set_cookie(name, value, options = {}) {');
    lines.push('  let cookie = `${name}=${encodeURIComponent(value)}`;');
    lines.push('  if (options.maxAge) cookie += `; Max-Age=${options.maxAge}`;');
    lines.push('  if (options.path) cookie += `; Path=${options.path}`;');
    lines.push('  if (options.domain) cookie += `; Domain=${options.domain}`;');
    lines.push('  if (options.httpOnly) cookie += "; HttpOnly";');
    lines.push('  if (options.secure) cookie += "; Secure";');
    lines.push('  if (options.sameSite) cookie += `; SameSite=${options.sameSite}`;');
    lines.push('  return cookie;');
    lines.push('}');
    lines.push('function stream(fn) {');
    lines.push('  const readable = new ReadableStream({');
    lines.push('    start(controller) {');
    lines.push('      const send = (data) => controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(data)}\\n\\n`));');
    lines.push('      const close = () => controller.close();');
    lines.push('      fn(send, close);');
    lines.push('    }');
    lines.push('  });');
    lines.push('  return new Response(readable, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });');
    lines.push('}');
    lines.push('function sse(fn) {');
    lines.push('  let cancelled = false;');
    lines.push('  const readable = new ReadableStream({');
    lines.push('    async start(controller) {');
    lines.push('      const send = (data, event) => {');
    lines.push('        if (cancelled) return;');
    lines.push('        let msg = "";');
    lines.push('        if (event) msg += `event: ${event}\\n`;');
    lines.push('        msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
    lines.push('        controller.enqueue(new TextEncoder().encode(msg));');
    lines.push('      };');
    lines.push('      const close = () => { cancelled = true; controller.close(); };');
    lines.push('      await fn(send, close);');
    lines.push('    },');
    lines.push('    cancel() { cancelled = true; }');
    lines.push('  });');
    lines.push('  return new Response(readable, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" } });');
    lines.push('}');
    lines.push('function html(body, status = 200, headers = {}) {');
    lines.push('  return new Response(body, { status, headers: { "Content-Type": "text/html", ...headers } });');
    lines.push('}');
    lines.push('function text(body, status = 200, headers = {}) {');
    lines.push('  return new Response(body, { status, headers: { "Content-Type": "text/plain", ...headers } });');
    lines.push('}');
    lines.push('function with_headers(response, headers) {');
    lines.push('  const h = new Headers(response.headers);');
    lines.push('  for (const [k, v] of Object.entries(headers)) h.set(k, v);');
    lines.push('  return new Response(response.body, { status: response.status, headers: h });');
    lines.push('}');
    lines.push('');

    // ── Auth Builtins: sign_jwt, hash_password, verify_password ──
    lines.push('// ── Auth Builtins ──');
    lines.push('let __jwtSignKey = null;');
    lines.push('async function sign_jwt(payload, secret, options = {}) {');
    lines.push('  const __secret = secret || (typeof __authSecret !== "undefined" ? __authSecret : "secret");');
    lines.push('  if (!__jwtSignKey || __secret !== (typeof __authSecret !== "undefined" ? __authSecret : "")) {');
    lines.push('    __jwtSignKey = await crypto.subtle.importKey(');
    lines.push('      "raw", new TextEncoder().encode(__secret),');
    lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign"]');
    lines.push('    );');
    lines.push('  }');
    lines.push('  const header = { alg: "HS256", typ: "JWT" };');
    lines.push('  const now = Math.floor(Date.now() / 1000);');
    lines.push('  const claims = { ...payload, iat: now };');
    lines.push('  if (options.expires_in) claims.exp = now + options.expires_in;');
    lines.push('  if (options.exp) claims.exp = options.exp;');
    lines.push('  const __b64url = (obj) => btoa(JSON.stringify(obj)).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
    lines.push('  const __headerB64 = __b64url(header);');
    lines.push('  const __payloadB64 = __b64url(claims);');
    lines.push('  const __sigData = __headerB64 + "." + __payloadB64;');
    lines.push('  const __sig = await crypto.subtle.sign("HMAC", __jwtSignKey, new TextEncoder().encode(__sigData));');
    lines.push('  const __sigB64 = btoa(String.fromCharCode(...new Uint8Array(__sig))).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
    lines.push('  return __sigData + "." + __sigB64;');
    lines.push('}');
    lines.push('');
    lines.push('async function hash_password(password) {');
    lines.push('  const salt = crypto.getRandomValues(new Uint8Array(16));');
    lines.push('  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]);');
    lines.push('  const hash = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, key, 256);');
    lines.push('  const saltHex = [...salt].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  const hashHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  return `pbkdf2:100000:${saltHex}:${hashHex}`;');
    lines.push('}');
    lines.push('');
    lines.push('async function verify_password(password, stored) {');
    lines.push('  const parts = stored.split(":");');
    lines.push('  if (parts[0] !== "pbkdf2" || parts.length !== 4) return false;');
    lines.push('  const iterations = parseInt(parts[1], 10);');
    lines.push('  const salt = new Uint8Array(parts[2].match(/.{2}/g).map(b => parseInt(b, 16)));');
    lines.push('  const expectedHash = parts[3];');
    lines.push('  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]);');
    lines.push('  const hash = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: "SHA-256" }, key, 256);');
    lines.push('  const hashHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");');
    lines.push('  return hashHex === expectedHash;');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 7. Router
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Router ──');
    lines.push('const __routes = [];');
    lines.push('function __addRoute(method, path, handler) {');
    lines.push('  let pattern = path');
    lines.push('    .replace(/\\*([a-zA-Z_][a-zA-Z0-9_]*)/g, "(?<$1>.+)")');
    lines.push('    .replace(/\\*$/g, "(.*)")');
    lines.push('    .replace(/:([^/]+)/g, "(?<$1>[^/]+)");');
    lines.push('  __routes.push({ method, regex: new RegExp(`^${pattern}$`), handler, _path: path });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 8. CORS
    // ════════════════════════════════════════════════════════════
    if (corsConfig) {
      const origins = corsConfig.origins ? this.genExpression(corsConfig.origins) : '["*"]';
      const methods = corsConfig.methods ? this.genExpression(corsConfig.methods) : '["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]';
      const headers = corsConfig.headers ? this.genExpression(corsConfig.headers) : '["Content-Type", "Authorization"]';
      const credentials = corsConfig.credentials ? this.genExpression(corsConfig.credentials) : 'false';
      lines.push('// ── CORS ──');
      lines.push(`const __corsOrigins = ${origins};`);
      lines.push(`const __corsCredentials = ${credentials};`);
      lines.push('function __getCorsHeaders(req) {');
      lines.push('  const origin = req.headers.get("Origin") || "*";');
      lines.push('  const allowed = __corsOrigins.includes("*") || __corsOrigins.includes(origin);');
      lines.push('  const h = {');
      lines.push(`    "Access-Control-Allow-Origin": allowed ? (__corsCredentials ? origin : (origin === "*" ? "*" : origin)) : "",`);
      lines.push(`    "Access-Control-Allow-Methods": ${methods}.join(", "),`);
      lines.push(`    "Access-Control-Allow-Headers": ${headers}.join(", "),`);
      lines.push('  };');
      lines.push('  if (__corsCredentials) h["Access-Control-Allow-Credentials"] = "true";');
      lines.push('  return h;');
      lines.push('}');
    } else {
      lines.push('// ── CORS ──');
      lines.push('function __getCorsHeaders() {');
      lines.push('  return {');
      lines.push('    "Access-Control-Allow-Origin": "*",');
      lines.push('    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",');
      lines.push('    "Access-Control-Allow-Headers": "Content-Type, Authorization",');
      lines.push('  };');
      lines.push('}');
    }
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 9. Auth (F1) — fixed JWT / API key
    // ════════════════════════════════════════════════════════════
    if (authConfig) {
      lines.push('// ── Auth ──');
      const authType = authConfig.type ? authConfig.type.value : 'jwt';

      if (authType === 'api_key') {
        const keysExpr = authConfig.keys ? this.genExpression(authConfig.keys) : '[]';
        const headerExpr = authConfig.header ? this.genExpression(authConfig.header) : '"X-API-Key"';
        lines.push(`const __validApiKeys = new Set(${keysExpr});`);
        lines.push(`const __apiKeyHeader = ${headerExpr};`);
        lines.push('function __authenticate(req) {');
        lines.push('  const key = req.headers.get(__apiKeyHeader);');
        lines.push('  if (!key || !__validApiKeys.has(key)) return null;');
        lines.push('  return { authenticated: true };');
        lines.push('}');
      } else {
        // JWT auth (default)
        const secretExpr = authConfig.secret ? this.genExpression(authConfig.secret) : '"secret"';
        lines.push(`const __authSecret = ${secretExpr};`);
        lines.push('let __authKey = null;');
        lines.push('async function __authenticate(req) {');
        lines.push('  const authHeader = req.headers.get("Authorization");');
        lines.push('  if (!authHeader || !authHeader.startsWith("Bearer ")) return null;');
        lines.push('  const token = authHeader.slice(7);');
        lines.push('  try {');
        lines.push('    const parts = token.split(".");');
        lines.push('    if (parts.length !== 3) return null;');
        lines.push('    if (!__authKey) {');
        lines.push('      __authKey = await crypto.subtle.importKey(');
        lines.push('        "raw", new TextEncoder().encode(__authSecret),');
        lines.push('        { name: "HMAC", hash: "SHA-256" }, false, ["sign"]');
        lines.push('      );');
        lines.push('    }');
        lines.push('    const __sigData = parts[0] + "." + parts[1];');
        lines.push('    const __sig = await crypto.subtle.sign("HMAC", __authKey, new TextEncoder().encode(__sigData));');
        lines.push('    const __expectedSig = btoa(String.fromCharCode(...new Uint8Array(__sig)))');
        lines.push('      .replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
        lines.push('    const __sigBuf = new TextEncoder().encode(__expectedSig);');
        lines.push('    const __tokBuf = new TextEncoder().encode(parts[2]);');
        lines.push('    if (__sigBuf.length !== __tokBuf.length) return null;');
        lines.push('    let __mismatch = 0;');
        lines.push('    for (let i = 0; i < __sigBuf.length; i++) __mismatch |= __sigBuf[i] ^ __tokBuf[i];');
        lines.push('    if (__mismatch !== 0) return null;');
        lines.push('    const __payload = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));');
        lines.push('    if (__payload.exp && __payload.exp < Math.floor(Date.now() / 1000)) return null;');
        lines.push('    return __payload;');
        lines.push('  } catch { return null; }');
        lines.push('}');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 10. Max Body Size
    // ════════════════════════════════════════════════════════════
    if (maxBodyLimit) {
      lines.push('// ── Max Body Size ──');
      lines.push(`const __maxBodySize = ${this.genExpression(maxBodyLimit)};`);
      lines.push('');
    } else {
      lines.push('// ── Max Body Size ──');
      lines.push('const __maxBodySize = 1048576;');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11. Rate Limiting (F2) — store + checker
    // ════════════════════════════════════════════════════════════
    if (needsRateLimitStore) {
      lines.push('// ── Rate Limiting ──');
      if (rateLimitConfig) {
        const maxExpr = rateLimitConfig.max ? this.genExpression(rateLimitConfig.max) : '100';
        const windowExpr = rateLimitConfig.window ? this.genExpression(rateLimitConfig.window) : '60';
        lines.push(`const __rateLimitMax = ${maxExpr};`);
        lines.push(`const __rateLimitWindow = ${windowExpr};`);
      }
      lines.push('const __rateLimitStore = new Map();');
      lines.push('function __checkRateLimit(key, max, windowSec) {');
      lines.push('  const now = Date.now();');
      lines.push('  const windowMs = windowSec * 1000;');
      lines.push('  let entry = __rateLimitStore.get(key);');
      lines.push('  if (!entry) { entry = { timestamps: [] }; __rateLimitStore.set(key, entry); }');
      lines.push('  entry.timestamps = entry.timestamps.filter(t => now - t < windowMs);');
      lines.push('  if (entry.timestamps.length >= max) {');
      lines.push('    const retryAfter = Math.ceil((entry.timestamps[0] + windowMs - now) / 1000);');
      lines.push('    return { limited: true, retryAfter };');
      lines.push('  }');
      lines.push('  entry.timestamps.push(now);');
      lines.push('  return { limited: false };');
      lines.push('}');
      lines.push('setInterval(() => {');
      lines.push('  const now = Date.now();');
      lines.push('  for (const [key, entry] of __rateLimitStore) {');
      lines.push('    if (entry.timestamps.length === 0 || now - entry.timestamps[entry.timestamps.length - 1] > 60000) {');
      lines.push('      __rateLimitStore.delete(key);');
      lines.push('    }');
      lines.push('  }');
      lines.push('}, 60000);');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11b. File Upload Helpers
    // ════════════════════════════════════════════════════════════
    if (uploadConfig || routes.some(r => (r.decorators || []).some(d => d.name === 'upload'))) {
      lines.push('// ── File Upload Helpers ──');
      const maxSizeExpr = uploadConfig && uploadConfig.max_size ? this.genExpression(uploadConfig.max_size) : '10485760';
      const allowedTypesExpr = uploadConfig && uploadConfig.allowed_types ? this.genExpression(uploadConfig.allowed_types) : '[]';
      lines.push(`const __uploadMaxSize = ${maxSizeExpr};`);
      lines.push(`const __uploadAllowedTypes = ${allowedTypesExpr};`);
      lines.push('function __validateFile(file, fieldName) {');
      lines.push('  if (!file || (typeof file !== "object") || typeof file.size !== "number") {');
      lines.push('    return { valid: false, error: `${fieldName}: not a valid file` };');
      lines.push('  }');
      lines.push('  if (file.size > __uploadMaxSize) {');
      lines.push('    return { valid: false, error: `${fieldName}: file too large (max ${__uploadMaxSize} bytes)` };');
      lines.push('  }');
      lines.push('  if (__uploadAllowedTypes.length > 0 && !__uploadAllowedTypes.includes(file.type)) {');
      lines.push('    return { valid: false, error: `${fieldName}: file type ${file.type} not allowed` };');
      lines.push('  }');
      lines.push('  return { valid: true };');
      lines.push('}');
      lines.push('async function save_file(file, dir) {');
      lines.push('  const fs = await import("node:fs/promises");');
      lines.push('  await fs.mkdir(dir, { recursive: true });');
      lines.push('  const name = file.name || "upload_" + Date.now();');
      lines.push('  const dest = dir + "/" + name;');
      lines.push('  await Bun.write(dest, file);');
      lines.push('  return dest;');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 11c. Session Management
    // ════════════════════════════════════════════════════════════
    if (sessionConfig) {
      lines.push('// ── Session Management ──');
      const secretExpr = sessionConfig.secret ? this.genExpression(sessionConfig.secret) : '"tova-session-secret"';
      const maxAgeExpr = sessionConfig.max_age ? this.genExpression(sessionConfig.max_age) : '3600';
      const cookieNameExpr = sessionConfig.cookie_name ? this.genExpression(sessionConfig.cookie_name) : '"__sid"';
      lines.push(`const __sessionSecret = ${secretExpr};`);
      lines.push(`const __sessionMaxAge = ${maxAgeExpr};`);
      lines.push(`const __sessionCookieName = ${cookieNameExpr};`);
      lines.push('let __sessionKey = null;');
      lines.push('async function __getSessionKey() {');
      lines.push('  if (!__sessionKey) {');
      lines.push('    __sessionKey = await crypto.subtle.importKey(');
      lines.push('      "raw", new TextEncoder().encode(__sessionSecret),');
      lines.push('      { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]');
      lines.push('    );');
      lines.push('  }');
      lines.push('  return __sessionKey;');
      lines.push('}');
      lines.push('async function __signSessionId(id) {');
      lines.push('  const key = await __getSessionKey();');
      lines.push('  const sig = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(id));');
      lines.push('  const b64 = btoa(String.fromCharCode(...new Uint8Array(sig))).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=+$/, "");');
      lines.push('  return id + "." + b64;');
      lines.push('}');
      lines.push('async function __verifySessionId(signed) {');
      lines.push('  const dot = signed.lastIndexOf(".");');
      lines.push('  if (dot === -1) return null;');
      lines.push('  const id = signed.slice(0, dot);');
      lines.push('  const expected = await __signSessionId(id);');
      lines.push('  const __eBuf = new TextEncoder().encode(expected);');
      lines.push('  const __sBuf = new TextEncoder().encode(signed);');
      lines.push('  if (__eBuf.length !== __sBuf.length) return null;');
      lines.push('  let __m = 0;');
      lines.push('  for (let i = 0; i < __eBuf.length; i++) __m |= __eBuf[i] ^ __sBuf[i];');
      lines.push('  return __m === 0 ? id : null;');
      lines.push('}');

      // Use SQLite-backed sessions when db is available
      if (dbConfig || usesDb) {
        lines.push('// SQLite-backed session store');
        lines.push('__db.exec(`CREATE TABLE IF NOT EXISTS __sessions (');
        lines.push("  id TEXT PRIMARY KEY, data TEXT NOT NULL DEFAULT '{}', created_at INTEGER NOT NULL, updated_at INTEGER NOT NULL");
        lines.push(')`);');
        lines.push('const __sessionStmts = {');
        lines.push('  get: __db.prepare("SELECT data, created_at FROM __sessions WHERE id = ? AND created_at > ?"),');
        lines.push('  upsert: __db.prepare("INSERT INTO __sessions (id, data, created_at, updated_at) VALUES (?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET data = excluded.data, updated_at = excluded.updated_at"),');
        lines.push('  del: __db.prepare("DELETE FROM __sessions WHERE id = ?"),');
        lines.push('  cleanup: __db.prepare("DELETE FROM __sessions WHERE created_at <= ?"),');
        lines.push('};');
        lines.push('function __createSession(id) {');
        lines.push('  const cutoff = Date.now() - __sessionMaxAge * 1000;');
        lines.push('  const row = __sessionStmts.get.get(id, cutoff);');
        lines.push('  let __data = row ? JSON.parse(row.data) : {};');
        lines.push('  let __dirty = !row;');
        lines.push('  return {');
        lines.push('    get(key) { return __data[key]; },');
        lines.push('    set(key, value) { __data[key] = value; __dirty = true; },');
        lines.push('    delete(key) { delete __data[key]; __dirty = true; },');
        lines.push('    destroy() { __sessionStmts.del.run(id); __data = {}; },');
        lines.push('    get data() { return { ...__data }; },');
        lines.push('    __flush() { if (__dirty) { const now = Date.now(); __sessionStmts.upsert.run(id, JSON.stringify(__data), now, now); __dirty = false; } },');
        lines.push('  };');
        lines.push('}');
        lines.push('setInterval(() => {');
        lines.push('  const cutoff = Date.now() - __sessionMaxAge * 1000;');
        lines.push('  __sessionStmts.cleanup.run(cutoff);');
        lines.push('}, 60000);');
      } else {
        lines.push('// In-memory session store');
        lines.push('const __sessionStore = new Map();');
        lines.push('function __createSession(id) {');
        lines.push('  if (!__sessionStore.has(id)) {');
        lines.push('    __sessionStore.set(id, { data: {}, createdAt: Date.now() });');
        lines.push('  }');
        lines.push('  const entry = __sessionStore.get(id);');
        lines.push('  return {');
        lines.push('    get(key) { return entry.data[key]; },');
        lines.push('    set(key, value) { entry.data[key] = value; },');
        lines.push('    delete(key) { delete entry.data[key]; },');
        lines.push('    destroy() { __sessionStore.delete(id); },');
        lines.push('    get data() { return { ...entry.data }; },');
        lines.push('    __flush() {},');
        lines.push('  };');
        lines.push('}');
        lines.push('setInterval(() => {');
        lines.push('  const now = Date.now();');
        lines.push('  for (const [id, entry] of __sessionStore) {');
        lines.push('    if (now - entry.createdAt > __sessionMaxAge * 1000) __sessionStore.delete(id);');
        lines.push('  }');
        lines.push('}, 60000);');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12. Event Bus (F5) — if subscriptions exist
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0) {
      lines.push('// ── Event Bus ──');
      lines.push('const __eventBus = new Map();');
      lines.push('function __subscribe(event, handler) {');
      lines.push('  if (!__eventBus.has(event)) __eventBus.set(event, []);');
      lines.push('  __eventBus.get(event).push(handler);');
      lines.push('}');
      lines.push('async function publish(event, data) {');
      lines.push('  const handlers = __eventBus.get(event) || [];');
      lines.push('  await Promise.all(handlers.map(h => h(data)));');
      if (peerBlocks && peerBlocks.size > 0) {
        lines.push('  const __peerUrls = [');
        for (const [peerName] of peerBlocks) {
          lines.push(`    ${peerName}.__baseUrl,`);
        }
        lines.push('  ];');
        lines.push('  for (const __peerUrl of __peerUrls) {');
        lines.push('    try {');
        lines.push('      await fetch(`${__peerUrl}/rpc/__event`, {');
        lines.push('        method: "POST",');
        lines.push('        headers: { "Content-Type": "application/json" },');
        lines.push('        body: JSON.stringify({ event, data }),');
        lines.push('      });');
        lines.push('    } catch {}');
        lines.push('  }');
      }
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12b. Background Jobs
    // ════════════════════════════════════════════════════════════
    if (backgroundJobs.length > 0) {
      lines.push('// ── Background Jobs ──');
      lines.push('const __jobQueue = [];');
      lines.push('let __jobProcessing = false;');
      lines.push('async function __processJobQueue() {');
      lines.push('  if (__jobProcessing) return;');
      lines.push('  __jobProcessing = true;');
      lines.push('  while (__jobQueue.length > 0) {');
      lines.push('    const job = __jobQueue.shift();');
      lines.push('    try { await job.fn(...job.args); } catch (err) {');
      lines.push('      __log("error", `Background job ${job.name} failed`, { error: err.message });');
      lines.push('      if (job.retries > 0) {');
      lines.push('        job.retries--;');
      lines.push('        __jobQueue.push(job);');
      lines.push('      }');
      lines.push('    }');
      lines.push('  }');
      lines.push('  __jobProcessing = false;');
      lines.push('}');
      for (const job of backgroundJobs) {
        const fnName = job.name;
        const params = job.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of job.params) this.declareVar(p.name);
        const body = this.genBlockBody(job.body);
        this.popScope();
        lines.push(`async function __bg_${fnName}(${params}) {`);
        lines.push(body);
        lines.push('}');
      }
      lines.push('function spawn_job(name, ...args) {');
      lines.push('  const __jobFns = {');
      for (const job of backgroundJobs) {
        lines.push(`    "${job.name}": __bg_${job.name},`);
      }
      lines.push('  };');
      lines.push('  const fn = __jobFns[name];');
      lines.push('  if (!fn) throw new Error(`Unknown background job: ${name}`);');
      lines.push('  __jobQueue.push({ name, fn, args, retries: 2 });');
      lines.push('  setTimeout(__processJobQueue, 0);');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12c. Response Compression
    // ════════════════════════════════════════════════════════════
    if (compressionConfig) {
      const minSizeExpr = compressionConfig.min_size ? this.genExpression(compressionConfig.min_size) : '1024';
      lines.push('// ── Compression ──');
      lines.push(`const __compressionMinSize = ${minSizeExpr};`);
      lines.push('async function __compressResponse(req, res) {');
      lines.push('  const accept = req.headers.get("Accept-Encoding") || "";');
      lines.push('  const ct = res.headers.get("Content-Type") || "";');
      lines.push('  if (!ct.match(/text|json|javascript|xml|svg/)) return res;');
      lines.push('  const body = await res.arrayBuffer();');
      lines.push('  if (body.byteLength < __compressionMinSize) {');
      lines.push('    return new Response(body, { status: res.status, headers: res.headers });');
      lines.push('  }');
      lines.push('  const h = new Headers(res.headers);');
      lines.push('  if (accept.includes("gzip")) {');
      lines.push('    const compressed = Bun.gzipSync(new Uint8Array(body));');
      lines.push('    h.set("Content-Encoding", "gzip");');
      lines.push('    h.set("Content-Length", String(compressed.length));');
      lines.push('    return new Response(compressed, { status: res.status, headers: h });');
      lines.push('  }');
      lines.push('  if (accept.includes("deflate")) {');
      lines.push('    const compressed = Bun.deflateSync(new Uint8Array(body));');
      lines.push('    h.set("Content-Encoding", "deflate");');
      lines.push('    h.set("Content-Length", String(compressed.length));');
      lines.push('    return new Response(compressed, { status: res.status, headers: h });');
      lines.push('  }');
      lines.push('  return new Response(body, { status: res.status, headers: res.headers });');
      lines.push('}');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 12d. Response Caching Helpers
    // ════════════════════════════════════════════════════════════
    if (cacheConfig) {
      const maxAgeExpr = cacheConfig.max_age ? this.genExpression(cacheConfig.max_age) : '0';
      const staleExpr = cacheConfig.stale_while_revalidate ? this.genExpression(cacheConfig.stale_while_revalidate) : '0';
      lines.push('// ── Cache Helpers ──');
      lines.push(`const __cacheMaxAge = ${maxAgeExpr};`);
      lines.push(`const __cacheStale = ${staleExpr};`);
      lines.push('');
    }
    // Always emit cache helpers
    lines.push('function cache_control(res, maxAge, options = {}) {');
    lines.push('  const h = new Headers(res.headers);');
    lines.push('  let directive = options.private ? "private" : "public";');
    lines.push('  directive += `, max-age=${maxAge}`;');
    lines.push('  if (options.stale_while_revalidate) directive += `, stale-while-revalidate=${options.stale_while_revalidate}`;');
    lines.push('  if (options.no_cache) directive = "no-cache";');
    lines.push('  if (options.no_store) directive = "no-store";');
    lines.push('  h.set("Cache-Control", directive);');
    lines.push('  return new Response(res.body, { status: res.status, headers: h });');
    lines.push('}');
    lines.push('function etag(res, tag) {');
    lines.push('  const h = new Headers(res.headers);');
    lines.push('  h.set("ETag", `"${tag}"`);');
    lines.push('  return new Response(res.body, { status: res.status, headers: h });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12e. Model / ORM Layer — auto-generate CRUD from shared types
    // ════════════════════════════════════════════════════════════
    if (modelDecls.length > 0 && (dbConfig || usesDb)) {
      lines.push('// ── Model / ORM Layer ──');
      const isAsync = dbDriver !== 'sqlite';
      const aw = isAsync ? 'await ' : '';
      for (const modelDecl of modelDecls) {
        const typeName = modelDecl.name;
        const typeInfo = sharedTypes.get(typeName);
        if (!typeInfo) continue;
        const tableName = modelDecl.config && modelDecl.config.table
          ? this.genExpression(modelDecl.config.table).replace(/"/g, '')
          : typeName.toLowerCase() + 's';
        const hasTimestamps = modelDecl.config && modelDecl.config.timestamps;
        const fields = typeInfo.fields;
        const fieldNames = fields.map(f => f.name);
        const hasId = fieldNames.includes('id');

        // Extract relations from config
        const belongsToNames = [];
        const hasManyNames = [];
        if (modelDecl.config) {
          const extractRelNames = (val) => {
            if (!val) return [];
            if (val.type === 'Identifier') return [val.name];
            if (val.type === 'ArrayLiteral') return val.elements.filter(e => e.type === 'Identifier').map(e => e.name);
            return [];
          };
          belongsToNames.push(...extractRelNames(modelDecl.config.belongs_to));
          hasManyNames.push(...extractRelNames(modelDecl.config.has_many));
        }

        // Map Tova types to SQL types
        const sqlType = (tovaType) => {
          if (dbDriver === 'postgres') {
            switch (tovaType) {
              case 'Int': return 'INTEGER';
              case 'Float': return 'DOUBLE PRECISION';
              case 'Bool': return 'BOOLEAN';
              case 'String': return 'TEXT';
              default: return 'TEXT';
            }
          }
          switch (tovaType) {
            case 'Int': return 'INTEGER';
            case 'Float': return 'REAL';
            case 'Bool': return 'INTEGER';
            case 'String': return 'TEXT';
            default: return 'TEXT';
          }
        };

        // Generate CREATE TABLE
        const colDefs = [];
        for (const f of fields) {
          if (f.name === 'id') {
            if (dbDriver === 'postgres') {
              colDefs.push('id SERIAL PRIMARY KEY');
            } else {
              colDefs.push('id INTEGER PRIMARY KEY AUTOINCREMENT');
            }
          } else {
            colDefs.push(`${f.name} ${sqlType(f.type)}`);
          }
        }
        // Add FK columns for belongs_to relations
        for (const parentName of belongsToNames) {
          const fkCol = parentName.toLowerCase() + '_id';
          if (!fieldNames.includes(fkCol)) {
            const parentTable = parentName.toLowerCase() + 's';
            colDefs.push(`${fkCol} INTEGER REFERENCES ${parentTable}(id)`);
          }
        }
        if (hasTimestamps) {
          colDefs.push('created_at TEXT DEFAULT (datetime(\'now\'))');
          colDefs.push('updated_at TEXT DEFAULT (datetime(\'now\'))');
        }

        const placeholder = dbDriver === 'postgres' ? (i) => `$${i}` : () => '?';
        const insertFields = fields.filter(f => f.name !== 'id');
        const insertCols = insertFields.map(f => f.name).join(', ');
        const insertPlaceholders = insertFields.map((_, i) => placeholder(i + 1)).join(', ');
        const updateSets = insertFields.map((f, i) => `${f.name} = ${placeholder(i + 1)}`).join(', ');
        const returningClause = dbDriver === 'postgres' ? ' RETURNING *' : '';

        lines.push(`// Model: ${typeName} -> ${tableName}`);
        lines.push(`${aw}db.exec(\`CREATE TABLE IF NOT EXISTS ${tableName} (${colDefs.join(', ')})\`);`);
        lines.push('');

        // Embed valid column whitelist for SQL injection prevention
        const allColNames = [...fieldNames];
        for (const parentName of belongsToNames) {
          const fkCol = parentName.toLowerCase() + '_id';
          if (!allColNames.includes(fkCol)) allColNames.push(fkCol);
        }
        if (hasTimestamps) {
          allColNames.push('created_at', 'updated_at');
        }
        const colWhitelistJson = JSON.stringify(allColNames);

        // Generate the model object
        lines.push(`const ${typeName}Model = {`);
        lines.push(`  __validCols: new Set(${colWhitelistJson}),`);
        lines.push(`  __assertCols(keys) {`);
        lines.push(`    for (const k of keys) {`);
        lines.push(`      if (!this.__validCols.has(k)) throw new Error(\`Invalid column: \${k}\`);`);
        lines.push(`    }`);
        lines.push(`  },`);

        // find(id)
        lines.push(`  ${isAsync ? 'async ' : ''}find(id) {`);
        lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ${placeholder(1)}", id);`);
        lines.push('  },');

        // all()
        lines.push(`  ${isAsync ? 'async ' : ''}all() {`);
        lines.push(`    return ${aw}db.query("SELECT * FROM ${tableName}");`);
        lines.push('  },');

        // where(conditions)
        lines.push(`  ${isAsync ? 'async ' : ''}where(conditions) {`);
        lines.push('    const keys = Object.keys(conditions);');
        lines.push('    this.__assertCols(keys);');
        lines.push('    const vals = Object.values(conditions);');
        if (dbDriver === 'postgres') {
          lines.push('    const clauses = keys.map((k, i) => `${k} = $${i + 1}`).join(" AND ");');
        } else {
          lines.push('    const clauses = keys.map(k => `${k} = ?`).join(" AND ");');
        }
        lines.push(`    return ${aw}db.query(\`SELECT * FROM ${tableName} WHERE \${clauses}\`, ...vals);`);
        lines.push('  },');

        // create(data)
        lines.push(`  ${isAsync ? 'async ' : ''}create(data) {`);
        lines.push(`    const cols = Object.keys(data).filter(k => k !== 'id');`);
        lines.push('    this.__assertCols(cols);');
        lines.push(`    const vals = cols.map(k => data[k]);`);
        if (dbDriver === 'postgres') {
          lines.push('    const placeholders = cols.map((_, i) => `$${i + 1}`).join(", ");');
          lines.push(`    const rows = ${aw}db.query(\`INSERT INTO ${tableName} (\${cols.join(", ")}) VALUES (\${placeholders}) RETURNING *\`, ...vals);`);
          lines.push('    return rows[0];');
        } else {
          lines.push('    const placeholders = cols.map(() => "?").join(", ");');
          lines.push(`    const result = ${aw}db.run(\`INSERT INTO ${tableName} (\${cols.join(", ")}) VALUES (\${placeholders})\`, ...vals);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", result.lastInsertRowid);`);
        }
        lines.push('  },');

        // update(id, data)
        lines.push(`  ${isAsync ? 'async ' : ''}update(id, data) {`);
        lines.push(`    const cols = Object.keys(data).filter(k => k !== 'id');`);
        lines.push('    this.__assertCols(cols);');
        lines.push(`    const vals = cols.map(k => data[k]);`);
        if (dbDriver === 'postgres') {
          lines.push('    const sets = cols.map((k, i) => `${k} = $${i + 1}`).join(", ");');
          lines.push(`    const rows = ${aw}db.query(\`UPDATE ${tableName} SET \${sets} WHERE id = $\${cols.length + 1} RETURNING *\`, ...vals, id);`);
          lines.push('    return rows[0];');
        } else {
          lines.push('    const sets = cols.map(k => `${k} = ?`).join(", ");');
          lines.push(`    ${aw}db.run(\`UPDATE ${tableName} SET \${sets} WHERE id = ?\`, ...vals, id);`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${tableName} WHERE id = ?", id);`);
        }
        lines.push('  },');

        // delete(id)
        lines.push(`  ${isAsync ? 'async ' : ''}delete(id) {`);
        lines.push(`    return ${aw}db.run("DELETE FROM ${tableName} WHERE id = ${placeholder(1)}", id);`);
        lines.push('  },');

        // count()
        lines.push(`  ${isAsync ? 'async ' : ''}count(conditions) {`);
        lines.push('    if (!conditions) {');
        lines.push(`      const row = ${aw}db.get("SELECT COUNT(*) as count FROM ${tableName}");`);
        lines.push('      return row ? row.count : 0;');
        lines.push('    }');
        lines.push('    const keys = Object.keys(conditions);');
        lines.push('    this.__assertCols(keys);');
        lines.push('    const vals = Object.values(conditions);');
        if (dbDriver === 'postgres') {
          lines.push('    const clauses = keys.map((k, i) => `${k} = $${i + 1}`).join(" AND ");');
        } else {
          lines.push('    const clauses = keys.map(k => `${k} = ?`).join(" AND ");');
        }
        lines.push(`    const row = ${aw}db.get(\`SELECT COUNT(*) as count FROM ${tableName} WHERE \${clauses}\`, ...vals);`);
        lines.push('    return row ? row.count : 0;');
        lines.push('  },');

        // belongs_to accessors: PostModel.user(user_id) → single parent record
        for (const parentName of belongsToNames) {
          const parentTable = parentName.toLowerCase() + 's';
          const accessorName = parentName.toLowerCase();
          lines.push(`  ${isAsync ? 'async ' : ''}${accessorName}(${accessorName}_id) {`);
          lines.push(`    return ${aw}db.get("SELECT * FROM ${parentTable} WHERE id = ${placeholder(1)}", ${accessorName}_id);`);
          lines.push('  },');
        }

        // has_many accessors: UserModel.posts(id) → array of child records
        for (const childName of hasManyNames) {
          const childTable = childName.toLowerCase() + 's';
          const accessorName = childName.toLowerCase() + 's';
          const fkCol = typeName.toLowerCase() + '_id';
          lines.push(`  ${isAsync ? 'async ' : ''}${accessorName}(id) {`);
          lines.push(`    return ${aw}db.query("SELECT * FROM ${childTable} WHERE ${fkCol} = ${placeholder(1)}", id);`);
          lines.push('  },');
        }

        lines.push('};');
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 12f. SSE (Server-Sent Events) Support
    // ════════════════════════════════════════════════════════════
    if (sseDecls.length > 0) {
      lines.push('// ── SSE (Server-Sent Events) ──');
      lines.push('class __SSEChannel {');
      lines.push('  constructor() { this.clients = new Set(); }');
      lines.push('  subscribe(controller) { this.clients.add(controller); }');
      lines.push('  unsubscribe(controller) { this.clients.delete(controller); }');
      lines.push('  send(data, event = null) {');
      lines.push('    let msg = "";');
      lines.push('    if (event) msg += `event: ${event}\\n`;');
      lines.push('    msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
      lines.push('    const encoded = new TextEncoder().encode(msg);');
      lines.push('    for (const c of this.clients) { try { c.enqueue(encoded); } catch { this.clients.delete(c); } }');
      lines.push('  }');
      lines.push('  get count() { return this.clients.size; }');
      lines.push('}');
      lines.push('const __sseChannels = new Map();');
      lines.push('function sse_channel(name) {');
      lines.push('  if (!__sseChannels.has(name)) __sseChannels.set(name, new __SSEChannel());');
      lines.push('  return __sseChannels.get(name);');
      lines.push('}');
      lines.push('');

      for (const sse of sseDecls) {
        const params = sse.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sse.params) this.declareVar(p.name);
        const body = this.genBlockBody(sse.body);
        this.popScope();

        lines.push(`__addRoute("GET", ${JSON.stringify(sse.path)}, async (req) => {`);
        lines.push('  const stream = new ReadableStream({');
        lines.push(`    start(controller) {`);
        lines.push('      const send = (data, event) => {');
        lines.push('        let msg = "";');
        lines.push('        if (event) msg += `event: ${event}\\n`;');
        lines.push('        msg += `data: ${typeof data === "string" ? data : JSON.stringify(data)}\\n\\n`;');
        lines.push('        controller.enqueue(new TextEncoder().encode(msg));');
        lines.push('      };');
        lines.push('      const close = () => controller.close();');
        lines.push(`      (async (${params || 'send, close'}) => {`);
        lines.push(body);
        lines.push(`      })(${params || 'send, close'});`);
        lines.push('    }');
        lines.push('  });');
        lines.push('  return new Response(stream, {');
        lines.push('    headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" }');
        lines.push('  });');
        lines.push('});');
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 12g. Content Negotiation Helper
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Content Negotiation ──');
    lines.push('function negotiate(req, data, options = {}) {');
    lines.push('  const accept = (req.headers.get("Accept") || "application/json").toLowerCase();');
    lines.push('  if (accept.includes("text/html") && options.html) {');
    lines.push('    const body = typeof options.html === "function" ? options.html(data) : options.html;');
    lines.push('    return new Response(body, { status: options.status || 200, headers: { "Content-Type": "text/html" } });');
    lines.push('  }');
    lines.push('  if (accept.includes("text/xml") || accept.includes("application/xml")) {');
    lines.push('    if (options.xml) {');
    lines.push('      const body = typeof options.xml === "function" ? options.xml(data) : options.xml;');
    lines.push('      return new Response(body, { status: options.status || 200, headers: { "Content-Type": "application/xml" } });');
    lines.push('    }');
    lines.push('  }');
    lines.push('  if (accept.includes("text/plain")) {');
    lines.push('    const body = typeof data === "string" ? data : JSON.stringify(data, null, 2);');
    lines.push('    return new Response(body, { status: options.status || 200, headers: { "Content-Type": "text/plain" } });');
    lines.push('  }');
    lines.push('  return Response.json(data, { status: options.status || 200 });');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 12h. Race Condition Protection — Async Mutex for shared state
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Async Mutex ──');
    lines.push('class __Mutex {');
    lines.push('  constructor() { this._queue = []; this._locked = false; }');
    lines.push('  async acquire() {');
    lines.push('    if (!this._locked) { this._locked = true; return; }');
    lines.push('    return new Promise(resolve => this._queue.push(resolve));');
    lines.push('  }');
    lines.push('  release() {');
    lines.push('    if (this._queue.length > 0) { this._queue.shift()(); }');
    lines.push('    else { this._locked = false; }');
    lines.push('  }');
    lines.push('}');
    lines.push('const __mutex = new __Mutex();');
    lines.push('async function withLock(fn) {');
    lines.push('  await __mutex.acquire();');
    lines.push('  try { return await fn(); } finally { __mutex.release(); }');
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 13. Other statements + Server Functions
    // ════════════════════════════════════════════════════════════
    for (const stmt of otherStatements) {
      lines.push(this.generateStatement(stmt));
    }

    if (functions.length > 0) {
      lines.push('// ── Server Functions ──');
      for (const fn of functions) {
        lines.push(this.generateStatement(fn));
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 14. Subscribe registrations (F5)
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0) {
      lines.push('// ── Event Subscriptions ──');
      for (const sub of subscriptions) {
        const params = sub.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sub.params) this.declareVar(p.name);
        const body = this.genBlockBody(sub.body);
        this.popScope();
        lines.push(`__subscribe(${JSON.stringify(sub.event)}, async (${params}) => {`);
        lines.push(body);
        lines.push('});');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 15. Middleware, Error handler, Health check, RPC endpoints
    // ════════════════════════════════════════════════════════════
    if (middlewares.length > 0) {
      lines.push('// ── Middleware ──');
      for (const mw of middlewares) {
        const params = mw.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of mw.params) this.declareVar(p.name);
        const body = this.genBlockBody(mw.body);
        this.popScope();
        lines.push(`async function ${mw.name}(${params}) {`);
        lines.push(body);
        lines.push('}');
        lines.push('');
      }
    }

    if (errorHandler) {
      const params = errorHandler.params.map(p => p.name).join(', ');
      this.pushScope();
      for (const p of errorHandler.params) this.declareVar(p.name);
      const body = this.genBlockBody(errorHandler.body);
      this.popScope();
      lines.push('// ── Error Handler ──');
      lines.push(`async function __errorHandler(${params}) {`);
      lines.push(body);
      lines.push('}');
      lines.push('');
    }

    if (healthPath) {
      lines.push('// ── Health Check ──');
      lines.push(`__addRoute("GET", ${JSON.stringify(healthPath)}, async () => {`);
      lines.push('  return Response.json({ status: "ok", uptime: process.uptime() });');
      lines.push('});');
      lines.push('');
    }

    // RPC Endpoints (auto-wired)
    if (functions.length > 0) {
      lines.push('// ── RPC Endpoints ──');
      for (const fn of functions) {
        const name = fn.name;
        const paramNames = fn.params.map(p => p.name);
        lines.push(`__addRoute("POST", "/rpc/${name}", async (req) => {`);
        lines.push(`  const body = await req.json();`);
        if (paramNames.length > 0) {
          for (let pi = 0; pi < paramNames.length; pi++) {
            lines.push(`  const ${paramNames[pi]} = body.__args ? body.__args[${pi}] : body.${paramNames[pi]};`);
          }
          const validationChecks = this._genValidationCode(fn.params);
          if (validationChecks.length > 0) {
            lines.push(`  const __validationErrors = [];`);
            for (const check of validationChecks) {
              lines.push(check);
            }
            lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
          }
          lines.push(`  const result = await ${name}(${paramNames.join(', ')});`);
        } else {
          lines.push(`  const result = await ${name}();`);
        }
        lines.push(`  return Response.json({ result });`);
        lines.push(`});`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 16. Event RPC endpoint (F5) — if multi-server + subscriptions
    // ════════════════════════════════════════════════════════════
    if (subscriptions.length > 0 && peerBlocks && peerBlocks.size > 0) {
      lines.push('// ── Event RPC Endpoint ──');
      lines.push('__addRoute("POST", "/rpc/__event", async (req) => {');
      lines.push('  const { event, data } = await req.json();');
      lines.push('  const handlers = __eventBus.get(event) || [];');
      lines.push('  await Promise.all(handlers.map(h => h(data)));');
      lines.push('  return Response.json({ ok: true });');
      lines.push('});');
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 17. Explicit Routes — with timeout (F7) + per-route rate_limit (F2)
    // ════════════════════════════════════════════════════════════
    if (routes.length > 0) {
      // Sort routes by specificity: static > :param > *wildcard, longer paths first
      const segWeight = (seg) => {
        if (seg.startsWith('*')) return 2; // wildcard — least specific
        if (seg.startsWith(':')) return 1; // param
        return 0; // static — most specific
      };
      routes.sort((a, b) => {
        const segsA = a.path.split('/').filter(Boolean);
        const segsB = b.path.split('/').filter(Boolean);
        // More segments = more specific (but wildcards are inherently less specific)
        const aHasWild = segsA.some(s => s.startsWith('*'));
        const bHasWild = segsB.some(s => s.startsWith('*'));
        if (aHasWild !== bHasWild) return aHasWild ? 1 : -1;
        if (segsA.length !== segsB.length) return segsB.length - segsA.length;
        // Compare segment by segment: static beats dynamic beats wildcard
        for (let i = 0; i < Math.min(segsA.length, segsB.length); i++) {
          const wa = segWeight(segsA[i]);
          const wb = segWeight(segsB[i]);
          if (wa !== wb) return wa - wb;
        }
        // Stable sort: same path, order by method (deterministic)
        const methodOrder = { HEAD: 0, GET: 1, POST: 2, PUT: 3, PATCH: 4, DELETE: 5, OPTIONS: 6 };
        return (methodOrder[a.method.toUpperCase()] || 9) - (methodOrder[b.method.toUpperCase()] || 9);
      });
      lines.push('// ── Routes ──');
      for (const route of routes) {
        const method = route.method.toUpperCase();
        const path = route.path;
        const handlerRaw = this.genExpression(route.handler);
        // Wrap inline lambda handlers in parens so they can be called as IIFEs
        const handlerIsInline = route.handler.type !== 'Identifier';
        const handler = handlerIsInline ? `(${handlerRaw})` : handlerRaw;

        const handlerName = route.handler.type === 'Identifier' ? route.handler.name : null;
        const handlerParams = handlerName ? fnParamMap.get(handlerName) : null;
        const handlerDecl = handlerName ? fnDeclMap.get(handlerName) : null;

        const decorators = route.decorators || [];
        const groupMws = route._groupMiddlewares || [];
        const hasAuth = decorators.some(d => d.name === 'auth');
        const roleDecorator = decorators.find(d => d.name === 'role');
        const rateLimitDec = decorators.find(d => d.name === 'rate_limit');
        const timeoutDec = decorators.find(d => d.name === 'timeout');
        const timeoutMs = timeoutDec && timeoutDec.args[0] ? this.genExpression(timeoutDec.args[0]) : null;
        const validateDec = decorators.find(d => d.name === 'validate');
        const uploadDec = decorators.find(d => d.name === 'upload');

        lines.push(`__addRoute(${JSON.stringify(method)}, ${JSON.stringify(path)}, async (req, params) => {`);

        // Auth decorator check
        if (hasAuth && authConfig) {
          lines.push(`  const __user = await __authenticate(req);`);
          lines.push(`  if (!__user) return Response.json({ error: "Unauthorized" }, { status: 401 });`);
          if (roleDecorator && roleDecorator.args.length > 0) {
            const roleExpr = this.genExpression(roleDecorator.args[0]);
            lines.push(`  if (__user.role !== ${roleExpr}) return Response.json({ error: "Forbidden" }, { status: 403 });`);
          }
        }

        // Per-route rate limit check
        if (rateLimitDec && needsRateLimitStore) {
          const rlMax = rateLimitDec.args[0] ? this.genExpression(rateLimitDec.args[0]) : '100';
          const rlWindow = rateLimitDec.args[1] ? this.genExpression(rateLimitDec.args[1]) : '60';
          lines.push(`  const __rlIp = req.headers.get("x-forwarded-for") || "unknown";`);
          lines.push(`  const __rlRoute = __checkRateLimit(\`route:${path}:\${__rlIp}\`, ${rlMax}, ${rlWindow});`);
          lines.push(`  if (__rlRoute.limited) return Response.json({ error: "Too Many Requests" }, { status: 429, headers: { "Retry-After": String(__rlRoute.retryAfter) } });`);
        }

        // Upload decorator — parse multipart body, validate file field
        if (uploadDec) {
          const fieldExpr = uploadDec.args[0] ? this.genExpression(uploadDec.args[0]) : '"file"';
          lines.push(`  const __body = (await __parseBody(req)) || {};`);
          lines.push(`  const __uploadField = ${fieldExpr};`);
          lines.push(`  const __uploadFile = __body[__uploadField];`);
          lines.push(`  const __uploadCheck = __validateFile(__uploadFile, __uploadField);`);
          lines.push(`  if (!__uploadCheck.valid) return Response.json({ error: __uploadCheck.error }, { status: 400 });`);
        }

        // Validate decorator — advanced field validation on body
        if (validateDec && validateDec.args[0]) {
          if (!uploadDec) {
            lines.push(`  const __body = (await __parseBody(req)) || {};`);
          }
          lines.push(`  const __validationErrors = [];`);
          const advChecks = this._genAdvancedValidationCode(validateDec.args[0]);
          for (const check of advChecks) lines.push(check);
          lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
        }

        // Type-safe body deserialization: if a param has a shared type annotation, auto-validate
        if (handlerDecl && ['POST', 'PUT', 'PATCH'].includes(method)) {
          for (const p of handlerDecl.params) {
            if (p.typeAnnotation && p.typeAnnotation.type === 'TypeAnnotation' && sharedTypes.has(p.typeAnnotation.name) && p.name !== 'req') {
              const typeInfo = sharedTypes.get(p.typeAnnotation.name);
              if (!uploadDec && !validateDec) {
                lines.push(`  if (!__body) { var __body = (await __parseBody(req)) || {}; }`);
              }
              lines.push(`  // Type-safe validation for ${p.name}: ${p.typeAnnotation.name}`);
              lines.push(`  const __tsErrors_${p.name} = [];`);
              for (const f of typeInfo.fields) {
                if (f.name === 'id') continue;
                switch (f.type) {
                  case 'String':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "string") __tsErrors_${p.name}.push("${f.name} must be a string");`);
                    break;
                  case 'Int':
                    lines.push(`  if (__body.${f.name} !== undefined && !Number.isInteger(__body.${f.name})) __tsErrors_${p.name}.push("${f.name} must be an integer");`);
                    break;
                  case 'Float':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "number") __tsErrors_${p.name}.push("${f.name} must be a number");`);
                    break;
                  case 'Bool':
                    lines.push(`  if (__body.${f.name} !== undefined && typeof __body.${f.name} !== "boolean") __tsErrors_${p.name}.push("${f.name} must be a boolean");`);
                    break;
                }
              }
              lines.push(`  if (__tsErrors_${p.name}.length > 0) return Response.json({ error: "Validation failed", details: __tsErrors_${p.name} }, { status: 400 });`);
            }
          }
        }

        if (handlerParams !== null && handlerParams !== undefined) {
          if (handlerParams.length === 0) {
            if (groupMws.length > 0) {
              this._emitGroupMiddlewareChain(lines, groupMws, handler, '()', timeoutMs);
            } else {
              this._emitHandlerCall(lines, `${handler}()`, timeoutMs);
            }
          } else if (handlerParams[0] === 'req') {
            lines.push(`  const __url = new URL(req.url);`);
            lines.push(`  const __ctx = {`);
            lines.push(`    method: req.method, path: __url.pathname, params,`);
            lines.push(`    query: __parseQuery(__url.searchParams),`);
            lines.push(`    headers: Object.fromEntries(req.headers),`);
            lines.push(`    cookies: __parseCookies(req.headers.get("cookie")),`);
            lines.push(`    body: null, raw: req, locals: __getLocals(),`);
            lines.push(`  };`);
            if (sessionConfig) {
              lines.push(`  if (req.__session) __ctx.session = req.__session;`);
            }
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
              lines.push(`  __ctx.body = await __parseBody(req);`);
            }
            const remainingParams = handlerParams.slice(1);
            if (remainingParams.length > 0) {
              if (['POST', 'PUT', 'PATCH'].includes(method)) {
                lines.push(`  const __body = __ctx.body || {};`);
                for (const pn of remainingParams) {
                  lines.push(`  const ${pn} = params.${pn} ?? __body.${pn};`);
                }
              } else {
                for (const pn of remainingParams) {
                  lines.push(`  const ${pn} = params.${pn} ?? __ctx.query.${pn};`);
                }
              }
              if (handlerDecl) {
                const validationChecks = this._genValidationCode(handlerDecl.params.slice(1));
                if (validationChecks.length > 0) {
                  lines.push(`  const __validationErrors = [];`);
                  for (const check of validationChecks) lines.push(check);
                  lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
                }
              }
              if (groupMws.length > 0) {
                this._emitGroupMiddlewareChain(lines, groupMws, handler, `(__ctx, ${remainingParams.join(', ')})`, timeoutMs);
              } else {
                this._emitHandlerCall(lines, `${handler}(__ctx, ${remainingParams.join(', ')})`, timeoutMs);
              }
            } else {
              if (groupMws.length > 0) {
                this._emitGroupMiddlewareChain(lines, groupMws, handler, '(__ctx)', timeoutMs);
              } else {
                this._emitHandlerCall(lines, `${handler}(__ctx)`, timeoutMs);
              }
            }
          } else {
            if (['POST', 'PUT', 'PATCH'].includes(method)) {
              lines.push(`  const __body = (await __parseBody(req)) || {};`);
              for (const pn of handlerParams) {
                lines.push(`  const ${pn} = params.${pn} ?? __body.${pn};`);
              }
            } else {
              lines.push(`  const __url = new URL(req.url);`);
              for (const pn of handlerParams) {
                lines.push(`  const ${pn} = params.${pn} ?? __url.searchParams.get(${JSON.stringify(pn)});`);
              }
            }
            if (handlerDecl) {
              const validationChecks = this._genValidationCode(handlerDecl.params);
              if (validationChecks.length > 0) {
                lines.push(`  const __validationErrors = [];`);
                for (const check of validationChecks) lines.push(check);
                lines.push(`  if (__validationErrors.length > 0) return Response.json({ error: "Validation failed", details: __validationErrors }, { status: 400 });`);
              }
            }
            if (groupMws.length > 0) {
              this._emitGroupMiddlewareChain(lines, groupMws, handler, `(${handlerParams.join(', ')})`, timeoutMs);
            } else {
              this._emitHandlerCall(lines, `${handler}(${handlerParams.join(', ')})`, timeoutMs);
            }
          }
        } else {
          this._emitHandlerCall(lines, `${handler}(req, params)`, timeoutMs);
        }

        lines.push(`  if (__result instanceof Response) return __result;`);
        lines.push(`  return Response.json(__result);`);
        lines.push(`});`);
        lines.push('');
      }
    }

    // ════════════════════════════════════════════════════════════
    // 17b. OpenAPI Spec Generation — auto-generate from routes + types
    // ════════════════════════════════════════════════════════════
    if (routes.length > 0) {
      const tovaTypeToJsonSchema = (typeName) => {
        switch (typeName) {
          case 'Int': return '{ "type": "integer" }';
          case 'Float': return '{ "type": "number" }';
          case 'Bool': return '{ "type": "boolean" }';
          case 'String': return '{ "type": "string" }';
          default: return `{ "$ref": "#/components/schemas/${typeName}" }`;
        }
      };

      lines.push('// ── OpenAPI Spec ──');
      lines.push('const __openApiSpec = {');
      lines.push('  openapi: "3.0.3",');
      lines.push(`  info: { title: ${JSON.stringify(blockName || 'Tova API')}, version: "1.0.0" },`);
      lines.push('  paths: {},');
      lines.push('  components: { schemas: {} },');
      lines.push('};');

      // Generate schemas from shared types
      for (const [typeName, typeInfo] of sharedTypes) {
        const props = typeInfo.fields.map(f => {
          let jsonType;
          switch (f.type) {
            case 'Int': jsonType = '"integer"'; break;
            case 'Float': jsonType = '"number"'; break;
            case 'Bool': jsonType = '"boolean"'; break;
            case 'String': jsonType = '"string"'; break;
            case 'Array': jsonType = '"array"'; break;
            default: jsonType = '"string"'; break;
          }
          return `${f.name}: { type: ${jsonType} }`;
        }).join(', ');
        lines.push(`__openApiSpec.components.schemas[${JSON.stringify(typeName)}] = { type: "object", properties: { ${props} } };`);
      }

      // Generate paths from routes
      for (const route of routes) {
        const method = route.method.toLowerCase();
        const path = route.path.replace(/:([^/]+)/g, '{$1}');
        const handlerName = route.handler.type === 'Identifier' ? route.handler.name : null;
        const handlerDecl = handlerName ? fnDeclMap.get(handlerName) : null;

        lines.push(`if (!__openApiSpec.paths[${JSON.stringify(path)}]) __openApiSpec.paths[${JSON.stringify(path)}] = {};`);
        lines.push(`__openApiSpec.paths[${JSON.stringify(path)}][${JSON.stringify(method)}] = {`);

        // Summary from handler name
        if (handlerName) {
          lines.push(`  summary: ${JSON.stringify(handlerName.replace(/_/g, ' '))},`);
        }

        // Parameters from path params and handler params
        const pathParams = (route.path.match(/:([^/]+)/g) || []).map(p => p.slice(1));
        if (pathParams.length > 0) {
          lines.push('  parameters: [');
          for (const pp of pathParams) {
            lines.push(`    { name: ${JSON.stringify(pp)}, in: "path", required: true, schema: { type: "string" } },`);
          }
          lines.push('  ],');
        }

        // Request body schema for POST/PUT/PATCH
        if (['post', 'put', 'patch'].includes(method) && handlerDecl) {
          const bodyParams = handlerDecl.params.filter(p => p.name !== 'req' && !pathParams.includes(p.name));
          if (bodyParams.length > 0) {
            lines.push('  requestBody: {');
            lines.push('    content: { "application/json": { schema: { type: "object", properties: {');
            for (const bp of bodyParams) {
              const ta = bp.typeAnnotation;
              if (ta && ta.name && sharedTypes.has(ta.name)) {
                lines.push(`      ${bp.name}: { "$ref": "#/components/schemas/${ta.name}" },`);
              } else if (ta) {
                let jsonType;
                switch (ta.name) {
                  case 'Int': jsonType = '"integer"'; break;
                  case 'Float': jsonType = '"number"'; break;
                  case 'Bool': jsonType = '"boolean"'; break;
                  default: jsonType = '"string"'; break;
                }
                lines.push(`      ${bp.name}: { type: ${jsonType} },`);
              } else {
                lines.push(`      ${bp.name}: { type: "string" },`);
              }
            }
            lines.push('    } } } },');
            lines.push('  },');
          }
        }

        // Response schema from return type
        if (handlerDecl && handlerDecl.returnType) {
          const rt = handlerDecl.returnType;
          if (rt.type === 'ArrayTypeAnnotation' && rt.elementType) {
            const elName = rt.elementType.name;
            if (sharedTypes.has(elName)) {
              lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { type: "array", items: { "$ref": "#/components/schemas/${elName}" } } } } } },`);
            } else {
              lines.push('  responses: { "200": { description: "Success" } },');
            }
          } else if (rt.type === 'TypeAnnotation' && sharedTypes.has(rt.name)) {
            lines.push(`  responses: { "200": { description: "Success", content: { "application/json": { schema: { "$ref": "#/components/schemas/${rt.name}" } } } } },`);
          } else {
            lines.push('  responses: { "200": { description: "Success" } },');
          }
        } else {
          lines.push('  responses: { "200": { description: "Success" } },');
        }

        lines.push('};');
      }

      // Add the /docs endpoint
      lines.push('__addRoute("GET", "/openapi.json", async () => {');
      lines.push('  return Response.json(__openApiSpec);');
      lines.push('});');
      lines.push('__addRoute("GET", "/docs", async () => {');
      lines.push('  const html = `<!DOCTYPE html><html><head><title>API Docs</title>');
      lines.push('    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"></head>');
      lines.push('    <body><div id="swagger-ui"></div>');
      lines.push('    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"><\\/script>');
      lines.push('    <script>SwaggerUIBundle({ url: "/openapi.json", dom_id: "#swagger-ui" });<\\/script>');
      lines.push('    </body></html>`;');
      lines.push('  return new Response(html, { headers: { "Content-Type": "text/html" } });');
      lines.push('});');
      lines.push('');
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 18. Logging, Static files, WebSocket
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Structured Logging ──');
    lines.push('let __reqCounter = 0;');
    lines.push('function __genRequestId() {');
    lines.push('  return `${Date.now().toString(36)}-${(++__reqCounter).toString(36)}`;');
    lines.push('}');
    lines.push('const __logLevels = { debug: 0, info: 1, warn: 2, error: 3 };');
    lines.push('const __logMinLevel = __logLevels[process.env.LOG_LEVEL || "info"] || 1;');
    lines.push('let __logFile = null;');
    lines.push('if (process.env.LOG_FILE) {');
    lines.push('  const __fs = await import("node:fs");');
    lines.push('  __logFile = __fs.createWriteStream(process.env.LOG_FILE, { flags: "a" });');
    lines.push('}');
    lines.push('function __log(level, msg, meta = {}) {');
    lines.push('  if ((__logLevels[level] || 0) < __logMinLevel) return;');
    lines.push('  const entry = JSON.stringify({ timestamp: new Date().toISOString(), level, msg, ...meta });');
    lines.push('  console.log(entry);');
    lines.push('  if (__logFile) __logFile.write(entry + "\\n");');
    lines.push('}');
    lines.push('');

    if (staticDecl) {
      lines.push('// ── Static File Serving ──');
      lines.push(`const __staticPrefix = ${JSON.stringify(staticDecl.path)};`);
      lines.push(`const __staticDir = ${JSON.stringify(staticDecl.dir)};`);
      if (staticDecl.fallback) {
        lines.push(`const __staticFallback = ${JSON.stringify(staticDecl.fallback)};`);
      }
      lines.push('async function __serveStatic(pathname, req) {');
      lines.push('  const filePath = __staticDir + pathname.slice(__staticPrefix.length);');
      lines.push('  try {');
      lines.push('    const file = Bun.file(filePath);');
      lines.push('    if (await file.exists()) {');
      lines.push('      const stat = { size: file.size, lastModified: file.lastModified };');
      lines.push('      const etagVal = `"${stat.size.toString(36)}-${stat.lastModified.toString(36)}"`;');
      lines.push('      if (req && req.headers.get("If-None-Match") === etagVal) {');
      lines.push('        return new Response(null, { status: 304 });');
      lines.push('      }');
      const staticCacheAge = cacheConfig && cacheConfig.max_age ? this.genExpression(cacheConfig.max_age) : '3600';
      lines.push(`      return new Response(file, { headers: { ETag: etagVal, "Cache-Control": "public, max-age=${staticCacheAge}" } });`);
      lines.push('    }');
      lines.push('  } catch {}');
      if (staticDecl.fallback) {
        lines.push('  try {');
        lines.push('    const fb = Bun.file(__staticDir + "/" + __staticFallback);');
        lines.push('    if (await fb.exists()) return new Response(fb, { headers: { "Content-Type": "text/html" } });');
        lines.push('  } catch {}');
      }
      lines.push('  return null;');
      lines.push('}');
      lines.push('');
    }

    if (wsDecl) {
      lines.push('// ── WebSocket Handlers ──');
      lines.push('const __wsClients = new Set();');
      lines.push('const __wsRooms = new Map();');
      lines.push('function broadcast(data, exclude = null) {');
      lines.push('  const msg = typeof data === "string" ? data : JSON.stringify(data);');
      lines.push('  for (const c of __wsClients) { if (c !== exclude) c.send(msg); }');
      lines.push('}');
      lines.push('function join(ws, room) {');
      lines.push('  if (!__wsRooms.has(room)) __wsRooms.set(room, new Set());');
      lines.push('  __wsRooms.get(room).add(ws);');
      lines.push('}');
      lines.push('function leave(ws, room) {');
      lines.push('  const r = __wsRooms.get(room);');
      lines.push('  if (r) { r.delete(ws); if (r.size === 0) __wsRooms.delete(room); }');
      lines.push('}');
      lines.push('function broadcast_to(room, data, exclude = null) {');
      lines.push('  const r = __wsRooms.get(room);');
      lines.push('  if (!r) return;');
      lines.push('  const msg = typeof data === "string" ? data : JSON.stringify(data);');
      lines.push('  for (const c of r) { if (c !== exclude) c.send(msg); }');
      lines.push('}');
      lines.push('const __wsHandlers = {};');
      for (const [event, handler] of Object.entries(wsDecl.handlers)) {
        if (!handler) continue;
        const params = handler.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of handler.params) this.declareVar(p.name);
        const body = this.genBlockBody(handler.body);
        this.popScope();
        lines.push(`__wsHandlers.${event} = function(${params}) {`);
        lines.push(body);
        lines.push('};');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 19. Schedule helpers (F8) — interval/cron parser
    // ════════════════════════════════════════════════════════════
    if (schedules.length > 0) {
      lines.push('// ── Schedule Helpers ──');
      lines.push('function __parseInterval(pattern) {');
      lines.push('  const m = pattern.match(/^(\\d+)(s|m|h)$/);');
      lines.push('  if (!m) return null;');
      lines.push('  const val = parseInt(m[1], 10);');
      lines.push('  switch (m[2]) {');
      lines.push('    case "s": return val * 1000;');
      lines.push('    case "m": return val * 60 * 1000;');
      lines.push('    case "h": return val * 60 * 60 * 1000;');
      lines.push('  }');
      lines.push('}');
      lines.push('function __cronFieldMatches(field, value) {');
      lines.push('  if (field === "*") return true;');
      lines.push('  for (const part of field.split(",")) {');
      lines.push('    if (part.includes("/")) {');
      lines.push('      const [range, stepStr] = part.split("/");');
      lines.push('      const step = parseInt(stepStr, 10);');
      lines.push('      if (range === "*") { if (value % step === 0) return true; }');
      lines.push('      else if (range.includes("-")) {');
      lines.push('        const [lo, hi] = range.split("-").map(Number);');
      lines.push('        if (value >= lo && value <= hi && (value - lo) % step === 0) return true;');
      lines.push('      }');
      lines.push('    } else if (part.includes("-")) {');
      lines.push('      const [lo, hi] = part.split("-").map(Number);');
      lines.push('      if (value >= lo && value <= hi) return true;');
      lines.push('    } else { if (parseInt(part, 10) === value) return true; }');
      lines.push('  }');
      lines.push('  return false;');
      lines.push('}');
      lines.push('function __cronMatches(parts, date) {');
      lines.push('  const fields = [date.getMinutes(), date.getHours(), date.getDate(), date.getMonth() + 1, date.getDay()];');
      lines.push('  for (let i = 0; i < 5; i++) {');
      lines.push('    if (!__cronFieldMatches(parts[i], fields[i])) return false;');
      lines.push('  }');
      lines.push('  return true;');
      lines.push('}');
      lines.push('const __scheduleIntervals = [];');

      for (let si = 0; si < schedules.length; si++) {
        const sched = schedules[si];
        const fnName = sched.name || `__scheduled_${si}`;
        const params = sched.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of sched.params) this.declareVar(p.name);
        const body = this.genBlockBody(sched.body);
        this.popScope();
        lines.push(`async function ${fnName}(${params}) {`);
        lines.push(body);
        lines.push('}');
        const pattern = sched.pattern;
        // Check if it's a simple interval (no spaces) or cron (has spaces)
        if (pattern.includes(' ')) {
          // Cron expression
          const cronParts = JSON.stringify(pattern.split(/\s+/));
          lines.push(`__scheduleIntervals.push(setInterval(() => {`);
          lines.push(`  if (__cronMatches(${cronParts}, new Date())) ${fnName}();`);
          lines.push(`}, 60000));`);
        } else {
          // Simple interval
          lines.push(`__scheduleIntervals.push(setInterval(${fnName}, __parseInterval(${JSON.stringify(pattern)})));`);
        }
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 20. Middleware chain, Graceful Drain
    // ════════════════════════════════════════════════════════════
    if (globalMiddlewares.length > 0) {
      lines.push('// ── Middleware Chain ──');
      const mwNames = globalMiddlewares.map(m => m.name);
      lines.push(`const __middlewares = [${mwNames.join(', ')}];`);
      lines.push('');
    }

    lines.push('// ── Graceful Drain ──');
    lines.push('let __activeRequests = 0;');
    lines.push('let __shuttingDown = false;');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 21. Request Handler — with global rate limit check (F2)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Request Handler ──');
    lines.push('async function __handleRequest(req) {');

    lines.push('  if (__shuttingDown) {');
    lines.push('    return new Response("Service Unavailable", { status: 503 });');
    lines.push('  }');
    lines.push('  __activeRequests++;');

    lines.push('  const url = new URL(req.url);');
    lines.push('  const __rid = req.headers.get("X-Request-Id") || __genRequestId();');
    lines.push('  const __startTime = Date.now();');
    lines.push('  const __cors = __getCorsHeaders(req);');

    lines.push('  return __requestContext.run({ rid: __rid, locals: {} }, async () => {');
    lines.push('  try {');

    // WebSocket upgrade
    if (wsDecl) {
      // Determine if WS auth is needed:
      // - If ws has auth: false, skip auth even if authConfig exists
      // - If ws has auth: true or authConfig exists (and ws doesn't disable), require auth
      const wsAuthExplicitlyDisabled = wsDecl.config && wsDecl.config.auth &&
        wsDecl.config.auth.type === 'BooleanLiteral' && wsDecl.config.auth.value === false;
      const wsNeedsAuth = !wsAuthExplicitlyDisabled && (authConfig || (wsDecl.config && wsDecl.config.auth &&
        !(wsDecl.config.auth.type === 'BooleanLiteral' && wsDecl.config.auth.value === false)));

      lines.push('  if (req.headers.get("upgrade") === "websocket") {');
      if (wsNeedsAuth) {
        lines.push('    try {');
        lines.push('      const __wsUser = await __authenticate(req);');
        lines.push('      const upgraded = __server.upgrade(req, { data: { rid: __rid, user: __wsUser } });');
        lines.push('      if (upgraded) return undefined;');
        lines.push('      return new Response("WebSocket upgrade failed", { status: 400 });');
        lines.push('    } catch (__authErr) {');
        lines.push('      return Response.json({ error: "Unauthorized" }, { status: 401 });');
        lines.push('    }');
      } else {
        lines.push('    const upgraded = __server.upgrade(req, { data: { rid: __rid } });');
        lines.push('    if (upgraded) return undefined;');
        lines.push('    return new Response("WebSocket upgrade failed", { status: 400 });');
      }
      lines.push('  }');
    }

    lines.push('  if (req.method === "OPTIONS") {');
    lines.push('    return new Response(null, { status: 204, headers: __cors });');
    lines.push('  }');

    // Max body size check
    lines.push('  const __contentLength = parseInt(req.headers.get("Content-Length") || "0", 10);');
    lines.push('  if (__contentLength > __maxBodySize) {');
    lines.push('    return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
    lines.push('  }');

    // Global rate limit check (F2)
    if (rateLimitConfig) {
      lines.push('  const __clientIp = req.headers.get("x-forwarded-for") || "unknown";');
      lines.push('  const __rl = __checkRateLimit(__clientIp, __rateLimitMax, __rateLimitWindow);');
      lines.push('  if (__rl.limited) {');
      lines.push('    return Response.json({ error: "Too Many Requests" }, { status: 429, headers: { ...__cors, "Retry-After": String(__rl.retryAfter) } });');
      lines.push('  }');
    }

    // Session loading
    if (sessionConfig) {
      lines.push('  let __sessionId = null;');
      lines.push('  let __sessionIsNew = false;');
      lines.push('  const __cookies = __parseCookies(req.headers.get("cookie"));');
      lines.push('  const __signedSid = __cookies[__sessionCookieName];');
      lines.push('  if (__signedSid) {');
      lines.push('    __sessionId = await __verifySessionId(__signedSid);');
      lines.push('  }');
      lines.push('  if (!__sessionId) {');
      lines.push('    __sessionId = crypto.randomUUID();');
      lines.push('    __sessionIsNew = true;');
      lines.push('  }');
      lines.push('  req.__session = __createSession(__sessionId);');
    }

    // Static file serving
    if (staticDecl) {
      lines.push(`  if (url.pathname.startsWith(__staticPrefix)) {`);
      lines.push('    const __staticRes = await __serveStatic(url.pathname, req);');
      lines.push('    if (__staticRes) return __staticRes;');
      lines.push('  }');
    }

    // Route matching
    lines.push('  for (const route of __routes) {');
    lines.push('    if (req.method === route.method || (route.method === "GET" && req.method === "HEAD" && !__routes.some(r => r.method === "HEAD" && r.regex.source === route.regex.source))) {');
    lines.push('      const match = url.pathname.match(route.regex);');
    lines.push('      if (match) {');

    if (globalMiddlewares.length > 0) {
      lines.push('        const __handler = async (__req) => route.handler(__req, match.groups || {});');
      lines.push('        const __chain = __middlewares.reduceRight(');
      lines.push('          (next, mw) => async (__req) => mw(__req, next),');
      lines.push('          __handler');
      lines.push('        );');
      lines.push('        try {');
      lines.push('          const res = await __chain(req);');
      lines.push('          __log("info", `${req.method} ${url.pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('          const headers = new Headers(res.headers);');
      lines.push('          for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
      lines.push('          return new Response(res.body, { status: res.status, headers });');
      lines.push('        } catch (err) {');
      lines.push('          if (err.message === "__BODY_TOO_LARGE__") return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
      if (errorHandler) {
        lines.push('          try {');
        lines.push('            const errRes = await __errorHandler(err, req);');
        lines.push('            if (errRes instanceof Response) {');
        lines.push('              const headers = new Headers(errRes.headers);');
        lines.push('              for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
        lines.push('              return new Response(errRes.body, { status: errRes.status, headers });');
        lines.push('            }');
        lines.push('            return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('          } catch { /**/ }');
      }
      lines.push('          __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('          return Response.json({ error: "Internal Server Error" }, { status: 500, headers: __cors });');
      lines.push('        }');
    } else {
      lines.push('        try {');
      lines.push('          const res = await route.handler(req, match.groups || {});');
      lines.push('          __log("info", `${req.method} ${url.pathname}`, { rid: __rid, status: res.status, ms: Date.now() - __startTime });');
      lines.push('          const headers = new Headers(res.headers);');
      lines.push('          for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
      lines.push('          return new Response(res.body, { status: res.status, headers });');
      lines.push('        } catch (err) {');
      lines.push('          if (err.message === "__BODY_TOO_LARGE__") return Response.json({ error: "Payload Too Large" }, { status: 413, headers: __cors });');
      if (errorHandler) {
        lines.push('          try {');
        lines.push('            const errRes = await __errorHandler(err, req);');
        lines.push('            if (errRes instanceof Response) {');
        lines.push('              const headers = new Headers(errRes.headers);');
        lines.push('              for (const [k, v] of Object.entries(__cors)) headers.set(k, v);');
        lines.push('              return new Response(errRes.body, { status: errRes.status, headers });');
        lines.push('            }');
        lines.push('            return Response.json(errRes, { status: 500, headers: __cors });');
        lines.push('          } catch { /**/ }');
      }
      lines.push('          __log("error", `Unhandled error: ${err.message}`, { error: err.stack || err.message });');
      lines.push('          return Response.json({ error: "Internal Server Error" }, { status: 500, headers: __cors });');
      lines.push('        }');
    }

    lines.push('      }');
    lines.push('    }');
    lines.push('  }');

    // Serve client HTML at root
    lines.push('  if (url.pathname === "/" && typeof __clientHTML !== "undefined") {');
    lines.push('    return new Response(__clientHTML, { status: 200, headers: { "Content-Type": "text/html", ...(__cors) } });');
    lines.push('  }');
    lines.push('  const __notFound = Response.json({ error: "Not Found" }, { status: 404, headers: __cors });');
    lines.push('  __log("warn", "Not Found", { rid: __rid, method: req.method, path: url.pathname, status: 404, ms: Date.now() - __startTime });');
    lines.push('  return __notFound;');

    if (sessionConfig) {
      lines.push('  } catch (__e) { throw __e; }');
      lines.push('  }).then(async (__res) => {');
      lines.push('    if (req.__session && req.__session.__flush) await req.__session.__flush();');
      lines.push('    if (__res && __sessionIsNew) {');
      lines.push('      const __signed = await __signSessionId(__sessionId);');
      lines.push('      const __h = new Headers(__res.headers);');
      lines.push('      __h.set("Set-Cookie", `${__sessionCookieName}=${__signed}; Path=/; HttpOnly; Max-Age=${__sessionMaxAge}`);');
      lines.push('      return new Response(__res.body, { status: __res.status, headers: __h });');
      lines.push('    }');
      lines.push('    return __res;');
      lines.push('  }, async (__e) => {');
      lines.push('    if (req.__session && req.__session.__flush) await req.__session.__flush();');
      lines.push('    throw __e;');
      lines.push('  }).finally(() => { __activeRequests--; });');
    } else {
      lines.push('  } finally {');
      lines.push('    __activeRequests--;');
      lines.push('  }');
      lines.push('  });');
    }
    lines.push('}');
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 22. Bun.serve()
    // ════════════════════════════════════════════════════════════
    const label = blockName ? ` [${blockName}]` : '';
    const portVar = blockName ? `PORT_${blockName.toUpperCase().replace(/[^A-Z0-9]/g, '_')}` : 'PORT';
    lines.push('// ── Start Server ──');
    lines.push(`const __port = process.env.${portVar} || process.env.PORT || 3000;`);
    // Compression wrapper
    if (compressionConfig) {
      lines.push('const __fetchHandler = async (req) => {');
      lines.push('  const res = await __handleRequest(req);');
      lines.push('  if (!res) return res;');
      lines.push('  return __compressResponse(req, res);');
      lines.push('};');
    }
    lines.push(`const __server = Bun.serve({`);
    lines.push(`  port: __port,`);
    lines.push(`  maxRequestBodySize: __maxBodySize,`);
    lines.push(`  fetch: ${compressionConfig ? '__fetchHandler' : '__handleRequest'},`);
    if (tlsConfig) {
      const certExpr = tlsConfig.cert ? this.genExpression(tlsConfig.cert) : 'undefined';
      const keyExpr = tlsConfig.key ? this.genExpression(tlsConfig.key) : 'undefined';
      lines.push(`  tls: {`);
      lines.push(`    cert: Bun.file(${certExpr}),`);
      lines.push(`    key: Bun.file(${keyExpr}),`);
      if (tlsConfig.ca) {
        lines.push(`    ca: Bun.file(${this.genExpression(tlsConfig.ca)}),`);
      }
      lines.push(`  },`);
    }
    if (wsDecl) {
      lines.push(`  websocket: {`);
      if (wsDecl.handlers.on_open) {
        lines.push(`    open(ws) { __wsClients.add(ws); __wsHandlers.on_open(ws); },`);
      } else {
        lines.push(`    open(ws) { __wsClients.add(ws); },`);
      }
      if (wsDecl.handlers.on_message) {
        lines.push(`    message(ws, message) { __wsHandlers.on_message(ws, message); },`);
      }
      if (wsDecl.handlers.on_close) {
        lines.push(`    close(ws, code, reason) { __wsClients.delete(ws); for (const [,r] of __wsRooms) r.delete(ws); __wsHandlers.on_close(ws, code, reason); },`);
      } else {
        lines.push(`    close(ws) { __wsClients.delete(ws); for (const [,r] of __wsRooms) r.delete(ws); },`);
      }
      if (wsDecl.handlers.on_error) {
        lines.push(`    error(ws, error) { __wsHandlers.on_error(ws, error); },`);
      }
      lines.push(`  },`);
    }
    lines.push(`});`);
    lines.push(`console.log(\`Tova server${label} running on \${__server.url}\`);`);
    lines.push('');

    // ════════════════════════════════════════════════════════════
    // 23. on_start hooks (F3) + schedule intervals (F8)
    // ════════════════════════════════════════════════════════════
    if (onStartHooks.length > 0) {
      lines.push('// ── Lifecycle: on_start ──');
      for (let hi = 0; hi < onStartHooks.length; hi++) {
        const hook = onStartHooks[hi];
        const params = hook.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of hook.params) this.declareVar(p.name);
        const body = this.genBlockBody(hook.body);
        this.popScope();
        lines.push(`(async (${params}) => {`);
        lines.push(body);
        lines.push('})();');
      }
      lines.push('');
    }

    // ════════════════════════════════════════════════════════════
    // 24. Graceful Shutdown — on_stop hooks (F3) + clearInterval (F8)
    // ════════════════════════════════════════════════════════════
    lines.push('// ── Graceful Shutdown ──');
    lines.push('async function __shutdown() {');
    lines.push(`  console.log(\`Tova server${label} shutting down...\`);`);
    lines.push('  __shuttingDown = true;');
    lines.push('  __server.stop();');
    lines.push('  const __drainStart = Date.now();');
    lines.push('  while (__activeRequests > 0 && Date.now() - __drainStart < 10000) {');
    lines.push('    await new Promise(r => setTimeout(r, 50));');
    lines.push('  }');

    // on_stop hooks
    if (onStopHooks.length > 0) {
      for (let hi = 0; hi < onStopHooks.length; hi++) {
        const hook = onStopHooks[hi];
        const params = hook.params.map(p => p.name).join(', ');
        this.pushScope();
        for (const p of hook.params) this.declareVar(p.name);
        const body = this.genBlockBody(hook.body);
        this.popScope();
        lines.push(`  await (async (${params}) => {`);
        lines.push(body);
        lines.push('  })();');
      }
    }

    // Schedule cleanup
    if (schedules.length > 0) {
      lines.push('  for (const __iv of __scheduleIntervals) clearInterval(__iv);');
    }

    if (dbConfig || usesDb) {
      if (dbDriver !== 'sqlite') {
        lines.push('  await db.close();');
      } else {
        lines.push('  db.close();');
      }
    }
    if (backgroundJobs.length > 0) {
      lines.push('  // Wait for in-flight background jobs');
      lines.push('  const __bgDrainStart = Date.now();');
      lines.push('  while (__jobProcessing && Date.now() - __bgDrainStart < 5000) {');
      lines.push('    await new Promise(r => setTimeout(r, 50));');
      lines.push('  }');
    }
    lines.push('  if (__logFile) __logFile.end();');
    lines.push('  process.exit(0);');
    lines.push('}');
    lines.push('process.on("SIGINT", __shutdown);');
    lines.push('process.on("SIGTERM", __shutdown);');

    return lines.join('\n');
  }

  // Helper: emit group middleware chain wrapping a handler call
  _emitGroupMiddlewareChain(lines, groupMws, handler, callArgs, timeoutMs) {
    lines.push(`  const __grpHandler = async (__req) => ${handler}${callArgs};`);
    lines.push(`  const __grpChain = [${groupMws.join(', ')}].reduceRight(`);
    lines.push(`    (next, mw) => async (__req) => mw(__req, next),`);
    lines.push(`    __grpHandler`);
    lines.push(`  );`);
    this._emitHandlerCall(lines, `__grpChain(req)`, timeoutMs);
  }

  generateTests(testBlocks) {
    const lines = [];
    lines.push('import { describe, test, expect } from "bun:test";');
    lines.push('');
    lines.push('// ── Test Helpers ──');
    lines.push('async function request(method, path, options = {}) {');
    lines.push('  const url = new URL(path, "http://localhost");');
    lines.push('  const init = { method };');
    lines.push('  if (options.headers) init.headers = new Headers(options.headers);');
    lines.push('  else init.headers = new Headers();');
    lines.push('  if (options.body) {');
    lines.push('    init.headers.set("Content-Type", "application/json");');
    lines.push('    init.body = JSON.stringify(options.body);');
    lines.push('  }');
    lines.push('  const req = new Request(url.toString(), init);');
    lines.push('  const res = await __handleRequest(req);');
    lines.push('  let data = null;');
    lines.push('  try { data = await res.clone().json(); } catch {}');
    lines.push('  return { status: res.status, headers: Object.fromEntries(res.headers), data, raw: res };');
    lines.push('}');
    lines.push('function assert(condition, message) {');
    lines.push('  if (!condition) throw new Error(message || "Assertion failed");');
    lines.push('}');
    lines.push('');

    for (const block of testBlocks) {
      const name = block.name || 'Tests';
      lines.push(`describe(${JSON.stringify(name)}, () => {`);
      for (const stmt of block.body) {
        if (stmt.type === 'FunctionDeclaration') {
          const fnName = stmt.name;
          const displayName = fnName.replace(/_/g, ' ');
          this.pushScope();
          for (const p of (stmt.params || [])) {
            const pName = typeof p === 'string' ? p : (p.name || p.identifier);
            if (pName) this.declareVar(pName);
          }
          const body = this.genBlockBody(stmt.body);
          this.popScope();
          lines.push(`  test(${JSON.stringify(displayName)}, async () => {`);
          lines.push(body);
          lines.push('  });');
        } else {
          lines.push('  ' + this.generateStatement(stmt));
        }
      }
      lines.push('});');
      lines.push('');
    }

    return lines.join('\n');
  }
}

// ─── src/codegen/client-codegen.js ─────────────────────

class ClientCodegen extends BaseCodegen {
  constructor() {
    super();
    this.stateNames = new Set(); // Track state variable names for setter transforms
    this.computedNames = new Set(); // Track computed variable names for getter transforms
    this.componentNames = new Set(); // Track component names for JSX
    this.storeNames = new Set(); // Track store names
    this._asyncContext = false; // When true, server.xxx() calls emit `await`
  }

  // AST-walk to check if a subtree contains server.xxx() RPC calls
  _containsRPC(node) {
    if (!node) return false;
    if (node.type === 'CallExpression' && this._isRPCCall(node)) return true;
    if (node.type === 'BlockStatement') return node.body.some(s => this._containsRPC(s));
    if (node.type === 'ExpressionStatement') return this._containsRPC(node.expression);
    if (node.type === 'Assignment') return node.values.some(v => this._containsRPC(v));
    if (node.type === 'VarDeclaration') return node.values.some(v => this._containsRPC(v));
    if (node.type === 'ReturnStatement') return this._containsRPC(node.value);
    if (node.type === 'IfStatement') {
      return this._containsRPC(node.condition) || this._containsRPC(node.consequent) ||
        node.alternates.some(a => this._containsRPC(a.body)) ||
        this._containsRPC(node.elseBody);
    }
    if (node.type === 'IfExpression') {
      return this._containsRPC(node.condition) || this._containsRPC(node.consequent) ||
        this._containsRPC(node.elseBody);
    }
    if (node.type === 'ForStatement') return this._containsRPC(node.iterable) || this._containsRPC(node.body);
    if (node.type === 'WhileStatement') return this._containsRPC(node.condition) || this._containsRPC(node.body);
    if (node.type === 'CallExpression') {
      return this._containsRPC(node.callee) || node.arguments.some(a => this._containsRPC(a));
    }
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
      return this._containsRPC(node.left) || this._containsRPC(node.right);
    }
    if (node.type === 'MemberExpression') return this._containsRPC(node.object);
    if (node.type === 'CompoundAssignment') return this._containsRPC(node.value);
    if (node.type === 'LambdaExpression') return this._containsRPC(node.body);
    if (node.type === 'NamedArgument') return this._containsRPC(node.value);
    if (node.type === 'MatchExpression') {
      return this._containsRPC(node.subject) || node.arms.some(a => this._containsRPC(a.body));
    }
    if (node.type === 'TryCatchStatement') {
      return this._containsRPC(node.tryBlock) || this._containsRPC(node.catchBlock) ||
        this._containsRPC(node.finallyBlock);
    }
    if (node.type === 'PipeExpression') {
      return this._containsRPC(node.left) || this._containsRPC(node.right);
    }
    if (node.type === 'GuardStatement') {
      return this._containsRPC(node.condition) || this._containsRPC(node.elseBlock);
    }
    if (node.type === 'LetDestructure') return this._containsRPC(node.value);
    if (node.type === 'ArrayLiteral') return node.elements.some(e => this._containsRPC(e));
    if (node.type === 'ObjectLiteral') return node.properties.some(p => this._containsRPC(p.value));
    if (node.type === 'SpreadExpression') return this._containsRPC(node.argument);
    if (node.type === 'AwaitExpression') return this._containsRPC(node.argument);
    if (node.type === 'PropagateExpression') return this._containsRPC(node.expression);
    if (node.type === 'UnaryExpression') return this._containsRPC(node.operand);
    if (node.type === 'TemplateLiteral') return node.parts.some(p => p.type === 'expr' && this._containsRPC(p.expression));
    if (node.type === 'ChainedComparison') return node.operands.some(o => this._containsRPC(o));
    if (node.type === 'RangeExpression') return this._containsRPC(node.start) || this._containsRPC(node.end);
    if (node.type === 'SliceExpression') return this._containsRPC(node.object) || this._containsRPC(node.start) || this._containsRPC(node.end) || this._containsRPC(node.step);
    if (node.type === 'ListComprehension') return this._containsRPC(node.iterable) || this._containsRPC(node.expression) || this._containsRPC(node.condition);
    if (node.type === 'DictComprehension') return this._containsRPC(node.iterable) || this._containsRPC(node.key) || this._containsRPC(node.value) || this._containsRPC(node.condition);
    if (node.type === 'DeferStatement') return this._containsRPC(node.body);
    return false;
  }

  _isRPCCall(node) {
    return node.type === 'CallExpression' &&
      node.callee.type === 'MemberExpression' &&
      node.callee.object.type === 'Identifier' &&
      node.callee.object.name === 'server';
  }

  // Override genCallExpression to add await for server.xxx() in async context
  genCallExpression(node) {
    const isRPC = this._isRPCCall(node);
    const base = super.genCallExpression(node);
    if (isRPC && this._asyncContext) {
      return `await ${base}`;
    }
    return base;
  }

  // Override to add () for signal/computed reads
  genExpression(node) {
    if (node && node.type === 'Identifier' &&
        (this.stateNames.has(node.name) || this.computedNames.has(node.name))) {
      return `${node.name}()`;
    }
    return super.genExpression(node);
  }

  // Override to transform state assignments to setter calls
  generateStatement(node) {
    if (!node) return '';

    // Intercept compound assignments to state variables: count += 1 → setCount(prev => prev + 1)
    if (node.type === 'CompoundAssignment' && node.target.type === 'Identifier' && this.stateNames.has(node.target.name)) {
      const name = node.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.operator[0]; // += → +, -= → -, etc.
      const val = this.genExpression(node.value);
      return `${this.i()}${setter}(__tova_p => __tova_p ${op} ${val});`;
    }

    // Intercept assignments to state variables: count = 0 → setCount(0)
    if (node.type === 'Assignment' && node.targets.length === 1 && this.stateNames.has(node.targets[0])) {
      const name = node.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.values[0]);
      return `${this.i()}${setter}(${val});`;
    }

    return super.generateStatement(node);
  }

  // Override lambda expression to handle state mutations in lambda bodies
  genLambdaExpression(node) {
    const params = this.genParams(node.params);
    const hasPropagate = this._containsPropagate(node.body);
    const asyncPrefix = node.isAsync ? 'async ' : '';

    if (node.body.type === 'BlockStatement') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      const body = this.genBlockBody(node.body);
      this.popScope();
      if (hasPropagate) {
        return `${asyncPrefix}(${params}) => {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
      }
      return `${asyncPrefix}(${params}) => {\n${body}\n${this.i()}}`;
    }

    // Compound assignment in lambda body: fn() count += 1
    if (node.body.type === 'CompoundAssignment' && node.body.target.type === 'Identifier' && this.stateNames.has(node.body.target.name)) {
      const name = node.body.target.name;
      const setter = `set${capitalize(name)}`;
      const op = node.body.operator[0];
      const val = this.genExpression(node.body.value);
      return `${asyncPrefix}(${params}) => { ${setter}(__tova_p => __tova_p ${op} ${val}); }`;
    }

    // Assignment in lambda body: fn() count = 0
    if (node.body.type === 'Assignment' && node.body.targets.length === 1 && this.stateNames.has(node.body.targets[0])) {
      const name = node.body.targets[0];
      const setter = `set${capitalize(name)}`;
      const val = this.genExpression(node.body.values[0]);
      return `${asyncPrefix}(${params}) => { ${setter}(${val}); }`;
    }

    // Non-state statement bodies
    if (node.body.type === 'CompoundAssignment' || node.body.type === 'Assignment' || node.body.type === 'VarDeclaration') {
      this.pushScope();
      for (const p of node.params) { if (p.destructure) this._declareDestructureVars(p.destructure); else this.declareVar(p.name); }
      this.indent++;
      const stmt = super.generateStatement(node.body);
      this.indent--;
      this.popScope();
      return `${asyncPrefix}(${params}) => { ${stmt.trim()} }`;
    }

    if (hasPropagate) {
      return `${asyncPrefix}(${params}) => { try { return ${this.genExpression(node.body)}; } catch (__e) { if (__e && __e.__tova_propagate) return __e.value; throw __e; } }`;
    }
    return `${asyncPrefix}(${params}) => ${this.genExpression(node.body)}`;
  }

  generate(clientBlocks, sharedCode) {
    const lines = [];

    // Runtime imports
    lines.push(`import { createSignal, createEffect, createComputed, mount, hydrate, tova_el, tova_fragment, tova_keyed, tova_inject_css, batch, onMount, onUnmount, onCleanup, createRef, createContext, provide, inject, createErrorBoundary, ErrorBoundary, createRoot, watch, untrack, Dynamic, Portal, lazy } from './runtime/reactivity.js';`);
    lines.push(`import { rpc } from './runtime/rpc.js';`);
    lines.push('');

    // Shared code
    if (sharedCode.trim()) {
      lines.push('// ── Shared ──');
      lines.push(sharedCode);
      lines.push('');
    }

    // Stdlib core functions (available in all Tova code)
    lines.push('// ── Stdlib ──');
    lines.push(this.getStdlibCore());
    lines.push('');

    // Server RPC proxy
    lines.push('// ── Server RPC Proxy ──');
    lines.push('const server = new Proxy({}, {');
    lines.push('  get(_, name) {');
    lines.push('    return (...args) => rpc(name, args);');
    lines.push('  }');
    lines.push('});');
    lines.push('');

    const states = [];
    const computeds = [];
    const effects = [];
    const components = [];
    const stores = [];
    const other = [];

    for (const block of clientBlocks) {
      for (const stmt of block.body) {
        switch (stmt.type) {
          case 'StateDeclaration': states.push(stmt); break;
          case 'ComputedDeclaration': computeds.push(stmt); break;
          case 'EffectDeclaration': effects.push(stmt); break;
          case 'ComponentDeclaration': components.push(stmt); break;
          case 'StoreDeclaration': stores.push(stmt); break;
          default: other.push(stmt); break;
        }
      }
    }

    // Register state names for setter transforms
    for (const s of states) {
      this.stateNames.add(s.name);
    }

    // Register computed names for getter transforms
    for (const c of computeds) {
      this.computedNames.add(c.name);
    }

    // Register component names
    for (const comp of components) {
      this.componentNames.add(comp.name);
    }

    // Register store names
    for (const store of stores) {
      this.storeNames.add(store.name);
    }

    // Generate state signals
    if (states.length > 0) {
      lines.push('// ── Reactive State ──');
      for (const s of states) {
        const init = this.genExpression(s.initialValue);
        lines.push(`const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});`);
      }
      lines.push('');
    }

    // Generate computed values
    if (computeds.length > 0) {
      lines.push('// ── Computed Values ──');
      for (const c of computeds) {
        const expr = this.genExpression(c.expression);
        lines.push(`const ${c.name} = createComputed(() => ${expr});`);
      }
      lines.push('');
    }

    // Generate stores
    if (stores.length > 0) {
      lines.push('// ── Stores ──');
      for (const store of stores) {
        lines.push(this.generateStore(store));
        lines.push('');
      }
    }

    // Generate other statements
    for (const stmt of other) {
      lines.push(this.generateStatement(stmt));
    }

    // Generate components
    if (components.length > 0) {
      lines.push('// ── Components ──');
      for (const comp of components) {
        lines.push(this.generateComponent(comp));
        lines.push('');
      }
    }

    // Generate effects
    if (effects.length > 0) {
      lines.push('// ── Effects ──');
      for (const e of effects) {
        lines.push(this._generateEffect(e.body));
        lines.push('');
      }
    }

    // Include __contains helper if needed
    if (this._needsContainsHelper) {
      lines.push('// ── Runtime Helpers ──');
      lines.push(this.getContainsHelper());
      lines.push('');
    }

    // Auto-mount the App component if it exists
    const hasApp = components.some(c => c.name === 'App');
    if (hasApp) {
      lines.push('// ── Mount ──');
      lines.push('document.addEventListener("DOMContentLoaded", () => {');
      lines.push('  mount(App, document.getElementById("app") || document.body);');
      lines.push('});');
    }

    return lines.join('\n');
  }

  _generateEffect(body) {
    const hasRPC = this._containsRPC(body);
    let code;
    if (hasRPC) {
      code = `createEffect(() => {\n`;
      code += `${this.i()}  (async () => {\n`;
      this.indent += 2;
      const prevAsync = this._asyncContext;
      this._asyncContext = true;
      code += this.genBlockStatements(body);
      this._asyncContext = prevAsync;
      this.indent -= 2;
      code += `\n${this.i()}  })();\n`;
      code += `${this.i()}});`;
    } else {
      code = `createEffect(() => {\n`;
      this.indent++;
      code += this.genBlockStatements(body);
      this.indent--;
      code += `\n${this.i()}});`;
    }
    return code;
  }

  // Generate a short hash from component name + CSS content (for CSS scoping)
  _genScopeId(name, css) {
    const str = name + ':' + (css || '');
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = ((h << 5) - h + str.charCodeAt(i)) | 0;
    }
    return Math.abs(h).toString(36).slice(0, 6);
  }

  // Scope CSS selectors by appending [data-tova-HASH] to each selector
  _scopeCSS(css, scopeAttr) {
    return css.replace(/([^{}@/]+)\{/g, (match, selectorGroup) => {
      const selectors = selectorGroup.split(',').map(s => {
        s = s.trim();
        if (!s || s.startsWith('@') || s === 'from' || s === 'to' || /^\d+%$/.test(s)) return s;
        // Handle pseudo-elements (::before, ::after)
        const pseudoElMatch = s.match(/(::[\w-]+)$/);
        if (pseudoElMatch) {
          return s.slice(0, -pseudoElMatch[0].length) + scopeAttr + pseudoElMatch[0];
        }
        // Handle pseudo-classes (:hover, :focus, etc.)
        const pseudoClsMatch = s.match(/(:[\w-]+(?:\([^)]*\))?)$/);
        if (pseudoClsMatch) {
          return s.slice(0, -pseudoClsMatch[0].length) + scopeAttr + pseudoClsMatch[0];
        }
        return s + scopeAttr;
      }).join(', ');
      return selectors + ' {';
    });
  }

  generateComponent(comp) {
    const hasParams = comp.params.length > 0;
    const paramStr = hasParams ? '__props' : '';

    // Save state/computed names so component-local names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);

    let code = `function ${comp.name}(${paramStr}) {\n`;
    this.indent++;

    // Generate reactive prop accessors — each prop is accessed through __props getter
    // This ensures parent signal changes propagate reactively to the child
    if (hasParams) {
      for (const p of comp.params) {
        this.computedNames.add(p.name);
        const def = p.default || p.defaultValue;
        if (def) {
          const defaultExpr = this.genExpression(def);
          code += `${this.i()}const ${p.name} = () => __props.${p.name} !== undefined ? __props.${p.name} : ${defaultExpr};\n`;
        } else {
          code += `${this.i()}const ${p.name} = () => __props.${p.name};\n`;
        }
      }
    }

    // Separate JSX elements, style blocks, and statements
    const jsxElements = [];
    const styleBlocks = [];
    const bodyItems = [];

    for (const node of comp.body) {
      if (node.type === 'JSXElement' || node.type === 'JSXFor' || node.type === 'JSXIf') {
        jsxElements.push(node);
      } else if (node.type === 'ComponentStyleBlock') {
        styleBlocks.push(node);
      } else {
        bodyItems.push(node);
      }
    }

    // Set up scoped CSS if style blocks exist
    const savedScopeId = this._currentScopeId;
    if (styleBlocks.length > 0) {
      const rawCSS = styleBlocks.map(s => s.css).join('\n');
      const scopeId = this._genScopeId(comp.name, rawCSS);
      this._currentScopeId = scopeId;
      const scopedCSS = this._scopeCSS(rawCSS, `[data-tova-${scopeId}]`);
      code += `${this.i()}tova_inject_css(${JSON.stringify(scopeId)}, ${JSON.stringify(scopedCSS)});\n`;
    }

    // Generate body items in order (state, computed, effect, other statements)
    for (const node of bodyItems) {
      if (node.type === 'StateDeclaration') {
        this.stateNames.add(node.name);
        const init = this.genExpression(node.initialValue);
        code += `${this.i()}const [${node.name}, set${capitalize(node.name)}] = createSignal(${init});\n`;
      } else if (node.type === 'ComputedDeclaration') {
        this.computedNames.add(node.name);
        const expr = this.genExpression(node.expression);
        code += `${this.i()}const ${node.name} = createComputed(() => ${expr});\n`;
      } else if (node.type === 'EffectDeclaration') {
        this.indent++;
        const effectCode = this._generateEffect(node.body);
        this.indent--;
        code += `${this.i()}${effectCode}\n`;
      } else {
        code += this.generateStatement(node) + '\n';
      }
    }

    // Generate JSX return
    if (jsxElements.length === 1) {
      code += `${this.i()}return ${this.genJSX(jsxElements[0])};\n`;
    } else if (jsxElements.length > 1) {
      const children = jsxElements.map(el => this.genJSX(el)).join(', ');
      code += `${this.i()}return tova_fragment([${children}]);\n`;
    }

    this.indent--;
    code += `}`;

    // Restore scoped names and scope id
    this.stateNames = savedState;
    this.computedNames = savedComputed;
    this._currentScopeId = savedScopeId;

    return code;
  }

  generateStore(store) {
    // Save/restore state and computed names so store-internal names don't leak
    const savedState = new Set(this.stateNames);
    const savedComputed = new Set(this.computedNames);

    // Collect store-local state and computed names
    const storeStates = [];
    const storeComputeds = [];
    const storeFunctions = [];

    for (const node of store.body) {
      if (node.type === 'StateDeclaration') {
        storeStates.push(node);
        this.stateNames.add(node.name);
      } else if (node.type === 'ComputedDeclaration') {
        storeComputeds.push(node);
        this.computedNames.add(node.name);
      } else if (node.type === 'FunctionDeclaration') {
        storeFunctions.push(node);
      }
    }

    let code = `const ${store.name} = (() => {\n`;
    this.indent++;

    // Generate state signals
    for (const s of storeStates) {
      const init = this.genExpression(s.initialValue);
      code += `${this.i()}const [${s.name}, set${capitalize(s.name)}] = createSignal(${init});\n`;
    }

    // Generate computed values
    for (const c of storeComputeds) {
      const expr = this.genExpression(c.expression);
      code += `${this.i()}const ${c.name} = createComputed(() => ${expr});\n`;
    }

    // Generate functions
    for (const fn of storeFunctions) {
      code += this.genFunctionDeclaration(fn) + '\n';
    }

    // Build return object with getters/setters
    code += `${this.i()}return {\n`;
    this.indent++;

    for (const s of storeStates) {
      code += `${this.i()}get ${s.name}() { return ${s.name}(); },\n`;
      code += `${this.i()}set ${s.name}(v) { set${capitalize(s.name)}(v); },\n`;
    }

    for (const c of storeComputeds) {
      code += `${this.i()}get ${c.name}() { return ${c.name}(); },\n`;
    }

    for (const fn of storeFunctions) {
      code += `${this.i()}${fn.name},\n`;
    }

    this.indent--;
    code += `${this.i()}};\n`;

    this.indent--;
    code += `${this.i()}})();`;

    // Restore state/computed names
    this.stateNames = savedState;
    this.computedNames = savedComputed;

    return code;
  }

  // Check if an AST expression references any signal/computed name
  _exprReadsSignal(node) {
    if (!node) return false;
    if (node.type === 'Identifier') return this.stateNames.has(node.name) || this.computedNames.has(node.name);
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
      return this._exprReadsSignal(node.left) || this._exprReadsSignal(node.right);
    }
    if (node.type === 'UnaryExpression') return this._exprReadsSignal(node.operand);
    if (node.type === 'CallExpression') {
      return this._exprReadsSignal(node.callee) || node.arguments.some(a => this._exprReadsSignal(a));
    }
    if (node.type === 'MemberExpression') {
      if (node.object.type === 'Identifier' && this.storeNames.has(node.object.name)) {
        return true; // Store property access is reactive (getters call signals)
      }
      return this._exprReadsSignal(node.object);
    }
    if (node.type === 'TemplateLiteral') {
      return node.parts.some(p => p.type === 'expr' && this._exprReadsSignal(p.value));
    }
    if (node.type === 'ChainedComparison') return node.operands.some(o => this._exprReadsSignal(o));
    if (node.type === 'PipeExpression') return this._exprReadsSignal(node.left) || this._exprReadsSignal(node.right);
    if (node.type === 'ArrayLiteral') return node.elements.some(e => this._exprReadsSignal(e));
    if (node.type === 'ObjectLiteral') return node.properties.some(p => this._exprReadsSignal(p.value));
    if (node.type === 'IfExpression') {
      return this._exprReadsSignal(node.condition) || this._exprReadsSignal(node.consequent) ||
        this._exprReadsSignal(node.elseBody);
    }
    if (node.type === 'MatchExpression') {
      if (this._exprReadsSignal(node.subject)) return true;
      return node.arms.some(arm => this._exprReadsSignal(arm.body));
    }
    if (node.type === 'SpreadExpression') return this._exprReadsSignal(node.argument);
    if (node.type === 'AwaitExpression') return this._exprReadsSignal(node.argument);
    if (node.type === 'RangeExpression') return this._exprReadsSignal(node.start) || this._exprReadsSignal(node.end);
    if (node.type === 'SliceExpression') return this._exprReadsSignal(node.object) || this._exprReadsSignal(node.start) || this._exprReadsSignal(node.end);
    if (node.type === 'ListComprehension') return this._exprReadsSignal(node.iterable) || this._exprReadsSignal(node.expression);
    if (node.type === 'LambdaExpression') return this._exprReadsSignal(node.body);
    if (node.type === 'PropagateExpression') return this._exprReadsSignal(node.expression);
    return false;
  }

  genJSX(node) {
    if (!node) return 'null';

    switch (node.type) {
      case 'JSXElement': return this.genJSXElement(node);
      case 'JSXText': return this.genJSXText(node);
      case 'JSXExpression': {
        // If expression reads a signal, wrap as () => expr for fine-grained reactivity
        const expr = this.genExpression(node.expression);
        if (this._exprReadsSignal(node.expression)) {
          return `() => ${expr}`;
        }
        return expr;
      }
      case 'JSXFor': return this.genJSXFor(node);
      case 'JSXIf': return this.genJSXIf(node);
      default: return this.genExpression(node);
    }
  }

  genJSXElement(node) {
    const isComponent = node.tag[0] === node.tag[0].toUpperCase() && /^[A-Z]/.test(node.tag);

    // Attributes
    const attrs = {};
    const events = {};
    const classDirectives = [];
    const spreads = []; // collected spread expressions

    for (const attr of node.attributes) {
      if (attr.type === 'JSXSpreadAttribute') {
        spreads.push(this.genExpression(attr.expression));
        continue;
      }
      if (attr.name === 'bind:value') {
        // Two-way binding: bind:value={name} → reactive value + event handler
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs.value = reactive ? `() => ${expr}` : expr;
        const exprName = attr.value.name;
        if (this.stateNames.has(exprName)) {
          // <select> fires 'change', all other inputs fire 'input'
          const eventName = node.tag === 'select' ? 'change' : 'input';
          events[eventName] = `(e) => { set${capitalize(exprName)}(e.target.value); }`;
        }
      } else if (attr.name === 'bind:checked') {
        // Two-way binding: bind:checked={flag} → reactive checked + onChange
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs.checked = reactive ? `() => ${expr}` : expr;
        const exprName = attr.value.name;
        if (this.stateNames.has(exprName)) {
          events.change = `(e) => { set${capitalize(exprName)}(e.target.checked); }`;
        }
      } else if (attr.name === 'bind:group') {
        // Radio/checkbox group binding
        // For radio: bind:group={selected} → checked = selected === value, onChange sets selected = value
        // For checkbox: bind:group={items} → checked = items.includes(value), onChange toggles value in array
        const expr = this.genExpression(attr.value);
        const exprName = attr.value.name;
        const reactive = this._exprReadsSignal(attr.value);
        // Determine type from other attributes
        const typeAttr = node.attributes.find(a => a.name === 'type');
        const typeStr = typeAttr ? (typeAttr.value.value || '') : '';
        const valueAttr = node.attributes.find(a => a.name === 'value');
        const valueExpr = valueAttr ? this.genExpression(valueAttr.value) : '""';

        if (typeStr === 'checkbox') {
          // Array-based: checked when array includes value
          attrs.checked = reactive
            ? `() => ${expr}.includes(${valueExpr})`
            : `${expr}.includes(${valueExpr})`;
          if (this.stateNames.has(exprName)) {
            events.change = `(e) => { const v = ${valueExpr}; if (e.target.checked) { set${capitalize(exprName)}(__tova_p => [...__tova_p, v]); } else { set${capitalize(exprName)}(__tova_p => __tova_p.filter(x => x !== v)); } }`;
          }
        } else {
          // Radio: single value
          attrs.checked = reactive
            ? `() => ${expr} === ${valueExpr}`
            : `${expr} === ${valueExpr}`;
          if (this.stateNames.has(exprName)) {
            events.change = `(e) => { set${capitalize(exprName)}(${valueExpr}); }`;
          }
        }
      } else if (attr.name.startsWith('class:')) {
        // Conditional class: class:active={cond}
        const className = attr.name.slice(6);
        classDirectives.push({ className, condition: this.genExpression(attr.value), node: attr.value });
      } else if (attr.name.startsWith('on:')) {
        const eventName = attr.name.slice(3);
        events[eventName] = this.genExpression(attr.value);
      } else {
        const attrName = attr.name === 'class' ? 'className' : attr.name;
        const expr = this.genExpression(attr.value);
        const reactive = this._exprReadsSignal(attr.value);
        attrs[attrName] = reactive ? `() => ${expr}` : expr;
      }
    }

    // Merge class directives with className
    if (classDirectives.length > 0) {
      const parts = [];
      if (attrs.className) {
        parts.push(attrs.className);
      }
      for (const { className, condition } of classDirectives) {
        parts.push(`${condition} && "${className}"`);
      }
      const isReactive = classDirectives.some(d => this._exprReadsSignal(d.node));
      const classExpr = `[${parts.join(', ')}].filter(Boolean).join(" ")`;
      attrs.className = isReactive ? `() => ${classExpr}` : classExpr;
    }

    // Add scoped CSS attribute to HTML elements (not components)
    if (this._currentScopeId && !isComponent) {
      attrs[`"data-tova-${this._currentScopeId}"`] = '""';
    }

    const propParts = [];
    for (const [key, val] of Object.entries(attrs)) {
      // For component props, convert reactive () => wrappers to JS getter syntax
      // so the prop stays reactive through the __props access pattern
      if (isComponent && spreads.length === 0 && typeof val === 'string' && val.startsWith('() => ')) {
        const rawExpr = val.slice(6);
        propParts.push(`get ${key}() { return ${rawExpr}; }`);
      } else {
        propParts.push(`${key}: ${val}`);
      }
    }
    for (const [event, handler] of Object.entries(events)) {
      propParts.push(`on${capitalize(event)}: ${handler}`);
    }

    // Build props object, merging spreads if present
    let propsStr;
    if (spreads.length > 0) {
      const ownProps = `{${propParts.join(', ')}}`;
      propsStr = `Object.assign({}, ${spreads.join(', ')}, ${ownProps})`;
    } else {
      propsStr = `{${propParts.join(', ')}}`;
    }

    // Components: call as function, passing props (with children if any)
    if (isComponent) {
      if (!node.selfClosing && node.children.length > 0) {
        // Named slots: children with slot="name" become named props
        const defaultChildren = [];
        const namedSlots = {};

        for (const child of node.children) {
          if (child.type === 'JSXElement') {
            const slotAttr = child.attributes.find(a => a.name === 'slot');
            if (slotAttr && slotAttr.value.type === 'StringLiteral') {
              const slotName = slotAttr.value.value;
              if (!namedSlots[slotName]) namedSlots[slotName] = [];
              namedSlots[slotName].push(child);
              continue;
            }
          }
          defaultChildren.push(child);
        }

        // Add named slot props
        for (const [slotName, slotChildren] of Object.entries(namedSlots)) {
          const slotContent = slotChildren.map(c => this.genJSX(c)).join(', ');
          propParts.push(`${slotName}: [${slotContent}]`);
        }

        if (defaultChildren.length > 0) {
          const children = defaultChildren.map(c => this.genJSX(c)).join(', ');
          propParts.push(`children: [${children}]`);
        }

        if (spreads.length > 0) {
          propsStr = `Object.assign({}, ${spreads.join(', ')}, {${propParts.join(', ')}})`;
        } else {
          propsStr = `{${propParts.join(', ')}}`;
        }
      }
      return `${node.tag}(${propsStr})`;
    }

    const tag = JSON.stringify(node.tag);

    if (node.selfClosing || node.children.length === 0) {
      return `tova_el(${tag}, ${propsStr})`;
    }

    const children = node.children.map(c => this.genJSX(c)).join(', ');
    return `tova_el(${tag}, ${propsStr}, [${children}])`;
  }

  genJSXText(node) {
    if (node.value.type === 'StringLiteral') {
      return JSON.stringify(node.value.value);
    }
    if (node.value.type === 'TemplateLiteral') {
      const code = this.genTemplateLiteral(node.value);
      // Wrap in reactive closure if the template reads signals
      if (this._exprReadsSignal(node.value)) {
        return `() => ${code}`;
      }
      return code;
    }
    return this.genExpression(node.value);
  }

  genJSXFor(node) {
    const varName = node.variable;
    const iterable = this.genExpression(node.iterable);
    const children = node.body.map(c => this.genJSX(c));

    // Wrap in reactive closure so the runtime creates a dynamic block that
    // re-evaluates when the iterable signal changes
    if (node.keyExpr) {
      const keyExpr = this.genExpression(node.keyExpr);
      if (children.length === 1) {
        return `() => ${iterable}.map((${varName}) => tova_keyed(${keyExpr}, ${children[0]}))`;
      }
      return `() => ${iterable}.map((${varName}) => tova_keyed(${keyExpr}, tova_fragment([${children.join(', ')}])))`;
    }

    if (children.length === 1) {
      return `() => ${iterable}.map((${varName}) => ${children[0]})`;
    }
    return `() => ${iterable}.map((${varName}) => tova_fragment([${children.join(', ')}]))`;
  }

  genJSXIf(node) {
    const cond = this.genExpression(node.condition);
    const consequent = node.consequent.map(c => this.genJSX(c));
    const thenPart = consequent.length === 1 ? consequent[0] : `tova_fragment([${consequent.join(', ')}])`;

    // Build chained ternary: cond1 ? a : cond2 ? b : cond3 ? c : else
    let result = `(${cond}) ? ${thenPart}`;

    // elif chains
    if (node.alternates && node.alternates.length > 0) {
      for (const alt of node.alternates) {
        const elifCond = this.genExpression(alt.condition);
        const elifBody = alt.body.map(c => this.genJSX(c));
        const elifPart = elifBody.length === 1 ? elifBody[0] : `tova_fragment([${elifBody.join(', ')}])`;
        result += ` : (${elifCond}) ? ${elifPart}`;
      }
    }

    if (node.alternate) {
      const alt = node.alternate.map(c => this.genJSX(c));
      const elsePart = alt.length === 1 ? alt[0] : `tova_fragment([${alt.join(', ')}])`;
      result += ` : ${elsePart}`;
    } else {
      result += ` : null`;
    }

    // Wrap in reactive closure so the runtime creates a dynamic block
    return `() => ${result}`;
  }

  // Override function declaration to make async if it contains server.* calls
  genFunctionDeclaration(node) {
    const hasRPC = this._containsRPC(node.body);
    const hasPropagate = this._containsPropagate(node.body);
    const isGenerator = this._containsYield(node.body);
    const exportPrefix = node.isPublic ? 'export ' : '';
    const asyncPrefix = (hasRPC || node.isAsync) ? 'async ' : '';
    const genStar = isGenerator ? '*' : '';
    const params = this.genParams(node.params);
    this.pushScope();
    for (const p of node.params) {
      if (p.destructure) {
        this._declareDestructureVars(p.destructure);
      } else {
        this.declareVar(p.name);
      }
    }
    const prevAsync = this._asyncContext;
    if (hasRPC || node.isAsync) this._asyncContext = true;
    const body = this.genBlockBody(node.body);
    this._asyncContext = prevAsync;
    this.popScope();
    if (hasPropagate) {
      return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${this.i()}  try {\n${body}\n${this.i()}  } catch (__e) {\n${this.i()}    if (__e && __e.__tova_propagate) return __e.value;\n${this.i()}    throw __e;\n${this.i()}  }\n${this.i()}}`;
    }
    return `${this.i()}${exportPrefix}${asyncPrefix}function${genStar} ${node.name}(${params}) {\n${body}\n${this.i()}}`;
  }

  getStdlibCore() {
    const parts = [];
    // Only include used builtin functions (tree-shaking)
    const selectiveStdlib = buildSelectiveStdlib(this._usedBuiltins);
    if (selectiveStdlib) parts.push(selectiveStdlib);
    // Include Result/Option if Ok/Err/Some/None are used
    if (this._needsResultOption) parts.push(RESULT_OPTION);
    // Include propagate if needed
    if (this._needsPropagateHelper) parts.push(PROPAGATE);
    return parts.join('\n');
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ─── src/codegen/codegen.js ────────────────────────────

// Main code generator — orchestrates shared/server/client codegen
// Supports named multi-blocks: server "api" { }, server "ws" { }
// Blocks with the same name are merged; different names produce separate output files.
class CodeGenerator {
  constructor(ast, filename = '<stdin>') {
    this.ast = ast;
    this.filename = filename;
  }

  // Group blocks by name (null name = "default")
  _groupByName(blocks) {
    const groups = new Map();
    for (const block of blocks) {
      const key = block.name || null;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key).push(block);
    }
    return groups;
  }

  generate() {
    const sharedBlocks = [];
    const serverBlocks = [];
    const clientBlocks = [];
    const topLevel = [];

    const testBlocks = [];

    for (const node of this.ast.body) {
      switch (node.type) {
        case 'SharedBlock': sharedBlocks.push(node); break;
        case 'ServerBlock': serverBlocks.push(node); break;
        case 'ClientBlock': clientBlocks.push(node); break;
        case 'TestBlock': testBlocks.push(node); break;
        default: topLevel.push(node); break;
      }
    }

    const sharedGen = new SharedCodegen();

    // All shared blocks (regardless of name) are merged into one shared output
    const sharedCode = sharedBlocks.map(b => sharedGen.generate(b)).join('\n');
    const topLevelCode = topLevel.map(s => sharedGen.generateStatement(s)).join('\n');
    const helpers = sharedGen.generateHelpers();
    const combinedShared = [helpers, sharedCode, topLevelCode].filter(s => s.trim()).join('\n').trim();

    // Group server and client blocks by name
    const serverGroups = this._groupByName(serverBlocks);
    const clientGroups = this._groupByName(clientBlocks);

    // Collect function names per named server block for inter-server RPC
    const serverFunctionMap = new Map(); // blockName -> [fnName, ...]
    const collectFns = (stmts) => {
      const fns = [];
      for (const stmt of stmts) {
        if (stmt.type === 'FunctionDeclaration') {
          fns.push(stmt.name);
        } else if (stmt.type === 'RouteGroupDeclaration') {
          fns.push(...collectFns(stmt.body));
        }
      }
      return fns;
    };
    for (const [name, blocks] of serverGroups) {
      if (name) {
        const fns = [];
        for (const block of blocks) {
          fns.push(...collectFns(block.body));
        }
        serverFunctionMap.set(name, fns);
      }
    }

    // Generate server outputs (one per named group)
    const servers = {};
    for (const [name, blocks] of serverGroups) {
      const gen = new ServerCodegen();
      const key = name || 'default';
      // Build peer blocks map (all named blocks except self)
      let peerBlocks = null;
      if (name && serverFunctionMap.size > 1) {
        peerBlocks = new Map();
        for (const [peerName, peerFns] of serverFunctionMap) {
          if (peerName !== name) {
            peerBlocks.set(peerName, peerFns);
          }
        }
      }
      servers[key] = gen.generate(blocks, combinedShared, name, peerBlocks, sharedBlocks);
    }

    // Generate client outputs (one per named group)
    const clients = {};
    for (const [name, blocks] of clientGroups) {
      const gen = new ClientCodegen();
      const key = name || 'default';
      clients[key] = gen.generate(blocks, combinedShared);
    }

    // Generate tests if test blocks exist
    let testCode = '';
    if (testBlocks.length > 0) {
      const testGen = new ServerCodegen();
      testCode = testGen.generateTests(testBlocks);

      // Add __handleRequest export to server code
      const defaultServer = servers['default'] || '';
      if (defaultServer) {
        servers['default'] = defaultServer + '\nexport { __handleRequest };\n';
      }
    }

    // Backward-compatible: if only unnamed blocks, return flat structure
    const hasNamedBlocks = [...serverGroups.keys(), ...clientGroups.keys()].some(k => k !== null);

    // Collect source mappings from all codegens
    const sourceMappings = sharedGen.getSourceMappings();

    if (!hasNamedBlocks) {
      const result = {
        shared: combinedShared,
        server: servers['default'] || '',
        client: clients['default'] || '',
        sourceMappings,
      };
      if (testCode) result.test = testCode;
      return result;
    }

    // Multi-block output: separate files per named block
    const result = {
      shared: combinedShared,
      server: servers['default'] || '',
      client: clients['default'] || '',
      servers,   // { "api": code, "ws": code, ... }
      clients,   // { "admin": code, "dashboard": code, ... }
      multiBlock: true,
      sourceMappings,
    };
    if (testCode) result.test = testCode;
    return result;
  }
}

window.Lexer = Lexer;

window.Parser = Parser;

window.Analyzer = Analyzer;

window.CodeGenerator = CodeGenerator;

})();
</script>

<!-- ─── CodeMirror shared dependency map ──────────── -->
<script type="importmap">
{
  "imports": {
    "codemirror": "https://esm.sh/*codemirror@6.0.1",
    "@codemirror/state": "https://esm.sh/*@codemirror/state@6.4.1",
    "@codemirror/view": "https://esm.sh/*@codemirror/view@6.26.0",
    "@codemirror/language": "https://esm.sh/*@codemirror/language@6.10.1",
    "@codemirror/commands": "https://esm.sh/*@codemirror/commands@6.3.3",
    "@codemirror/search": "https://esm.sh/*@codemirror/search@6.5.5",
    "@codemirror/autocomplete": "https://esm.sh/*@codemirror/autocomplete@6.12.0",
    "@codemirror/lint": "https://esm.sh/*@codemirror/lint@6.5.0",
    "@codemirror/theme-one-dark": "https://esm.sh/*@codemirror/theme-one-dark@6.1.2",
    "@lezer/common": "https://esm.sh/*@lezer/common@1.2.1",
    "@lezer/highlight": "https://esm.sh/*@lezer/highlight@1.2.0",
    "@lezer/lr": "https://esm.sh/*@lezer/lr@1.4.0",
    "crelt": "https://esm.sh/*crelt@1.0.6",
    "style-mod": "https://esm.sh/*style-mod@4.1.2",
    "w3c-keyname": "https://esm.sh/*w3c-keyname@2.2.8"
  }
}
</script>

<!-- ─── CodeMirror & App ─────────────────────────── -->
<script type="module">
import {basicSetup} from 'codemirror';
import {EditorState, StateField, StateEffect} from '@codemirror/state';
import {EditorView, keymap, Decoration} from '@codemirror/view';
import {StreamLanguage} from '@codemirror/language';
import {oneDark} from '@codemirror/theme-one-dark';
import {autocompletion} from '@codemirror/autocomplete';

// ─── Tova Syntax Highlighting ────────────────────────
const tovaLanguage = StreamLanguage.define({
  startState() { return { inComment: false, commentDepth: 0 }; },
  token(stream, state) {
    // Block comment (nestable)
    if (state.inComment) {
      if (stream.match('/*')) { state.commentDepth++; return 'blockComment'; }
      if (stream.match('*/')) { state.commentDepth--; if (state.commentDepth <= 0) { state.inComment = false; state.commentDepth = 0; } return 'blockComment'; }
      stream.next(); return 'blockComment';
    }
    // Docstring
    if (stream.match('///')) { stream.skipToEnd(); return 'docString'; }
    // Line comment
    if (stream.match('//')) { stream.skipToEnd(); return 'lineComment'; }
    // Block comment start
    if (stream.match('/*')) { state.inComment = true; state.commentDepth = 1; return 'blockComment'; }
    // Strings with interpolation
    if (stream.match('"')) {
      while (!stream.eol()) {
        const ch = stream.next();
        if (ch === '\\') { stream.next(); continue; }
        if (ch === '{') { return 'string'; }
        if (ch === '"') return 'string';
      }
      return 'string';
    }
    // Simple strings
    if (stream.match("'")) {
      while (!stream.eol()) { const ch = stream.next(); if (ch === '\\') { stream.next(); continue; } if (ch === "'") return 'string'; }
      return 'string';
    }
    // Braces (interpolation)
    if (stream.match('{')) return 'brace';
    if (stream.match('}')) return 'brace';
    // Numbers
    if (stream.match(/^0[xX][0-9a-fA-F]+/)) return 'number';
    if (stream.match(/^0[bB][01]+/)) return 'number';
    if (stream.match(/^\d+\.\d+([eE][+-]?\d+)?/)) return 'number';
    if (stream.match(/^\d+([eE][+-]?\d+)?/)) return 'number';
    // Multi-char operators
    if (stream.match('|>')) return 'operator';
    if (stream.match('=>')) return 'operator';
    if (stream.match('->')) return 'operator';
    if (stream.match('..=')) return 'operator';
    if (stream.match('...')) return 'operator';
    if (stream.match('..')) return 'operator';
    if (stream.match('?.')) return 'operator';
    if (stream.match('??')) return 'operator';
    if (stream.match('::')) return 'operator';
    if (stream.match('**')) return 'operator';
    if (stream.match(/^[+\-*\/%]=?/)) return 'operator';
    if (stream.match(/^[<>!=]=?/)) return 'operator';
    if (stream.match(/^&&|\|\|/)) return 'operator';
    if (stream.match('=')) return 'operator';
    // JSX close tag
    if (stream.match(/^<\/[A-Za-z][A-Za-z0-9]*/)) { stream.match('>'); return 'tagName'; }
    // Identifiers and keywords
    if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
      const w = stream.current();
      if (['fn','let','var','if','elif','else','for','while','in','not','and','or','match',
           'return','type','import','from','export','as','true','false','nil',
           'server','client','shared','state','computed','effect','component',
           'route','GET','POST','PUT','DELETE','PATCH'].includes(w)) return 'keyword';
      if (/^[A-Z]/.test(w)) return 'typeName';
      return 'variableName';
    }
    // JSX
    if (stream.match('/>')) return 'angleBracket';
    if (stream.peek() === '<' && /[A-Za-z]/.test(stream.string.charAt(stream.pos + 1) || '')) {
      stream.next(); return 'angleBracket';
    }
    stream.next();
    return null;
  }
});

// ─── Autocompletion ─────────────────────────────────
const tovaKeywords = [
  'fn', 'let', 'var', 'if', 'elif', 'else', 'for', 'while', 'match',
  'type', 'state', 'computed', 'effect', 'component', 'server', 'client',
  'shared', 'route', 'return', 'import', 'from', 'in', 'and', 'or', 'not',
  'true', 'false', 'nil', 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'as', 'export'
];

const tovaStdlib = [
  { label: 'print', detail: '(...args)', info: 'Print values to console' },
  { label: 'len', detail: '(v)', info: 'Length of string, array, or object' },
  { label: 'range', detail: '(start?, end, step?)', info: 'Generate number array' },
  { label: 'sum', detail: '(arr)', info: 'Sum of array elements' },
  { label: 'min', detail: '(arr)', info: 'Minimum value in array' },
  { label: 'max', detail: '(arr)', info: 'Maximum value in array' },
  { label: 'sorted', detail: '(arr, key?)', info: 'Sort array (with optional key fn)' },
  { label: 'reversed', detail: '(arr)', info: 'Reverse array' },
  { label: 'enumerate', detail: '(arr)', info: 'Index-value pairs' },
  { label: 'zip', detail: '(...arrs)', info: 'Combine arrays element-wise' },
  { label: 'type_of', detail: '(v)', info: 'Runtime type name as string' },
  { label: 'filter', detail: '(arr, fn)', info: 'Filter array by predicate' },
  { label: 'map', detail: '(arr, fn)', info: 'Transform each element' },
  { label: 'flat_map', detail: '(arr, fn)', info: 'Map then flatten one level' },
  { label: 'any', detail: '(arr, fn)', info: 'True if any element matches' },
  { label: 'all', detail: '(arr, fn)', info: 'True if all elements match' },
];

const tovaSnippets = [
  { label: 'fn', detail: 'function', apply: 'fn name() {\n  \n}', boost: -1 },
  { label: 'for', detail: 'for-in loop', apply: 'for item in items {\n  \n}', boost: -1 },
  { label: 'match', detail: 'match expression', apply: 'match value {\n  _ => \n}', boost: -1 },
  { label: 'type', detail: 'type definition', apply: 'type Name {\n  \n}', boost: -1 },
  { label: 'client', detail: 'client block', apply: 'client {\n  state count = 0\n\n  component App {\n    <div>\n      \n    </div>\n  }\n}', boost: -1 },
  { label: 'component', detail: 'component', apply: 'component App {\n  <div>\n    \n  </div>\n}', boost: -1 },
  { label: 'server', detail: 'server block', apply: 'server {\n  \n}', boost: -1 },
  { label: 'effect', detail: 'side effect', apply: 'effect {\n  \n}', boost: -1 },
  { label: 'if', detail: 'conditional', apply: 'if condition {\n  \n}', boost: -1 },
  { label: 'while', detail: 'while loop', apply: 'while condition {\n  \n}', boost: -1 },
  { label: 'route', detail: 'HTTP route', apply: 'route GET "/path" => fn(req) {\n  \n}', boost: -1 },
];

function tovaCompletions(context) {
  const word = context.matchBefore(/[a-zA-Z_]\w*/);
  if (!word && !context.explicit) return null;
  const from = word ? word.from : context.pos;
  const text = word ? word.text : '';

  const options = [];

  // Keywords
  for (const kw of tovaKeywords) {
    if (!text || kw.startsWith(text)) {
      // Check if there's a matching snippet
      const snippet = tovaSnippets.find(s => s.label === kw);
      if (snippet) {
        options.push({ label: kw, type: 'keyword', detail: snippet.detail, apply: snippet.apply, boost: 1 });
      } else {
        options.push({ label: kw, type: 'keyword', boost: 0 });
      }
    }
  }

  // Stdlib functions
  for (const fn of tovaStdlib) {
    if (!text || fn.label.startsWith(text)) {
      options.push({ label: fn.label, type: 'function', detail: fn.detail, info: fn.info, boost: 2 });
    }
  }

  return { from, options, filter: true };
}

// ─── Error Decorations ──────────────────────────────
const setErrorEffect = StateEffect.define();
const clearErrorEffect = StateEffect.define();

const errorLineDeco = Decoration.line({ class: 'cm-error-line' });

const errorField = StateField.define({
  create() { return Decoration.none; },
  update(decos, tr) {
    for (const e of tr.effects) {
      if (e.is(clearErrorEffect)) return Decoration.none;
      if (e.is(setErrorEffect)) {
        const lines = e.value;
        const ranges = [];
        for (const lineNum of lines) {
          try {
            const line = tr.state.doc.line(lineNum);
            ranges.push(errorLineDeco.range(line.from));
          } catch(ex) {}
        }
        return ranges.length ? Decoration.set(ranges) : Decoration.none;
      }
    }
    return decos;
  },
  provide: f => EditorView.decorations.from(f)
});

// ─── Data ───────────────────────────────────────────
const EXAMPLES = [
  {
    "category": "Getting Started",
    "name": "Hello World",
    "code": "// Welcome to Tova! A modern language that transpiles to JavaScript.\n// Click \"Run\" or press Cmd/Ctrl+Enter to execute.\n\nname = \"World\"\ngreeting = \"Hello, {name}!\"\nprint(greeting)\n\n// Tova uses string interpolation with {expressions}\nx = 42\npi = 3.14159\nprint(\"x is {x} and pi is {pi}\")\n\n// Variables: immutable by default, use 'var' for mutable\nlanguage = \"Tova\"         // immutable\nvar version = 1          // mutable\nversion += 1\nprint(\"{language} v{version}\")\n"
  },
  {
    "category": "Getting Started",
    "name": "Variables & Types",
    "code": "// Immutable bindings (default)\nname = \"Alice\"\nage = 30\npi = 3.14159\nis_active = true\nnothing = nil\n\n// Mutable bindings\nvar count = 0\ncount += 1\ncount += 1\nprint(\"count = {count}\")\n\n// Multiple assignment\na, b, c = 1, 2, 3\nprint(\"a={a}, b={b}, c={c}\")\n\n// Swap\nvar x = 10\nvar y = 20\nx, y = y, x\nprint(\"After swap: x={x}, y={y}\")\n\n// Type checking\nprint(type_of(42))\nprint(type_of(\"hello\"))\nprint(type_of(true))\nprint(type_of([1, 2, 3]))\nprint(type_of(nil))\n"
  },
  {
    "category": "Getting Started",
    "name": "String Operations",
    "code": "// String interpolation with expressions\nname = \"hello world\"\nprint(\"Upper: {name.upper()}\")\nprint(\"Capitalized: {name.capitalize()}\")\nprint(\"Title: {name.title_case()}\")\n\n// String methods\nsentence = \"the quick brown fox jumps\"\nprint(\"Words: {sentence.words()}\")\nprint(\"Starts with 'the': {sentence.starts_with(\"the\")}\")\nprint(\"Contains 'brown': {sentence.contains(\"brown\")}\")\n\n// Useful conversions\nprint(\"snake_case: {\"helloWorld\".snake_case()}\")\nprint(\"camelCase: {\"hello_world\".camel_case()}\")\n\n// String multiply (repeat)\nborder = \"-\" * 30\nprint(border)\nprint(\"  Tova Language\")\nprint(border)\n\n// Characters and lines\ntext = \"Tova\"\nprint(\"Chars: {text.chars()}\")\n"
  },
  {
    "category": "Functions",
    "name": "Functions & Lambdas",
    "code": "// Functions return the last expression (implicit return)\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"friend\") {\n  \"Hey, {name}!\"\n}\n\nprint(add(1, 2))\nprint(greet())\nprint(greet(\"Alice\"))\n\n// Lambda / anonymous functions\ndouble = fn(x) x * 2\nsquare = fn(x) x * x\nprint(\"double(7) = {double(7)}\")\nprint(\"square(5) = {square(5)}\")\n\n// Arrow syntax\nadd3 = fn(a, b, c) a + b + c\nprint(\"add3(1,2,3) = {add3(1, 2, 3)}\")\n\n// Functions are first-class\nfn apply(f, x) { f(x) }\nprint(\"apply(double, 21) = {apply(double, 21)}\")\n\n// Explicit return\nfn first_positive(items) {\n  for item in items {\n    if item > 0 { return item }\n  }\n  nil\n}\nprint(\"First positive: {first_positive([-3, -1, 0, 4, 7])}\")\n"
  },
  {
    "category": "Functions",
    "name": "Higher-Order Functions",
    "code": "// Map, filter, and reduce with lambdas\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndoubled = map(numbers, fn(x) x * 2)\nprint(\"Doubled: {doubled}\")\n\nevens = filter(numbers, fn(x) x % 2 == 0)\nprint(\"Evens: {evens}\")\n\ntotal = sum(numbers)\nprint(\"Sum: {total}\")\n\n// Composition\nfn compose(f, g) {\n  fn(x) f(g(x))\n}\n\ndouble = fn(x) x * 2\nadd_one = fn(x) x + 1\ndouble_then_add = compose(add_one, double)\nprint(\"double_then_add(5) = {double_then_add(5)}\")\n\n// Sorting with key function\nwords = [\"banana\", \"apple\", \"cherry\", \"date\"]\nby_length = sorted(words, fn(w) len(w))\nprint(\"By length: {by_length}\")\n\n// Checking conditions\nhas_negative = any([-1, 2, 3], fn(x) x < 0)\nall_positive = all([1, 2, 3], fn(x) x > 0)\nprint(\"Has negative: {has_negative}\")\nprint(\"All positive: {all_positive}\")\n"
  },
  {
    "category": "Functions",
    "name": "Pipe Operator",
    "code": "// The pipe operator |> chains function calls beautifully\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Another example\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\", \"Eve\"]\nresult2 = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\n  |> reversed()\nprint(\"Long names (Z-A): {result2}\")\n\n// Simple pipeline\n42 |> fn(x) x * 2 |> fn(x) \"The answer is {x}\" |> print()\n"
  },
  {
    "category": "Data Structures",
    "name": "Lists & Comprehensions",
    "code": "// List literals\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"Fruits: {fruits}\")\nprint(\"Length: {len(fruits)}\")\n\n// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// With filter\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Nested comprehension\npairs = [[x, y] for x in range(1, 4) for y in range(1, 4) if x != y]\nprint(\"Pairs: {pairs}\")\n\n// Dict comprehension\nsquare_map = {x: x * x for x in range(1, 6)}\nprint(\"Square map: {square_map}\")\n\n// Slice operations\nnums = [10, 20, 30, 40, 50, 60, 70]\nprint(\"nums[1:4] = {nums[1:4]}\")\nprint(\"nums[:3]  = {nums[:3]}\")\nprint(\"nums[4:]  = {nums[4:]}\")\nprint(\"nums[::-1] = {nums[::-1]}\")\n"
  },
  {
    "category": "Data Structures",
    "name": "Spread & Destructuring",
    "code": "// Array spread\nfirst = [1, 2, 3]\nsecond = [4, 5, 6]\ncombined = [...first, ...second]\nprint(\"Combined: {combined}\")\n\n// Object literals\nconfig = {\n  color: \"blue\",\n  size: \"medium\",\n  bold: false,\n  count: 42\n}\nprint(\"Config: {config}\")\n\n// Destructuring objects\nlet {color, size, bold} = config\nprint(\"Color: {color}\")\nprint(\"Size: {size}\")\n\n// Destructuring arrays\nlet [a, b, c] = [10, 20, 30]\nprint(\"a={a}, b={b}, c={c}\")\n\n// Membership testing\nfruits = [\"apple\", \"banana\", \"cherry\"]\nif \"banana\" in fruits {\n  print(\"We have bananas!\")\n}\nif \"grape\" not in fruits {\n  print(\"No grapes available\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "If / Elif / Else",
    "code": "// If expressions (they return values!)\nfn grade(score) {\n  if score >= 90 {\n    \"A\"\n  } elif score >= 80 {\n    \"B\"\n  } elif score >= 70 {\n    \"C\"\n  } elif score >= 60 {\n    \"D\"\n  } else {\n    \"F\"\n  }\n}\n\nfor s in [95, 85, 72, 65, 45] {\n  print(\"Score {s} = Grade {grade(s)}\")\n}\n\n// Chained comparisons (Python-style!)\ny = 5\nif 1 < y < 10 {\n  print(\"{y} is between 1 and 10\")\n}\n\nage = 25\nif 18 <= age < 65 {\n  print(\"Working age\")\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Loops",
    "code": "// For loops with range\nprint(\"Counting:\")\nfor i in range(1, 6) {\n  print(\"  {i}\")\n}\n\n// For-in with arrays\ncolors = [\"red\", \"green\", \"blue\"]\nfor color in colors {\n  print(\"Color: {color}\")\n}\n\n// Enumerate (get index + value)\nfor pair in enumerate(colors) {\n  print(\"  {pair[0]}: {pair[1]}\")\n}\n\n// While loops\nvar n = 1\nwhile n < 100 {\n  n = n * 2\n}\nprint(\"First power of 2 >= 100: {n}\")\n\n// FizzBuzz\nfn fizzbuzz(n) {\n  if n % 15 == 0 { \"FizzBuzz\" }\n  elif n % 3 == 0 { \"Fizz\" }\n  elif n % 5 == 0 { \"Buzz\" }\n  else { \"{n}\" }\n}\n\nfor i in range(1, 21) {\n  print(fizzbuzz(i))\n}\n"
  },
  {
    "category": "Control Flow",
    "name": "Pattern Matching",
    "code": "// Pattern matching — Tova's most powerful feature!\n\n// Simple value matching\nfn describe(value) {\n  match value {\n    0 => \"zero\"\n    1..10 => \"small (1-9)\"\n    n if n > 100 => \"big: {n}\"\n    _ => \"other: {value}\"\n  }\n}\n\nprint(describe(0))\nprint(describe(5))\nprint(describe(200))\nprint(describe(50))\n\n// Pattern matching on algebraic types\ntype Shape {\n  Circle(radius: Float),\n  Rect(w: Float, h: Float),\n  Triangle(base: Float, height: Float),\n  Point\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n    Triangle(b, h) => 0.5 * b * h\n    Point => 0.0\n  }\n}\n\nfn describe_shape(s) {\n  match s {\n    Circle(r) => \"Circle with radius {r}\"\n    Rect(w, h) => \"Rectangle {w}x{h}\"\n    Triangle(b, h) => \"Triangle base={b} height={h}\"\n    Point => \"Just a point\"\n  }\n}\n\nshapes = [Circle(5.0), Rect(3.0, 4.0), Triangle(6.0, 3.0), Point]\nfor shape in shapes {\n  print(\"{describe_shape(shape)} => area = {area(shape)}\")\n}\n"
  },
  {
    "category": "Types",
    "name": "Algebraic Data Types",
    "code": "// Algebraic Data Types (tagged unions / sum types)\ntype Color {\n  Red,\n  Green,\n  Blue,\n  Custom(r: Int, g: Int, b: Int)\n}\n\nfn to_hex(c) {\n  match c {\n    Red => \"#FF0000\"\n    Green => \"#00FF00\"\n    Blue => \"#0000FF\"\n    Custom(r, g, b) => \"rgb({r},{g},{b})\"\n  }\n}\n\nprint(to_hex(Red))\nprint(to_hex(Custom(255, 128, 0)))\n\n// Option type pattern\ntype Option {\n  Some(value: Any),\n  None\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { None }\n  else { Some(a / b) }\n}\n\nfn unwrap(opt, default_val) {\n  match opt {\n    Some(v) => v\n    None => default_val\n  }\n}\n\nprint(unwrap(safe_divide(10, 3), 0))\nprint(unwrap(safe_divide(10, 0), 0))\n\n// Result type\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_age(input) {\n  if input > 0 and input < 150 {\n    Ok(input)\n  } else {\n    Err(\"Invalid age: {input}\")\n  }\n}\n\nprint(parse_age(25))\nprint(parse_age(-5))\n"
  },
  {
    "category": "Types",
    "name": "Struct Types",
    "code": "// Struct-like types with named fields\ntype Point {\n  x: Float\n  y: Float\n}\n\ntype User {\n  name: String\n  age: Int\n}\n\n// Creating instances\np1 = Point(3.0, 4.0)\np2 = Point(1.0, 2.0)\nprint(\"p1 = ({p1.x}, {p1.y})\")\nprint(\"p2 = ({p2.x}, {p2.y})\")\n\n// Distance function\nfn distance(a, b) {\n  dx = a.x - b.x\n  dy = a.y - b.y\n  (dx ** 2 + dy ** 2) ** 0.5\n}\nprint(\"Distance: {distance(p1, p2)}\")\n\n// User records\nusers = [\n  User(\"Alice\", 30),\n  User(\"Bob\", 25),\n  User(\"Charlie\", 35)\n]\n\n// Sort by age\nby_age = sorted(users, fn(u) u.age)\nfor u in by_age {\n  print(\"{u.name}: {u.age}\")\n}\n"
  },
  {
    "category": "Standard Library",
    "name": "Built-in Functions",
    "code": "// Tova comes with useful built-in functions\n\n// range(start?, end, step?)\nprint(\"range(5): {range(5)}\")\nprint(\"range(2,8): {range(2, 8)}\")\nprint(\"range(0,20,3): {range(0, 20, 3)}\")\n\n// len — works on strings, arrays, objects\nprint(\"len('hello'): {len(\"hello\")}\")\nprint(\"len([1,2,3]): {len([1, 2, 3])}\")\n\n// sum, min, max\nnums = [4, 2, 7, 1, 9, 3]\nprint(\"sum: {sum(nums)}\")\nprint(\"min: {min(nums)}\")\nprint(\"max: {max(nums)}\")\n\n// sorted, reversed\nprint(\"sorted: {sorted(nums)}\")\nprint(\"reversed: {reversed(nums)}\")\n\n// enumerate — get index,value pairs\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor pair in enumerate(fruits) {\n  print(\"  [{pair[0]}] {pair[1]}\")\n}\n\n// zip — combine arrays\nkeys = [\"name\", \"age\", \"city\"]\nvals = [\"Alice\", 30, \"NYC\"]\nprint(\"zipped: {zip(keys, vals)}\")\n\n// type_of — runtime type checking\nprint(\"type_of(42): {type_of(42)}\")\nprint(\"type_of(3.14): {type_of(3.14)}\")\nprint(\"type_of('hi'): {type_of(\"hi\")}\")\nprint(\"type_of(true): {type_of(true)}\")\nprint(\"type_of(nil): {type_of(nil)}\")\nprint(\"type_of([1]): {type_of([1, 2])}\")\n"
  },
  {
    "category": "Reactive UI",
    "name": "Counter App",
    "code": "// Counter App in Tova — demonstrates reactive UI\n\nclient {\n  state count = 0\n\n  computed doubled = count * 2\n  computed message = match count {\n    0 => \"Click the button!\"\n    1..5 => \"Keep going...\"\n    n if n >= 10 => \"You're on fire! 🔥\"\n    _ => \"Nice!\"\n  }\n\n  component App {\n    <div class=\"counter-app\">\n      <h1>\"Tova Counter\"</h1>\n      <p class=\"count\">\"{count}\"</p>\n      <p class=\"doubled\">\"Doubled: {doubled}\"</p>\n      <p class=\"message\">\"{message}\"</p>\n      <div class=\"buttons\">\n        <button on:click={fn() count -= 1}>\"-\"</button>\n        <button on:click={fn() count += 1}>\"+\"</button>\n        <button on:click={fn() count = 0}>\"Reset\"</button>\n      </div>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Todo App (Full-Stack)",
    "code": "// Full-Stack Todo App in Tova — demonstrates server/client/shared blocks\n\nshared {\n  type Todo {\n    id: Int\n    title: String\n    completed: Bool\n  }\n}\n\nserver {\n  // In-memory store for demo (use db.query for real apps)\n  var todos = []\n  var next_id = 1\n\n  fn get_todos() -> [Todo] {\n    todos\n  }\n\n  fn add_todo(title: String) -> Todo {\n    todo = Todo(next_id, title, false)\n    next_id += 1\n    todos = [...todos, todo]\n    todo\n  }\n\n  fn toggle_todo(id: Int) -> Todo {\n    for t in todos {\n      if t.id == id {\n        return Todo(t.id, t.title, not t.completed)\n      }\n    }\n    nil\n  }\n\n  fn delete_todo(id: Int) {\n    todos = [t for t in todos if t.id != id]\n  }\n\n  route GET \"/api/todos\" => get_todos\n}\n\nclient {\n  state todos: [Todo] = []\n  state new_title = \"\"\n\n  computed remaining = len([t for t in todos if not t.completed])\n  computed total = len(todos)\n\n  effect {\n    todos = server.get_todos()\n  }\n\n  fn handle_add() {\n    if new_title != \"\" {\n      server.add_todo(new_title)\n      new_title = \"\"\n      todos = server.get_todos()\n    }\n  }\n\n  fn handle_toggle(id) {\n    server.toggle_todo(id)\n    todos = server.get_todos()\n  }\n\n  fn handle_delete(id) {\n    server.delete_todo(id)\n    todos = server.get_todos()\n  }\n\n  component TodoItem(todo) {\n    <li class=\"todo-item\">\n      <input type=\"checkbox\" checked={todo.completed} on:change={fn() handle_toggle(todo.id)} />\n      <span class=\"todo-text\">\"{todo.title}\"</span>\n      <button on:click={fn() handle_delete(todo.id)}>\"×\"</button>\n    </li>\n  }\n\n  component App {\n    <div class=\"todo-app\">\n      <h1>\"Tova Todo\"</h1>\n      <div class=\"input-row\">\n        <input\n          type=\"text\"\n          placeholder=\"What needs to be done?\"\n          value={new_title}\n          on:input={fn(e) new_title = e.target.value}\n        />\n        <button on:click={handle_add}>\"Add\"</button>\n      </div>\n      <ul class=\"todo-list\">\n        for todo in todos {\n          <TodoItem todo={todo} />\n        }\n      </ul>\n      <p class=\"status\">\"{remaining} of {total} remaining\"</p>\n    </div>\n  }\n}"
  },
  {
    "category": "Reactive UI",
    "name": "Temperature Converter",
    "code": "// Temperature converter — reactive two-way conversion\nclient {\n  state celsius = 20\n  computed fahrenheit = celsius * 9 / 5 + 32\n  computed kelvin = celsius + 273.15\n\n  computed description = match celsius {\n    c if c <= 0 => \"Freezing!\"\n    c if c <= 15 => \"Cold\"\n    c if c <= 25 => \"Comfortable\"\n    c if c <= 35 => \"Warm\"\n    _ => \"Hot!\"\n  }\n\n  component App {\n    <div class=\"converter\">\n      <h1>\"Temperature Converter\"</h1>\n      <div class=\"input-group\">\n        <label>\"Celsius\"</label>\n        <input type=\"range\" min=\"-40\" max=\"60\" value={celsius}\n               on:input={fn(e) celsius = e.target.value * 1} />\n        <span class=\"value\">\"{celsius}C\"</span>\n      </div>\n      <div class=\"results\">\n        <p>\"{celsius}C = {fahrenheit}F = {kelvin}K\"</p>\n        <p class=\"desc\">\"{description}\"</p>\n      </div>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Reactive UI",
    "name": "Stopwatch",
    "code": "// Stopwatch with reactive state\nclient {\n  state elapsed = 0\n  state running = false\n  state timer_id = nil\n\n  fn start_timer() {\n    if not running {\n      running = true\n    }\n  }\n\n  fn stop_timer() {\n    running = false\n  }\n\n  fn reset_timer() {\n    running = false\n    elapsed = 0\n  }\n\n  computed display = match elapsed {\n    t if t < 60 => \"{t}s\"\n    t if t < 3600 => \"{t / 60}m {t % 60}s\"\n    _ => \"{elapsed / 3600}h {(elapsed % 3600) / 60}m\"\n  }\n\n  component App {\n    <div class=\"stopwatch\">\n      <h1>\"Stopwatch\"</h1>\n      <p class=\"time\">\"{display}\"</p>\n      <div class=\"controls\">\n        <button on:click={fn() elapsed += 1}>\"+1s\"</button>\n        <button on:click={fn() elapsed += 10}>\"+10s\"</button>\n        <button on:click={fn() elapsed += 60}>\"+1m\"</button>\n        <button on:click={reset_timer}>\"Reset\"</button>\n      </div>\n      <p class=\"hint\">\"(Click buttons to simulate time passing)\"</p>\n    </div>\n  }\n}\n"
  },
  {
    "category": "Algorithms",
    "name": "Fibonacci",
    "code": "// Fibonacci sequence — multiple approaches\n\n// Recursive (simple but slow)\nfn fib_recursive(n) {\n  if n <= 1 { n }\n  else { fib_recursive(n - 1) + fib_recursive(n - 2) }\n}\n\n// Iterative (fast)\nfn fib(n) {\n  if n <= 1 { return n }\n  var a = 0\n  var b = 1\n  for i in range(2, n + 1) {\n    var temp = b\n    b = a + b\n    a = temp\n  }\n  b\n}\n\n// Print first 15 Fibonacci numbers\nprint(\"Fibonacci sequence:\")\nfor i in range(15) {\n  print(\"  fib({i}) = {fib(i)}\")\n}\n\n// Using list comprehension\nfibs = [fib(i) for i in range(20)]\nprint(\"\\nFirst 20: {fibs}\")\nprint(\"Sum: {sum(fibs)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Binary Search",
    "code": "// Binary search on sorted array\nfn binary_search(arr, target) {\n  var lo = 0\n  var hi = len(arr) - 1\n  while lo <= hi {\n    mid = (lo + hi) / 2\n    if arr[mid] == target {\n      return mid\n    } elif arr[mid] < target {\n      lo = mid + 1\n    } else {\n      hi = mid - 1\n    }\n  }\n  -1\n}\n\n// Test it\nnums = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\nprint(\"Array: {nums}\")\n\nfor target in [23, 72, 15, 2, 91] {\n  idx = binary_search(nums, target)\n  if idx >= 0 {\n    print(\"Found {target} at index {idx}\")\n  } else {\n    print(\"{target} not found\")\n  }\n}\n\n// Sorting + searching\nwords = [\"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\", \"fig\"]\nsorted_words = sorted(words)\nprint(\"\\nSorted: {sorted_words}\")\nprint(\"Index of 'cherry': {binary_search(sorted_words, \"cherry\")}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Linked List with ADTs",
    "code": "// Linked List using algebraic data types\ntype List {\n  Cons(head: Any, tail: Any),\n  Empty\n}\n\n// Constructor helper\nfn list_of(arr) {\n  var result = Empty\n  for i in range(len(arr) - 1, -1, -1) {\n    result = Cons(arr[i], result)\n  }\n  result\n}\n\n// Operations\nfn list_len(lst) {\n  match lst {\n    Empty => 0\n    Cons(_, tail) => 1 + list_len(tail)\n  }\n}\n\nfn list_map(lst, f) {\n  match lst {\n    Empty => Empty\n    Cons(h, t) => Cons(f(h), list_map(t, f))\n  }\n}\n\nfn list_to_array(lst) {\n  var result = []\n  var current = lst\n  while true {\n    match current {\n      Empty => return result\n      Cons(h, t) => {\n        result = [...result, h]\n        current = t\n      }\n    }\n  }\n  result\n}\n\n// Test it\nmy_list = list_of([1, 2, 3, 4, 5])\nprint(\"Length: {list_len(my_list)}\")\n\ndoubled = list_map(my_list, fn(x) x * 2)\nprint(\"Doubled: {list_to_array(doubled)}\")\n\nsquared = list_map(my_list, fn(x) x * x)\nprint(\"Squared: {list_to_array(squared)}\")\n"
  },
  {
    "category": "Algorithms",
    "name": "Game of Life",
    "code": "// Conway's Game of Life — one generation step\n\nfn make_grid(rows, cols) {\n  [[0 for c in range(cols)] for r in range(rows)]\n}\n\nfn count_neighbors(grid, r, c) {\n  rows = len(grid)\n  cols = len(grid[0])\n  var count = 0\n  for dr in [-1, 0, 1] {\n    for dc in [-1, 0, 1] {\n      if dr == 0 and dc == 0 { }\n      else {\n        nr = (r + dr + rows) % rows\n        nc = (c + dc + cols) % cols\n        count = count + grid[nr][nc]\n      }\n    }\n  }\n  count\n}\n\nfn step(grid) {\n  rows = len(grid)\n  cols = len(grid[0])\n  [\n    [\n      match [grid[r][c], count_neighbors(grid, r, c)] {\n        [1, n] if n < 2 => 0\n        [1, n] if n > 3 => 0\n        [1, _] => 1\n        [0, 3] => 3\n        _ => grid[r][c]\n      }\n    for c in range(cols)]\n  for r in range(rows)]\n}\n\nfn display(grid) {\n  for row in grid {\n    line = [match cell { 0 => \".\" _ => \"#\" } for cell in row]\n    print(line)\n  }\n}\n\n// Glider pattern\ngrid = make_grid(8, 8)\ngrid[1][2] = 1\ngrid[2][3] = 1\ngrid[3][1] = 1\ngrid[3][2] = 1\ngrid[3][3] = 1\n\nprint(\"Generation 0:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 1:\")\ndisplay(grid)\nprint(\"\")\n\ngrid = step(grid)\nprint(\"Generation 2:\")\ndisplay(grid)\n"
  }
];
const REFERENCE = [
  {
    "title": "Variables",
    "items": [
      {
        "syntax": "name = \"Alice\"",
        "desc": "Immutable binding"
      },
      {
        "syntax": "var count = 0",
        "desc": "Mutable binding"
      },
      {
        "syntax": "a, b = 1, 2",
        "desc": "Multiple assignment"
      },
      {
        "syntax": "x, y = y, x",
        "desc": "Swap values"
      }
    ]
  },
  {
    "title": "Types",
    "items": [
      {
        "syntax": "Int, Float, String, Bool, Nil",
        "desc": "Primitive types"
      },
      {
        "syntax": "type Point { x: Float, y: Float }",
        "desc": "Struct type"
      },
      {
        "syntax": "type Color { Red, Blue, Custom(r: Int) }",
        "desc": "Algebraic type (ADT)"
      }
    ]
  },
  {
    "title": "Functions",
    "items": [
      {
        "syntax": "fn add(a, b) { a + b }",
        "desc": "Function (implicit return)"
      },
      {
        "syntax": "fn greet(name = \"world\") { ... }",
        "desc": "Default parameters"
      },
      {
        "syntax": "double = fn(x) x * 2",
        "desc": "Lambda expression"
      },
      {
        "syntax": "return value",
        "desc": "Early return"
      }
    ]
  },
  {
    "title": "Control Flow",
    "items": [
      {
        "syntax": "if cond { } elif { } else { }",
        "desc": "Conditionals"
      },
      {
        "syntax": "for item in items { }",
        "desc": "For-in loop"
      },
      {
        "syntax": "for i in range(10) { }",
        "desc": "Range loop"
      },
      {
        "syntax": "while cond { }",
        "desc": "While loop"
      }
    ]
  },
  {
    "title": "Pattern Matching",
    "items": [
      {
        "syntax": "match value { 0 => \"zero\", _ => \"other\" }",
        "desc": "Value matching"
      },
      {
        "syntax": "1..10 => \"small\"",
        "desc": "Range pattern"
      },
      {
        "syntax": "n if n > 100 => \"big\"",
        "desc": "Guard clause"
      },
      {
        "syntax": "Circle(r) => 3.14 * r ** 2",
        "desc": "Destructure ADT"
      }
    ]
  },
  {
    "title": "Strings",
    "items": [
      {
        "syntax": "\"Hello, {name}!\"",
        "desc": "Interpolation"
      },
      {
        "syntax": ".upper() .lower() .trim()",
        "desc": "Case methods"
      },
      {
        "syntax": ".contains(s) .starts_with(s)",
        "desc": "Search methods"
      },
      {
        "syntax": ".words() .chars() .lines()",
        "desc": "Split methods"
      },
      {
        "syntax": ".capitalize() .title_case()",
        "desc": "Format methods"
      },
      {
        "syntax": "\"-\" * 20",
        "desc": "String repeat"
      }
    ]
  },
  {
    "title": "Collections",
    "items": [
      {
        "syntax": "[1, 2, 3]",
        "desc": "Array literal"
      },
      {
        "syntax": "{key: value}",
        "desc": "Object literal"
      },
      {
        "syntax": "[x*2 for x in items if x > 0]",
        "desc": "List comprehension"
      },
      {
        "syntax": "{k: v for k in keys}",
        "desc": "Dict comprehension"
      },
      {
        "syntax": "arr[1:3]  arr[::-1]",
        "desc": "Slice syntax"
      },
      {
        "syntax": "[...a, ...b]",
        "desc": "Spread operator"
      }
    ]
  },
  {
    "title": "Operators",
    "items": [
      {
        "syntax": "+ - * / % **",
        "desc": "Arithmetic (** is power)"
      },
      {
        "syntax": "== != < <= > >=",
        "desc": "Comparison"
      },
      {
        "syntax": "and  or  not",
        "desc": "Logical"
      },
      {
        "syntax": "|>",
        "desc": "Pipe operator"
      },
      {
        "syntax": "x in list / x not in list",
        "desc": "Membership"
      },
      {
        "syntax": "1 < x < 10",
        "desc": "Chained comparison"
      },
      {
        "syntax": "a?.b",
        "desc": "Optional chaining"
      }
    ]
  },
  {
    "title": "Stdlib Functions",
    "items": [
      {
        "syntax": "print(...args)",
        "desc": "Print to console"
      },
      {
        "syntax": "len(v)",
        "desc": "Length of string/array/object"
      },
      {
        "syntax": "range(start?, end, step?)",
        "desc": "Generate number array"
      },
      {
        "syntax": "sum(arr) min(arr) max(arr)",
        "desc": "Aggregation"
      },
      {
        "syntax": "sorted(arr, key?) reversed(arr)",
        "desc": "Ordering"
      },
      {
        "syntax": "enumerate(arr)",
        "desc": "Index-value pairs"
      },
      {
        "syntax": "zip(a, b, ...)",
        "desc": "Combine arrays"
      },
      {
        "syntax": "map(arr, fn) filter(arr, fn)",
        "desc": "Transform/filter"
      },
      {
        "syntax": "type_of(value)",
        "desc": "Runtime type name"
      }
    ]
  },
  {
    "title": "Reactive (client)",
    "items": [
      {
        "syntax": "state count = 0",
        "desc": "Reactive variable (signal)"
      },
      {
        "syntax": "computed doubled = count * 2",
        "desc": "Derived value"
      },
      {
        "syntax": "effect { ... }",
        "desc": "Side effect (auto-tracks deps)"
      },
      {
        "syntax": "component App { <div>...</div> }",
        "desc": "UI component"
      },
      {
        "syntax": "on:click={fn() ...}",
        "desc": "Event handler"
      },
      {
        "syntax": "server.method()",
        "desc": "RPC call to server"
      }
    ]
  },
  {
    "title": "Full-Stack Blocks",
    "items": [
      {
        "syntax": "server { ... }",
        "desc": "Server-side code (Bun)"
      },
      {
        "syntax": "client { ... }",
        "desc": "Client-side code (browser)"
      },
      {
        "syntax": "shared { ... }",
        "desc": "Shared code (both)"
      },
      {
        "syntax": "route GET \"/path\" => handler",
        "desc": "HTTP route"
      }
    ]
  }
];
const TUTORIAL = [
  {
    "title": "Welcome to Tova",
    "description": "Tova is a modern language that compiles to JavaScript. It combines Python's readability with ML-style pattern matching and built-in reactivity.",
    "code": "// Try running this! Press Cmd/Ctrl+Enter or click Run.\nprint(\"Welcome to Tova!\")\n\n// Variables are immutable by default\nname = \"Developer\"\nprint(\"Hello, {name}!\")\n\n// Use 'var' for mutable variables\nvar count = 0\ncount += 1\nprint(\"Count: {count}\")"
  },
  {
    "title": "Functions",
    "description": "Functions use the fn keyword and return their last expression. No \"return\" needed!",
    "code": "// Implicit return — the last expression is returned\nfn add(a, b) {\n  a + b\n}\n\n// Default parameters\nfn greet(name = \"World\") {\n  \"Hello, {name}!\"\n}\n\nprint(add(3, 4))\nprint(greet())\nprint(greet(\"Tova\"))\n\n// Lambdas for short functions\ndouble = fn(x) x * 2\nprint(double(21))"
  },
  {
    "title": "Collections",
    "description": "Tova has powerful collection features: list comprehensions, slicing, and the pipe operator.",
    "code": "// List comprehension\nsquares = [x * x for x in range(1, 11)]\nprint(\"Squares: {squares}\")\n\n// Filter with comprehension\nevens = [x for x in range(1, 21) if x % 2 == 0]\nprint(\"Evens: {evens}\")\n\n// Pipe operator for readable chains\nresult = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\nprint(\"Sum of squares of evens: {result}\")\n\n// Slicing\narr = [10, 20, 30, 40, 50]\nprint(\"First 3: {arr[:3]}\")\nprint(\"Last 2: {arr[3:]}\")"
  },
  {
    "title": "Pattern Matching",
    "description": "Match expressions are like switch on steroids. They support values, ranges, guards, and destructuring.",
    "code": "// Match on values and ranges\nfn classify(n) {\n  match n {\n    0 => \"zero\"\n    1..10 => \"small\"\n    n if n > 100 => \"huge: {n}\"\n    _ => \"medium: {n}\"\n  }\n}\n\nfor n in [0, 3, 50, 200] {\n  print(\"{n} -> {classify(n)}\")\n}\n\n// Match on algebraic types\ntype Shape {\n  Circle(r: Float),\n  Rect(w: Float, h: Float)\n}\n\nfn area(s) {\n  match s {\n    Circle(r) => 3.14159 * r ** 2\n    Rect(w, h) => w * h\n  }\n}\n\nprint(\"Circle area: {area(Circle(5.0))}\")\nprint(\"Rect area: {area(Rect(3.0, 4.0))}\")"
  },
  {
    "title": "Types & ADTs",
    "description": "Define struct-like types and algebraic data types (tagged unions) for type-safe data modeling.",
    "code": "// Struct type\ntype User {\n  name: String\n  age: Int\n}\n\n// Algebraic type (sum type)\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn validate_age(age) {\n  if age >= 0 and age <= 150 {\n    Ok(User(\"Valid\", age))\n  } else {\n    Err(\"Age must be 0-150, got {age}\")\n  }\n}\n\nfor age in [25, -5, 200, 42] {\n  result = validate_age(age)\n  match result {\n    Ok(user) => print(\"Valid: age {user.age}\")\n    Err(msg) => print(\"Error: {msg}\")\n  }\n}"
  },
  {
    "title": "Reactive UI",
    "description": "Tova has built-in reactivity for building UIs. State changes automatically update the DOM!",
    "code": "// Switch to the \"Preview\" tab to see this in action!\nclient {\n  state count = 0\n  computed doubled = count * 2\n  computed emoji = match count {\n    0 => \"Start clicking!\"\n    c if c < 5 => \"Getting started...\"\n    c if c < 10 => \"Nice!\"\n    _ => \"On fire!\"\n  }\n\n  component App {\n    <div style=\"text-align: center; padding: 20px;\">\n      <h1>\"Tova Reactive Demo\"</h1>\n      <p style=\"font-size: 48px;\">\"{count}\"</p>\n      <p>\"Doubled: {doubled}\"</p>\n      <p>\"{emoji}\"</p>\n      <button on:click={fn() count += 1}>\"+ Add\"</button>\n      <button on:click={fn() count -= 1}>\"- Sub\"</button>\n      <button on:click={fn() count = 0}>\"Reset\"</button>\n    </div>\n  }\n}"
  },
  {
    "title": "Strings & Interpolation",
    "description": "Tova strings support interpolation with {expressions}, plus Python-style methods like .upper(), .contains(), and even string repetition.",
    "code": "// String interpolation with any expression\nname = \"World\"\nprint(\"Hello, {name}!\")\n\n// Expressions inside interpolation\nx = 7\nprint(\"{x} squared is {x * x}\")\n\n// String methods\ngreeting = \"hello world\"\nprint(greeting.upper())\nprint(greeting.capitalize())\nprint(greeting.title_case())\n\n// Useful checks\nprint(\"contains 'world': {greeting.contains(\"world\")}\")\nprint(\"starts with 'hello': {greeting.starts_with(\"hello\")}\")\n\n// String repetition\nborder = \"=\" * 30\nprint(border)\nprint(\"  Tova is great!\")\nprint(border)"
  },
  {
    "title": "Pipe Operator",
    "description": "The pipe operator |> chains function calls, making data transformations read top-to-bottom instead of inside-out.",
    "code": "// Without pipe (nested, hard to read):\n// sum(map(filter(numbers, fn(x) x % 2 == 0), fn(x) x * x))\n\n// With pipe (reads top to bottom):\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nresult = numbers\n  |> filter(fn(x) x % 2 == 0)\n  |> map(fn(x) x * x)\n  |> sum()\n\nprint(\"Sum of squares of evens: {result}\")\n\n// Name pipeline\nnames = [\"Charlie\", \"Alice\", \"Bob\", \"Diana\"]\nsorted_long = names\n  |> filter(fn(n) len(n) > 3)\n  |> sorted()\nprint(\"Long names sorted: {sorted_long}\")\n\n// Simple value pipeline\n42 |> fn(x) x * 2 |> fn(x) \"Answer: {x}\" |> print()"
  },
  {
    "title": "Full-Stack App",
    "description": "Tova has built-in full-stack blocks: server, client, and shared. In the playground, server features are simulated.",
    "code": "// A full-stack app has server + client blocks.\n// In playground mode, server calls are stubbed.\n\nclient {\n  state name = \"World\"\n  computed greeting = \"Hello, {name}!\"\n\n  component App {\n    <div style=\"padding: 20px;\">\n      <h1>\"Full-Stack Demo\"</h1>\n      <div class=\"input-group\">\n        <label>\"Your name:\"</label>\n        <input type=\"text\" value={name}\n               on:input={fn(e) name = e.target.value} />\n      </div>\n      <p style=\"font-size: 24px; margin-top: 16px;\">\"{greeting}\"</p>\n      <p class=\"hint\">\"(Type to see reactive updates!)\"</p>\n    </div>\n  }\n}"
  },
  {
    "title": "Advanced Patterns",
    "description": "Combine pattern matching with algebraic types, guards, and destructuring for expressive code.",
    "code": "// Result type with pattern matching\ntype Result {\n  Ok(value: Any),\n  Err(message: String)\n}\n\nfn parse_number(s) {\n  n = s * 1  // coerce to number\n  if n != n { Err(\"Not a number: {s}\") }\n  else { Ok(n) }\n}\n\nfn safe_divide(a, b) {\n  if b == 0 { Err(\"Division by zero\") }\n  else { Ok(a / b) }\n}\n\n// Chain operations with match\ninputs = [[\"10\", \"2\"], [\"42\", \"0\"], [\"abc\", \"5\"], [\"100\", \"4\"]]\nfor pair in inputs {\n  result = match parse_number(pair[0]) {\n    Err(msg) => Err(msg)\n    Ok(a) => match parse_number(pair[1]) {\n      Err(msg) => Err(msg)\n      Ok(b) => safe_divide(a, b)\n    }\n  }\n  match result {\n    Ok(v) => print(\"{pair[0]} / {pair[1]} = {v}\")\n    Err(msg) => print(\"{pair[0]} / {pair[1]} -> Error: {msg}\")\n  }\n}"
  }
];

// ─── State ──────────────────────────────────────────
let autoCompile = true;
let autoRun = true;
let sidebarMode = null; // 'reference' | 'tutorial' | null
let tutorialStep = 0;
let compileTimer = null;

// ─── Early embed mode detection ─────────────────────
const __isEmbed = new URLSearchParams(location.search).get('embed') === 'true';

// ─── Restore settings from localStorage ─────────────
try {
  const saved = JSON.parse(localStorage.getItem('tova-playground-settings') || '{}');
  if (saved.fontSize) document.documentElement.style.setProperty('--editor-font-size', saved.fontSize + 'px');
  if (saved.fontSize) document.getElementById('setting-fontsize').value = saved.fontSize;
  if (saved.autoCompile === false) { autoCompile = false; document.getElementById('setting-autocompile').classList.remove('on'); }
  if (saved.autoRun === false) { autoRun = false; document.getElementById('setting-autorun').classList.remove('on'); }
} catch(e) {}

function saveSettings() {
  try {
    localStorage.setItem('tova-playground-settings', JSON.stringify({
      fontSize: parseInt(document.getElementById('setting-fontsize').value),
      autoCompile,
      autoRun
    }));
  } catch(e) {}
}

// ─── Editor Setup ───────────────────────────────────
const statusCursor = document.getElementById('status-cursor');

// Restore last code or use first example (skip localStorage in embed mode)
let initialCode = EXAMPLES[0].code;
if (!__isEmbed) {
  try {
    const lastCode = localStorage.getItem('tova-playground-code');
    if (lastCode && lastCode.trim()) initialCode = lastCode;
  } catch(e) {}
}

const editor = new EditorView({
  state: EditorState.create({
    doc: initialCode,
    extensions: [
      basicSetup,
      oneDark,
      tovaLanguage,
      errorField,
      autocompletion({
        override: [tovaCompletions],
        icons: true,
        activateOnTyping: true,
      }),
      EditorView.updateListener.of(update => {
        if (update.docChanged) {
          try { localStorage.setItem('tova-playground-code', update.state.doc.toString()); } catch(e) {}
          if (autoCompile) scheduleCompile();
        }
        if (update.selectionSet) {
          const pos = update.state.selection.main.head;
          const line = update.state.doc.lineAt(pos);
          const lines = update.state.doc.lines;
          const chars = update.state.doc.length;
          statusCursor.textContent = 'Ln ' + line.number + ', Col ' + (pos - line.from + 1) + '  |  ' + lines + ' lines, ' + chars + ' chars';
        }
      }),
      keymap.of([
        { key: 'Mod-Enter', run: () => { compile(); return true; } },
        { key: 'Mod-k', run: () => { toggleCommandPalette(); return true; } },
        { key: 'Mod-s', run: () => {
          try { localStorage.setItem('tova-playground-code', editor.state.doc.toString()); } catch(e) {}
          const s = document.getElementById('status-compile');
          s.className = 'success'; s.textContent = 'Saved to browser';
          setTimeout(() => compile(), 1000);
          return true;
        }},
        { key: 'Mod-Shift-r', run: () => { toggleSidebar('reference'); return true; } },
        { key: 'Mod-Shift-s', run: () => { downloadCode(); return true; } },
        { key: 'Mod-/', run: () => { toggleModal('shortcuts-modal'); return true; } },
        { key: 'Mod-j', run: () => { toggleLayout(); return true; } },
      ]),
    ],
  }),
  parent: document.getElementById('editor'),
});

// ─── Populate Examples (with optgroups) ─────────────
const exSelect = document.getElementById('examples-select');
let optgroup = null;
let currentCat = null;
EXAMPLES.forEach((ex, i) => {
  if (ex.category !== currentCat) {
    currentCat = ex.category;
    optgroup = document.createElement('optgroup');
    optgroup.label = currentCat;
    exSelect.appendChild(optgroup);
  }
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = ex.name;
  optgroup.appendChild(opt);
});
exSelect.addEventListener('change', () => {
  const code = EXAMPLES[+exSelect.value].code;
  setEditorCode(code);
  exSelect.value = '';
});

function setEditorCode(code) {
  editor.dispatch({ changes: { from: 0, to: editor.state.doc.length, insert: code } });
  compile();
}

// ─── Output Tabs ────────────────────────────────────
function switchTab(tabName) {
  document.querySelectorAll('#output-tabs .tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.output-panel').forEach(p => p.classList.remove('active'));
  const tab = document.querySelector('#output-tabs .tab[data-tab="' + tabName + '"]');
  if (tab) tab.classList.add('active');
  const panel = document.getElementById('panel-' + tabName);
  if (panel) panel.classList.add('active');
}

document.querySelectorAll('#output-tabs .tab').forEach(tab => {
  tab.addEventListener('click', () => switchTab(tab.dataset.tab));
});

// ─── Drag Handle ────────────────────────────────────
const dragHandle = document.getElementById('drag-handle');
const mainEl = document.querySelector('.main');
const editorPane = document.querySelector('.pane-editor');
const outputPane = document.querySelector('.pane-output');

let dragging = false;
dragHandle.addEventListener('mousedown', e => { dragging = true; dragHandle.classList.add('active'); e.preventDefault(); });
document.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = mainEl.getBoundingClientRect();
  const sidebarW = sidebarMode ? parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w')) : 0;
  const availW = rect.width - sidebarW;
  const pct = ((e.clientX - rect.left) / availW) * 100;
  const clamped = Math.max(20, Math.min(80, pct));
  editorPane.style.flex = 'none';
  editorPane.style.width = clamped + '%';
  outputPane.style.flex = '1';
});
document.addEventListener('mouseup', () => { dragging = false; dragHandle.classList.remove('active'); });

// ─── Share ──────────────────────────────────────────
document.getElementById('btn-share').addEventListener('click', () => {
  const code = editor.state.doc.toString();
  const compressed = LZString.compressToEncodedURIComponent(code);
  const url = location.origin + location.pathname + '#code=' + compressed;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('btn-share');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Share'; }, 2000);
  });
});

// ─── Download ───────────────────────────────────────
function downloadCode() {
  const code = editor.state.doc.toString();
  const blob = new Blob([code], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'playground.tova';
  a.click();
  URL.revokeObjectURL(a.href);
}
document.getElementById('btn-download').addEventListener('click', downloadCode);

// ─── Load from URL hash ─────────────────────────────
function loadFromHash() {
  const hash = location.hash.slice(1);
  if (hash.startsWith('code=')) {
    try {
      const code = LZString.decompressFromEncodedURIComponent(hash.slice(5));
      if (code) { setEditorCode(code); return true; }
    } catch (e) {}
  }
  return false;
}
loadFromHash();

// ─── Run Button ─────────────────────────────────────
document.getElementById('btn-run').addEventListener('click', compile);

// ─── Debounced Compile ──────────────────────────────
function scheduleCompile() {
  clearTimeout(compileTimer);
  compileTimer = setTimeout(compile, 350);
}

// ─── Compiler ───────────────────────────────────────
let lastJsText = '';

function compile() {
  const source = editor.state.doc.toString();
  const statusEl = document.getElementById('status-compile');
  const statusSize = document.getElementById('status-size');
  const errorBanner = document.getElementById('error-banner');
  const errorText = document.getElementById('error-text');
  const errorHint = document.getElementById('error-hint');
  const consoleOutput = document.getElementById('console-output');
  const consoleBadge = document.getElementById('console-badge');
  const consoleTimingEl = document.getElementById('console-timing');
  const astOutput = document.getElementById('ast-output');
  const previewFrame = document.getElementById('preview-frame');

  errorBanner.classList.remove('visible');
  errorText.textContent = '';
  if (errorHint) errorHint.textContent = '';
  consoleOutput.innerHTML = '';
  consoleBadge.style.display = 'none';

  // Clear error decorations
  editor.dispatch({ effects: clearErrorEffect.of(null) });

  const start = performance.now();

  try {
    const lexer = new Lexer(source, 'playground.tova');
    const tokens = lexer.tokenize();

    const parser = new Parser(tokens, 'playground.tova');
    const ast = parser.parse();

    const analyzer = new Analyzer(ast, 'playground.tova');
    const { warnings } = analyzer.analyze();

    const codegen = new CodeGenerator(ast, 'playground.tova');
    const result = codegen.generate();

    const elapsed = (performance.now() - start).toFixed(1);

    // JS Output
    let jsText = '';
    if (result.shared) jsText += '// ── Shared ──\n' + result.shared + '\n\n';
    if (result.server) jsText += '// ── Server ──\n' + result.server + '\n\n';
    if (result.client) jsText += '// ── Client ──\n' + result.client + '\n\n';
    if (!result.shared && !result.server && !result.client && result.code) {
      jsText = result.code;
    }
    lastJsText = jsText || '// No output';

    // Update JS output (use CodeMirror read-only editor if available, else pre tag)
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: lastJsText } });
    } else {
      document.getElementById('js-output').textContent = lastJsText;
    }

    // Status bar output size
    if (statusSize) statusSize.textContent = (lastJsText.length / 1024).toFixed(1) + ' KB output';

    // AST
    astOutput.innerHTML = '';
    astOutput.appendChild(renderAST(ast));

    // Console + Preview
    if (autoRun) {
      executeCode(result, consoleOutput, previewFrame, consoleBadge, consoleTimingEl);
    }

    // Warnings
    const warnCount = warnings ? warnings.length : 0;
    if (warnCount) {
      for (const w of warnings) {
        const div = document.createElement('div');
        div.className = 'log-warn';
        div.innerHTML = '<span class="log-icon">\u26A0</span> Warning: ' + escapeHtml(w.message || String(w));
        consoleOutput.appendChild(div);
      }
    }

    statusEl.className = 'success';
    statusEl.textContent = '\u2713 Compiled in ' + elapsed + 'ms' + (warnCount ? ' (' + warnCount + ' warning' + (warnCount > 1 ? 's' : '') + ')' : '');

  } catch (err) {
    const elapsed = (performance.now() - start).toFixed(1);
    statusEl.className = 'error';
    statusEl.textContent = '\u2717 Error (' + elapsed + 'ms)';
    errorText.textContent = err.message;

    // Error hints for common mistakes
    const hints = getErrorHint(err.message);
    if (errorHint && hints) errorHint.textContent = hints;

    errorBanner.classList.add('visible');
    if (window.jsEditor) {
      window.jsEditor.dispatch({ changes: { from: 0, to: window.jsEditor.state.doc.length, insert: '// Compilation error\n// ' + err.message } });
    } else {
      document.getElementById('js-output').textContent = '// Compilation error\n// ' + err.message;
    }
    previewFrame.srcdoc = '';

    // Highlight error line in editor with decorations
    const lineMatch = err.message.match(/:(\d+):/);
    if (lineMatch) {
      const lineNum = parseInt(lineMatch[1]);
      editor.dispatch({ effects: setErrorEffect.of([lineNum]) });
      // Scroll to error line
      try {
        const lineInfo = editor.state.doc.line(lineNum);
        editor.dispatch({ selection: { anchor: lineInfo.from } });
      } catch(e) {}
    }
  }
}

function getErrorHint(msg) {
  if (msg.includes('Unexpected token')) return 'Tip: Check for missing closing brackets or semicolons';
  if (msg.includes('not defined')) return 'Tip: Make sure the variable is declared before use';
  if (msg.includes('Expected')) return 'Tip: The compiler expected a different token here';
  return null;
}

// ─── Execute Code ───────────────────────────────────
function executeCode(result, consoleEl, previewFrame, consoleBadge, consoleTimingEl) {
  const logs = [];
  const fakeConsole = {
    log: (...args) => logs.push({ type: 'log', args }),
    warn: (...args) => logs.push({ type: 'warn', args }),
    error: (...args) => logs.push({ type: 'error', args }),
    info: (...args) => logs.push({ type: 'info', args }),
  };

  const execStart = performance.now();
  const codeToRun = result.code || result.shared || '';
  if (codeToRun.trim()) {
    try {
      const fn = new Function('console', STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n' + codeToRun);
      fn(fakeConsole);
    } catch (e) {
      logs.push({ type: 'error', args: ['Runtime Error: ' + e.message] });
    }
  }
  const execTime = (performance.now() - execStart).toFixed(2);

  if (consoleTimingEl) consoleTimingEl.textContent = 'Executed in ' + execTime + 'ms';

  // Render logs with icons and better formatting
  const icons = { log: '\u203A', warn: '\u26A0', error: '\u2717', info: '\u2139' };
  let errorCount = 0;
  for (const log of logs) {
    const div = document.createElement('div');
    div.className = 'log-' + log.type;
    const icon = document.createElement('span');
    icon.className = 'log-icon';
    icon.textContent = icons[log.type] || '';
    div.appendChild(icon);
    const content = document.createElement('span');
    content.className = 'log-content';
    const textParts = log.args.map(a => {
      if (a === null) return 'null';
      if (a === undefined) return 'undefined';
      if (typeof a === 'object') {
        try { return JSON.stringify(a, null, 2); } catch(e) { return String(a); }
      }
      return String(a);
    });
    content.textContent = textParts.join(' ');
    div.appendChild(content);
    consoleEl.appendChild(div);
    if (log.type === 'error') errorCount++;
  }

  // Badge for errors
  if (errorCount > 0) {
    consoleBadge.textContent = errorCount;
    consoleBadge.style.display = 'inline';
    switchTab('console');
  }

  // Auto-switch to console if there are logs and no client code
  if (logs.length > 0 && !result.client) {
    switchTab('console');
  }

  // Live Preview for client code
  if (result.client) {
    const clientCode = result.client
      .replace(/import\s+.*from\s+['"].*['"];?/g, '')
      .replace(/import\s+['"].*['"];?/g, '');

    const previewCSS = '*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }' +
      'body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding: 20px; color: #333; }' +
      'button { cursor: pointer; padding: 8px 16px; margin: 4px; border-radius: 6px; border: 1px solid #ddd; background: #f5f5f5; font-size: 14px; transition: all 0.15s; }' +
      'button:hover { background: #e8e8e8; border-color: #ccc; }' +
      'button:active { transform: scale(0.97); }' +
      'input[type="text"], input[type="number"] { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; margin: 4px; font-size: 14px; outline: none; }' +
      'input[type="text"]:focus, input[type="number"]:focus { border-color: #7c3aed; box-shadow: 0 0 0 3px rgba(124,58,237,0.1); }' +
      'input[type="range"] { width: 200px; margin: 8px 0; }' +
      'input[type="checkbox"] { margin: 4px 8px 4px 0; }' +
      'ul { list-style: none; } li { padding: 6px 0; }' +
      'h1 { margin-bottom: 16px; font-size: 24px; } h2 { margin-bottom: 12px; font-size: 20px; }' +
      'p { margin: 6px 0; line-height: 1.5; }' +
      '.status { color: #666; font-size: 14px; margin-top: 12px; }' +
      '.counter-app, .todo-app, .converter, .stopwatch { max-width: 400px; }' +
      '.count { font-size: 48px; font-weight: 700; color: #7c3aed; }' +
      '.buttons { display: flex; gap: 4px; margin-top: 8px; }' +
      '.input-row { display: flex; gap: 4px; margin-bottom: 12px; }' +
      '.input-row input { flex: 1; }' +
      '.todo-item { display: flex; align-items: center; gap: 8px; }' +
      '.todo-text { flex: 1; }' +
      '.input-group { margin: 12px 0; }' +
      '.input-group label { display: block; font-weight: 600; margin-bottom: 4px; }' +
      '.value { font-size: 18px; font-weight: 600; color: #7c3aed; margin-left: 8px; }' +
      '.desc { font-style: italic; color: #666; }' +
      '.time { font-size: 48px; font-weight: 700; color: #7c3aed; margin: 16px 0; }' +
      '.controls { display: flex; gap: 4px; flex-wrap: wrap; }' +
      '.hint { color: #999; font-size: 12px; margin-top: 12px; }';

    const sharedCode = (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');

    // Build preview HTML using string concatenation — NOT a template literal.
    // Generated client code may contain backticks (JS template strings from
    // string interpolation) which would break a template-literal wrapper.
    const previewHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8">\n<style>' + previewCSS + '</style>\n</head><body>\n' +
      '<div id="app"></div>\n<script>\n' +
      RUNTIME_CODE + '\n' +
      STDLIB_CODE + '\n' +
      STRING_PROTO_CODE + '\n' +
      'function rpc(name, args) { console.warn("[Playground] server." + name + "() is not available in playground mode"); return Promise.resolve(null); }\n' +
      sharedCode + '\n' +
      clientCode + '\n' +
      'if (typeof App === "function") {' +
      '  if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", function() { mount(App, document.getElementById("app")); }); }' +
      '  else { mount(App, document.getElementById("app")); }' +
      '}\n' +
      '<\/script>\n</body></html>';
    previewFrame.srcdoc = previewHTML;
    // Auto-switch to preview when there's a client block
    switchTab('preview');
  } else {
    previewFrame.srcdoc = '<html><body style="font-family:sans-serif;padding:20px;color:#aaa"><p>Write a <code>client { }</code> block with a <code>component App</code> to see a live preview here.</p></body></html>';
  }
}

// ─── AST Renderer ───────────────────────────────────
function renderAST(node, depth = 0) {
  if (node === null || node === undefined) {
    const span = document.createElement('span');
    span.className = 'ast-null'; span.textContent = 'null'; return span;
  }
  if (typeof node !== 'object') {
    const span = document.createElement('span');
    if (typeof node === 'string') { span.className = 'ast-string'; span.textContent = '"' + node + '"'; }
    else if (typeof node === 'number') { span.className = 'ast-number'; span.textContent = String(node); }
    else if (typeof node === 'boolean') { span.className = 'ast-bool'; span.textContent = String(node); }
    else { span.textContent = String(node); }
    return span;
  }
  if (Array.isArray(node)) {
    if (node.length === 0) { const s = document.createElement('span'); s.className = 'ast-null'; s.textContent = '[]'; return s; }
    const c = document.createElement('div'); c.className = 'ast-node';
    const t = document.createElement('span'); t.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
    t.textContent = 'Array[' + node.length + ']';
    const ch = document.createElement('div'); ch.className = 'ast-children' + (depth < 2 ? ' open' : '');
    t.addEventListener('click', () => { t.classList.toggle('open'); ch.classList.toggle('open'); });
    for (let i = 0; i < node.length; i++) {
      const r = document.createElement('div'); r.className = 'ast-node';
      const k = document.createElement('span'); k.className = 'ast-key'; k.textContent = i + ': ';
      r.appendChild(k); r.appendChild(renderAST(node[i], depth + 1)); ch.appendChild(r);
    }
    c.appendChild(t); c.appendChild(ch); return c;
  }
  const container = document.createElement('div'); container.className = 'ast-node';
  const typeName = node.constructor?.name || 'Object';
  const keys = Object.keys(node).filter(k => k !== 'line' && k !== 'column');
  if (keys.length === 0) { const s = document.createElement('span'); s.className = 'ast-type'; s.textContent = typeName; container.appendChild(s); return container; }
  const toggle = document.createElement('span'); toggle.className = 'ast-toggle' + (depth < 2 ? ' open' : '');
  const typeSpan = document.createElement('span'); typeSpan.className = 'ast-type'; typeSpan.textContent = typeName;
  toggle.appendChild(typeSpan);
  const children = document.createElement('div'); children.className = 'ast-children' + (depth < 2 ? ' open' : '');
  toggle.addEventListener('click', () => { toggle.classList.toggle('open'); children.classList.toggle('open'); });
  for (const key of keys) {
    const row = document.createElement('div'); row.className = 'ast-node';
    const keySpan = document.createElement('span'); keySpan.className = 'ast-key'; keySpan.textContent = key + ': ';
    row.appendChild(keySpan); row.appendChild(renderAST(node[key], depth + 1)); children.appendChild(row);
  }
  container.appendChild(toggle); container.appendChild(children);
  return container;
}

// ─── Sidebar (Reference / Tutorial) ─────────────────
const sidebar = document.getElementById('sidebar');
const sidebarBody = document.getElementById('sidebar-body');
const sidebarTitle = document.getElementById('sidebar-title');
const tutorialNav = document.getElementById('tutorial-nav');

function toggleSidebar(mode) {
  if (sidebarMode === mode) {
    sidebar.classList.remove('open');
    sidebarMode = null;
    document.getElementById('btn-reference').classList.remove('active');
    document.getElementById('btn-tutorial').classList.remove('active');
    return;
  }
  sidebarMode = mode;
  sidebar.classList.add('open');

  document.getElementById('btn-reference').classList.toggle('active', mode === 'reference');
  document.getElementById('btn-tutorial').classList.toggle('active', mode === 'tutorial');

  if (mode === 'reference') {
    sidebarTitle.textContent = 'Tova Reference';
    tutorialNav.style.display = 'none';
    renderReference();
  } else if (mode === 'tutorial') {
    sidebarTitle.textContent = 'Learn Tova';
    tutorialNav.style.display = 'flex';
    renderTutorialStep();
  }
}

function renderTutorialStep() {
  sidebarBody.innerHTML = '';
  const step = TUTORIAL[tutorialStep];
  if (!step) return;

  // Progress dots
  const progress = document.createElement('div');
  progress.className = 'tutorial-progress';
  for (let i = 0; i < TUTORIAL.length; i++) {
    const dot = document.createElement('div');
    dot.className = 'tutorial-dot' + (i === tutorialStep ? ' active' : '') + (i < tutorialStep ? ' completed' : '');
    dot.addEventListener('click', () => { tutorialStep = i; renderTutorialStep(); });
    progress.appendChild(dot);
  }
  sidebarBody.appendChild(progress);

  const div = document.createElement('div');
  div.className = 'tutorial-step';
  div.innerHTML = '<h4>' + (tutorialStep + 1) + '. ' + escapeHtml(step.title) + '</h4>'
    + '<p>' + escapeHtml(step.description) + '</p>';
  const tryBtn = document.createElement('button');
  tryBtn.className = 'try-btn';
  tryBtn.textContent = '\u25B6 Try this code';
  tryBtn.addEventListener('click', () => { setEditorCode(step.code); });
  div.appendChild(tryBtn);
  sidebarBody.appendChild(div);

  // Update nav buttons
  document.getElementById('tut-prev').disabled = tutorialStep === 0;
  document.getElementById('tut-next').textContent = tutorialStep === TUTORIAL.length - 1 ? 'Finish \u2713' : 'Next \u2192';
}

document.getElementById('btn-reference').addEventListener('click', () => toggleSidebar('reference'));
document.getElementById('btn-tutorial').addEventListener('click', () => toggleSidebar('tutorial'));
document.getElementById('sidebar-close').addEventListener('click', () => toggleSidebar(sidebarMode));

document.getElementById('tut-prev').addEventListener('click', () => {
  if (tutorialStep > 0) { tutorialStep--; renderTutorialStep(); }
});
document.getElementById('tut-next').addEventListener('click', () => {
  if (tutorialStep < TUTORIAL.length - 1) { tutorialStep++; renderTutorialStep(); }
  else { toggleSidebar('tutorial'); }
});

// ─── Settings ───────────────────────────────────────
document.getElementById('btn-settings').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('settings-dropdown').classList.toggle('visible');
});
document.addEventListener('click', (e) => {
  if (!e.target.closest('#settings-dropdown') && !e.target.closest('#btn-settings')) {
    document.getElementById('settings-dropdown').classList.remove('visible');
  }
});
document.getElementById('setting-fontsize').addEventListener('change', (e) => {
  document.documentElement.style.setProperty('--editor-font-size', e.target.value + 'px');
  saveSettings();
});
document.getElementById('setting-autocompile').addEventListener('click', function() {
  autoCompile = !autoCompile;
  this.classList.toggle('on', autoCompile);
  saveSettings();
});
document.getElementById('setting-autorun').addEventListener('click', function() {
  autoRun = !autoRun;
  this.classList.toggle('on', autoRun);
  saveSettings();
});

// ─── Keyboard Shortcuts Modal ───────────────────────
function toggleModal(id) {
  document.getElementById(id).classList.toggle('visible');
}
document.getElementById('btn-shortcuts').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-close').addEventListener('click', () => toggleModal('shortcuts-modal'));
document.getElementById('shortcuts-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) toggleModal('shortcuts-modal');
});

// ─── Error banner click → jump to error line ────────
document.getElementById('error-banner').addEventListener('click', () => {
  const text = document.getElementById('error-text').textContent;
  const lineMatch = text.match(/:(\d+):/);
  if (lineMatch) {
    const line = parseInt(lineMatch[1]);
    try {
      const lineInfo = editor.state.doc.line(line);
      editor.dispatch({ selection: { anchor: lineInfo.from } });
      editor.focus();
    } catch(e) {}
  }
});

// ─── JS Output Editor (read-only CodeMirror) ────────
try {
  const jsEditorParent = document.getElementById('js-output-editor');
  if (jsEditorParent) {
    window.jsEditor = new EditorView({
      state: EditorState.create({
        doc: '// Compiled JS output will appear here',
        extensions: [
          basicSetup,
          oneDark,
          EditorState.readOnly.of(true),
          EditorView.editable.of(false),
        ],
      }),
      parent: jsEditorParent,
    });
  }
} catch(e) { console.warn('JS output editor init failed:', e); }

// ─── Console Buttons ────────────────────────────────
document.getElementById('btn-clear-console').addEventListener('click', () => {
  document.getElementById('console-output').innerHTML = '';
  document.getElementById('console-timing').textContent = '';
  const badge = document.getElementById('console-badge');
  badge.style.display = 'none';
});

document.getElementById('btn-copy-console').addEventListener('click', () => {
  const text = document.getElementById('console-output').innerText;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btn-copy-console');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
});

// ─── Command Palette ────────────────────────────────
let cmdPaletteOpen = false;
let cmdSelectedIndex = 0;

function getCommandItems(query) {
  const q = query.toLowerCase();
  const items = [];

  // Actions
  const actions = [
    { icon: '\u25B6', label: 'Run Code', category: 'Action', shortcut: '\u2318Enter', action: () => compile() },
    { icon: '\u2197', label: 'Share URL', category: 'Action', action: () => document.getElementById('btn-share').click() },
    { icon: '\u2913', label: 'Download .tova', category: 'Action', shortcut: '\u2318\u21E7S', action: () => downloadCode() },
    { icon: '\uD83D\uDCE4', label: 'Export as HTML', category: 'Action', action: () => exportAsHTML() },
    { icon: '\uD83D\uDCD6', label: 'Toggle Reference', category: 'Action', shortcut: '\u2318\u21E7R', action: () => toggleSidebar('reference') },
    { icon: '\uD83C\uDF93', label: 'Start Tutorial', category: 'Action', action: () => toggleSidebar('tutorial') },
    { icon: '\u2699', label: 'Toggle Light Theme', category: 'Action', action: () => document.getElementById('setting-theme').click() },
    { icon: '\u2B12', label: 'Toggle Layout', category: 'Action', shortcut: '\u2318J', action: () => toggleLayout() },
  ];

  for (const a of actions) {
    if (!q || a.label.toLowerCase().includes(q)) items.push(a);
  }

  // Examples
  for (let i = 0; i < EXAMPLES.length; i++) {
    const ex = EXAMPLES[i];
    if (!q || ex.name.toLowerCase().includes(q) || ex.category.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDCC4',
        label: ex.name,
        category: ex.category,
        action: () => { setEditorCode(ex.code); }
      });
    }
  }

  // Reference sections
  for (const section of REFERENCE) {
    if (!q || section.title.toLowerCase().includes(q)) {
      items.push({
        icon: '\uD83D\uDD0D',
        label: section.title,
        category: 'Reference',
        action: () => { toggleSidebar('reference'); }
      });
    }
  }

  return items;
}

function renderCommandPalette(query) {
  const results = document.getElementById('cmd-results');
  const items = getCommandItems(query || '');
  results.innerHTML = '';
  cmdSelectedIndex = 0;

  if (items.length === 0) {
    results.innerHTML = '<div class="cmd-palette-empty">No results found</div>';
    return;
  }

  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'cmd-palette-item' + (i === 0 ? ' selected' : '');
    div.innerHTML = '<span class="cmd-icon">' + item.icon + '</span>'
      + '<span class="cmd-label">' + escapeHtml(item.label) + '</span>'
      + '<span class="cmd-category">' + escapeHtml(item.category) + '</span>'
      + (item.shortcut ? '<span class="cmd-shortcut">' + item.shortcut + '</span>' : '');
    div.addEventListener('click', () => { item.action(); closeCommandPalette(); });
    div.addEventListener('mouseenter', () => {
      results.querySelectorAll('.cmd-palette-item').forEach(el => el.classList.remove('selected'));
      div.classList.add('selected');
      cmdSelectedIndex = i;
    });
    results.appendChild(div);
  });

  window._cmdItems = items;
}

function toggleCommandPalette() {
  if (cmdPaletteOpen) { closeCommandPalette(); return; }
  cmdPaletteOpen = true;
  document.getElementById('cmd-palette').classList.add('visible');
  const input = document.getElementById('cmd-input');
  input.value = '';
  renderCommandPalette('');
  input.focus();
}

function closeCommandPalette() {
  cmdPaletteOpen = false;
  document.getElementById('cmd-palette').classList.remove('visible');
  editor.focus();
}

document.getElementById('cmd-input').addEventListener('input', (e) => {
  renderCommandPalette(e.target.value);
});

document.getElementById('cmd-input').addEventListener('keydown', (e) => {
  const results = document.getElementById('cmd-results');
  const items = results.querySelectorAll('.cmd-palette-item');
  if (e.key === 'Escape') { closeCommandPalette(); e.preventDefault(); return; }
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    cmdSelectedIndex = Math.min(cmdSelectedIndex + 1, items.length - 1);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    cmdSelectedIndex = Math.max(cmdSelectedIndex - 1, 0);
    items.forEach((el, i) => el.classList.toggle('selected', i === cmdSelectedIndex));
    items[cmdSelectedIndex]?.scrollIntoView({ block: 'nearest' });
  }
  if (e.key === 'Enter') {
    e.preventDefault();
    if (window._cmdItems && window._cmdItems[cmdSelectedIndex]) {
      window._cmdItems[cmdSelectedIndex].action();
      closeCommandPalette();
    }
  }
});

document.getElementById('cmd-palette').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) closeCommandPalette();
});

// Global Cmd+K for command palette
document.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
    e.preventDefault();
    toggleCommandPalette();
  }
  if (e.key === 'Escape' && cmdPaletteOpen) {
    closeCommandPalette();
  }
});

// ─── Layout Toggle ──────────────────────────────────
let layoutVertical = false;
try {
  layoutVertical = localStorage.getItem('tova-playground-layout') === 'vertical';
} catch(e) {}

function toggleLayout() {
  layoutVertical = !layoutVertical;
  document.querySelector('.main').classList.toggle('vertical', layoutVertical);
  try { localStorage.setItem('tova-playground-layout', layoutVertical ? 'vertical' : 'horizontal'); } catch(e) {}
}

// Apply saved layout
if (layoutVertical) document.querySelector('.main').classList.add('vertical');

document.getElementById('btn-layout').addEventListener('click', toggleLayout);

// ─── Theme Toggle ───────────────────────────────────
let lightTheme = false;
try { lightTheme = localStorage.getItem('tova-playground-theme') === 'light'; } catch(e) {}

function applyTheme() {
  document.body.classList.toggle('light-theme', lightTheme);
  document.getElementById('setting-theme').classList.toggle('on', lightTheme);
}

document.getElementById('setting-theme').addEventListener('click', function() {
  lightTheme = !lightTheme;
  applyTheme();
  try { localStorage.setItem('tova-playground-theme', lightTheme ? 'light' : 'dark'); } catch(e) {}
  saveSettings();
});

applyTheme();

// ─── Export as HTML ─────────────────────────────────
function exportAsHTML() {
  if (!lastJsText || lastJsText.startsWith('// No output') || lastJsText.startsWith('// Compilation')) {
    alert('Nothing to export — compile your code first.');
    return;
  }
  const source = editor.state.doc.toString();
  const hasClient = source.includes('client {') || source.includes('client{');

  let exportHTML;
  if (hasClient) {
    // Export client app as standalone HTML
    try {
      const lexer = new Lexer(source, 'export.tova');
      const tokens = lexer.tokenize();
      const parser = new Parser(tokens, 'export.tova');
      const ast = parser.parse();
      const analyzer = new Analyzer(ast, 'export.tova');
      analyzer.analyze();
      const codegen = new CodeGenerator(ast, 'export.tova');
      const result = codegen.generate();
      const clientCode = (result.client || '').replace(/import\s+.*from\s+['"].*['"];?/g, '');
      exportHTML = '<!DOCTYPE html>\n<html><head><meta charset="UTF-8"><title>Tova App</title>\n'
        + '<style>*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}'
        + 'body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;padding:20px;color:#333}'
        + 'button{cursor:pointer;padding:8px 16px;margin:4px;border-radius:6px;border:1px solid #ddd;background:#f5f5f5;font-size:14px}'
        + 'input[type="text"],input[type="number"]{padding:8px 12px;border:1px solid #ddd;border-radius:6px;margin:4px;font-size:14px}'
        + '</style></head><body><div id="app"></div>\n<script>\n'
        + RUNTIME_CODE + '\n' + STDLIB_CODE + '\n' + STRING_PROTO_CODE + '\n'
        + (result.shared || '').replace(/import\s+.*from\s+['"].*['"];?/g, '') + '\n'
        + clientCode + '\n'
        + 'if(typeof App==="function"){mount(App,document.getElementById("app"));}\n'
        + '<\/script></body></html>';
    } catch(e) {
      exportHTML = '<!-- Export failed: ' + e.message + ' -->';
    }
  } else {
    // Export as Node/Bun script
    exportHTML = '// Generated by Tova Playground\n' + STDLIB_CODE + '\n' + lastJsText;
  }

  const blob = new Blob([exportHTML], { type: hasClient ? 'text/html' : 'text/javascript' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = hasClient ? 'tova-app.html' : 'tova-output.js';
  a.click();
  URL.revokeObjectURL(a.href);
}

document.getElementById('btn-export').addEventListener('click', exportAsHTML);

// ─── Embed Mode ─────────────────────────────────────
if (__isEmbed) {
  document.body.classList.add('embed-mode');
}

// ─── Theme query param override ─────────────────────
const __themeParam = new URLSearchParams(location.search).get('theme');
if (__themeParam === 'light' || __themeParam === 'dark') {
  lightTheme = __themeParam === 'light';
  applyTheme();
}

// ─── postMessage listener for parent integration ────
window.addEventListener('message', function(e) {
  if (!e.data || typeof e.data !== 'object') return;
  if (e.data.type === 'tova-playground-theme') {
    const t = e.data.theme;
    if (t === 'light' || t === 'dark') {
      lightTheme = t === 'light';
      applyTheme();
    }
  } else if (e.data.type === 'tova-playground-set-code') {
    if (typeof e.data.code === 'string') {
      editor.dispatch({
        changes: { from: 0, to: editor.state.doc.length, insert: e.data.code }
      });
    }
  }
});

// ─── Reference Search & Runnable Snippets ───────────
function renderReference() {
  sidebarBody.innerHTML = '';

  // Search box
  const searchBox = document.createElement('input');
  searchBox.type = 'text';
  searchBox.placeholder = 'Search reference...';
  searchBox.style.cssText = 'width:calc(100% - 28px);margin:8px 14px;padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;outline:none;font-family:var(--font-sans);';
  searchBox.addEventListener('input', () => renderRefSections(searchBox.value));
  sidebarBody.appendChild(searchBox);

  const container = document.createElement('div');
  container.id = 'ref-container';
  sidebarBody.appendChild(container);

  renderRefSections('');
}

function renderRefSections(query) {
  const container = document.getElementById('ref-container');
  if (!container) return;
  container.innerHTML = '';
  const q = query.toLowerCase();

  for (const section of REFERENCE) {
    const matchingItems = section.items.filter(item =>
      !q || section.title.toLowerCase().includes(q) || item.syntax.toLowerCase().includes(q) || item.desc.toLowerCase().includes(q)
    );
    if (matchingItems.length === 0) continue;

    const div = document.createElement('div');
    div.className = 'ref-section';
    const title = document.createElement('div');
    title.className = 'ref-title' + (q ? ' open' : '');
    title.textContent = section.title;
    const items = document.createElement('div');
    items.className = 'ref-items' + (q ? ' open' : '');
    for (const item of matchingItems) {
      const row = document.createElement('div');
      row.className = 'ref-item';
      row.style.cursor = 'pointer';
      row.innerHTML = '<code>' + escapeHtml(item.syntax) + '</code><span class="ref-desc"> \u2014 ' + escapeHtml(item.desc) + '</span>';
      row.title = 'Click to insert into editor';
      row.addEventListener('click', () => {
        // Insert the syntax at cursor position
        const pos = editor.state.selection.main.head;
        editor.dispatch({ changes: { from: pos, insert: item.syntax } });
        editor.focus();
      });
      items.appendChild(row);
    }
    title.addEventListener('click', () => { title.classList.toggle('open'); items.classList.toggle('open'); });
    div.appendChild(title);
    div.appendChild(items);
    container.appendChild(div);
  }

  // Open first two sections by default when no search
  if (!q) {
    const titles = container.querySelectorAll('.ref-title');
    const itemSections = container.querySelectorAll('.ref-items');
    if (titles[0]) { titles[0].classList.add('open'); itemSections[0].classList.add('open'); }
    if (titles[1]) { titles[1].classList.add('open'); itemSections[1].classList.add('open'); }
  }
}

// ─── Welcome Toast ──────────────────────────────────
if (!localStorage.getItem('tova-playground-welcomed')) {
  const toast = document.createElement('div');
  toast.className = 'welcome-toast';
  toast.innerHTML = 'Welcome! Try the <strong style="color:var(--accent);margin:0 2px">Learn</strong> button, or press <span class="kbd-hint">Cmd+Enter</span> to run code. <button class="close-toast" aria-label="Close">\u2715</button>';
  document.querySelector('.pane-editor').appendChild(toast);
  toast.querySelector('.close-toast').addEventListener('click', () => { toast.remove(); localStorage.setItem('tova-playground-welcomed', '1'); });
  setTimeout(() => { if (toast.parentNode) toast.remove(); }, 15000);
  localStorage.setItem('tova-playground-welcomed', '1');
}

// ─── Utility ────────────────────────────────────────
function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ─── Initial Compile ────────────────────────────────
compile();
</script>
</body>
</html>